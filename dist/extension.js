module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/extension.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/accepts/index.js":
/*!***************************************!*\
  !*** ./node_modules/accepts/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * accepts
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var Negotiator = __webpack_require__(/*! negotiator */ "./node_modules/negotiator/index.js")
var mime = __webpack_require__(/*! mime-types */ "./node_modules/mime-types/index.js")

/**
 * Module exports.
 * @public
 */

module.exports = Accepts

/**
 * Create a new Accepts object for the given req.
 *
 * @param {object} req
 * @public
 */

function Accepts (req) {
  if (!(this instanceof Accepts)) {
    return new Accepts(req)
  }

  this.headers = req.headers
  this.negotiator = new Negotiator(req)
}

/**
 * Check if the given `type(s)` is acceptable, returning
 * the best match when true, otherwise `undefined`, in which
 * case you should respond with 406 "Not Acceptable".
 *
 * The `type` value may be a single mime type string
 * such as "application/json", the extension name
 * such as "json" or an array `["json", "html", "text/plain"]`. When a list
 * or array is given the _best_ match, if any is returned.
 *
 * Examples:
 *
 *     // Accept: text/html
 *     this.types('html');
 *     // => "html"
 *
 *     // Accept: text/*, application/json
 *     this.types('html');
 *     // => "html"
 *     this.types('text/html');
 *     // => "text/html"
 *     this.types('json', 'text');
 *     // => "json"
 *     this.types('application/json');
 *     // => "application/json"
 *
 *     // Accept: text/*, application/json
 *     this.types('image/png');
 *     this.types('png');
 *     // => undefined
 *
 *     // Accept: text/*;q=.5, application/json
 *     this.types(['html', 'json']);
 *     this.types('html', 'json');
 *     // => "json"
 *
 * @param {String|Array} types...
 * @return {String|Array|Boolean}
 * @public
 */

Accepts.prototype.type =
Accepts.prototype.types = function (types_) {
  var types = types_

  // support flattened arguments
  if (types && !Array.isArray(types)) {
    types = new Array(arguments.length)
    for (var i = 0; i < types.length; i++) {
      types[i] = arguments[i]
    }
  }

  // no types, return all requested types
  if (!types || types.length === 0) {
    return this.negotiator.mediaTypes()
  }

  // no accept header, return first given type
  if (!this.headers.accept) {
    return types[0]
  }

  var mimes = types.map(extToMime)
  var accepts = this.negotiator.mediaTypes(mimes.filter(validMime))
  var first = accepts[0]

  return first
    ? types[mimes.indexOf(first)]
    : false
}

/**
 * Return accepted encodings or best fit based on `encodings`.
 *
 * Given `Accept-Encoding: gzip, deflate`
 * an array sorted by quality is returned:
 *
 *     ['gzip', 'deflate']
 *
 * @param {String|Array} encodings...
 * @return {String|Array}
 * @public
 */

Accepts.prototype.encoding =
Accepts.prototype.encodings = function (encodings_) {
  var encodings = encodings_

  // support flattened arguments
  if (encodings && !Array.isArray(encodings)) {
    encodings = new Array(arguments.length)
    for (var i = 0; i < encodings.length; i++) {
      encodings[i] = arguments[i]
    }
  }

  // no encodings, return all requested encodings
  if (!encodings || encodings.length === 0) {
    return this.negotiator.encodings()
  }

  return this.negotiator.encodings(encodings)[0] || false
}

/**
 * Return accepted charsets or best fit based on `charsets`.
 *
 * Given `Accept-Charset: utf-8, iso-8859-1;q=0.2, utf-7;q=0.5`
 * an array sorted by quality is returned:
 *
 *     ['utf-8', 'utf-7', 'iso-8859-1']
 *
 * @param {String|Array} charsets...
 * @return {String|Array}
 * @public
 */

Accepts.prototype.charset =
Accepts.prototype.charsets = function (charsets_) {
  var charsets = charsets_

  // support flattened arguments
  if (charsets && !Array.isArray(charsets)) {
    charsets = new Array(arguments.length)
    for (var i = 0; i < charsets.length; i++) {
      charsets[i] = arguments[i]
    }
  }

  // no charsets, return all requested charsets
  if (!charsets || charsets.length === 0) {
    return this.negotiator.charsets()
  }

  return this.negotiator.charsets(charsets)[0] || false
}

/**
 * Return accepted languages or best fit based on `langs`.
 *
 * Given `Accept-Language: en;q=0.8, es, pt`
 * an array sorted by quality is returned:
 *
 *     ['es', 'pt', 'en']
 *
 * @param {String|Array} langs...
 * @return {Array|String}
 * @public
 */

Accepts.prototype.lang =
Accepts.prototype.langs =
Accepts.prototype.language =
Accepts.prototype.languages = function (languages_) {
  var languages = languages_

  // support flattened arguments
  if (languages && !Array.isArray(languages)) {
    languages = new Array(arguments.length)
    for (var i = 0; i < languages.length; i++) {
      languages[i] = arguments[i]
    }
  }

  // no languages, return all requested languages
  if (!languages || languages.length === 0) {
    return this.negotiator.languages()
  }

  return this.negotiator.languages(languages)[0] || false
}

/**
 * Convert extnames to mime.
 *
 * @param {String} type
 * @return {String}
 * @private
 */

function extToMime (type) {
  return type.indexOf('/') === -1
    ? mime.lookup(type)
    : type
}

/**
 * Check if mime is valid.
 *
 * @param {String} type
 * @return {String}
 * @private
 */

function validMime (type) {
  return typeof type === 'string'
}


/***/ }),

/***/ "./node_modules/ansi-styles/index.js":
/*!*******************************************!*\
  !*** ./node_modules/ansi-styles/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {
const colorConvert = __webpack_require__(/*! color-convert */ "./node_modules/color-convert/index.js");

const wrapAnsi16 = (fn, offset) => function () {
	const code = fn.apply(colorConvert, arguments);
	return `\u001B[${code + offset}m`;
};

const wrapAnsi256 = (fn, offset) => function () {
	const code = fn.apply(colorConvert, arguments);
	return `\u001B[${38 + offset};5;${code}m`;
};

const wrapAnsi16m = (fn, offset) => function () {
	const rgb = fn.apply(colorConvert, arguments);
	return `\u001B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
};

function assembleStyles() {
	const codes = new Map();
	const styles = {
		modifier: {
			reset: [0, 0],
			// 21 isn't widely supported and 22 does the same thing
			bold: [1, 22],
			dim: [2, 22],
			italic: [3, 23],
			underline: [4, 24],
			inverse: [7, 27],
			hidden: [8, 28],
			strikethrough: [9, 29]
		},
		color: {
			black: [30, 39],
			red: [31, 39],
			green: [32, 39],
			yellow: [33, 39],
			blue: [34, 39],
			magenta: [35, 39],
			cyan: [36, 39],
			white: [37, 39],
			gray: [90, 39],

			// Bright color
			redBright: [91, 39],
			greenBright: [92, 39],
			yellowBright: [93, 39],
			blueBright: [94, 39],
			magentaBright: [95, 39],
			cyanBright: [96, 39],
			whiteBright: [97, 39]
		},
		bgColor: {
			bgBlack: [40, 49],
			bgRed: [41, 49],
			bgGreen: [42, 49],
			bgYellow: [43, 49],
			bgBlue: [44, 49],
			bgMagenta: [45, 49],
			bgCyan: [46, 49],
			bgWhite: [47, 49],

			// Bright color
			bgBlackBright: [100, 49],
			bgRedBright: [101, 49],
			bgGreenBright: [102, 49],
			bgYellowBright: [103, 49],
			bgBlueBright: [104, 49],
			bgMagentaBright: [105, 49],
			bgCyanBright: [106, 49],
			bgWhiteBright: [107, 49]
		}
	};

	// Fix humans
	styles.color.grey = styles.color.gray;

	for (const groupName of Object.keys(styles)) {
		const group = styles[groupName];

		for (const styleName of Object.keys(group)) {
			const style = group[styleName];

			styles[styleName] = {
				open: `\u001B[${style[0]}m`,
				close: `\u001B[${style[1]}m`
			};

			group[styleName] = styles[styleName];

			codes.set(style[0], style[1]);
		}

		Object.defineProperty(styles, groupName, {
			value: group,
			enumerable: false
		});

		Object.defineProperty(styles, 'codes', {
			value: codes,
			enumerable: false
		});
	}

	const ansi2ansi = n => n;
	const rgb2rgb = (r, g, b) => [r, g, b];

	styles.color.close = '\u001B[39m';
	styles.bgColor.close = '\u001B[49m';

	styles.color.ansi = {
		ansi: wrapAnsi16(ansi2ansi, 0)
	};
	styles.color.ansi256 = {
		ansi256: wrapAnsi256(ansi2ansi, 0)
	};
	styles.color.ansi16m = {
		rgb: wrapAnsi16m(rgb2rgb, 0)
	};

	styles.bgColor.ansi = {
		ansi: wrapAnsi16(ansi2ansi, 10)
	};
	styles.bgColor.ansi256 = {
		ansi256: wrapAnsi256(ansi2ansi, 10)
	};
	styles.bgColor.ansi16m = {
		rgb: wrapAnsi16m(rgb2rgb, 10)
	};

	for (let key of Object.keys(colorConvert)) {
		if (typeof colorConvert[key] !== 'object') {
			continue;
		}

		const suite = colorConvert[key];

		if (key === 'ansi16') {
			key = 'ansi';
		}

		if ('ansi16' in suite) {
			styles.color.ansi[key] = wrapAnsi16(suite.ansi16, 0);
			styles.bgColor.ansi[key] = wrapAnsi16(suite.ansi16, 10);
		}

		if ('ansi256' in suite) {
			styles.color.ansi256[key] = wrapAnsi256(suite.ansi256, 0);
			styles.bgColor.ansi256[key] = wrapAnsi256(suite.ansi256, 10);
		}

		if ('rgb' in suite) {
			styles.color.ansi16m[key] = wrapAnsi16m(suite.rgb, 0);
			styles.bgColor.ansi16m[key] = wrapAnsi16m(suite.rgb, 10);
		}
	}

	return styles;
}

// Make the export immutable
Object.defineProperty(module, 'exports', {
	enumerable: true,
	get: assembleStyles
});

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/anymatch/index.js":
/*!****************************************!*\
  !*** ./node_modules/anymatch/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });

const picomatch = __webpack_require__(/*! picomatch */ "./node_modules/picomatch/index.js");
const normalizePath = __webpack_require__(/*! normalize-path */ "./node_modules/normalize-path/index.js");

/**
 * @typedef {(testString: string) => boolean} AnymatchFn
 * @typedef {string|RegExp|AnymatchFn} AnymatchPattern
 * @typedef {AnymatchPattern|AnymatchPattern[]} AnymatchMatcher
 */
const BANG = '!';
const arrify = (item) => Array.isArray(item) ? item : [item];

/**
 * @param {AnymatchPattern} matcher
 * @returns {AnymatchFn}
 */
const createPattern = (matcher) => {
  if (typeof matcher === 'function') {
    return matcher;
  }
  if (typeof matcher === 'string') {
    const glob = picomatch(matcher);
    return (string) => matcher === string || glob(string);
  }
  if (matcher instanceof RegExp) {
    return (string) => matcher.test(string);
  }
  return (string) => false;
};

/**
 * @param {Array<Function>} patterns
 * @param {Array<Function>} negatedGlobs
 * @param {String|Array} path
 * @param {Boolean} returnIndex
 * @returns {boolean|number}
 */
const matchPatterns = (patterns, negatedGlobs, path, returnIndex) => {
  const additionalArgs = Array.isArray(path);
  const upath = normalizePath(additionalArgs ? path[0] : path);
  for (let index = 0; index < negatedGlobs.length; index++) {
    const nglob = negatedGlobs[index];
    if (nglob(upath)) {
      return returnIndex ? -1 : false;
    }
  }
  const args = additionalArgs && [upath].concat(path.slice(1));
  for (let index = 0; index < patterns.length; index++) {
    const pattern = patterns[index];
    if (additionalArgs ? pattern(...args) : pattern(upath)) {
      return returnIndex ? index : true;
    }
  }

  return returnIndex ? -1 : false;
};

/**
 * @param {AnymatchMatcher} matchers
 * @param {Array|string} testString
 * @param {boolean=} returnIndex
 * @returns {boolean|number|Function}
 */
const anymatch = (matchers, testString, returnIndex = false) => {
  if (matchers == null) {
    throw new TypeError('anymatch: specify first argument');
  }
  // Early cache for matchers.
  const mtchers = arrify(matchers);
  const negatedGlobs = mtchers
    .filter(item => typeof item === 'string' && item.charAt(0) === BANG)
    .map(item => item.slice(1))
    .map(item => picomatch(item));
  const patterns = mtchers.map(createPattern);

  if (testString == null) {
    return (testString, ri = false) => {
      const returnIndex = typeof ri === 'boolean' ? ri : false;
      return matchPatterns(patterns, negatedGlobs, testString, returnIndex);
    }
  }
  if (!Array.isArray(testString) && typeof testString !== 'string') {
    throw new TypeError('anymatch: second argument must be a string: got ' +
      Object.prototype.toString.call(testString))
  }

  return matchPatterns(patterns, negatedGlobs, testString, returnIndex);
};

anymatch.default = anymatch;
module.exports = anymatch;


/***/ }),

/***/ "./node_modules/array-flatten/array-flatten.js":
/*!*****************************************************!*\
  !*** ./node_modules/array-flatten/array-flatten.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Expose `arrayFlatten`.
 */
module.exports = arrayFlatten

/**
 * Recursive flatten function with depth.
 *
 * @param  {Array}  array
 * @param  {Array}  result
 * @param  {Number} depth
 * @return {Array}
 */
function flattenWithDepth (array, result, depth) {
  for (var i = 0; i < array.length; i++) {
    var value = array[i]

    if (depth > 0 && Array.isArray(value)) {
      flattenWithDepth(value, result, depth - 1)
    } else {
      result.push(value)
    }
  }

  return result
}

/**
 * Recursive flatten function. Omitting depth is slightly faster.
 *
 * @param  {Array} array
 * @param  {Array} result
 * @return {Array}
 */
function flattenForever (array, result) {
  for (var i = 0; i < array.length; i++) {
    var value = array[i]

    if (Array.isArray(value)) {
      flattenForever(value, result)
    } else {
      result.push(value)
    }
  }

  return result
}

/**
 * Flatten an array, with the ability to define a depth.
 *
 * @param  {Array}  array
 * @param  {Number} depth
 * @return {Array}
 */
function arrayFlatten (array, depth) {
  if (depth == null) {
    return flattenForever(array, [])
  }

  return flattenWithDepth(array, [], depth)
}


/***/ }),

/***/ "./node_modules/async-limiter/index.js":
/*!*********************************************!*\
  !*** ./node_modules/async-limiter/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function Queue(options) {
  if (!(this instanceof Queue)) {
    return new Queue(options);
  }

  options = options || {};
  this.concurrency = options.concurrency || Infinity;
  this.pending = 0;
  this.jobs = [];
  this.cbs = [];
  this._done = done.bind(this);
}

var arrayAddMethods = [
  'push',
  'unshift',
  'splice'
];

arrayAddMethods.forEach(function(method) {
  Queue.prototype[method] = function() {
    var methodResult = Array.prototype[method].apply(this.jobs, arguments);
    this._run();
    return methodResult;
  };
});

Object.defineProperty(Queue.prototype, 'length', {
  get: function() {
    return this.pending + this.jobs.length;
  }
});

Queue.prototype._run = function() {
  if (this.pending === this.concurrency) {
    return;
  }
  if (this.jobs.length) {
    var job = this.jobs.shift();
    this.pending++;
    job(this._done);
    this._run();
  }

  if (this.pending === 0) {
    while (this.cbs.length !== 0) {
      var cb = this.cbs.pop();
      process.nextTick(cb);
    }
  }
};

Queue.prototype.onDone = function(cb) {
  if (typeof cb === 'function') {
    this.cbs.push(cb);
    this._run();
  }
};

function done() {
  this.pending--;
  this._run();
}

module.exports = Queue;


/***/ }),

/***/ "./node_modules/binary-extensions/binary-extensions.json":
/*!***************************************************************!*\
  !*** ./node_modules/binary-extensions/binary-extensions.json ***!
  \***************************************************************/
/*! exports provided: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, default */
/***/ (function(module) {

module.exports = JSON.parse("[\"3dm\",\"3ds\",\"3g2\",\"3gp\",\"7z\",\"a\",\"aac\",\"adp\",\"ai\",\"aif\",\"aiff\",\"alz\",\"ape\",\"apk\",\"ar\",\"arj\",\"asf\",\"au\",\"avi\",\"bak\",\"baml\",\"bh\",\"bin\",\"bk\",\"bmp\",\"btif\",\"bz2\",\"bzip2\",\"cab\",\"caf\",\"cgm\",\"class\",\"cmx\",\"cpio\",\"cr2\",\"cur\",\"dat\",\"dcm\",\"deb\",\"dex\",\"djvu\",\"dll\",\"dmg\",\"dng\",\"doc\",\"docm\",\"docx\",\"dot\",\"dotm\",\"dra\",\"DS_Store\",\"dsk\",\"dts\",\"dtshd\",\"dvb\",\"dwg\",\"dxf\",\"ecelp4800\",\"ecelp7470\",\"ecelp9600\",\"egg\",\"eol\",\"eot\",\"epub\",\"exe\",\"f4v\",\"fbs\",\"fh\",\"fla\",\"flac\",\"fli\",\"flv\",\"fpx\",\"fst\",\"fvt\",\"g3\",\"gh\",\"gif\",\"graffle\",\"gz\",\"gzip\",\"h261\",\"h263\",\"h264\",\"icns\",\"ico\",\"ief\",\"img\",\"ipa\",\"iso\",\"jar\",\"jpeg\",\"jpg\",\"jpgv\",\"jpm\",\"jxr\",\"key\",\"ktx\",\"lha\",\"lib\",\"lvp\",\"lz\",\"lzh\",\"lzma\",\"lzo\",\"m3u\",\"m4a\",\"m4v\",\"mar\",\"mdi\",\"mht\",\"mid\",\"midi\",\"mj2\",\"mka\",\"mkv\",\"mmr\",\"mng\",\"mobi\",\"mov\",\"movie\",\"mp3\",\"mp4\",\"mp4a\",\"mpeg\",\"mpg\",\"mpga\",\"mxu\",\"nef\",\"npx\",\"numbers\",\"nupkg\",\"o\",\"oga\",\"ogg\",\"ogv\",\"otf\",\"pages\",\"pbm\",\"pcx\",\"pdb\",\"pdf\",\"pea\",\"pgm\",\"pic\",\"png\",\"pnm\",\"pot\",\"potm\",\"potx\",\"ppa\",\"ppam\",\"ppm\",\"pps\",\"ppsm\",\"ppsx\",\"ppt\",\"pptm\",\"pptx\",\"psd\",\"pya\",\"pyc\",\"pyo\",\"pyv\",\"qt\",\"rar\",\"ras\",\"raw\",\"resources\",\"rgb\",\"rip\",\"rlc\",\"rmf\",\"rmvb\",\"rtf\",\"rz\",\"s3m\",\"s7z\",\"scpt\",\"sgi\",\"shar\",\"sil\",\"sketch\",\"slk\",\"smv\",\"snk\",\"so\",\"stl\",\"suo\",\"sub\",\"swf\",\"tar\",\"tbz\",\"tbz2\",\"tga\",\"tgz\",\"thmx\",\"tif\",\"tiff\",\"tlz\",\"ttc\",\"ttf\",\"txz\",\"udf\",\"uvh\",\"uvi\",\"uvm\",\"uvp\",\"uvs\",\"uvu\",\"viv\",\"vob\",\"war\",\"wav\",\"wax\",\"wbmp\",\"wdp\",\"weba\",\"webm\",\"webp\",\"whl\",\"wim\",\"wm\",\"wma\",\"wmv\",\"wmx\",\"woff\",\"woff2\",\"wrm\",\"wvx\",\"xbm\",\"xif\",\"xla\",\"xlam\",\"xls\",\"xlsb\",\"xlsm\",\"xlsx\",\"xlt\",\"xltm\",\"xltx\",\"xm\",\"xmind\",\"xpi\",\"xpm\",\"xwd\",\"xz\",\"z\",\"zip\",\"zipx\"]");

/***/ }),

/***/ "./node_modules/binary-extensions/index.js":
/*!*************************************************!*\
  !*** ./node_modules/binary-extensions/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./binary-extensions.json */ "./node_modules/binary-extensions/binary-extensions.json");


/***/ }),

/***/ "./node_modules/body-parser/index.js":
/*!*******************************************!*\
  !*** ./node_modules/body-parser/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var deprecate = __webpack_require__(/*! depd */ "./node_modules/depd/index.js")('body-parser')

/**
 * Cache of loaded parsers.
 * @private
 */

var parsers = Object.create(null)

/**
 * @typedef Parsers
 * @type {function}
 * @property {function} json
 * @property {function} raw
 * @property {function} text
 * @property {function} urlencoded
 */

/**
 * Module exports.
 * @type {Parsers}
 */

exports = module.exports = deprecate.function(bodyParser,
  'bodyParser: use individual json/urlencoded middlewares')

/**
 * JSON parser.
 * @public
 */

Object.defineProperty(exports, 'json', {
  configurable: true,
  enumerable: true,
  get: createParserGetter('json')
})

/**
 * Raw parser.
 * @public
 */

Object.defineProperty(exports, 'raw', {
  configurable: true,
  enumerable: true,
  get: createParserGetter('raw')
})

/**
 * Text parser.
 * @public
 */

Object.defineProperty(exports, 'text', {
  configurable: true,
  enumerable: true,
  get: createParserGetter('text')
})

/**
 * URL-encoded parser.
 * @public
 */

Object.defineProperty(exports, 'urlencoded', {
  configurable: true,
  enumerable: true,
  get: createParserGetter('urlencoded')
})

/**
 * Create a middleware to parse json and urlencoded bodies.
 *
 * @param {object} [options]
 * @return {function}
 * @deprecated
 * @public
 */

function bodyParser (options) {
  var opts = {}

  // exclude type option
  if (options) {
    for (var prop in options) {
      if (prop !== 'type') {
        opts[prop] = options[prop]
      }
    }
  }

  var _urlencoded = exports.urlencoded(opts)
  var _json = exports.json(opts)

  return function bodyParser (req, res, next) {
    _json(req, res, function (err) {
      if (err) return next(err)
      _urlencoded(req, res, next)
    })
  }
}

/**
 * Create a getter for loading a parser.
 * @private
 */

function createParserGetter (name) {
  return function get () {
    return loadParser(name)
  }
}

/**
 * Load a parser module.
 * @private
 */

function loadParser (parserName) {
  var parser = parsers[parserName]

  if (parser !== undefined) {
    return parser
  }

  // this uses a switch for static require analysis
  switch (parserName) {
    case 'json':
      parser = __webpack_require__(/*! ./lib/types/json */ "./node_modules/body-parser/lib/types/json.js")
      break
    case 'raw':
      parser = __webpack_require__(/*! ./lib/types/raw */ "./node_modules/body-parser/lib/types/raw.js")
      break
    case 'text':
      parser = __webpack_require__(/*! ./lib/types/text */ "./node_modules/body-parser/lib/types/text.js")
      break
    case 'urlencoded':
      parser = __webpack_require__(/*! ./lib/types/urlencoded */ "./node_modules/body-parser/lib/types/urlencoded.js")
      break
  }

  // store to prevent invoking require()
  return (parsers[parserName] = parser)
}


/***/ }),

/***/ "./node_modules/body-parser/lib/read.js":
/*!**********************************************!*\
  !*** ./node_modules/body-parser/lib/read.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var createError = __webpack_require__(/*! http-errors */ "./node_modules/http-errors/index.js")
var getBody = __webpack_require__(/*! raw-body */ "./node_modules/raw-body/index.js")
var iconv = __webpack_require__(/*! iconv-lite */ "./node_modules/iconv-lite/lib/index.js")
var onFinished = __webpack_require__(/*! on-finished */ "./node_modules/on-finished/index.js")
var zlib = __webpack_require__(/*! zlib */ "zlib")

/**
 * Module exports.
 */

module.exports = read

/**
 * Read a request into a buffer and parse.
 *
 * @param {object} req
 * @param {object} res
 * @param {function} next
 * @param {function} parse
 * @param {function} debug
 * @param {object} options
 * @private
 */

function read (req, res, next, parse, debug, options) {
  var length
  var opts = options
  var stream

  // flag as parsed
  req._body = true

  // read options
  var encoding = opts.encoding !== null
    ? opts.encoding
    : null
  var verify = opts.verify

  try {
    // get the content stream
    stream = contentstream(req, debug, opts.inflate)
    length = stream.length
    stream.length = undefined
  } catch (err) {
    return next(err)
  }

  // set raw-body options
  opts.length = length
  opts.encoding = verify
    ? null
    : encoding

  // assert charset is supported
  if (opts.encoding === null && encoding !== null && !iconv.encodingExists(encoding)) {
    return next(createError(415, 'unsupported charset "' + encoding.toUpperCase() + '"', {
      charset: encoding.toLowerCase(),
      type: 'charset.unsupported'
    }))
  }

  // read body
  debug('read body')
  getBody(stream, opts, function (error, body) {
    if (error) {
      var _error

      if (error.type === 'encoding.unsupported') {
        // echo back charset
        _error = createError(415, 'unsupported charset "' + encoding.toUpperCase() + '"', {
          charset: encoding.toLowerCase(),
          type: 'charset.unsupported'
        })
      } else {
        // set status code on error
        _error = createError(400, error)
      }

      // read off entire request
      stream.resume()
      onFinished(req, function onfinished () {
        next(createError(400, _error))
      })
      return
    }

    // verify
    if (verify) {
      try {
        debug('verify body')
        verify(req, res, body, encoding)
      } catch (err) {
        next(createError(403, err, {
          body: body,
          type: err.type || 'entity.verify.failed'
        }))
        return
      }
    }

    // parse
    var str = body
    try {
      debug('parse body')
      str = typeof body !== 'string' && encoding !== null
        ? iconv.decode(body, encoding)
        : body
      req.body = parse(str)
    } catch (err) {
      next(createError(400, err, {
        body: str,
        type: err.type || 'entity.parse.failed'
      }))
      return
    }

    next()
  })
}

/**
 * Get the content stream of the request.
 *
 * @param {object} req
 * @param {function} debug
 * @param {boolean} [inflate=true]
 * @return {object}
 * @api private
 */

function contentstream (req, debug, inflate) {
  var encoding = (req.headers['content-encoding'] || 'identity').toLowerCase()
  var length = req.headers['content-length']
  var stream

  debug('content-encoding "%s"', encoding)

  if (inflate === false && encoding !== 'identity') {
    throw createError(415, 'content encoding unsupported', {
      encoding: encoding,
      type: 'encoding.unsupported'
    })
  }

  switch (encoding) {
    case 'deflate':
      stream = zlib.createInflate()
      debug('inflate body')
      req.pipe(stream)
      break
    case 'gzip':
      stream = zlib.createGunzip()
      debug('gunzip body')
      req.pipe(stream)
      break
    case 'identity':
      stream = req
      stream.length = length
      break
    default:
      throw createError(415, 'unsupported content encoding "' + encoding + '"', {
        encoding: encoding,
        type: 'encoding.unsupported'
      })
  }

  return stream
}


/***/ }),

/***/ "./node_modules/body-parser/lib/types/json.js":
/*!****************************************************!*\
  !*** ./node_modules/body-parser/lib/types/json.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * body-parser
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var bytes = __webpack_require__(/*! bytes */ "./node_modules/bytes/index.js")
var contentType = __webpack_require__(/*! content-type */ "./node_modules/content-type/index.js")
var createError = __webpack_require__(/*! http-errors */ "./node_modules/http-errors/index.js")
var debug = __webpack_require__(/*! debug */ "./node_modules/body-parser/node_modules/debug/src/index.js")('body-parser:json')
var read = __webpack_require__(/*! ../read */ "./node_modules/body-parser/lib/read.js")
var typeis = __webpack_require__(/*! type-is */ "./node_modules/type-is/index.js")

/**
 * Module exports.
 */

module.exports = json

/**
 * RegExp to match the first non-space in a string.
 *
 * Allowed whitespace is defined in RFC 7159:
 *
 *    ws = *(
 *            %x20 /              ; Space
 *            %x09 /              ; Horizontal tab
 *            %x0A /              ; Line feed or New line
 *            %x0D )              ; Carriage return
 */

var FIRST_CHAR_REGEXP = /^[\x20\x09\x0a\x0d]*(.)/ // eslint-disable-line no-control-regex

/**
 * Create a middleware to parse JSON bodies.
 *
 * @param {object} [options]
 * @return {function}
 * @public
 */

function json (options) {
  var opts = options || {}

  var limit = typeof opts.limit !== 'number'
    ? bytes.parse(opts.limit || '100kb')
    : opts.limit
  var inflate = opts.inflate !== false
  var reviver = opts.reviver
  var strict = opts.strict !== false
  var type = opts.type || 'application/json'
  var verify = opts.verify || false

  if (verify !== false && typeof verify !== 'function') {
    throw new TypeError('option verify must be function')
  }

  // create the appropriate type checking function
  var shouldParse = typeof type !== 'function'
    ? typeChecker(type)
    : type

  function parse (body) {
    if (body.length === 0) {
      // special-case empty json body, as it's a common client-side mistake
      // TODO: maybe make this configurable or part of "strict" option
      return {}
    }

    if (strict) {
      var first = firstchar(body)

      if (first !== '{' && first !== '[') {
        debug('strict violation')
        throw createStrictSyntaxError(body, first)
      }
    }

    try {
      debug('parse json')
      return JSON.parse(body, reviver)
    } catch (e) {
      throw normalizeJsonSyntaxError(e, {
        message: e.message,
        stack: e.stack
      })
    }
  }

  return function jsonParser (req, res, next) {
    if (req._body) {
      debug('body already parsed')
      next()
      return
    }

    req.body = req.body || {}

    // skip requests without bodies
    if (!typeis.hasBody(req)) {
      debug('skip empty body')
      next()
      return
    }

    debug('content-type %j', req.headers['content-type'])

    // determine if request should be parsed
    if (!shouldParse(req)) {
      debug('skip parsing')
      next()
      return
    }

    // assert charset per RFC 7159 sec 8.1
    var charset = getCharset(req) || 'utf-8'
    if (charset.substr(0, 4) !== 'utf-') {
      debug('invalid charset')
      next(createError(415, 'unsupported charset "' + charset.toUpperCase() + '"', {
        charset: charset,
        type: 'charset.unsupported'
      }))
      return
    }

    // read
    read(req, res, next, parse, debug, {
      encoding: charset,
      inflate: inflate,
      limit: limit,
      verify: verify
    })
  }
}

/**
 * Create strict violation syntax error matching native error.
 *
 * @param {string} str
 * @param {string} char
 * @return {Error}
 * @private
 */

function createStrictSyntaxError (str, char) {
  var index = str.indexOf(char)
  var partial = str.substring(0, index) + '#'

  try {
    JSON.parse(partial); /* istanbul ignore next */ throw new SyntaxError('strict violation')
  } catch (e) {
    return normalizeJsonSyntaxError(e, {
      message: e.message.replace('#', char),
      stack: e.stack
    })
  }
}

/**
 * Get the first non-whitespace character in a string.
 *
 * @param {string} str
 * @return {function}
 * @private
 */

function firstchar (str) {
  return FIRST_CHAR_REGEXP.exec(str)[1]
}

/**
 * Get the charset of a request.
 *
 * @param {object} req
 * @api private
 */

function getCharset (req) {
  try {
    return (contentType.parse(req).parameters.charset || '').toLowerCase()
  } catch (e) {
    return undefined
  }
}

/**
 * Normalize a SyntaxError for JSON.parse.
 *
 * @param {SyntaxError} error
 * @param {object} obj
 * @return {SyntaxError}
 */

function normalizeJsonSyntaxError (error, obj) {
  var keys = Object.getOwnPropertyNames(error)

  for (var i = 0; i < keys.length; i++) {
    var key = keys[i]
    if (key !== 'stack' && key !== 'message') {
      delete error[key]
    }
  }

  // replace stack before message for Node.js 0.10 and below
  error.stack = obj.stack.replace(error.message, obj.message)
  error.message = obj.message

  return error
}

/**
 * Get the simple type checker.
 *
 * @param {string} type
 * @return {function}
 */

function typeChecker (type) {
  return function checkType (req) {
    return Boolean(typeis(req, type))
  }
}


/***/ }),

/***/ "./node_modules/body-parser/lib/types/raw.js":
/*!***************************************************!*\
  !*** ./node_modules/body-parser/lib/types/raw.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 */

var bytes = __webpack_require__(/*! bytes */ "./node_modules/bytes/index.js")
var debug = __webpack_require__(/*! debug */ "./node_modules/body-parser/node_modules/debug/src/index.js")('body-parser:raw')
var read = __webpack_require__(/*! ../read */ "./node_modules/body-parser/lib/read.js")
var typeis = __webpack_require__(/*! type-is */ "./node_modules/type-is/index.js")

/**
 * Module exports.
 */

module.exports = raw

/**
 * Create a middleware to parse raw bodies.
 *
 * @param {object} [options]
 * @return {function}
 * @api public
 */

function raw (options) {
  var opts = options || {}

  var inflate = opts.inflate !== false
  var limit = typeof opts.limit !== 'number'
    ? bytes.parse(opts.limit || '100kb')
    : opts.limit
  var type = opts.type || 'application/octet-stream'
  var verify = opts.verify || false

  if (verify !== false && typeof verify !== 'function') {
    throw new TypeError('option verify must be function')
  }

  // create the appropriate type checking function
  var shouldParse = typeof type !== 'function'
    ? typeChecker(type)
    : type

  function parse (buf) {
    return buf
  }

  return function rawParser (req, res, next) {
    if (req._body) {
      debug('body already parsed')
      next()
      return
    }

    req.body = req.body || {}

    // skip requests without bodies
    if (!typeis.hasBody(req)) {
      debug('skip empty body')
      next()
      return
    }

    debug('content-type %j', req.headers['content-type'])

    // determine if request should be parsed
    if (!shouldParse(req)) {
      debug('skip parsing')
      next()
      return
    }

    // read
    read(req, res, next, parse, debug, {
      encoding: null,
      inflate: inflate,
      limit: limit,
      verify: verify
    })
  }
}

/**
 * Get the simple type checker.
 *
 * @param {string} type
 * @return {function}
 */

function typeChecker (type) {
  return function checkType (req) {
    return Boolean(typeis(req, type))
  }
}


/***/ }),

/***/ "./node_modules/body-parser/lib/types/text.js":
/*!****************************************************!*\
  !*** ./node_modules/body-parser/lib/types/text.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 */

var bytes = __webpack_require__(/*! bytes */ "./node_modules/bytes/index.js")
var contentType = __webpack_require__(/*! content-type */ "./node_modules/content-type/index.js")
var debug = __webpack_require__(/*! debug */ "./node_modules/body-parser/node_modules/debug/src/index.js")('body-parser:text')
var read = __webpack_require__(/*! ../read */ "./node_modules/body-parser/lib/read.js")
var typeis = __webpack_require__(/*! type-is */ "./node_modules/type-is/index.js")

/**
 * Module exports.
 */

module.exports = text

/**
 * Create a middleware to parse text bodies.
 *
 * @param {object} [options]
 * @return {function}
 * @api public
 */

function text (options) {
  var opts = options || {}

  var defaultCharset = opts.defaultCharset || 'utf-8'
  var inflate = opts.inflate !== false
  var limit = typeof opts.limit !== 'number'
    ? bytes.parse(opts.limit || '100kb')
    : opts.limit
  var type = opts.type || 'text/plain'
  var verify = opts.verify || false

  if (verify !== false && typeof verify !== 'function') {
    throw new TypeError('option verify must be function')
  }

  // create the appropriate type checking function
  var shouldParse = typeof type !== 'function'
    ? typeChecker(type)
    : type

  function parse (buf) {
    return buf
  }

  return function textParser (req, res, next) {
    if (req._body) {
      debug('body already parsed')
      next()
      return
    }

    req.body = req.body || {}

    // skip requests without bodies
    if (!typeis.hasBody(req)) {
      debug('skip empty body')
      next()
      return
    }

    debug('content-type %j', req.headers['content-type'])

    // determine if request should be parsed
    if (!shouldParse(req)) {
      debug('skip parsing')
      next()
      return
    }

    // get charset
    var charset = getCharset(req) || defaultCharset

    // read
    read(req, res, next, parse, debug, {
      encoding: charset,
      inflate: inflate,
      limit: limit,
      verify: verify
    })
  }
}

/**
 * Get the charset of a request.
 *
 * @param {object} req
 * @api private
 */

function getCharset (req) {
  try {
    return (contentType.parse(req).parameters.charset || '').toLowerCase()
  } catch (e) {
    return undefined
  }
}

/**
 * Get the simple type checker.
 *
 * @param {string} type
 * @return {function}
 */

function typeChecker (type) {
  return function checkType (req) {
    return Boolean(typeis(req, type))
  }
}


/***/ }),

/***/ "./node_modules/body-parser/lib/types/urlencoded.js":
/*!**********************************************************!*\
  !*** ./node_modules/body-parser/lib/types/urlencoded.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * body-parser
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var bytes = __webpack_require__(/*! bytes */ "./node_modules/bytes/index.js")
var contentType = __webpack_require__(/*! content-type */ "./node_modules/content-type/index.js")
var createError = __webpack_require__(/*! http-errors */ "./node_modules/http-errors/index.js")
var debug = __webpack_require__(/*! debug */ "./node_modules/body-parser/node_modules/debug/src/index.js")('body-parser:urlencoded')
var deprecate = __webpack_require__(/*! depd */ "./node_modules/depd/index.js")('body-parser')
var read = __webpack_require__(/*! ../read */ "./node_modules/body-parser/lib/read.js")
var typeis = __webpack_require__(/*! type-is */ "./node_modules/type-is/index.js")

/**
 * Module exports.
 */

module.exports = urlencoded

/**
 * Cache of parser modules.
 */

var parsers = Object.create(null)

/**
 * Create a middleware to parse urlencoded bodies.
 *
 * @param {object} [options]
 * @return {function}
 * @public
 */

function urlencoded (options) {
  var opts = options || {}

  // notice because option default will flip in next major
  if (opts.extended === undefined) {
    deprecate('undefined extended: provide extended option')
  }

  var extended = opts.extended !== false
  var inflate = opts.inflate !== false
  var limit = typeof opts.limit !== 'number'
    ? bytes.parse(opts.limit || '100kb')
    : opts.limit
  var type = opts.type || 'application/x-www-form-urlencoded'
  var verify = opts.verify || false

  if (verify !== false && typeof verify !== 'function') {
    throw new TypeError('option verify must be function')
  }

  // create the appropriate query parser
  var queryparse = extended
    ? extendedparser(opts)
    : simpleparser(opts)

  // create the appropriate type checking function
  var shouldParse = typeof type !== 'function'
    ? typeChecker(type)
    : type

  function parse (body) {
    return body.length
      ? queryparse(body)
      : {}
  }

  return function urlencodedParser (req, res, next) {
    if (req._body) {
      debug('body already parsed')
      next()
      return
    }

    req.body = req.body || {}

    // skip requests without bodies
    if (!typeis.hasBody(req)) {
      debug('skip empty body')
      next()
      return
    }

    debug('content-type %j', req.headers['content-type'])

    // determine if request should be parsed
    if (!shouldParse(req)) {
      debug('skip parsing')
      next()
      return
    }

    // assert charset
    var charset = getCharset(req) || 'utf-8'
    if (charset !== 'utf-8') {
      debug('invalid charset')
      next(createError(415, 'unsupported charset "' + charset.toUpperCase() + '"', {
        charset: charset,
        type: 'charset.unsupported'
      }))
      return
    }

    // read
    read(req, res, next, parse, debug, {
      debug: debug,
      encoding: charset,
      inflate: inflate,
      limit: limit,
      verify: verify
    })
  }
}

/**
 * Get the extended query parser.
 *
 * @param {object} options
 */

function extendedparser (options) {
  var parameterLimit = options.parameterLimit !== undefined
    ? options.parameterLimit
    : 1000
  var parse = parser('qs')

  if (isNaN(parameterLimit) || parameterLimit < 1) {
    throw new TypeError('option parameterLimit must be a positive number')
  }

  if (isFinite(parameterLimit)) {
    parameterLimit = parameterLimit | 0
  }

  return function queryparse (body) {
    var paramCount = parameterCount(body, parameterLimit)

    if (paramCount === undefined) {
      debug('too many parameters')
      throw createError(413, 'too many parameters', {
        type: 'parameters.too.many'
      })
    }

    var arrayLimit = Math.max(100, paramCount)

    debug('parse extended urlencoding')
    return parse(body, {
      allowPrototypes: true,
      arrayLimit: arrayLimit,
      depth: Infinity,
      parameterLimit: parameterLimit
    })
  }
}

/**
 * Get the charset of a request.
 *
 * @param {object} req
 * @api private
 */

function getCharset (req) {
  try {
    return (contentType.parse(req).parameters.charset || '').toLowerCase()
  } catch (e) {
    return undefined
  }
}

/**
 * Count the number of parameters, stopping once limit reached
 *
 * @param {string} body
 * @param {number} limit
 * @api private
 */

function parameterCount (body, limit) {
  var count = 0
  var index = 0

  while ((index = body.indexOf('&', index)) !== -1) {
    count++
    index++

    if (count === limit) {
      return undefined
    }
  }

  return count
}

/**
 * Get parser for module name dynamically.
 *
 * @param {string} name
 * @return {function}
 * @api private
 */

function parser (name) {
  var mod = parsers[name]

  if (mod !== undefined) {
    return mod.parse
  }

  // this uses a switch for static require analysis
  switch (name) {
    case 'qs':
      mod = __webpack_require__(/*! qs */ "./node_modules/body-parser/node_modules/qs/lib/index.js")
      break
    case 'querystring':
      mod = __webpack_require__(/*! querystring */ "querystring")
      break
  }

  // store to prevent invoking require()
  parsers[name] = mod

  return mod.parse
}

/**
 * Get the simple query parser.
 *
 * @param {object} options
 */

function simpleparser (options) {
  var parameterLimit = options.parameterLimit !== undefined
    ? options.parameterLimit
    : 1000
  var parse = parser('querystring')

  if (isNaN(parameterLimit) || parameterLimit < 1) {
    throw new TypeError('option parameterLimit must be a positive number')
  }

  if (isFinite(parameterLimit)) {
    parameterLimit = parameterLimit | 0
  }

  return function queryparse (body) {
    var paramCount = parameterCount(body, parameterLimit)

    if (paramCount === undefined) {
      debug('too many parameters')
      throw createError(413, 'too many parameters', {
        type: 'parameters.too.many'
      })
    }

    debug('parse urlencoding')
    return parse(body, undefined, undefined, { maxKeys: parameterLimit })
  }
}

/**
 * Get the simple type checker.
 *
 * @param {string} type
 * @return {function}
 */

function typeChecker (type) {
  return function checkType (req) {
    return Boolean(typeis(req, type))
  }
}


/***/ }),

/***/ "./node_modules/body-parser/node_modules/debug/src/browser.js":
/*!********************************************************************!*\
  !*** ./node_modules/body-parser/node_modules/debug/src/browser.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __webpack_require__(/*! ./debug */ "./node_modules/body-parser/node_modules/debug/src/debug.js");
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}


/***/ }),

/***/ "./node_modules/body-parser/node_modules/debug/src/debug.js":
/*!******************************************************************!*\
  !*** ./node_modules/body-parser/node_modules/debug/src/debug.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = __webpack_require__(/*! ms */ "./node_modules/ms/index.js");

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  return debug;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}


/***/ }),

/***/ "./node_modules/body-parser/node_modules/debug/src/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/body-parser/node_modules/debug/src/index.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Detect Electron renderer process, which is node, but we should
 * treat as a browser.
 */

if (typeof process !== 'undefined' && process.type === 'renderer') {
  module.exports = __webpack_require__(/*! ./browser.js */ "./node_modules/body-parser/node_modules/debug/src/browser.js");
} else {
  module.exports = __webpack_require__(/*! ./node.js */ "./node_modules/body-parser/node_modules/debug/src/node.js");
}


/***/ }),

/***/ "./node_modules/body-parser/node_modules/debug/src/node.js":
/*!*****************************************************************!*\
  !*** ./node_modules/body-parser/node_modules/debug/src/node.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Module dependencies.
 */

var tty = __webpack_require__(/*! tty */ "tty");
var util = __webpack_require__(/*! util */ "util");

/**
 * This is the Node.js implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __webpack_require__(/*! ./debug */ "./node_modules/body-parser/node_modules/debug/src/debug.js");
exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(function (key) {
  return /^debug_/i.test(key);
}).reduce(function (obj, key) {
  // camel-case
  var prop = key
    .substring(6)
    .toLowerCase()
    .replace(/_([a-z])/g, function (_, k) { return k.toUpperCase() });

  // coerce string value into JS value
  var val = process.env[key];
  if (/^(yes|on|true|enabled)$/i.test(val)) val = true;
  else if (/^(no|off|false|disabled)$/i.test(val)) val = false;
  else if (val === 'null') val = null;
  else val = Number(val);

  obj[prop] = val;
  return obj;
}, {});

/**
 * The file descriptor to write the `debug()` calls to.
 * Set the `DEBUG_FD` env variable to override with another value. i.e.:
 *
 *   $ DEBUG_FD=3 node script.js 3>debug.log
 */

var fd = parseInt(process.env.DEBUG_FD, 10) || 2;

if (1 !== fd && 2 !== fd) {
  util.deprecate(function(){}, 'except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)')()
}

var stream = 1 === fd ? process.stdout :
             2 === fd ? process.stderr :
             createWritableStdioStream(fd);

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
  return 'colors' in exports.inspectOpts
    ? Boolean(exports.inspectOpts.colors)
    : tty.isatty(fd);
}

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

exports.formatters.o = function(v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts)
    .split('\n').map(function(str) {
      return str.trim()
    }).join(' ');
};

/**
 * Map %o to `util.inspect()`, allowing multiple lines if needed.
 */

exports.formatters.O = function(v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts);
};

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var name = this.namespace;
  var useColors = this.useColors;

  if (useColors) {
    var c = this.color;
    var prefix = '  \u001b[3' + c + ';1m' + name + ' ' + '\u001b[0m';

    args[0] = prefix + args[0].split('\n').join('\n' + prefix);
    args.push('\u001b[3' + c + 'm+' + exports.humanize(this.diff) + '\u001b[0m');
  } else {
    args[0] = new Date().toUTCString()
      + ' ' + name + ' ' + args[0];
  }
}

/**
 * Invokes `util.format()` with the specified arguments and writes to `stream`.
 */

function log() {
  return stream.write(util.format.apply(util, arguments) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  if (null == namespaces) {
    // If you set a process.env field to null or undefined, it gets cast to the
    // string 'null' or 'undefined'. Just delete instead.
    delete process.env.DEBUG;
  } else {
    process.env.DEBUG = namespaces;
  }
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  return process.env.DEBUG;
}

/**
 * Copied from `node/src/node.js`.
 *
 * XXX: It's lame that node doesn't expose this API out-of-the-box. It also
 * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.
 */

function createWritableStdioStream (fd) {
  var stream;
  var tty_wrap = process.binding('tty_wrap');

  // Note stream._type is used for test-module-load-list.js

  switch (tty_wrap.guessHandleType(fd)) {
    case 'TTY':
      stream = new tty.WriteStream(fd);
      stream._type = 'tty';

      // Hack to have stream not keep the event loop alive.
      // See https://github.com/joyent/node/issues/1726
      if (stream._handle && stream._handle.unref) {
        stream._handle.unref();
      }
      break;

    case 'FILE':
      var fs = __webpack_require__(/*! fs */ "fs");
      stream = new fs.SyncWriteStream(fd, { autoClose: false });
      stream._type = 'fs';
      break;

    case 'PIPE':
    case 'TCP':
      var net = __webpack_require__(/*! net */ "net");
      stream = new net.Socket({
        fd: fd,
        readable: false,
        writable: true
      });

      // FIXME Should probably have an option in net.Socket to create a
      // stream from an existing fd which is writable only. But for now
      // we'll just add this hack and set the `readable` member to false.
      // Test: ./node test/fixtures/echo.js < /etc/passwd
      stream.readable = false;
      stream.read = null;
      stream._type = 'pipe';

      // FIXME Hack to have stream not keep the event loop alive.
      // See https://github.com/joyent/node/issues/1726
      if (stream._handle && stream._handle.unref) {
        stream._handle.unref();
      }
      break;

    default:
      // Probably an error on in uv_guess_handle()
      throw new Error('Implement me. Unknown stream file type!');
  }

  // For supporting legacy API we put the FD here.
  stream.fd = fd;

  stream._isStdio = true;

  return stream;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init (debug) {
  debug.inspectOpts = {};

  var keys = Object.keys(exports.inspectOpts);
  for (var i = 0; i < keys.length; i++) {
    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
  }
}

/**
 * Enable namespaces listed in `process.env.DEBUG` initially.
 */

exports.enable(load());


/***/ }),

/***/ "./node_modules/body-parser/node_modules/qs/lib/formats.js":
/*!*****************************************************************!*\
  !*** ./node_modules/body-parser/node_modules/qs/lib/formats.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var replace = String.prototype.replace;
var percentTwenties = /%20/g;

module.exports = {
    'default': 'RFC3986',
    formatters: {
        RFC1738: function (value) {
            return replace.call(value, percentTwenties, '+');
        },
        RFC3986: function (value) {
            return value;
        }
    },
    RFC1738: 'RFC1738',
    RFC3986: 'RFC3986'
};


/***/ }),

/***/ "./node_modules/body-parser/node_modules/qs/lib/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/body-parser/node_modules/qs/lib/index.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var stringify = __webpack_require__(/*! ./stringify */ "./node_modules/body-parser/node_modules/qs/lib/stringify.js");
var parse = __webpack_require__(/*! ./parse */ "./node_modules/body-parser/node_modules/qs/lib/parse.js");
var formats = __webpack_require__(/*! ./formats */ "./node_modules/body-parser/node_modules/qs/lib/formats.js");

module.exports = {
    formats: formats,
    parse: parse,
    stringify: stringify
};


/***/ }),

/***/ "./node_modules/body-parser/node_modules/qs/lib/parse.js":
/*!***************************************************************!*\
  !*** ./node_modules/body-parser/node_modules/qs/lib/parse.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/body-parser/node_modules/qs/lib/utils.js");

var has = Object.prototype.hasOwnProperty;

var defaults = {
    allowDots: false,
    allowPrototypes: false,
    arrayLimit: 20,
    charset: 'utf-8',
    charsetSentinel: false,
    comma: false,
    decoder: utils.decode,
    delimiter: '&',
    depth: 5,
    ignoreQueryPrefix: false,
    interpretNumericEntities: false,
    parameterLimit: 1000,
    parseArrays: true,
    plainObjects: false,
    strictNullHandling: false
};

var interpretNumericEntities = function (str) {
    return str.replace(/&#(\d+);/g, function ($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
    });
};

// This is what browsers will submit when the  character occurs in an
// application/x-www-form-urlencoded body and the encoding of the page containing
// the form is iso-8859-1, or when the submitted form has an accept-charset
// attribute of iso-8859-1. Presumably also with other charsets that do not contain
// the  character, such as us-ascii.
var isoSentinel = 'utf8=%26%2310003%3B'; // encodeURIComponent('&#10003;')

// These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.
var charsetSentinel = 'utf8=%E2%9C%93'; // encodeURIComponent('')

var parseValues = function parseQueryStringValues(str, options) {
    var obj = {};
    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
    var parts = cleanStr.split(options.delimiter, limit);
    var skipIndex = -1; // Keep track of where the utf8 sentinel was found
    var i;

    var charset = options.charset;
    if (options.charsetSentinel) {
        for (i = 0; i < parts.length; ++i) {
            if (parts[i].indexOf('utf8=') === 0) {
                if (parts[i] === charsetSentinel) {
                    charset = 'utf-8';
                } else if (parts[i] === isoSentinel) {
                    charset = 'iso-8859-1';
                }
                skipIndex = i;
                i = parts.length; // The eslint settings do not allow break;
            }
        }
    }

    for (i = 0; i < parts.length; ++i) {
        if (i === skipIndex) {
            continue;
        }
        var part = parts[i];

        var bracketEqualsPos = part.indexOf(']=');
        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;

        var key, val;
        if (pos === -1) {
            key = options.decoder(part, defaults.decoder, charset);
            val = options.strictNullHandling ? null : '';
        } else {
            key = options.decoder(part.slice(0, pos), defaults.decoder, charset);
            val = options.decoder(part.slice(pos + 1), defaults.decoder, charset);
        }

        if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {
            val = interpretNumericEntities(val);
        }

        if (val && options.comma && val.indexOf(',') > -1) {
            val = val.split(',');
        }

        if (has.call(obj, key)) {
            obj[key] = utils.combine(obj[key], val);
        } else {
            obj[key] = val;
        }
    }

    return obj;
};

var parseObject = function (chain, val, options) {
    var leaf = val;

    for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];

        if (root === '[]' && options.parseArrays) {
            obj = [].concat(leaf);
        } else {
            obj = options.plainObjects ? Object.create(null) : {};
            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
            var index = parseInt(cleanRoot, 10);
            if (!options.parseArrays && cleanRoot === '') {
                obj = { 0: leaf };
            } else if (
                !isNaN(index)
                && root !== cleanRoot
                && String(index) === cleanRoot
                && index >= 0
                && (options.parseArrays && index <= options.arrayLimit)
            ) {
                obj = [];
                obj[index] = leaf;
            } else {
                obj[cleanRoot] = leaf;
            }
        }

        leaf = obj;
    }

    return leaf;
};

var parseKeys = function parseQueryStringKeys(givenKey, val, options) {
    if (!givenKey) {
        return;
    }

    // Transform dot notation to bracket notation
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;

    // The regex chunks

    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;

    // Get the parent

    var segment = brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;

    // Stash the parent if it exists

    var keys = [];
    if (parent) {
        // If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
            if (!options.allowPrototypes) {
                return;
            }
        }

        keys.push(parent);
    }

    // Loop through children appending to the array until we hit depth

    var i = 0;
    while ((segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
            if (!options.allowPrototypes) {
                return;
            }
        }
        keys.push(segment[1]);
    }

    // If there's a remainder, just add whatever is left

    if (segment) {
        keys.push('[' + key.slice(segment.index) + ']');
    }

    return parseObject(keys, val, options);
};

var normalizeParseOptions = function normalizeParseOptions(opts) {
    if (!opts) {
        return defaults;
    }

    if (opts.decoder !== null && opts.decoder !== undefined && typeof opts.decoder !== 'function') {
        throw new TypeError('Decoder has to be a function.');
    }

    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new Error('The charset option must be either utf-8, iso-8859-1, or undefined');
    }
    var charset = typeof opts.charset === 'undefined' ? defaults.charset : opts.charset;

    return {
        allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,
        allowPrototypes: typeof opts.allowPrototypes === 'boolean' ? opts.allowPrototypes : defaults.allowPrototypes,
        arrayLimit: typeof opts.arrayLimit === 'number' ? opts.arrayLimit : defaults.arrayLimit,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === 'boolean' ? opts.comma : defaults.comma,
        decoder: typeof opts.decoder === 'function' ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === 'string' || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        depth: typeof opts.depth === 'number' ? opts.depth : defaults.depth,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === 'boolean' ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === 'number' ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === 'boolean' ? opts.plainObjects : defaults.plainObjects,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
};

module.exports = function (str, opts) {
    var options = normalizeParseOptions(opts);

    if (str === '' || str === null || typeof str === 'undefined') {
        return options.plainObjects ? Object.create(null) : {};
    }

    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
    var obj = options.plainObjects ? Object.create(null) : {};

    // Iterate over the keys and setup the new object

    var keys = Object.keys(tempObj);
    for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options);
        obj = utils.merge(obj, newObj, options);
    }

    return utils.compact(obj);
};


/***/ }),

/***/ "./node_modules/body-parser/node_modules/qs/lib/stringify.js":
/*!*******************************************************************!*\
  !*** ./node_modules/body-parser/node_modules/qs/lib/stringify.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/body-parser/node_modules/qs/lib/utils.js");
var formats = __webpack_require__(/*! ./formats */ "./node_modules/body-parser/node_modules/qs/lib/formats.js");
var has = Object.prototype.hasOwnProperty;

var arrayPrefixGenerators = {
    brackets: function brackets(prefix) { // eslint-disable-line func-name-matching
        return prefix + '[]';
    },
    comma: 'comma',
    indices: function indices(prefix, key) { // eslint-disable-line func-name-matching
        return prefix + '[' + key + ']';
    },
    repeat: function repeat(prefix) { // eslint-disable-line func-name-matching
        return prefix;
    }
};

var isArray = Array.isArray;
var push = Array.prototype.push;
var pushToArray = function (arr, valueOrArray) {
    push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
};

var toISO = Date.prototype.toISOString;

var defaults = {
    addQueryPrefix: false,
    allowDots: false,
    charset: 'utf-8',
    charsetSentinel: false,
    delimiter: '&',
    encode: true,
    encoder: utils.encode,
    encodeValuesOnly: false,
    formatter: formats.formatters[formats['default']],
    // deprecated
    indices: false,
    serializeDate: function serializeDate(date) { // eslint-disable-line func-name-matching
        return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
};

var stringify = function stringify( // eslint-disable-line func-name-matching
    object,
    prefix,
    generateArrayPrefix,
    strictNullHandling,
    skipNulls,
    encoder,
    filter,
    sort,
    allowDots,
    serializeDate,
    formatter,
    encodeValuesOnly,
    charset
) {
    var obj = object;
    if (typeof filter === 'function') {
        obj = filter(prefix, obj);
    } else if (obj instanceof Date) {
        obj = serializeDate(obj);
    } else if (generateArrayPrefix === 'comma' && isArray(obj)) {
        obj = obj.join(',');
    }

    if (obj === null) {
        if (strictNullHandling) {
            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset) : prefix;
        }

        obj = '';
    }

    if (typeof obj === 'string' || typeof obj === 'number' || typeof obj === 'boolean' || utils.isBuffer(obj)) {
        if (encoder) {
            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset);
            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder, charset))];
        }
        return [formatter(prefix) + '=' + formatter(String(obj))];
    }

    var values = [];

    if (typeof obj === 'undefined') {
        return values;
    }

    var objKeys;
    if (isArray(filter)) {
        objKeys = filter;
    } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
    }

    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];

        if (skipNulls && obj[key] === null) {
            continue;
        }

        if (isArray(obj)) {
            pushToArray(values, stringify(
                obj[key],
                typeof generateArrayPrefix === 'function' ? generateArrayPrefix(prefix, key) : prefix,
                generateArrayPrefix,
                strictNullHandling,
                skipNulls,
                encoder,
                filter,
                sort,
                allowDots,
                serializeDate,
                formatter,
                encodeValuesOnly,
                charset
            ));
        } else {
            pushToArray(values, stringify(
                obj[key],
                prefix + (allowDots ? '.' + key : '[' + key + ']'),
                generateArrayPrefix,
                strictNullHandling,
                skipNulls,
                encoder,
                filter,
                sort,
                allowDots,
                serializeDate,
                formatter,
                encodeValuesOnly,
                charset
            ));
        }
    }

    return values;
};

var normalizeStringifyOptions = function normalizeStringifyOptions(opts) {
    if (!opts) {
        return defaults;
    }

    if (opts.encoder !== null && opts.encoder !== undefined && typeof opts.encoder !== 'function') {
        throw new TypeError('Encoder has to be a function.');
    }

    var charset = opts.charset || defaults.charset;
    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }

    var format = formats['default'];
    if (typeof opts.format !== 'undefined') {
        if (!has.call(formats.formatters, opts.format)) {
            throw new TypeError('Unknown format option provided.');
        }
        format = opts.format;
    }
    var formatter = formats.formatters[format];

    var filter = defaults.filter;
    if (typeof opts.filter === 'function' || isArray(opts.filter)) {
        filter = opts.filter;
    }

    return {
        addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,
        encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter: filter,
        formatter: formatter,
        serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === 'function' ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
};

module.exports = function (object, opts) {
    var obj = object;
    var options = normalizeStringifyOptions(opts);

    var objKeys;
    var filter;

    if (typeof options.filter === 'function') {
        filter = options.filter;
        obj = filter('', obj);
    } else if (isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
    }

    var keys = [];

    if (typeof obj !== 'object' || obj === null) {
        return '';
    }

    var arrayFormat;
    if (opts && opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
    } else if (opts && 'indices' in opts) {
        arrayFormat = opts.indices ? 'indices' : 'repeat';
    } else {
        arrayFormat = 'indices';
    }

    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];

    if (!objKeys) {
        objKeys = Object.keys(obj);
    }

    if (options.sort) {
        objKeys.sort(options.sort);
    }

    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];

        if (options.skipNulls && obj[key] === null) {
            continue;
        }
        pushToArray(keys, stringify(
            obj[key],
            key,
            generateArrayPrefix,
            options.strictNullHandling,
            options.skipNulls,
            options.encode ? options.encoder : null,
            options.filter,
            options.sort,
            options.allowDots,
            options.serializeDate,
            options.formatter,
            options.encodeValuesOnly,
            options.charset
        ));
    }

    var joined = keys.join(options.delimiter);
    var prefix = options.addQueryPrefix === true ? '?' : '';

    if (options.charsetSentinel) {
        if (options.charset === 'iso-8859-1') {
            // encodeURIComponent('&#10003;'), the "numeric entity" representation of a checkmark
            prefix += 'utf8=%26%2310003%3B&';
        } else {
            // encodeURIComponent('')
            prefix += 'utf8=%E2%9C%93&';
        }
    }

    return joined.length > 0 ? prefix + joined : '';
};


/***/ }),

/***/ "./node_modules/body-parser/node_modules/qs/lib/utils.js":
/*!***************************************************************!*\
  !*** ./node_modules/body-parser/node_modules/qs/lib/utils.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;

var hexTable = (function () {
    var array = [];
    for (var i = 0; i < 256; ++i) {
        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
    }

    return array;
}());

var compactQueue = function compactQueue(queue) {
    while (queue.length > 1) {
        var item = queue.pop();
        var obj = item.obj[item.prop];

        if (isArray(obj)) {
            var compacted = [];

            for (var j = 0; j < obj.length; ++j) {
                if (typeof obj[j] !== 'undefined') {
                    compacted.push(obj[j]);
                }
            }

            item.obj[item.prop] = compacted;
        }
    }
};

var arrayToObject = function arrayToObject(source, options) {
    var obj = options && options.plainObjects ? Object.create(null) : {};
    for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== 'undefined') {
            obj[i] = source[i];
        }
    }

    return obj;
};

var merge = function merge(target, source, options) {
    if (!source) {
        return target;
    }

    if (typeof source !== 'object') {
        if (isArray(target)) {
            target.push(source);
        } else if (target && typeof target === 'object') {
            if ((options && (options.plainObjects || options.allowPrototypes)) || !has.call(Object.prototype, source)) {
                target[source] = true;
            }
        } else {
            return [target, source];
        }

        return target;
    }

    if (!target || typeof target !== 'object') {
        return [target].concat(source);
    }

    var mergeTarget = target;
    if (isArray(target) && !isArray(source)) {
        mergeTarget = arrayToObject(target, options);
    }

    if (isArray(target) && isArray(source)) {
        source.forEach(function (item, i) {
            if (has.call(target, i)) {
                var targetItem = target[i];
                if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {
                    target[i] = merge(targetItem, item, options);
                } else {
                    target.push(item);
                }
            } else {
                target[i] = item;
            }
        });
        return target;
    }

    return Object.keys(source).reduce(function (acc, key) {
        var value = source[key];

        if (has.call(acc, key)) {
            acc[key] = merge(acc[key], value, options);
        } else {
            acc[key] = value;
        }
        return acc;
    }, mergeTarget);
};

var assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function (acc, key) {
        acc[key] = source[key];
        return acc;
    }, target);
};

var decode = function (str, decoder, charset) {
    var strWithoutPlus = str.replace(/\+/g, ' ');
    if (charset === 'iso-8859-1') {
        // unescape never throws, no try...catch needed:
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
    }
    // utf-8
    try {
        return decodeURIComponent(strWithoutPlus);
    } catch (e) {
        return strWithoutPlus;
    }
};

var encode = function encode(str, defaultEncoder, charset) {
    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
    // It has been adapted here for stricter adherence to RFC 3986
    if (str.length === 0) {
        return str;
    }

    var string = typeof str === 'string' ? str : String(str);

    if (charset === 'iso-8859-1') {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {
            return '%26%23' + parseInt($0.slice(2), 16) + '%3B';
        });
    }

    var out = '';
    for (var i = 0; i < string.length; ++i) {
        var c = string.charCodeAt(i);

        if (
            c === 0x2D // -
            || c === 0x2E // .
            || c === 0x5F // _
            || c === 0x7E // ~
            || (c >= 0x30 && c <= 0x39) // 0-9
            || (c >= 0x41 && c <= 0x5A) // a-z
            || (c >= 0x61 && c <= 0x7A) // A-Z
        ) {
            out += string.charAt(i);
            continue;
        }

        if (c < 0x80) {
            out = out + hexTable[c];
            continue;
        }

        if (c < 0x800) {
            out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);
            continue;
        }

        if (c < 0xD800 || c >= 0xE000) {
            out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);
            continue;
        }

        i += 1;
        c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));
        out += hexTable[0xF0 | (c >> 18)]
            + hexTable[0x80 | ((c >> 12) & 0x3F)]
            + hexTable[0x80 | ((c >> 6) & 0x3F)]
            + hexTable[0x80 | (c & 0x3F)];
    }

    return out;
};

var compact = function compact(value) {
    var queue = [{ obj: { o: value }, prop: 'o' }];
    var refs = [];

    for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];

        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
            var key = keys[j];
            var val = obj[key];
            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {
                queue.push({ obj: obj, prop: key });
                refs.push(val);
            }
        }
    }

    compactQueue(queue);

    return value;
};

var isRegExp = function isRegExp(obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
};

var isBuffer = function isBuffer(obj) {
    if (!obj || typeof obj !== 'object') {
        return false;
    }

    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};

var combine = function combine(a, b) {
    return [].concat(a, b);
};

module.exports = {
    arrayToObject: arrayToObject,
    assign: assign,
    combine: combine,
    compact: compact,
    decode: decode,
    encode: encode,
    isBuffer: isBuffer,
    isRegExp: isRegExp,
    merge: merge
};


/***/ }),

/***/ "./node_modules/braces/index.js":
/*!**************************************!*\
  !*** ./node_modules/braces/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const stringify = __webpack_require__(/*! ./lib/stringify */ "./node_modules/braces/lib/stringify.js");
const compile = __webpack_require__(/*! ./lib/compile */ "./node_modules/braces/lib/compile.js");
const expand = __webpack_require__(/*! ./lib/expand */ "./node_modules/braces/lib/expand.js");
const parse = __webpack_require__(/*! ./lib/parse */ "./node_modules/braces/lib/parse.js");

/**
 * Expand the given pattern or create a regex-compatible string.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces('{a,b,c}', { compile: true })); //=> ['(a|b|c)']
 * console.log(braces('{a,b,c}')); //=> ['a', 'b', 'c']
 * ```
 * @param {String} `str`
 * @param {Object} `options`
 * @return {String}
 * @api public
 */

const braces = (input, options = {}) => {
  let output = [];

  if (Array.isArray(input)) {
    for (let pattern of input) {
      let result = braces.create(pattern, options);
      if (Array.isArray(result)) {
        output.push(...result);
      } else {
        output.push(result);
      }
    }
  } else {
    output = [].concat(braces.create(input, options));
  }

  if (options && options.expand === true && options.nodupes === true) {
    output = [...new Set(output)];
  }
  return output;
};

/**
 * Parse the given `str` with the given `options`.
 *
 * ```js
 * // braces.parse(pattern, [, options]);
 * const ast = braces.parse('a/{b,c}/d');
 * console.log(ast);
 * ```
 * @param {String} pattern Brace pattern to parse
 * @param {Object} options
 * @return {Object} Returns an AST
 * @api public
 */

braces.parse = (input, options = {}) => parse(input, options);

/**
 * Creates a braces string from an AST, or an AST node.
 *
 * ```js
 * const braces = require('braces');
 * let ast = braces.parse('foo/{a,b}/bar');
 * console.log(stringify(ast.nodes[2])); //=> '{a,b}'
 * ```
 * @param {String} `input` Brace pattern or AST.
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */

braces.stringify = (input, options = {}) => {
  if (typeof input === 'string') {
    return stringify(braces.parse(input, options), options);
  }
  return stringify(input, options);
};

/**
 * Compiles a brace pattern into a regex-compatible, optimized string.
 * This method is called by the main [braces](#braces) function by default.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces.compile('a/{b,c}/d'));
 * //=> ['a/(b|c)/d']
 * ```
 * @param {String} `input` Brace pattern or AST.
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */

braces.compile = (input, options = {}) => {
  if (typeof input === 'string') {
    input = braces.parse(input, options);
  }
  return compile(input, options);
};

/**
 * Expands a brace pattern into an array. This method is called by the
 * main [braces](#braces) function when `options.expand` is true. Before
 * using this method it's recommended that you read the [performance notes](#performance))
 * and advantages of using [.compile](#compile) instead.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces.expand('a/{b,c}/d'));
 * //=> ['a/b/d', 'a/c/d'];
 * ```
 * @param {String} `pattern` Brace pattern
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */

braces.expand = (input, options = {}) => {
  if (typeof input === 'string') {
    input = braces.parse(input, options);
  }

  let result = expand(input, options);

  // filter out empty strings if specified
  if (options.noempty === true) {
    result = result.filter(Boolean);
  }

  // filter out duplicates if specified
  if (options.nodupes === true) {
    result = [...new Set(result)];
  }

  return result;
};

/**
 * Processes a brace pattern and returns either an expanded array
 * (if `options.expand` is true), a highly optimized regex-compatible string.
 * This method is called by the main [braces](#braces) function.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces.create('user-{200..300}/project-{a,b,c}-{1..10}'))
 * //=> 'user-(20[0-9]|2[1-9][0-9]|300)/project-(a|b|c)-([1-9]|10)'
 * ```
 * @param {String} `pattern` Brace pattern
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */

braces.create = (input, options = {}) => {
  if (input === '' || input.length < 3) {
    return [input];
  }

 return options.expand !== true
    ? braces.compile(input, options)
    : braces.expand(input, options);
};

/**
 * Expose "braces"
 */

module.exports = braces;


/***/ }),

/***/ "./node_modules/braces/lib/compile.js":
/*!********************************************!*\
  !*** ./node_modules/braces/lib/compile.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const fill = __webpack_require__(/*! fill-range */ "./node_modules/fill-range/index.js");
const utils = __webpack_require__(/*! ./utils */ "./node_modules/braces/lib/utils.js");

const compile = (ast, options = {}) => {
  let walk = (node, parent = {}) => {
    let invalidBlock = utils.isInvalidBrace(parent);
    let invalidNode = node.invalid === true && options.escapeInvalid === true;
    let invalid = invalidBlock === true || invalidNode === true;
    let prefix = options.escapeInvalid === true ? '\\' : '';
    let output = '';

    if (node.isOpen === true) {
      return prefix + node.value;
    }
    if (node.isClose === true) {
      return prefix + node.value;
    }

    if (node.type === 'open') {
      return invalid ? (prefix + node.value) : '(';
    }

    if (node.type === 'close') {
      return invalid ? (prefix + node.value) : ')';
    }

    if (node.type === 'comma') {
      return node.prev.type === 'comma' ? '' : (invalid ? node.value : '|');
    }

    if (node.value) {
      return node.value;
    }

    if (node.nodes && node.ranges > 0) {
      let args = utils.reduce(node.nodes);
      let range = fill(...args, { ...options, wrap: false, toRegex: true });

      if (range.length !== 0) {
        return args.length > 1 && range.length > 1 ? `(${range})` : range;
      }
    }

    if (node.nodes) {
      for (let child of node.nodes) {
        output += walk(child, node);
      }
    }
    return output;
  };

  return walk(ast);
};

module.exports = compile;


/***/ }),

/***/ "./node_modules/braces/lib/constants.js":
/*!**********************************************!*\
  !*** ./node_modules/braces/lib/constants.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  MAX_LENGTH: 1024 * 64,

  // Digits
  CHAR_0: '0', /* 0 */
  CHAR_9: '9', /* 9 */

  // Alphabet chars.
  CHAR_UPPERCASE_A: 'A', /* A */
  CHAR_LOWERCASE_A: 'a', /* a */
  CHAR_UPPERCASE_Z: 'Z', /* Z */
  CHAR_LOWERCASE_Z: 'z', /* z */

  CHAR_LEFT_PARENTHESES: '(', /* ( */
  CHAR_RIGHT_PARENTHESES: ')', /* ) */

  CHAR_ASTERISK: '*', /* * */

  // Non-alphabetic chars.
  CHAR_AMPERSAND: '&', /* & */
  CHAR_AT: '@', /* @ */
  CHAR_BACKSLASH: '\\', /* \ */
  CHAR_BACKTICK: '`', /* ` */
  CHAR_CARRIAGE_RETURN: '\r', /* \r */
  CHAR_CIRCUMFLEX_ACCENT: '^', /* ^ */
  CHAR_COLON: ':', /* : */
  CHAR_COMMA: ',', /* , */
  CHAR_DOLLAR: '$', /* . */
  CHAR_DOT: '.', /* . */
  CHAR_DOUBLE_QUOTE: '"', /* " */
  CHAR_EQUAL: '=', /* = */
  CHAR_EXCLAMATION_MARK: '!', /* ! */
  CHAR_FORM_FEED: '\f', /* \f */
  CHAR_FORWARD_SLASH: '/', /* / */
  CHAR_HASH: '#', /* # */
  CHAR_HYPHEN_MINUS: '-', /* - */
  CHAR_LEFT_ANGLE_BRACKET: '<', /* < */
  CHAR_LEFT_CURLY_BRACE: '{', /* { */
  CHAR_LEFT_SQUARE_BRACKET: '[', /* [ */
  CHAR_LINE_FEED: '\n', /* \n */
  CHAR_NO_BREAK_SPACE: '\u00A0', /* \u00A0 */
  CHAR_PERCENT: '%', /* % */
  CHAR_PLUS: '+', /* + */
  CHAR_QUESTION_MARK: '?', /* ? */
  CHAR_RIGHT_ANGLE_BRACKET: '>', /* > */
  CHAR_RIGHT_CURLY_BRACE: '}', /* } */
  CHAR_RIGHT_SQUARE_BRACKET: ']', /* ] */
  CHAR_SEMICOLON: ';', /* ; */
  CHAR_SINGLE_QUOTE: '\'', /* ' */
  CHAR_SPACE: ' ', /*   */
  CHAR_TAB: '\t', /* \t */
  CHAR_UNDERSCORE: '_', /* _ */
  CHAR_VERTICAL_LINE: '|', /* | */
  CHAR_ZERO_WIDTH_NOBREAK_SPACE: '\uFEFF' /* \uFEFF */
};


/***/ }),

/***/ "./node_modules/braces/lib/expand.js":
/*!*******************************************!*\
  !*** ./node_modules/braces/lib/expand.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const fill = __webpack_require__(/*! fill-range */ "./node_modules/fill-range/index.js");
const stringify = __webpack_require__(/*! ./stringify */ "./node_modules/braces/lib/stringify.js");
const utils = __webpack_require__(/*! ./utils */ "./node_modules/braces/lib/utils.js");

const append = (queue = '', stash = '', enclose = false) => {
  let result = [];

  queue = [].concat(queue);
  stash = [].concat(stash);

  if (!stash.length) return queue;
  if (!queue.length) {
    return enclose ? utils.flatten(stash).map(ele => `{${ele}}`) : stash;
  }

  for (let item of queue) {
    if (Array.isArray(item)) {
      for (let value of item) {
        result.push(append(value, stash, enclose));
      }
    } else {
      for (let ele of stash) {
        if (enclose === true && typeof ele === 'string') ele = `{${ele}}`;
        result.push(Array.isArray(ele) ? append(item, ele, enclose) : (item + ele));
      }
    }
  }
  return utils.flatten(result);
};

const expand = (ast, options = {}) => {
  let rangeLimit = options.rangeLimit === void 0 ? 1000 : options.rangeLimit;

  let walk = (node, parent = {}) => {
    node.queue = [];

    let p = parent;
    let q = parent.queue;

    while (p.type !== 'brace' && p.type !== 'root' && p.parent) {
      p = p.parent;
      q = p.queue;
    }

    if (node.invalid || node.dollar) {
      q.push(append(q.pop(), stringify(node, options)));
      return;
    }

    if (node.type === 'brace' && node.invalid !== true && node.nodes.length === 2) {
      q.push(append(q.pop(), ['{}']));
      return;
    }

    if (node.nodes && node.ranges > 0) {
      let args = utils.reduce(node.nodes);

      if (utils.exceedsLimit(...args, options.step, rangeLimit)) {
        throw new RangeError('expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.');
      }

      let range = fill(...args, options);
      if (range.length === 0) {
        range = stringify(node, options);
      }

      q.push(append(q.pop(), range));
      node.nodes = [];
      return;
    }

    let enclose = utils.encloseBrace(node);
    let queue = node.queue;
    let block = node;

    while (block.type !== 'brace' && block.type !== 'root' && block.parent) {
      block = block.parent;
      queue = block.queue;
    }

    for (let i = 0; i < node.nodes.length; i++) {
      let child = node.nodes[i];

      if (child.type === 'comma' && node.type === 'brace') {
        if (i === 1) queue.push('');
        queue.push('');
        continue;
      }

      if (child.type === 'close') {
        q.push(append(q.pop(), queue, enclose));
        continue;
      }

      if (child.value && child.type !== 'open') {
        queue.push(append(queue.pop(), child.value));
        continue;
      }

      if (child.nodes) {
        walk(child, node);
      }
    }

    return queue;
  };

  return utils.flatten(walk(ast));
};

module.exports = expand;


/***/ }),

/***/ "./node_modules/braces/lib/parse.js":
/*!******************************************!*\
  !*** ./node_modules/braces/lib/parse.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const stringify = __webpack_require__(/*! ./stringify */ "./node_modules/braces/lib/stringify.js");

/**
 * Constants
 */

const {
  MAX_LENGTH,
  CHAR_BACKSLASH, /* \ */
  CHAR_BACKTICK, /* ` */
  CHAR_COMMA, /* , */
  CHAR_DOT, /* . */
  CHAR_LEFT_PARENTHESES, /* ( */
  CHAR_RIGHT_PARENTHESES, /* ) */
  CHAR_LEFT_CURLY_BRACE, /* { */
  CHAR_RIGHT_CURLY_BRACE, /* } */
  CHAR_LEFT_SQUARE_BRACKET, /* [ */
  CHAR_RIGHT_SQUARE_BRACKET, /* ] */
  CHAR_DOUBLE_QUOTE, /* " */
  CHAR_SINGLE_QUOTE, /* ' */
  CHAR_NO_BREAK_SPACE,
  CHAR_ZERO_WIDTH_NOBREAK_SPACE
} = __webpack_require__(/*! ./constants */ "./node_modules/braces/lib/constants.js");

/**
 * parse
 */

const parse = (input, options = {}) => {
  if (typeof input !== 'string') {
    throw new TypeError('Expected a string');
  }

  let opts = options || {};
  let max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
  if (input.length > max) {
    throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);
  }

  let ast = { type: 'root', input, nodes: [] };
  let stack = [ast];
  let block = ast;
  let prev = ast;
  let brackets = 0;
  let length = input.length;
  let index = 0;
  let depth = 0;
  let value;
  let memo = {};

  /**
   * Helpers
   */

  const advance = () => input[index++];
  const push = node => {
    if (node.type === 'text' && prev.type === 'dot') {
      prev.type = 'text';
    }

    if (prev && prev.type === 'text' && node.type === 'text') {
      prev.value += node.value;
      return;
    }

    block.nodes.push(node);
    node.parent = block;
    node.prev = prev;
    prev = node;
    return node;
  };

  push({ type: 'bos' });

  while (index < length) {
    block = stack[stack.length - 1];
    value = advance();

    /**
     * Invalid chars
     */

    if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {
      continue;
    }

    /**
     * Escaped chars
     */

    if (value === CHAR_BACKSLASH) {
      push({ type: 'text', value: (options.keepEscaping ? value : '') + advance() });
      continue;
    }

    /**
     * Right square bracket (literal): ']'
     */

    if (value === CHAR_RIGHT_SQUARE_BRACKET) {
      push({ type: 'text', value: '\\' + value });
      continue;
    }

    /**
     * Left square bracket: '['
     */

    if (value === CHAR_LEFT_SQUARE_BRACKET) {
      brackets++;

      let closed = true;
      let next;

      while (index < length && (next = advance())) {
        value += next;

        if (next === CHAR_LEFT_SQUARE_BRACKET) {
          brackets++;
          continue;
        }

        if (next === CHAR_BACKSLASH) {
          value += advance();
          continue;
        }

        if (next === CHAR_RIGHT_SQUARE_BRACKET) {
          brackets--;

          if (brackets === 0) {
            break;
          }
        }
      }

      push({ type: 'text', value });
      continue;
    }

    /**
     * Parentheses
     */

    if (value === CHAR_LEFT_PARENTHESES) {
      block = push({ type: 'paren', nodes: [] });
      stack.push(block);
      push({ type: 'text', value });
      continue;
    }

    if (value === CHAR_RIGHT_PARENTHESES) {
      if (block.type !== 'paren') {
        push({ type: 'text', value });
        continue;
      }
      block = stack.pop();
      push({ type: 'text', value });
      block = stack[stack.length - 1];
      continue;
    }

    /**
     * Quotes: '|"|`
     */

    if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {
      let open = value;
      let next;

      if (options.keepQuotes !== true) {
        value = '';
      }

      while (index < length && (next = advance())) {
        if (next === CHAR_BACKSLASH) {
          value += next + advance();
          continue;
        }

        if (next === open) {
          if (options.keepQuotes === true) value += next;
          break;
        }

        value += next;
      }

      push({ type: 'text', value });
      continue;
    }

    /**
     * Left curly brace: '{'
     */

    if (value === CHAR_LEFT_CURLY_BRACE) {
      depth++;

      let dollar = prev.value && prev.value.slice(-1) === '$' || block.dollar === true;
      let brace = {
        type: 'brace',
        open: true,
        close: false,
        dollar,
        depth,
        commas: 0,
        ranges: 0,
        nodes: []
      };

      block = push(brace);
      stack.push(block);
      push({ type: 'open', value });
      continue;
    }

    /**
     * Right curly brace: '}'
     */

    if (value === CHAR_RIGHT_CURLY_BRACE) {
      if (block.type !== 'brace') {
        push({ type: 'text', value });
        continue;
      }

      let type = 'close';
      block = stack.pop();
      block.close = true;

      push({ type, value });
      depth--;

      block = stack[stack.length - 1];
      continue;
    }

    /**
     * Comma: ','
     */

    if (value === CHAR_COMMA && depth > 0) {
      if (block.ranges > 0) {
        block.ranges = 0;
        let open = block.nodes.shift();
        block.nodes = [open, { type: 'text', value: stringify(block) }];
      }

      push({ type: 'comma', value });
      block.commas++;
      continue;
    }

    /**
     * Dot: '.'
     */

    if (value === CHAR_DOT && depth > 0 && block.commas === 0) {
      let siblings = block.nodes;

      if (depth === 0 || siblings.length === 0) {
        push({ type: 'text', value });
        continue;
      }

      if (prev.type === 'dot') {
        block.range = [];
        prev.value += value;
        prev.type = 'range';

        if (block.nodes.length !== 3 && block.nodes.length !== 5) {
          block.invalid = true;
          block.ranges = 0;
          prev.type = 'text';
          continue;
        }

        block.ranges++;
        block.args = [];
        continue;
      }

      if (prev.type === 'range') {
        siblings.pop();

        let before = siblings[siblings.length - 1];
        before.value += prev.value + value;
        prev = before;
        block.ranges--;
        continue;
      }

      push({ type: 'dot', value });
      continue;
    }

    /**
     * Text
     */

    push({ type: 'text', value });
  }

  // Mark imbalanced braces and brackets as invalid
  do {
    block = stack.pop();

    if (block.type !== 'root') {
      block.nodes.forEach(node => {
        if (!node.nodes) {
          if (node.type === 'open') node.isOpen = true;
          if (node.type === 'close') node.isClose = true;
          if (!node.nodes) node.type = 'text';
          node.invalid = true;
        }
      });

      // get the location of the block on parent.nodes (block's siblings)
      let parent = stack[stack.length - 1];
      let index = parent.nodes.indexOf(block);
      // replace the (invalid) block with it's nodes
      parent.nodes.splice(index, 1, ...block.nodes);
    }
  } while (stack.length > 0);

  push({ type: 'eos' });
  return ast;
};

module.exports = parse;


/***/ }),

/***/ "./node_modules/braces/lib/stringify.js":
/*!**********************************************!*\
  !*** ./node_modules/braces/lib/stringify.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const utils = __webpack_require__(/*! ./utils */ "./node_modules/braces/lib/utils.js");

module.exports = (ast, options = {}) => {
  let stringify = (node, parent = {}) => {
    let invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);
    let invalidNode = node.invalid === true && options.escapeInvalid === true;
    let output = '';

    if (node.value) {
      if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {
        return '\\' + node.value;
      }
      return node.value;
    }

    if (node.value) {
      return node.value;
    }

    if (node.nodes) {
      for (let child of node.nodes) {
        output += stringify(child);
      }
    }
    return output;
  };

  return stringify(ast);
};



/***/ }),

/***/ "./node_modules/braces/lib/utils.js":
/*!******************************************!*\
  !*** ./node_modules/braces/lib/utils.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.isInteger = num => {
  if (typeof num === 'number') {
    return Number.isInteger(num);
  }
  if (typeof num === 'string' && num.trim() !== '') {
    return Number.isInteger(Number(num));
  }
  return false;
};

/**
 * Find a node of the given type
 */

exports.find = (node, type) => node.nodes.find(node => node.type === type);

/**
 * Find a node of the given type
 */

exports.exceedsLimit = (min, max, step = 1, limit) => {
  if (limit === false) return false;
  if (!exports.isInteger(min) || !exports.isInteger(max)) return false;
  return ((Number(max) - Number(min)) / Number(step)) >= limit;
};

/**
 * Escape the given node with '\\' before node.value
 */

exports.escapeNode = (block, n = 0, type) => {
  let node = block.nodes[n];
  if (!node) return;

  if ((type && node.type === type) || node.type === 'open' || node.type === 'close') {
    if (node.escaped !== true) {
      node.value = '\\' + node.value;
      node.escaped = true;
    }
  }
};

/**
 * Returns true if the given brace node should be enclosed in literal braces
 */

exports.encloseBrace = node => {
  if (node.type !== 'brace') return false;
  if ((node.commas >> 0 + node.ranges >> 0) === 0) {
    node.invalid = true;
    return true;
  }
  return false;
};

/**
 * Returns true if a brace node is invalid.
 */

exports.isInvalidBrace = block => {
  if (block.type !== 'brace') return false;
  if (block.invalid === true || block.dollar) return true;
  if ((block.commas >> 0 + block.ranges >> 0) === 0) {
    block.invalid = true;
    return true;
  }
  if (block.open !== true || block.close !== true) {
    block.invalid = true;
    return true;
  }
  return false;
};

/**
 * Returns true if a node is an open or close node
 */

exports.isOpenOrClose = node => {
  if (node.type === 'open' || node.type === 'close') {
    return true;
  }
  return node.open === true || node.close === true;
};

/**
 * Reduce an array of text nodes.
 */

exports.reduce = nodes => nodes.reduce((acc, node) => {
  if (node.type === 'text') acc.push(node.value);
  if (node.type === 'range') node.type = 'text';
  return acc;
}, []);

/**
 * Flatten an array
 */

exports.flatten = (...args) => {
  const result = [];
  const flat = arr => {
    for (let i = 0; i < arr.length; i++) {
      let ele = arr[i];
      Array.isArray(ele) ? flat(ele, result) : ele !== void 0 && result.push(ele);
    }
    return result;
  };
  flat(args);
  return result;
};


/***/ }),

/***/ "./node_modules/bytes/index.js":
/*!*************************************!*\
  !*** ./node_modules/bytes/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * bytes
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015 Jed Watson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = bytes;
module.exports.format = format;
module.exports.parse = parse;

/**
 * Module variables.
 * @private
 */

var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g;

var formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/;

var map = {
  b:  1,
  kb: 1 << 10,
  mb: 1 << 20,
  gb: 1 << 30,
  tb: Math.pow(1024, 4),
  pb: Math.pow(1024, 5),
};

var parseRegExp = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb|pb)$/i;

/**
 * Convert the given value in bytes into a string or parse to string to an integer in bytes.
 *
 * @param {string|number} value
 * @param {{
 *  case: [string],
 *  decimalPlaces: [number]
 *  fixedDecimals: [boolean]
 *  thousandsSeparator: [string]
 *  unitSeparator: [string]
 *  }} [options] bytes options.
 *
 * @returns {string|number|null}
 */

function bytes(value, options) {
  if (typeof value === 'string') {
    return parse(value);
  }

  if (typeof value === 'number') {
    return format(value, options);
  }

  return null;
}

/**
 * Format the given value in bytes into a string.
 *
 * If the value is negative, it is kept as such. If it is a float,
 * it is rounded.
 *
 * @param {number} value
 * @param {object} [options]
 * @param {number} [options.decimalPlaces=2]
 * @param {number} [options.fixedDecimals=false]
 * @param {string} [options.thousandsSeparator=]
 * @param {string} [options.unit=]
 * @param {string} [options.unitSeparator=]
 *
 * @returns {string|null}
 * @public
 */

function format(value, options) {
  if (!Number.isFinite(value)) {
    return null;
  }

  var mag = Math.abs(value);
  var thousandsSeparator = (options && options.thousandsSeparator) || '';
  var unitSeparator = (options && options.unitSeparator) || '';
  var decimalPlaces = (options && options.decimalPlaces !== undefined) ? options.decimalPlaces : 2;
  var fixedDecimals = Boolean(options && options.fixedDecimals);
  var unit = (options && options.unit) || '';

  if (!unit || !map[unit.toLowerCase()]) {
    if (mag >= map.pb) {
      unit = 'PB';
    } else if (mag >= map.tb) {
      unit = 'TB';
    } else if (mag >= map.gb) {
      unit = 'GB';
    } else if (mag >= map.mb) {
      unit = 'MB';
    } else if (mag >= map.kb) {
      unit = 'KB';
    } else {
      unit = 'B';
    }
  }

  var val = value / map[unit.toLowerCase()];
  var str = val.toFixed(decimalPlaces);

  if (!fixedDecimals) {
    str = str.replace(formatDecimalsRegExp, '$1');
  }

  if (thousandsSeparator) {
    str = str.replace(formatThousandsRegExp, thousandsSeparator);
  }

  return str + unitSeparator + unit;
}

/**
 * Parse the string value into an integer in bytes.
 *
 * If no unit is given, it is assumed the value is in bytes.
 *
 * @param {number|string} val
 *
 * @returns {number|null}
 * @public
 */

function parse(val) {
  if (typeof val === 'number' && !isNaN(val)) {
    return val;
  }

  if (typeof val !== 'string') {
    return null;
  }

  // Test if the string passed is valid
  var results = parseRegExp.exec(val);
  var floatValue;
  var unit = 'b';

  if (!results) {
    // Nothing could be extracted from the given string
    floatValue = parseInt(val, 10);
    unit = 'b'
  } else {
    // Retrieve the value and the unit
    floatValue = parseFloat(results[1]);
    unit = results[4].toLowerCase();
  }

  return Math.floor(map[unit] * floatValue);
}


/***/ }),

/***/ "./node_modules/chalk/index.js":
/*!*************************************!*\
  !*** ./node_modules/chalk/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const escapeStringRegexp = __webpack_require__(/*! escape-string-regexp */ "./node_modules/escape-string-regexp/index.js");
const ansiStyles = __webpack_require__(/*! ansi-styles */ "./node_modules/ansi-styles/index.js");
const stdoutColor = __webpack_require__(/*! supports-color */ "./node_modules/chalk/node_modules/supports-color/index.js").stdout;

const template = __webpack_require__(/*! ./templates.js */ "./node_modules/chalk/templates.js");

const isSimpleWindowsTerm = process.platform === 'win32' && !(process.env.TERM || '').toLowerCase().startsWith('xterm');

// `supportsColor.level`  `ansiStyles.color[name]` mapping
const levelMapping = ['ansi', 'ansi', 'ansi256', 'ansi16m'];

// `color-convert` models to exclude from the Chalk API due to conflicts and such
const skipModels = new Set(['gray']);

const styles = Object.create(null);

function applyOptions(obj, options) {
	options = options || {};

	// Detect level if not set manually
	const scLevel = stdoutColor ? stdoutColor.level : 0;
	obj.level = options.level === undefined ? scLevel : options.level;
	obj.enabled = 'enabled' in options ? options.enabled : obj.level > 0;
}

function Chalk(options) {
	// We check for this.template here since calling `chalk.constructor()`
	// by itself will have a `this` of a previously constructed chalk object
	if (!this || !(this instanceof Chalk) || this.template) {
		const chalk = {};
		applyOptions(chalk, options);

		chalk.template = function () {
			const args = [].slice.call(arguments);
			return chalkTag.apply(null, [chalk.template].concat(args));
		};

		Object.setPrototypeOf(chalk, Chalk.prototype);
		Object.setPrototypeOf(chalk.template, chalk);

		chalk.template.constructor = Chalk;

		return chalk.template;
	}

	applyOptions(this, options);
}

// Use bright blue on Windows as the normal blue color is illegible
if (isSimpleWindowsTerm) {
	ansiStyles.blue.open = '\u001B[94m';
}

for (const key of Object.keys(ansiStyles)) {
	ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');

	styles[key] = {
		get() {
			const codes = ansiStyles[key];
			return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, key);
		}
	};
}

styles.visible = {
	get() {
		return build.call(this, this._styles || [], true, 'visible');
	}
};

ansiStyles.color.closeRe = new RegExp(escapeStringRegexp(ansiStyles.color.close), 'g');
for (const model of Object.keys(ansiStyles.color.ansi)) {
	if (skipModels.has(model)) {
		continue;
	}

	styles[model] = {
		get() {
			const level = this.level;
			return function () {
				const open = ansiStyles.color[levelMapping[level]][model].apply(null, arguments);
				const codes = {
					open,
					close: ansiStyles.color.close,
					closeRe: ansiStyles.color.closeRe
				};
				return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
			};
		}
	};
}

ansiStyles.bgColor.closeRe = new RegExp(escapeStringRegexp(ansiStyles.bgColor.close), 'g');
for (const model of Object.keys(ansiStyles.bgColor.ansi)) {
	if (skipModels.has(model)) {
		continue;
	}

	const bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);
	styles[bgModel] = {
		get() {
			const level = this.level;
			return function () {
				const open = ansiStyles.bgColor[levelMapping[level]][model].apply(null, arguments);
				const codes = {
					open,
					close: ansiStyles.bgColor.close,
					closeRe: ansiStyles.bgColor.closeRe
				};
				return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
			};
		}
	};
}

const proto = Object.defineProperties(() => {}, styles);

function build(_styles, _empty, key) {
	const builder = function () {
		return applyStyle.apply(builder, arguments);
	};

	builder._styles = _styles;
	builder._empty = _empty;

	const self = this;

	Object.defineProperty(builder, 'level', {
		enumerable: true,
		get() {
			return self.level;
		},
		set(level) {
			self.level = level;
		}
	});

	Object.defineProperty(builder, 'enabled', {
		enumerable: true,
		get() {
			return self.enabled;
		},
		set(enabled) {
			self.enabled = enabled;
		}
	});

	// See below for fix regarding invisible grey/dim combination on Windows
	builder.hasGrey = this.hasGrey || key === 'gray' || key === 'grey';

	// `__proto__` is used because we must return a function, but there is
	// no way to create a function with a different prototype
	builder.__proto__ = proto; // eslint-disable-line no-proto

	return builder;
}

function applyStyle() {
	// Support varags, but simply cast to string in case there's only one arg
	const args = arguments;
	const argsLen = args.length;
	let str = String(arguments[0]);

	if (argsLen === 0) {
		return '';
	}

	if (argsLen > 1) {
		// Don't slice `arguments`, it prevents V8 optimizations
		for (let a = 1; a < argsLen; a++) {
			str += ' ' + args[a];
		}
	}

	if (!this.enabled || this.level <= 0 || !str) {
		return this._empty ? '' : str;
	}

	// Turns out that on Windows dimmed gray text becomes invisible in cmd.exe,
	// see https://github.com/chalk/chalk/issues/58
	// If we're on Windows and we're dealing with a gray color, temporarily make 'dim' a noop.
	const originalDim = ansiStyles.dim.open;
	if (isSimpleWindowsTerm && this.hasGrey) {
		ansiStyles.dim.open = '';
	}

	for (const code of this._styles.slice().reverse()) {
		// Replace any instances already present with a re-opening code
		// otherwise only the part of the string until said closing code
		// will be colored, and the rest will simply be 'plain'.
		str = code.open + str.replace(code.closeRe, code.open) + code.close;

		// Close the styling before a linebreak and reopen
		// after next line to fix a bleed issue on macOS
		// https://github.com/chalk/chalk/pull/92
		str = str.replace(/\r?\n/g, `${code.close}$&${code.open}`);
	}

	// Reset the original `dim` if we changed it to work around the Windows dimmed gray issue
	ansiStyles.dim.open = originalDim;

	return str;
}

function chalkTag(chalk, strings) {
	if (!Array.isArray(strings)) {
		// If chalk() was called by itself or with a string,
		// return the string itself as a string.
		return [].slice.call(arguments, 1).join(' ');
	}

	const args = [].slice.call(arguments, 2);
	const parts = [strings.raw[0]];

	for (let i = 1; i < strings.length; i++) {
		parts.push(String(args[i - 1]).replace(/[{}\\]/g, '\\$&'));
		parts.push(String(strings.raw[i]));
	}

	return template(chalk, parts.join(''));
}

Object.defineProperties(Chalk.prototype, styles);

module.exports = Chalk(); // eslint-disable-line new-cap
module.exports.supportsColor = stdoutColor;
module.exports.default = module.exports; // For TypeScript


/***/ }),

/***/ "./node_modules/chalk/node_modules/has-flag/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/chalk/node_modules/has-flag/index.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = (flag, argv) => {
	argv = argv || process.argv;
	const prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');
	const pos = argv.indexOf(prefix + flag);
	const terminatorPos = argv.indexOf('--');
	return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
};


/***/ }),

/***/ "./node_modules/chalk/node_modules/supports-color/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/chalk/node_modules/supports-color/index.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const os = __webpack_require__(/*! os */ "os");
const hasFlag = __webpack_require__(/*! has-flag */ "./node_modules/chalk/node_modules/has-flag/index.js");

const env = process.env;

let forceColor;
if (hasFlag('no-color') ||
	hasFlag('no-colors') ||
	hasFlag('color=false')) {
	forceColor = false;
} else if (hasFlag('color') ||
	hasFlag('colors') ||
	hasFlag('color=true') ||
	hasFlag('color=always')) {
	forceColor = true;
}
if ('FORCE_COLOR' in env) {
	forceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;
}

function translateLevel(level) {
	if (level === 0) {
		return false;
	}

	return {
		level,
		hasBasic: true,
		has256: level >= 2,
		has16m: level >= 3
	};
}

function supportsColor(stream) {
	if (forceColor === false) {
		return 0;
	}

	if (hasFlag('color=16m') ||
		hasFlag('color=full') ||
		hasFlag('color=truecolor')) {
		return 3;
	}

	if (hasFlag('color=256')) {
		return 2;
	}

	if (stream && !stream.isTTY && forceColor !== true) {
		return 0;
	}

	const min = forceColor ? 1 : 0;

	if (process.platform === 'win32') {
		// Node.js 7.5.0 is the first version of Node.js to include a patch to
		// libuv that enables 256 color output on Windows. Anything earlier and it
		// won't work. However, here we target Node.js 8 at minimum as it is an LTS
		// release, and Node.js 7 is not. Windows 10 build 10586 is the first Windows
		// release that supports 256 colors. Windows 10 build 14931 is the first release
		// that supports 16m/TrueColor.
		const osRelease = os.release().split('.');
		if (
			Number(process.versions.node.split('.')[0]) >= 8 &&
			Number(osRelease[0]) >= 10 &&
			Number(osRelease[2]) >= 10586
		) {
			return Number(osRelease[2]) >= 14931 ? 3 : 2;
		}

		return 1;
	}

	if ('CI' in env) {
		if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(sign => sign in env) || env.CI_NAME === 'codeship') {
			return 1;
		}

		return min;
	}

	if ('TEAMCITY_VERSION' in env) {
		return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
	}

	if (env.COLORTERM === 'truecolor') {
		return 3;
	}

	if ('TERM_PROGRAM' in env) {
		const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

		switch (env.TERM_PROGRAM) {
			case 'iTerm.app':
				return version >= 3 ? 3 : 2;
			case 'Apple_Terminal':
				return 2;
			// No default
		}
	}

	if (/-256(color)?$/i.test(env.TERM)) {
		return 2;
	}

	if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
		return 1;
	}

	if ('COLORTERM' in env) {
		return 1;
	}

	if (env.TERM === 'dumb') {
		return min;
	}

	return min;
}

function getSupportLevel(stream) {
	const level = supportsColor(stream);
	return translateLevel(level);
}

module.exports = {
	supportsColor: getSupportLevel,
	stdout: getSupportLevel(process.stdout),
	stderr: getSupportLevel(process.stderr)
};


/***/ }),

/***/ "./node_modules/chalk/templates.js":
/*!*****************************************!*\
  !*** ./node_modules/chalk/templates.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const TEMPLATE_REGEX = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
const STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
const STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
const ESCAPE_REGEX = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi;

const ESCAPES = new Map([
	['n', '\n'],
	['r', '\r'],
	['t', '\t'],
	['b', '\b'],
	['f', '\f'],
	['v', '\v'],
	['0', '\0'],
	['\\', '\\'],
	['e', '\u001B'],
	['a', '\u0007']
]);

function unescape(c) {
	if ((c[0] === 'u' && c.length === 5) || (c[0] === 'x' && c.length === 3)) {
		return String.fromCharCode(parseInt(c.slice(1), 16));
	}

	return ESCAPES.get(c) || c;
}

function parseArguments(name, args) {
	const results = [];
	const chunks = args.trim().split(/\s*,\s*/g);
	let matches;

	for (const chunk of chunks) {
		if (!isNaN(chunk)) {
			results.push(Number(chunk));
		} else if ((matches = chunk.match(STRING_REGEX))) {
			results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, chr) => escape ? unescape(escape) : chr));
		} else {
			throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
		}
	}

	return results;
}

function parseStyle(style) {
	STYLE_REGEX.lastIndex = 0;

	const results = [];
	let matches;

	while ((matches = STYLE_REGEX.exec(style)) !== null) {
		const name = matches[1];

		if (matches[2]) {
			const args = parseArguments(name, matches[2]);
			results.push([name].concat(args));
		} else {
			results.push([name]);
		}
	}

	return results;
}

function buildStyle(chalk, styles) {
	const enabled = {};

	for (const layer of styles) {
		for (const style of layer.styles) {
			enabled[style[0]] = layer.inverse ? null : style.slice(1);
		}
	}

	let current = chalk;
	for (const styleName of Object.keys(enabled)) {
		if (Array.isArray(enabled[styleName])) {
			if (!(styleName in current)) {
				throw new Error(`Unknown Chalk style: ${styleName}`);
			}

			if (enabled[styleName].length > 0) {
				current = current[styleName].apply(current, enabled[styleName]);
			} else {
				current = current[styleName];
			}
		}
	}

	return current;
}

module.exports = (chalk, tmp) => {
	const styles = [];
	const chunks = [];
	let chunk = [];

	// eslint-disable-next-line max-params
	tmp.replace(TEMPLATE_REGEX, (m, escapeChar, inverse, style, close, chr) => {
		if (escapeChar) {
			chunk.push(unescape(escapeChar));
		} else if (style) {
			const str = chunk.join('');
			chunk = [];
			chunks.push(styles.length === 0 ? str : buildStyle(chalk, styles)(str));
			styles.push({inverse, styles: parseStyle(style)});
		} else if (close) {
			if (styles.length === 0) {
				throw new Error('Found extraneous } in Chalk template literal');
			}

			chunks.push(buildStyle(chalk, styles)(chunk.join('')));
			chunk = [];
			styles.pop();
		} else {
			chunk.push(chr);
		}
	});

	chunks.push(chunk.join(''));

	if (styles.length > 0) {
		const errMsg = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? '' : 's'} (\`}\`)`;
		throw new Error(errMsg);
	}

	return chunks.join('');
};


/***/ }),

/***/ "./node_modules/chokidar/index.js":
/*!****************************************!*\
  !*** ./node_modules/chokidar/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const EventEmitter = __webpack_require__(/*! events */ "events").EventEmitter;
const fs = __webpack_require__(/*! fs */ "fs");
const sysPath = __webpack_require__(/*! path */ "path");
const readdirp = __webpack_require__(/*! readdirp */ "./node_modules/readdirp/index.js");
const anymatch = __webpack_require__(/*! anymatch */ "./node_modules/anymatch/index.js");
const globParent = __webpack_require__(/*! glob-parent */ "./node_modules/glob-parent/index.js");
const isGlob = __webpack_require__(/*! is-glob */ "./node_modules/is-glob/index.js");
const braces = __webpack_require__(/*! braces */ "./node_modules/braces/index.js");
const normalizePath = __webpack_require__(/*! normalize-path */ "./node_modules/normalize-path/index.js");
const { promisify } = __webpack_require__(/*! util */ "util");

const NodeFsHandler = __webpack_require__(/*! ./lib/nodefs-handler */ "./node_modules/chokidar/lib/nodefs-handler.js");
const FsEventsHandler = __webpack_require__(/*! ./lib/fsevents-handler */ "./node_modules/chokidar/lib/fsevents-handler.js");

const stat = promisify(fs.stat);
const readdir = promisify(fs.readdir);

/**
 * @typedef {String} Path
 * @typedef {'all'|'add'|'addDir'|'change'|'unlink'|'unlinkDir'|'raw'|'error'|'ready'} EventName
 * @typedef {'readdir'|'watch'|'add'|'remove'|'change'} ThrottleType
 */

/**
 *
 * @typedef {Object} WatchHelpers
 * @property {Boolean} followSymlinks
 * @property {'stat'|'lstat'} statMethod
 * @property {Path} path
 * @property {Path} watchPath
 * @property {Function} entryPath
 * @property {Boolean} hasGlob
 * @property {Object} globFilter
 * @property {Function} filterPath
 * @property {Function} filterDir
 */

/**
 * @param {String|Array<String>} value
 */
const arrify = (value = []) => Array.isArray(value) ? value : [value];

const flatten = (list, result = []) => {
  list.forEach(item => {
    if (Array.isArray(item)) {
      flatten(item, result);
    } else {
      result.push(item);
    }
  });
  return result;
};

// Optimize RAM usage.
const BACK_SLASH = /\\/g;
const SLASH = '/';
const DOUBLE_SLASH = /\/\//;
const SLASH_OR_BACK_SLASH = /[\/\\]/;
const BRACE_START = '{';
const BANG = '!';
const ONE_DOT = '.';
const TWO_DOTS = '..';
const GLOBSTAR = '**';
const SLASH_GLOBSTAR = '/**';
const DOT_RE = /\..*\.(sw[px])$|\~$|\.subl.*\.tmp/;
const REPLACER_RE = /^\.[\/\\]/;
const STRING_TYPE = 'string';
const EMPTY_FN = () => {};

const toUnix = (string) => {
  let str = string.replace(BACK_SLASH, SLASH);
  while (str.match(DOUBLE_SLASH)) {
    str = str.replace(DOUBLE_SLASH, SLASH);
  }
  return str;
};

// Our version of upath.normalize
// TODO: this is not equal to path-normalize module - investigate why
const normalizePathToUnix = (path) => toUnix(sysPath.normalize(toUnix(path)));

const normalizeIgnored = (cwd = '') => (path) => {
  if (typeof path !== STRING_TYPE) return path;
  return normalizePathToUnix(sysPath.isAbsolute(path) ? path : sysPath.join(cwd, path));
};

const getAbsolutePath = (path, cwd) => {
  if (sysPath.isAbsolute(path)) {
    return path;
  } else if (path[0] === BANG) {
    return BANG + sysPath.join(cwd, path.substring(1));
  } else {
    return sysPath.join(cwd, path);
  }
};

const undef = (opts, key) => opts[key] === undefined;

/**
 * Directory entry.
 * @property {Path} path
 * @property {Set<Path>} items
 */
class DirEntry {
  /**
   * @param {Path} dir
   * @param {Function} removeWatcher
   */
  constructor(dir, removeWatcher) {
    this.path = dir;
    this._removeWatcher = removeWatcher;
    /** @type {Set<Path>} */
    this.items = new Set();
  }

  add(item) {
    if (item !== ONE_DOT && item !== TWO_DOTS) this.items.add(item);
  }

  async remove(item) {
    this.items.delete(item);

    if (!this.items.size) {
      const dir = this.path;
      try {
        await readdir(dir);
      } catch (err) {
        this._removeWatcher(sysPath.dirname(dir), sysPath.basename(dir));
      }
    }
  }

  has(item) {
    return this.items.has(item);
  }

  /**
   * @returns {Array<String>}
   */
  getChildren() {
    return Array.from(this.items.values());
  }
}

class WatchHelper {
  constructor(path, watchPath, follow, fsw) {
    this.fsw = fsw;
    this.path = path = path.replace(REPLACER_RE, '');
    this.watchPath = watchPath;
    this.fullWatchPath = sysPath.resolve(watchPath);
    this.hasGlob = watchPath !== path;
    /** @type {object|boolean} */
    this.globSymlink = this.hasGlob && follow ? null : false;
    this.globFilter = this.hasGlob ? anymatch(path) : false;
    this.dirParts = this.getDirParts(path);
    this.dirParts.forEach((parts) => {
      if (parts.length > 1) parts.pop();
    });
    this.followSymlinks = follow;
    this.statMethod = follow ? 'stat' : 'lstat';
  }

  checkGlobSymlink(entry) {
    // only need to resolve once
    // first entry should always have entry.parentDir === ''
    if (this.globSymlink == null) {
      this.globSymlink = entry.fullParentDir === this.fullWatchPath ?
        false : {realPath: entry.fullParentDir, linkPath: this.fullWatchPath};
    }

    if (this.globSymlink) {
      return entry.fullPath.replace(this.globSymlink.realPath, this.globSymlink.linkPath);
    }

    return entry.fullPath;
  }

  entryPath(entry) {
    return sysPath.join(this.watchPath,
      sysPath.relative(this.watchPath, this.checkGlobSymlink(entry))
    );
  }

  filterPath(entry) {
    const {stats} = entry;
    if (stats && stats.isSymbolicLink()) return this.filterDir(entry);
    const resolvedPath = this.entryPath(entry);
    const matchesGlob = this.hasGlob ? this.globFilter(resolvedPath) : true;
    return matchesGlob &&
      this.fsw._isntIgnored(resolvedPath, stats) &&
      this.fsw._hasReadPermissions(stats);
  }

  getDirParts(path) {
    if (!this.hasGlob) return [];
    const parts = [];
    const expandedPath = path.includes(BRACE_START)
      ? braces.expand(path)
      : [path];
    expandedPath.forEach((path) => {
      parts.push(sysPath.relative(this.watchPath, path).split(SLASH_OR_BACK_SLASH));
    });
    return parts;
  }

  filterDir(entry) {
    if (this.hasGlob) {
      const entryParts = this.getDirParts(this.checkGlobSymlink(entry));
      let globstar = false;
      this.unmatchedGlob = !this.dirParts.some((parts) => {
        return parts.every((part, i) => {
          if (part === GLOBSTAR) globstar = true;
          return globstar || !entryParts[0][i] || anymatch(part, entryParts[0][i]);
        });
      });
    }
    return !this.unmatchedGlob && this.fsw._isntIgnored(this.entryPath(entry), entry.stats);
  }
}

/**
 * Watches files & directories for changes. Emitted events:
 * `add`, `addDir`, `change`, `unlink`, `unlinkDir`, `all`, `error`
 *
 *     new FSWatcher()
 *       .add(directories)
 *       .on('add', path => log('File', path, 'was added'))
 */
class FSWatcher extends EventEmitter {
// Not indenting methods for history sake; for now.
constructor(_opts) {
  super();

  const opts = {};
  if (_opts) Object.assign(opts, _opts); // for frozen objects

  /** @type {Map<String, DirEntry>} */
  this._watched = new Map();
  /** @type {Map<String, Array>} */
  this._closers = new Map();
  /** @type {Set<String>} */
  this._ignoredPaths = new Set();

  /** @type {Map<ThrottleType, Map>} */
  this._throttled = new Map();

  /** @type {Map<Path, String|Boolean>} */
  this._symlinkPaths = new Map();

  this._streams = new Set();
  this.closed = false;


  // Set up default options.
  if (undef(opts, 'persistent')) opts.persistent = true;
  if (undef(opts, 'ignoreInitial')) opts.ignoreInitial = false;
  if (undef(opts, 'ignorePermissionErrors')) opts.ignorePermissionErrors = false;
  if (undef(opts, 'interval')) opts.interval = 100;
  if (undef(opts, 'binaryInterval')) opts.binaryInterval = 300;
  if (undef(opts, 'disableGlobbing')) opts.disableGlobbing = false;
  opts.enableBinaryInterval = opts.binaryInterval !== opts.interval;

  // Enable fsevents on OS X when polling isn't explicitly enabled.
  if (undef(opts, 'useFsEvents')) opts.useFsEvents = !opts.usePolling;

  // If we can't use fsevents, ensure the options reflect it's disabled.
  const canUseFsEvents = FsEventsHandler.canUse();
  if (!canUseFsEvents) opts.useFsEvents = false;

  // Use polling on Mac if not using fsevents.
  // Other platforms use non-polling fs_watch.
  if (undef(opts, 'usePolling') && !opts.useFsEvents) {
    opts.usePolling = process.platform === 'darwin';
  }

  // Global override (useful for end-developers that need to force polling for all
  // instances of chokidar, regardless of usage/dependency depth)
  const envPoll = process.env.CHOKIDAR_USEPOLLING;
  if (envPoll !== undefined) {
    const envLower = envPoll.toLowerCase();

    if (envLower === 'false' || envLower === '0') {
      opts.usePolling = false;
    } else if (envLower === 'true' || envLower === '1') {
      opts.usePolling = true;
    } else {
      opts.usePolling = !!envLower;
    }
  }
  const envInterval = process.env.CHOKIDAR_INTERVAL;
  if (envInterval) {
    opts.interval = parseInt(envInterval);
  }

  // Editor atomic write normalization enabled by default with fs.watch
  if (undef(opts, 'atomic')) opts.atomic = !opts.usePolling && !opts.useFsEvents;
  if (opts.atomic) this._pendingUnlinks = new Map();

  if (undef(opts, 'followSymlinks')) opts.followSymlinks = true;

  if (undef(opts, 'awaitWriteFinish')) opts.awaitWriteFinish = false;
  if (opts.awaitWriteFinish === true) opts.awaitWriteFinish = {};
  const awf = opts.awaitWriteFinish;
  if (awf) {
    if (!awf.stabilityThreshold) awf.stabilityThreshold = 2000;
    if (!awf.pollInterval) awf.pollInterval = 100;
    this._pendingWrites = new Map();
  }
  if (opts.ignored) opts.ignored = arrify(opts.ignored);

  let readyCalls = 0;
  this._emitReady = () => {
    readyCalls++;
    if (readyCalls >= this._readyCount) {
      this._emitReady = EMPTY_FN;
      this._readyEmitted = true;
      // use process.nextTick to allow time for listener to be bound
      process.nextTick(() => this.emit('ready'));
    }
  };
  this._emitRaw = (...args) => this.emit('raw', ...args);
  this._readyEmitted = false;
  this.options = opts;

  // Initialize with proper watcher.
  if (opts.useFsEvents) {
    this._fsEventsHandler = new FsEventsHandler(this);
  } else {
    this._nodeFsHandler = new NodeFsHandler(this);
  }

  // Youre frozen when your hearts not open.
  Object.freeze(opts);
}

// Public methods
// --------------

_normalizePaths(paths_) {
  const paths = flatten(arrify(paths_));

  if (!paths.every(p => typeof p === STRING_TYPE)) {
    throw new TypeError('Non-string provided as watch path: ' + paths);
  }

  return paths;
}

/**
 * Adds paths to be watched on an existing FSWatcher instance
 * @param {Path|Array<Path>} paths_
 * @param {String=} _origAdd private; for handling non-existent paths to be watched
 * @param {Boolean=} _internal private; indicates a non-user add
 * @returns {FSWatcher} for chaining
 */
async add(paths_, _origAdd, _internal) {
  const {cwd, disableGlobbing} = this.options;
  this.closed = false;

  /**
   * @type {Array<String>}
   */
  let paths = this._normalizePaths(paths_);

  if (cwd) {
    paths = paths.map((path) => {
      const absPath = getAbsolutePath(path, cwd);

      // Check `path` instead of `absPath` because the cwd portion can't be a glob
      if (disableGlobbing || !isGlob(path)) {
        return absPath;
      } else {
        return normalizePath(absPath);
      }
    });
  }

  // set aside negated glob strings
  paths = paths.filter((path) => {
    if (path[0] === BANG) {
      this._ignoredPaths.add(path.substring(1));
      return false;
    } else {
      // if a path is being added that was previously ignored, stop ignoring it
      this._ignoredPaths.delete(path);
      this._ignoredPaths.delete(path + SLASH_GLOBSTAR);

      // reset the cached userIgnored anymatch fn
      // to make ignoredPaths changes effective
      this._userIgnored = null;

      return true;
    }
  });

  if (this.options.useFsEvents && this._fsEventsHandler) {
    if (!this._readyCount) this._readyCount = paths.length;
    if (this.options.persistent) this._readyCount *= 2;
    paths.forEach((path) => this._fsEventsHandler._addToFsEvents(path));
  } else {
    if (!this._readyCount) this._readyCount = 0;
    this._readyCount += paths.length;
    const results = await Promise.all(
      paths.map(async path => {
        const res = await this._nodeFsHandler._addToNodeFs(path, !_internal, 0, 0, _origAdd);
        if (res) this._emitReady();
        return res;
      })
    );
    results.forEach((item) => {
      if (!item || this.closed) return;
      this.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));
    });
  }

  return this;
}

/**
 * Close watchers or start ignoring events from specified paths.
 * @param {Path|Array<Path>} paths - string or array of strings, file/directory paths and/or globs
 * @returns {FSWatcher} for chaining
*/
unwatch(paths) {
  if (this.closed) return this;
  paths = flatten(arrify(paths));
  const cwd = this.options.cwd;

  paths.forEach((path) => {
    // convert to absolute path unless relative path already matches
    if (!sysPath.isAbsolute(path) && !this._closers.has(path)) {
      if (cwd) path = sysPath.join(cwd, path);
      path = sysPath.resolve(path);
    }

    this._closePath(path);

    this._ignoredPaths.add(path);
    if (this._watched.has(path)) {
      this._ignoredPaths.add(path + SLASH_GLOBSTAR);
    }

    // reset the cached userIgnored anymatch fn
    // to make ignoredPaths changes effective
    this._userIgnored = null;
  });

  return this;
}

/**
 * Close watchers and remove all listeners from watched paths.
 * @returns {FSWatcher} for chaining.
*/
close() {
  if (this.closed) return this;
  this.closed = true;

  // Memory management.
  this._closers.forEach(closerList => closerList.forEach(closer => closer()));
  this._closers.clear();
  this._watched.clear();
  this._streams.forEach(stream => stream.destroy());
  this._streams.clear();
  this._symlinkPaths.clear();
  this._throttled.clear();
  this.removeAllListeners();

  return this;
}

/**
 * Expose list of watched paths
 * @returns {Object} for chaining
*/
getWatched() {
  const watchList = {};
  this._watched.forEach((entry, dir) => {
    const key = this.options.cwd ? sysPath.relative(this.options.cwd, dir) : dir;
    watchList[key || ONE_DOT] = entry.getChildren().sort();
  });
  return watchList;
}

emitWithAll(event, args) {
  this.emit(...args);
  if (event !== 'error') this.emit(...['all'].concat(args));
}

// Common helpers
// --------------

/**
 * Normalize and emit events.
 * Calling _emit DOES NOT MEAN emit() would be called!
 * @param {EventName} event Type of event
 * @param {Path} path File or directory path
 * @param {*=} val1 arguments to be passed with event
 * @param {*=} val2
 * @param {*=} val3
 * @returns the error if defined, otherwise the value of the FSWatcher instance's `closed` flag
 */
async _emit(event, path, val1, val2, val3) {
  if (this.closed) return;

  const opts = this.options;
  if (opts.cwd) path = sysPath.relative(opts.cwd, path);
  /** @type Array<any> */
  const args = [event, path];
  if (val3 !== undefined) args.push(val1, val2, val3);
  else if (val2 !== undefined) args.push(val1, val2);
  else if (val1 !== undefined) args.push(val1);

  const awf = opts.awaitWriteFinish;
  let pw;
  if (awf && (pw = this._pendingWrites.get(path))) {
    pw.lastChange = new Date();
    return this;
  }

  if (opts.atomic) {
    if (event === 'unlink') {
      this._pendingUnlinks.set(path, args);
      setTimeout(() => {
        this._pendingUnlinks.forEach((entry, path) => {
          this.emit(...entry);
          this.emit(...['all', ...entry]);
          this._pendingUnlinks.delete(path);
        });
      }, typeof opts.atomic === "number" ? opts.atomic : 100);
      return this;
    } else if (event === 'add' && this._pendingUnlinks.has(path)) {
      event = args[0] = 'change';
      this._pendingUnlinks.delete(path);
    }
  }

  if (awf && (event === 'add' || event === 'change') && this._readyEmitted) {
    const awfEmit = (err, stats) => {
      if (err) {
        event = args[0] = 'error';
        args[1] = err;
        this.emitWithAll(event, args);
      } else if (stats) {
        // if stats doesn't exist the file must have been deleted
        if (args.length > 2) {
          args[2] = stats;
        } else {
          args.push(stats);
        }
        this.emitWithAll(event, args);
      }
    };

    this._awaitWriteFinish(path, awf.stabilityThreshold, event, awfEmit);
    return this;
  }

  if (event === 'change') {
    const isThrottled = !this._throttle('change', path, 50);
    if (isThrottled) return this;
  }

  if (opts.alwaysStat && val1 === undefined &&
    (event === 'add' || event === 'addDir' || event === 'change')
  ) {
    const fullPath = opts.cwd ? sysPath.join(opts.cwd, path) : path;
    try {
      const stats = await stat(fullPath);
      // Suppress event when fs_stat fails, to avoid sending undefined 'stat'
      if (!stats) return;
      args.push(stats);
      this.emitWithAll(event, args);
    } catch (err) {}
  } else {
    this.emitWithAll(event, args);
  }

  return this;
}

/**
 * Common handler for errors
 * @param {Error} error
 * @returns {Error|Boolean} The error if defined, otherwise the value of the FSWatcher instance's `closed` flag
 */
_handleError(error) {
  const code = error && error.code;
  if (error && code !== 'ENOENT' && code !== 'ENOTDIR' &&
    (!this.options.ignorePermissionErrors || (code !== 'EPERM' && code !== 'EACCES'))
  ) {
    this.emit('error', error);
  }
  return error || this.closed;
}

/**
 * Helper utility for throttling
 * @param {ThrottleType} actionType type being throttled
 * @param {Path} path being acted upon
 * @param {Number} timeout duration of time to suppress duplicate actions
 * @returns {Object|false} tracking object or false if action should be suppressed
 */
_throttle(actionType, path, timeout) {
  if (!this._throttled.has(actionType)) {
    this._throttled.set(actionType, new Map());
  }

  /** @type {Map<Path, Object>} */
  const action = this._throttled.get(actionType);
  /** @type {Object} */
  const actionPath = action.get(path);

  if (actionPath) {
    actionPath.count++;
    return false;
  }

  let timeoutObject;
  const clear = () => {
    const item = action.get(path);
    const count = item ? item.count : 0;
    action.delete(path);
    clearTimeout(timeoutObject);
    if (item) clearTimeout(item.timeoutObject);
    return count;
  };
  timeoutObject = setTimeout(clear, timeout);
  const thr = {timeoutObject: timeoutObject, clear: clear, count: 0};
  action.set(path, thr);
  return thr;
}

_incrReadyCount() {
  return this._readyCount++;
}

/**
 * Awaits write operation to finish.
 * Polls a newly created file for size variations. When files size does not change for 'threshold' milliseconds calls callback.
 * @param {Path} path being acted upon
 * @param {Number} threshold Time in milliseconds a file size must be fixed before acknowledging write OP is finished
 * @param {EventName} event
 * @param {Function} awfEmit Callback to be called when ready for event to be emitted.
 */
_awaitWriteFinish(path, threshold, event, awfEmit) {
  let timeoutHandler;

  let fullPath = path;
  if (this.options.cwd && !sysPath.isAbsolute(path)) {
    fullPath = sysPath.join(this.options.cwd, path);
  }

  const now = new Date();

  const awaitWriteFinish = (prevStat) => {
    fs.stat(fullPath, (err, curStat) => {
      if (err || !this._pendingWrites.has(path)) {
        if (err && err.code !== 'ENOENT') awfEmit(err);
        return;
      }

      const now = Number(new Date());

      if (prevStat && curStat.size != prevStat.size) {
        this._pendingWrites.get(path).lastChange = now;
      }
      const pw = this._pendingWrites.get(path);
      const df = now - pw.lastChange;

      if (df >= threshold) {
        this._pendingWrites.delete(path);
        awfEmit(null, curStat);
      } else {
        timeoutHandler = setTimeout(
          awaitWriteFinish,
          this.options.awaitWriteFinish.pollInterval,
          curStat
        );
      }
    });
  };

  if (!this._pendingWrites.has(path)) {
    this._pendingWrites.set(path, {
      lastChange: now,
      cancelWait: () => {
        this._pendingWrites.delete(path);
        clearTimeout(timeoutHandler);
        return event;
      }
    });
    timeoutHandler = setTimeout(
      awaitWriteFinish,
      this.options.awaitWriteFinish.pollInterval
    );
  }
}

_getGlobIgnored() {
  return Array.from(this._ignoredPaths.values());
}

/**
 * Determines whether user has asked to ignore this path.
 * @param {Path} path filepath or dir
 * @param {fs.Stats=} stats result of fs.stat
 * @returns {Boolean}
 */
_isIgnored(path, stats) {
  if (this.options.atomic && DOT_RE.test(path)) return true;
  if (!this._userIgnored) {
    const cwd = this.options.cwd;
    const ign = this.options.ignored;

    const ignored = ign && ign.map(normalizeIgnored(cwd));
    const paths = arrify(ignored)
      .filter((path) => typeof path === STRING_TYPE && !isGlob(path))
      .map((path) => path + SLASH_GLOBSTAR);
    this._userIgnored = anymatch(
      this._getGlobIgnored()
        .map(normalizeIgnored(cwd))
        .concat(ignored)
        .concat(paths)
    );
  }

  return this._userIgnored([path, stats]);
}

_isntIgnored(path, stat) {
  return !this._isIgnored(path, stat);
}

/**
 * Provides a set of common helpers and properties relating to symlink and glob handling.
 * @param {Path} path file, directory, or glob pattern being watched
 * @param {Number=} depth at any depth > 0, this isn't a glob
 * @returns {WatchHelper} object containing helpers for this path
 */
_getWatchHelpers(path, depth) {
  const watchPath = depth || this.options.disableGlobbing || !isGlob(path) ? path : globParent(path);
  const follow = this.options.followSymlinks;

  return new WatchHelper(path, watchPath, follow, this);
}

// Directory helpers
// -----------------

/**
 * Provides directory tracking objects
 * @param {String} directory path of the directory
 * @returns {DirEntry} the directory's tracking object
 */
_getWatchedDir(directory) {
  if (!this._boundRemove) this._boundRemove = this._remove.bind(this);
  const dir = sysPath.resolve(directory);
  if (!this._watched.has(dir)) this._watched.set(dir, new DirEntry(dir, this._boundRemove));
  return this._watched.get(dir);
}

// File helpers
// ------------

/**
 * Check for read permissions.
 * Based on this answer on SO: http://stackoverflow.com/a/11781404/1358405
 * @param {fs.Stats} stats - object, result of fs_stat
 * @returns {Boolean} indicates whether the file can be read
*/
_hasReadPermissions(stats) {
  if (this.options.ignorePermissionErrors) return true;

  // stats.mode may be bigint
  const md = stats && Number.parseInt(stats.mode);
  const st = md & 0o777;
  const it = parseInt(st.toString(8)[0], 10);
  return Boolean(4 & it);
}

/**
 * Handles emitting unlink events for
 * files and directories, and via recursion, for
 * files and directories within directories that are unlinked
 * @param {String} directory within which the following item is located
 * @param {String} item      base path of item/directory
 * @returns {void}
*/
_remove(directory, item) {
  // if what is being deleted is a directory, get that directory's paths
  // for recursive deleting and cleaning of watched object
  // if it is not a directory, nestedDirectoryChildren will be empty array
  const path = sysPath.join(directory, item);
  const fullPath = sysPath.resolve(path);
  const isDirectory = this._watched.has(path) || this._watched.has(fullPath);

  // prevent duplicate handling in case of arriving here nearly simultaneously
  // via multiple paths (such as _handleFile and _handleDir)
  if (!this._throttle('remove', path, 100)) return;

  // if the only watched file is removed, watch for its return
  if (!isDirectory && !this.options.useFsEvents && this._watched.size === 1) {
    this.add(directory, item, true);
  }

  // This will create a new entry in the watched object in either case
  // so we got to do the directory check beforehand
  const wp = this._getWatchedDir(path);
  const nestedDirectoryChildren = wp.getChildren();

  // Recursively remove children directories / files.
  nestedDirectoryChildren.forEach(nested => this._remove(path, nested));

  // Check if item was on the watched list and remove it
  const parent = this._getWatchedDir(directory);
  const wasTracked = parent.has(item);
  parent.remove(item);

  // If we wait for this file to be fully written, cancel the wait.
  let relPath = path;
  if (this.options.cwd) relPath = sysPath.relative(this.options.cwd, path);
  if (this.options.awaitWriteFinish && this._pendingWrites.has(relPath)) {
    const event = this._pendingWrites.get(relPath).cancelWait();
    if (event === 'add') return;
  }

  // The Entry will either be a directory that just got removed
  // or a bogus entry to a file, in either case we have to remove it
  this._watched.delete(path);
  this._watched.delete(fullPath);
  const eventName = isDirectory ? 'unlinkDir' : 'unlink';
  if (wasTracked && !this._isIgnored(path)) this._emit(eventName, path);

  // Avoid conflicts if we later create another file with the same name
  if (!this.options.useFsEvents) {
    this._closePath(path);
  }
}

/**
 *
 * @param {Path} path
 */
_closePath(path) {
  let closers = this._closers.get(path);
  if (!closers) return;
  closers.forEach(closer => closer());
  this._closers.delete(path);
  closers = [];
  const dir = sysPath.dirname(path);
  this._getWatchedDir(dir).remove(sysPath.basename(path));
}

/**
 *
 * @param {Path} path
 * @param {Function} closer
 */
_addPathCloser(path, closer) {
  if (!closer) return;
  let list = this._closers.get(path);
  if (!list) {
    list = [];
    this._closers.set(path, list);
  }
  list.push(closer);
}

_readdirp(root, opts) {
  const options = Object.assign({type: 'all', alwaysStat: true, lstat: true}, opts);
  let stream = readdirp(root, options);
  this._streams.add(stream);
  stream.once('close', () => {
    stream = null;
  });
  stream.once('end', () => {
    if (stream) {
      this._streams.delete(stream);
      stream = null;
    }
  });
  return stream;
}

}

// Export FSWatcher class
exports.FSWatcher = FSWatcher;

/**
 * Instantiates watcher with paths to be tracked.
 * @param {String|Array<String>} paths file/directory paths and/or globs
 * @param {Object=} options chokidar opts
 * @returns an instance of FSWatcher for chaining.
 */
const watch = (paths, options) => {
  const watcher = new FSWatcher(options);
  watcher.add(watcher._normalizePaths(paths));
  return watcher;
};

exports.watch = watch;


/***/ }),

/***/ "./node_modules/chokidar/lib/fsevents-handler.js":
/*!*******************************************************!*\
  !*** ./node_modules/chokidar/lib/fsevents-handler.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const fs = __webpack_require__(/*! fs */ "fs");
const sysPath = __webpack_require__(/*! path */ "path");
const { promisify } = __webpack_require__(/*! util */ "util");

let fsevents;
try { fsevents = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module 'fsevents'"); e.code = 'MODULE_NOT_FOUND'; throw e; }())); } catch (error) {
  if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR) console.error(error);
}

if (fsevents) {
  // TODO: real check
  let mtch = process.version.match(/v(\d+)\.(\d+)/);
  if (mtch && mtch[1] && mtch[2]) {
    let maj = parseInt(mtch[1]);
    let min = parseInt(mtch[2]);
    if (maj === 8 && min < 16) {
      fsevents = null;
    }
  }
}

const EMPTY_FN = () => {};

const Option = (key, value) => isNaN(value) ? {} : {[key]: value};

const stat = promisify(fs.stat);
const open = promisify(fs.open);
const close = promisify(fs.close);
const lstat = promisify(fs.lstat);
const realpath = promisify(fs.realpath);

const statMethods = { stat, lstat };

/**
 * @typedef {String} Path
 */

/**
 * @typedef {Object} FsEventsWatchContainer
 * @property {Set<Function>} listeners
 * @property {Function} rawEmitter
 * @property {{stop: Function}} watcher
 */

// fsevents instance helper functions
/**
 * Object to hold per-process fsevents instances (may be shared across chokidar FSWatcher instances)
 * @type {Map<Path,FsEventsWatchContainer>}
 */
const FSEventsWatchers = new Map();

// Threshold of duplicate path prefixes at which to start
// consolidating going forward
const consolidateThreshhold = 10;

const wrongEventFlags = new Set([
  69888, 70400, 71424, 72704, 73472, 131328, 131840, 262912
]);

/**
 * Instantiates the fsevents interface
 * @param {Path} path path to be watched
 * @param {Function} callback called when fsevents is bound and ready
 * @returns {{stop: Function}} new fsevents instance
 */
const createFSEventsInstance = (path, callback) => {
  const stop = fsevents.watch(path, callback);
  return {stop};
};

/**
 * Instantiates the fsevents interface or binds listeners to an existing one covering
 * the same file tree.
 * @param {Path} path           - to be watched
 * @param {Path} realPath       - real path for symlinks
 * @param {Function} listener   - called when fsevents emits events
 * @param {Function} rawEmitter - passes data to listeners of the 'raw' event
 * @returns {Function} closer
 */
function setFSEventsListener(path, realPath, listener, rawEmitter) {
  let watchPath = sysPath.extname(path) ? sysPath.dirname(path) : path;
  const parentPath = sysPath.dirname(watchPath);
  let cont = FSEventsWatchers.get(watchPath);

  // If we've accumulated a substantial number of paths that
  // could have been consolidated by watching one directory
  // above the current one, create a watcher on the parent
  // path instead, so that we do consolidate going forward.
  if (couldConsolidate(parentPath)) {
    watchPath = parentPath;
  }

  const resolvedPath = sysPath.resolve(path);
  const hasSymlink = resolvedPath !== realPath;

  const filteredListener = (fullPath, flags, info) => {
    if (hasSymlink) fullPath = fullPath.replace(realPath, resolvedPath);
    if (
      fullPath === resolvedPath ||
      !fullPath.indexOf(resolvedPath + sysPath.sep)
    ) listener(fullPath, flags, info);
  };

  // check if there is already a watcher on a parent path
  // modifies `watchPath` to the parent path when it finds a match
  let watchedParent = false;
  for (const watchedPath of FSEventsWatchers.keys()) {
    if (realPath.indexOf(sysPath.resolve(watchedPath) + sysPath.sep) === 0) {
      watchPath = watchedPath;
      cont = FSEventsWatchers.get(watchPath);
      watchedParent = true;
      break;
    }
  }

  if (cont || watchedParent) {
    cont.listeners.add(filteredListener);
  } else {
    cont = {
      listeners: new Set([filteredListener]),
      rawEmitter: rawEmitter,
      watcher: createFSEventsInstance(watchPath, (fullPath, flags) => {
        const info = fsevents.getInfo(fullPath, flags);
        cont.listeners.forEach(list => {
          list(fullPath, flags, info);
        });

        cont.rawEmitter(info.event, fullPath, info);
      })
    };
    FSEventsWatchers.set(watchPath, cont);
  }

  // removes this instance's listeners and closes the underlying fsevents
  // instance if there are no more listeners left
  return () => {
    const wl = cont.listeners;

    wl.delete(filteredListener);
    if (!wl.size) {
      FSEventsWatchers.delete(watchPath);
      cont.watcher.stop();
      cont.rawEmitter = cont.watcher = null;
      Object.freeze(cont);
      Object.freeze(cont.listeners);
    }
  };
}

// Decide whether or not we should start a new higher-level
// parent watcher
const couldConsolidate = (path) => {
  let count = 0;
  for (const watchPath of FSEventsWatchers.keys()) {
    if (watchPath.indexOf(path) === 0) {
      count++;
      if (count >= consolidateThreshhold) {
        return true;
      }
    }
  }

  return false;
};

// returns boolean indicating whether fsevents can be used
const canUse = () => fsevents && FSEventsWatchers.size < 128;

// determines subdirectory traversal levels from root to path
const depth = (path, root) => {
  let i = 0;
  while (!path.indexOf(root) && (path = sysPath.dirname(path)) !== root) i++;
  return i;
};

/**
 * @mixin
 */
class FsEventsHandler {

/**
 * @param {FSWatcher} fsW
 */
constructor(fsW) {
  const FSWatcher = __webpack_require__(/*! ../index */ "./node_modules/chokidar/index.js").FSWatcher;
  this.fsw = fsW;
}
checkIgnored(path, stats) {
  const ipaths = this.fsw._ignoredPaths;
  if (this.fsw._isIgnored(path, stats)) {
    ipaths.add(path);
    if (stats && stats.isDirectory()) {
      ipaths.add(path + '/**/*');
    }
    return true;
  } else {
    ipaths.delete(path);
    ipaths.delete(path + '/**/*');
  }
}

addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts) {
  const event = watchedDir.has(item) ? 'change' : 'add';
  this.handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts);
}

async checkFd(path, fullPath, realPath, parent, watchedDir, item, info, opts) {
  try {
    const fd = await open(path, 'r');
    await close(fd);
    this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);
  } catch (error) {
    if (error.code !== 'EACCES') {
      this.handleEvent('unlink', path, fullPath, realPath, parent, watchedDir, item, info, opts);
    } else {
      this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);
    }
  }
}

handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts) {
  if (this.fsw.closed || this.checkIgnored(path)) return;

  if (event === 'unlink') {
    // suppress unlink events on never before seen files
    if (info.type === 'directory' || watchedDir.has(item)) {
      this.fsw._remove(parent, item);
    }
  } else {
    if (event === 'add') {
      // track new directories
      if (info.type === 'directory') this.fsw._getWatchedDir(path);

      if (info.type === 'symlink' && opts.followSymlinks) {
        // push symlinks back to the top of the stack to get handled
        const curDepth = opts.depth === undefined ?
          undefined : depth(fullPath, realPath) + 1;
        return this._addToFsEvents(path, false, true, curDepth);
      } else {
        // track new paths
        // (other than symlinks being followed, which will be tracked soon)
        this.fsw._getWatchedDir(parent).add(item);
      }
    }
    /**
     * @type {'add'|'addDir'|'unlink'|'unlinkDir'}
     */
    const eventName = info.type === 'directory' ? event + 'Dir' : event;
    this.fsw._emit(eventName, path);
    if (eventName === 'addDir') this._addToFsEvents(path, false, true);
  }
}

/**
 * Handle symlinks encountered during directory scan
 * @param {String} watchPath  - file/dir path to be watched with fsevents
 * @param {String} realPath   - real path (in case of symlinks)
 * @param {Function} transform  - path transformer
 * @param {Function} globFilter - path filter in case a glob pattern was provided
 * @returns {Function} closer for the watcher instance
*/
_watchWithFsEvents(watchPath, realPath, transform, globFilter) {

  if (this.fsw._isIgnored(watchPath)) return;
  const opts = this.fsw.options;
  const watchCallback = async (fullPath, flags, info) => {
    if (
      opts.depth !== undefined &&
      depth(fullPath, realPath) > opts.depth
    ) return;
    const path = transform(sysPath.join(
      watchPath, sysPath.relative(watchPath, fullPath)
    ));
    if (globFilter && !globFilter(path)) return;
    // ensure directories are tracked
    const parent = sysPath.dirname(path);
    const item = sysPath.basename(path);
    const watchedDir = this.fsw._getWatchedDir(
      info.type === 'directory' ? path : parent
    );

    // correct for wrong events emitted
    if (wrongEventFlags.has(flags) || info.event === 'unknown') {
      if (typeof opts.ignored === 'function') {
        let stats;
        try {
          stats = await stat(path);
        } catch (error) {}
        if (this.checkIgnored(path, stats)) return;
        if (stats) {
          this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);
        } else {
          this.handleEvent('unlink', path, fullPath, realPath, parent, watchedDir, item, info, opts);
        }
      } else {
        this.checkFd(path, fullPath, realPath, parent, watchedDir, item, info, opts);
      }
    } else {
      switch (info.event) {
      case 'created':
      case 'modified':
        return this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);
      case 'deleted':
      case 'moved':
        return this.checkFd(path, fullPath, realPath, parent, watchedDir, item, info, opts);
      }
    }
  };

  const closer = setFSEventsListener(
    watchPath,
    realPath,
    watchCallback,
    this.fsw._emitRaw
  );

  this.fsw._emitReady();
  return closer;
}

/**
 * Handle symlinks encountered during directory scan
 * @param {String} linkPath path to symlink
 * @param {String} fullPath absolute path to the symlink
 * @param {Function} transform pre-existing path transformer
 * @param {Number} curDepth level of subdirectories traversed to where symlink is
 * @returns {void}
 */
async _handleFsEventsSymlink(linkPath, fullPath, transform, curDepth) {
  // don't follow the same symlink more than once
  if (this.fsw.closed || this.fsw._symlinkPaths.has(fullPath)) return;

  this.fsw._symlinkPaths.set(fullPath, true);
  this.fsw._incrReadyCount();

  try {
    const linkTarget = await realpath(linkPath);
    if (this.fsw._isIgnored(linkTarget)) {
      return this.fsw._emitReady();
    }

    this.fsw._incrReadyCount();

    // add the linkTarget for watching with a wrapper for transform
    // that causes emitted paths to incorporate the link's path
    this._addToFsEvents(linkTarget || linkPath, (path) => {
      const dotSlash = '.' + sysPath.sep;
      let aliasedPath = linkPath;
      if (linkTarget && linkTarget !== dotSlash) {
        aliasedPath = path.replace(linkTarget, linkPath);
      } else if (path !== dotSlash) {
        aliasedPath = sysPath.join(linkPath, path);
      }
      return transform(aliasedPath);
    }, false, curDepth);
  } catch(error) {
    if (this.fsw._handleError(error)) {
      return this.fsw._emitReady();
    }
  }
}

/**
 *
 * @param {Path} newPath
 * @param {fs.Stats} stats
 */
emitAdd(newPath, stats, processPath, opts, forceAdd) {
  const pp = processPath(newPath);
  const isDir = stats.isDirectory();
  const dirObj = this.fsw._getWatchedDir(sysPath.dirname(pp));
  const base = sysPath.basename(pp);

  // ensure empty dirs get tracked
  if (isDir) this.fsw._getWatchedDir(pp);
  if (dirObj.has(base)) return;
  dirObj.add(base);

  if (!opts.ignoreInitial || forceAdd === true) {
    this.fsw._emit(isDir ? 'addDir' : 'add', pp, stats);
  }
}

initWatch(realPath, path, wh, processPath) {
  if (this.fsw.closed) return;
  const closer = this._watchWithFsEvents(
    wh.watchPath,
    sysPath.resolve(realPath || wh.watchPath),
    processPath,
    wh.globFilter
  );
  this.fsw._addPathCloser(path, closer);
}

/**
 * Handle added path with fsevents
 * @param {String} path file/dir path or glob pattern
 * @param {Function|Boolean=} transform converts working path to what the user expects
 * @param {Boolean=} forceAdd ensure add is emitted
 * @param {Number=} priorDepth Level of subdirectories already traversed.
 * @returns {void}
 */
async _addToFsEvents(path, transform, forceAdd, priorDepth) {
  if (this.fsw.closed) {
    return;
  }
  const opts = this.fsw.options;
  const processPath = typeof transform === 'function' ? transform : (val => val);

  const wh = this.fsw._getWatchHelpers(path);

  // evaluate what is at the path we're being asked to watch
  try {
    const stats = await statMethods[wh.statMethod](wh.watchPath);
    if (this.fsw.closed) {
      return;
    }
    if (this.fsw._isIgnored(wh.watchPath, stats)) {
      throw null;
    }
    if (stats.isDirectory()) {
      // emit addDir unless this is a glob parent
      if (!wh.globFilter) this.emitAdd(processPath(path), stats, processPath, opts, forceAdd);

      // don't recurse further if it would exceed depth setting
      if (priorDepth && priorDepth > opts.depth) return;

      // scan the contents of the dir
      this.fsw._readdirp(wh.watchPath, {
        fileFilter: entry => wh.filterPath(entry),
        directoryFilter: entry => wh.filterDir(entry),
        ...Option("depth", opts.depth - (priorDepth || 0))
      }).on('data', (entry) => {
        // need to check filterPath on dirs b/c filterDir is less restrictive
        if (this.fsw.closed) {
          return;
        }
        if (entry.stats.isDirectory() && !wh.filterPath(entry)) return;

        const joinedPath = sysPath.join(wh.watchPath, entry.path);
        const fullPath = entry.fullPath;

        if (wh.followSymlinks && entry.stats.isSymbolicLink()) {
          // preserve the current depth here since it can't be derived from
          // real paths past the symlink
          const curDepth = opts.depth === undefined ?
            undefined : depth(joinedPath, sysPath.resolve(wh.watchPath)) + 1;

          this._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);
        } else {
          this.emitAdd(joinedPath, entry.stats, processPath, opts, forceAdd);
        }
      }).on('error', EMPTY_FN).on('end', () => {
        this.fsw._emitReady();
      });
    } else {
      this.emitAdd(wh.watchPath, stats, processPath, opts, forceAdd);
      this.fsw._emitReady();
    }
  } catch (error) {
    if (!error || this.fsw._handleError(error)) {
      // TODO: Strange thing: "should not choke on an ignored watch path" will be failed without 2 ready calls -__-
      this.fsw._emitReady();
      this.fsw._emitReady();
    }
  }

  if (opts.persistent && forceAdd !== true) {
    if (typeof transform === 'function') {
      // realpath has already been resolved
      this.initWatch(null, path, wh, processPath);
    } else {
      let realPath;
      try {
        realPath = await realpath(wh.watchPath);
      } catch (e) {}
      this.initWatch(realPath, path, wh, processPath);
    }
  }
}

}

module.exports = FsEventsHandler;
module.exports.canUse = canUse;


/***/ }),

/***/ "./node_modules/chokidar/lib/nodefs-handler.js":
/*!*****************************************************!*\
  !*** ./node_modules/chokidar/lib/nodefs-handler.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const fs = __webpack_require__(/*! fs */ "fs");
const sysPath = __webpack_require__(/*! path */ "path");
const isBinaryPath = __webpack_require__(/*! is-binary-path */ "./node_modules/is-binary-path/index.js");
const { promisify } = __webpack_require__(/*! util */ "util");

const open = promisify(fs.open);
const stat = promisify(fs.stat);
const lstat = promisify(fs.lstat);
const close = promisify(fs.close);
const realpath = promisify(fs.realpath);

const statMethods = { lstat, stat };

/**
 * @typedef {String} Path
 */

// fs_watch helpers

// object to hold per-process fs_watch instances
// (may be shared across chokidar FSWatcher instances)

/**
 * @typedef {Object} FsWatchContainer
 * @property {Set} listeners
 * @property {Set} errHandlers
 * @property {Set} rawEmitters
 * @property {fs.FSWatcher=} watcher
 * @property {Boolean=} watcherUnusable
 */

/**
 * @type {Map<String,FsWatchContainer>}
 */
const FsWatchInstances = new Map();
const emptyFn = () => {};
const FUNCTIONS = ['listeners', 'errHandlers', 'rawEmitters'];

/**
 * Instantiates the fs_watch interface
 * @param {String} path to be watched
 * @param {Object} options to be passed to fs_watch
 * @param {Function} listener main event handler
 * @param {Function} errHandler emits info about errors
 * @param {Function} emitRaw emits raw event data
 * @returns {fs.FSWatcher} new fsevents instance
 */
function createFsWatchInstance(path, options, listener, errHandler, emitRaw) {
  const handleEvent = (rawEvent, evPath) => {
    listener(path);
    emitRaw(rawEvent, evPath, {watchedPath: path});

    // emit based on events occurring for files from a directory's watcher in
    // case the file's watcher misses it (and rely on throttling to de-dupe)
    if (evPath && path !== evPath) {
      fsWatchBroadcast(
        sysPath.resolve(path, evPath), 'listeners', sysPath.join(path, evPath)
      );
    }
  };
  try {
    return fs.watch(path, options, handleEvent);
  } catch (error) {
    errHandler(error);
  }
}

/**
 * Helper for passing fs_watch event data to a collection of listeners
 * @param {Path} fullPath absolute path bound to fs_watch instance
 * @param {String} type listener type
 * @param {*=} val1 arguments to be passed to listeners
 * @param {*=} val2
 * @param {*=} val3
 */
const fsWatchBroadcast = (fullPath, type, val1, val2, val3) => {
  const cont = FsWatchInstances.get(fullPath);
  if (!cont) return;
  cont[type].forEach((listener) => {
    listener(val1, val2, val3);
  });
};

/**
 * Instantiates the fs_watch interface or binds listeners
 * to an existing one covering the same file system entry
 * @param {String} path
 * @param {String} fullPath absolute path
 * @param {Object} options to be passed to fs_watch
 * @param {Object} handlers container for event listener functions
 */
const setFsWatchListener = (path, fullPath, options, handlers) => {
  const listener = handlers.listener;
  const errHandler = handlers.errHandler;
  const rawEmitter = handlers.rawEmitter;
  let cont = FsWatchInstances.get(fullPath);

  /** @type {fs.FSWatcher=} */
  let watcher;
  if (!options.persistent) {
    watcher = createFsWatchInstance(
      path, options, listener, errHandler, rawEmitter
    );
    return watcher.close.bind(watcher);
  }
  if (cont) {
    cont.listeners.add(listener);
    cont.errHandlers.add(errHandler);
    cont.rawEmitters.add(rawEmitter);
  } else {
    watcher = createFsWatchInstance(
      path,
      options,
      fsWatchBroadcast.bind(null, fullPath, 'listeners'),
      errHandler, // no need to use broadcast here
      fsWatchBroadcast.bind(null, fullPath, 'rawEmitters')
    );
    if (!watcher) return;
    const broadcastErr = fsWatchBroadcast.bind(null, fullPath, 'errHandlers');
    watcher.on('error', async (error) => {
      cont.watcherUnusable = true; // documented since Node 10.4.1
      // Workaround for https://github.com/joyent/node/issues/4337
      if (process.platform === 'win32' && error.code === 'EPERM') {
        try {
          const fd = await open(path, 'r');
          await close(fd);
          broadcastErr(error);
        } catch (err) {}
      } else {
        broadcastErr(error);
      }
    });
    cont = {
      listeners: new Set([listener]),
      errHandlers: new Set([errHandler]),
      rawEmitters: new Set([rawEmitter]),
      watcher: watcher
    };
    FsWatchInstances.set(fullPath, cont);
  }
  // const index = cont.listeners.indexOf(listener);

  // removes this instance's listeners and closes the underlying fs_watch
  // instance if there are no more listeners left
  return () => {
    cont.listeners.delete(listener);
    cont.errHandlers.delete(errHandler);
    cont.rawEmitters.delete(rawEmitter);
    if (!cont.listeners.size) {
      // Check to protect against issue gh-730.
      // if (cont.watcherUnusable) {
      cont.watcher.close();
      // }
      FsWatchInstances.delete(fullPath);
      FUNCTIONS.forEach(key => {
        const set = cont[key];
        set.clear();
        Object.freeze(set);
      });
      cont.watcher = null;
      Object.freeze(cont);
    }
  };
};

// fs_watchFile helpers

// object to hold per-process fs_watchFile instances
// (may be shared across chokidar FSWatcher instances)
const FsWatchFileInstances = new Map();

/**
 * Instantiates the fs_watchFile interface or binds listeners
 * to an existing one covering the same file system entry
 * @param {String} path to be watched
 * @param {String} fullPath absolute path
 * @param {Object} options options to be passed to fs_watchFile
 * @param {Object} handlers container for event listener functions
 * @returns {Function} closer
 */
const setFsWatchFileListener = (path, fullPath, options, handlers) => {
  const listener = handlers.listener;
  const rawEmitter = handlers.rawEmitter;
  let cont = FsWatchFileInstances.get(fullPath);
  let listeners = new Set();
  let rawEmitters = new Set();

  const copts = cont && cont.options;
  if (copts && (copts.persistent < options.persistent || copts.interval > options.interval)) {
    // "Upgrade" the watcher to persistence or a quicker interval.
    // This creates some unlikely edge case issues if the user mixes
    // settings in a very weird way, but solving for those cases
    // doesn't seem worthwhile for the added complexity.
    listeners = cont.listeners;
    rawEmitters = cont.rawEmitters;
    fs.unwatchFile(fullPath);
    cont = null;
  }

  if (cont) {
    cont.listeners.add(listener);
    cont.rawEmitters.add(rawEmitter);
  } else {
    listeners.add(listener);
    rawEmitters.add(rawEmitter);
    cont = {
      listeners: listeners,
      rawEmitters: rawEmitters,
      options: options,
      watcher: fs.watchFile(fullPath, options, (curr, prev) => {
        cont.rawEmitters.forEach((rawEmitter) => {
          rawEmitter('change', fullPath, {curr: curr, prev: prev});
        });
        const currmtime = curr.mtimeMs;
        if (curr.size !== prev.size || currmtime > prev.mtimeMs || currmtime === 0) {
          cont.listeners.forEach((listener) => listener(path, curr));
        }
      })
    };
    FsWatchFileInstances.set(fullPath, cont);
  }
  // const index = cont.listeners.indexOf(listener);

  // Removes this instance's listeners and closes the underlying fs_watchFile
  // instance if there are no more listeners left.
    return () => {
    cont.listeners.delete(listener);
    cont.rawEmitters.delete(rawEmitter);
    if (!cont.listeners.size) {
      FsWatchFileInstances.delete(fullPath);
      fs.unwatchFile(fullPath);
      cont.options = cont.watcher = null;
      Object.freeze(cont);
      Object.freeze(cont.listeners);
    }
  };
};

/**
 * @mixin
 */
class NodeFsHandler {

/**
 * @param {FSWatcher} fsW
 */
constructor(fsW) {
  const FSWatcher = __webpack_require__(/*! ../index */ "./node_modules/chokidar/index.js").FSWatcher;
  this.fsw = fsW;
  this._boundHandleError = (error) => fsW._handleError(error);
}

/**
 * Watch file for changes with fs_watchFile or fs_watch.
 * @param {String} path to file or dir
 * @param {Function} listener on fs change
 * @returns {Function} closer for the watcher instance
 */
_watchWithNodeFs(path, listener) {
  const opts = this.fsw.options;
  const directory = sysPath.dirname(path);
  const basename = sysPath.basename(path);
  const parent = this.fsw._getWatchedDir(directory);
  parent.add(basename);
  const absolutePath = sysPath.resolve(path);
  const options = {persistent: opts.persistent};
  if (!listener) listener = emptyFn;

  let closer;
  if (opts.usePolling) {
    options.interval = opts.enableBinaryInterval && isBinaryPath(basename) ?
      opts.binaryInterval : opts.interval;
    closer = setFsWatchFileListener(path, absolutePath, options, {
      listener: listener,
      rawEmitter: this.fsw._emitRaw
    });
  } else {
    closer = setFsWatchListener(path, absolutePath, options, {
      listener: listener,
      errHandler: this._boundHandleError,
      rawEmitter: this.fsw._emitRaw
    });
  }
  return closer;
}

/**
 * Watch a file and emit add event if warranted.
 * @param {Path} file Path
 * @param {fs.Stats} stats result of fs_stat
 * @param {Boolean} initialAdd was the file added at watch instantiation?
 * @returns {Function} closer for the watcher instance
 */
_handleFile(file, stats, initialAdd) {
  if (this.fsw.closed) {
    return;
  }
  const dirname = sysPath.dirname(file);
  const basename = sysPath.basename(file);
  const parent = this.fsw._getWatchedDir(dirname);
  // stats is always present
  let prevStats = stats;

  // if the file is already being watched, do nothing
  if (parent.has(basename)) return;

  // kick off the watcher
  const closer = this._watchWithNodeFs(file, async (path, newStats) => {
    if (!this.fsw._throttle('watch', file, 5)) return;
    if (!newStats || newStats && newStats.mtimeMs === 0) {
      try {
        const newStats = await stat(file);
        if (this.fsw.closed) {
          return;
        }
        // Check that change event was not fired because of changed only accessTime.
        const at = newStats.atimeMs;
        const mt = newStats.mtimeMs;
        if (!at || at <= mt || mt !== prevStats.mtimeMs) {
          this.fsw._emit('change', file, newStats);
        }
        prevStats = newStats;
      } catch (error) {
        // Fix issues where mtime is null but file is still present
        this.fsw._remove(dirname, basename);
      }
    // add is about to be emitted if file not already tracked in parent
    } else if (parent.has(basename)) {
      // Check that change event was not fired because of changed only accessTime.
      const at = newStats.atimeMs;
      const mt = newStats.mtimeMs;
      if (!at || at <= mt || mt !== prevStats.mtimeMs) {
        this.fsw._emit('change', file, newStats);
      }
      prevStats = newStats;
    }
  });

  // emit an add event if we're supposed to
  if (!(initialAdd && this.fsw.options.ignoreInitial) && this.fsw._isntIgnored(file)) {
    if (!this.fsw._throttle('add', file, 0)) return;
    this.fsw._emit('add', file, stats);
  }

  return closer;
}

/**
 * Handle symlinks encountered while reading a dir.
 * @param {Object} entry returned by readdirp
 * @param {String} directory path of dir being read
 * @param {String} path of this item
 * @param {String} item basename of this item
 * @returns {Promise<Boolean>} true if no more processing is needed for this entry.
 */
async _handleSymlink(entry, directory, path, item) {
  if (this.fsw.closed) {
    return;
  }
  const full = entry.fullPath;
  const dir = this.fsw._getWatchedDir(directory);

  if (!this.fsw.options.followSymlinks) {
    // watch symlink directly (don't follow) and detect changes
    this.fsw._incrReadyCount();
    const linkPath = await realpath(path);
    if (dir.has(item)) {
      if (this.fsw._symlinkPaths.get(full) !== linkPath) {
        this.fsw._symlinkPaths.set(full, linkPath);
        this.fsw._emit('change', path, entry.stats);
      }
    } else {
      dir.add(item);
      this.fsw._symlinkPaths.set(full, linkPath);
      this.fsw._emit('add', path, entry.stats);
    }
    this.fsw._emitReady();
    return true;
  }

  // don't follow the same symlink more than once
  if (this.fsw._symlinkPaths.has(full)) {
    return true;
  } else {
    this.fsw._symlinkPaths.set(full,  true);
  }
}

_handleRead(directory, initialAdd, wh, target, dir, depth, throttler) {
  // Normalize the directory name on Windows
  directory = sysPath.join(directory, '');

  if (!wh.hasGlob) {
    // throttler = this.fsw._throttle('readdir', directory, 1000);
    // if (!throttler) return;
  }

  const previous = this.fsw._getWatchedDir(wh.path);
  const current = new Set();

  const stream = this.fsw._readdirp(directory, {
    fileFilter: entry => wh.filterPath(entry),
    directoryFilter: entry => wh.filterDir(entry),
    depth: 0,
  }).on('data', async (entry) => {
    if (this.fsw.closed) {
      return;
    }
    const item = entry.path;
    let path = sysPath.join(directory, item);
    current.add(item);

    if (entry.stats.isSymbolicLink() && await this._handleSymlink(entry, directory, path, item))
      return;

    // Files that present in current directory snapshot
    // but absent in previous are added to watch list and
    // emit `add` event.
    if (item === target || !target && !previous.has(item)) {
      this.fsw._incrReadyCount();

      // ensure relativeness of path is preserved in case of watcher reuse
      path = sysPath.join(dir, sysPath.relative(dir, path));

      this._addToNodeFs(path, initialAdd, wh, depth + 1);
    }
  }).on('error', this._boundHandleError);
  return new Promise(res =>
    stream
    .on('end', () => {
      const wasThrottled = throttler ? throttler.clear() : false;

      res();

      // Files that absent in current directory snapshot
      // but present in previous emit `remove` event
      // and are removed from @watched[directory].
      previous.getChildren().filter((item) =>
        item !== directory &&
          !current.has(item) &&
          // in case of intersecting globs;
          // a path may have been filtered out of this readdir, but
          // shouldn't be removed because it matches a different glob
          (!wh.hasGlob || wh.filterPath({
            fullPath: sysPath.resolve(directory, item)
          }))
      ).forEach((item) => {
        this.fsw._remove(directory, item);
      });

      // one more time for any missed in case changes came in extremely quickly
      if (wasThrottled) this._handleRead(directory, false, wh, target, dir, depth, throttler);
    })
  );
}

/**
 * Read directory to add / remove files from `@watched` list and re-read it on change.
 * @param {String} dir fs path
 * @param {fs.Stats} stats
 * @param {Boolean} initialAdd
 * @param {Number} depth relative to user-supplied path
 * @param {String} target child path targetted for watch
 * @param {Object} wh Common watch helpers for this path
 * @param {String} realpath
 * @returns {Promise<Function>} closer for the watcher instance.
 */
async _handleDir(dir, stats, initialAdd, depth, target, wh, realpath) {
  const parentDir = this.fsw._getWatchedDir(sysPath.dirname(dir));
  const tracked = parentDir.has(sysPath.basename(dir));
  if (!(initialAdd && this.fsw.options.ignoreInitial) && !target && !tracked) {
    if (!wh.hasGlob || wh.globFilter(dir)) this.fsw._emit('addDir', dir, stats);
  }

  // ensure dir is tracked (harmless if redundant)
  parentDir.add(sysPath.basename(dir));
  this.fsw._getWatchedDir(dir);
  let throttler;


  let closer;

  const oDepth = this.fsw.options.depth;
  if ((oDepth == null || depth <= oDepth) && !this.fsw._symlinkPaths.has(realpath)) {
    if (!target) {
      await this._handleRead(dir, initialAdd, wh, target, dir, depth, throttler);
    }

    closer = this._watchWithNodeFs(dir, (dirPath, stats) => {
      // if current directory is removed, do nothing
      if (stats && stats.mtimeMs === 0) return;

      this._handleRead(dirPath, false, wh, target, dir, depth, throttler);
    });
  }
  return closer;
}

/**
 * Handle added file, directory, or glob pattern.
 * Delegates call to _handleFile / _handleDir after checks.
 * @param {String} path to file or ir
 * @param {Boolean} initialAdd was the file added at watch instantiation?
 * @param {Object} priorWh depth relative to user-supplied path
 * @param {Number} depth Child path actually targetted for watch
 * @param {String=} target Child path actually targeted for watch
 * @returns {Promise}
 */
async _addToNodeFs(path, initialAdd, priorWh, depth, target) {
  const ready = this.fsw._emitReady;
  if (this.fsw._isIgnored(path) || this.fsw.closed) {
    ready();
    return false;
  }

  let wh = this.fsw._getWatchHelpers(path, depth);
  if (!wh.hasGlob && priorWh) {
    wh.hasGlob = priorWh.hasGlob;
    wh.globFilter = priorWh.globFilter;
    wh.filterPath = entry => priorWh.filterPath(entry);
    wh.filterDir = entry => priorWh.filterDir(entry);
  }

  // evaluate what is at the path we're being asked to watch
  try {
    const stats = await statMethods[wh.statMethod](wh.watchPath);
    if (this.fsw.closed) {
      return;
    }
    if (this.fsw._isIgnored(wh.watchPath, stats)) {
      ready();
      return false;
    }

    const targetPath = path.includes("*") || path.includes("{") ? path : await realpath(path);
    let closer;
    if (stats.isDirectory()) {
      closer = await this._handleDir(wh.watchPath, stats, initialAdd, depth, target, wh, targetPath);
      // preserve this symlink's target path
      if (path !== targetPath && targetPath !== undefined) {
        this.fsw._symlinkPaths.set(targetPath, true);
      }
    } else if (stats.isSymbolicLink()) {
      const parent = sysPath.dirname(wh.watchPath);
      this.fsw._getWatchedDir(parent).add(wh.watchPath);
      this.fsw._emit('add', wh.watchPath, stats);
      closer = await this._handleDir(parent, stats, initialAdd, depth, path, wh, targetPath);

      // preserve this symlink's target path
      if (targetPath !== undefined) {
        this.fsw._symlinkPaths.set(sysPath.resolve(path), targetPath);
      }
    } else {
      closer = this._handleFile(wh.watchPath, stats, initialAdd);
    }
    ready();

    this.fsw._addPathCloser(path, closer);
    return false;

  } catch (error) {
    if (this.fsw._handleError(error)) {
      ready();
      return path;
    }
  }
}

}

module.exports = NodeFsHandler;


/***/ }),

/***/ "./node_modules/color-convert/conversions.js":
/*!***************************************************!*\
  !*** ./node_modules/color-convert/conversions.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* MIT license */
var cssKeywords = __webpack_require__(/*! color-name */ "./node_modules/color-name/index.js");

// NOTE: conversions should only return primitive values (i.e. arrays, or
//       values that give correct `typeof` results).
//       do not use box values types (i.e. Number(), String(), etc.)

var reverseKeywords = {};
for (var key in cssKeywords) {
	if (cssKeywords.hasOwnProperty(key)) {
		reverseKeywords[cssKeywords[key]] = key;
	}
}

var convert = module.exports = {
	rgb: {channels: 3, labels: 'rgb'},
	hsl: {channels: 3, labels: 'hsl'},
	hsv: {channels: 3, labels: 'hsv'},
	hwb: {channels: 3, labels: 'hwb'},
	cmyk: {channels: 4, labels: 'cmyk'},
	xyz: {channels: 3, labels: 'xyz'},
	lab: {channels: 3, labels: 'lab'},
	lch: {channels: 3, labels: 'lch'},
	hex: {channels: 1, labels: ['hex']},
	keyword: {channels: 1, labels: ['keyword']},
	ansi16: {channels: 1, labels: ['ansi16']},
	ansi256: {channels: 1, labels: ['ansi256']},
	hcg: {channels: 3, labels: ['h', 'c', 'g']},
	apple: {channels: 3, labels: ['r16', 'g16', 'b16']},
	gray: {channels: 1, labels: ['gray']}
};

// hide .channels and .labels properties
for (var model in convert) {
	if (convert.hasOwnProperty(model)) {
		if (!('channels' in convert[model])) {
			throw new Error('missing channels property: ' + model);
		}

		if (!('labels' in convert[model])) {
			throw new Error('missing channel labels property: ' + model);
		}

		if (convert[model].labels.length !== convert[model].channels) {
			throw new Error('channel and label counts mismatch: ' + model);
		}

		var channels = convert[model].channels;
		var labels = convert[model].labels;
		delete convert[model].channels;
		delete convert[model].labels;
		Object.defineProperty(convert[model], 'channels', {value: channels});
		Object.defineProperty(convert[model], 'labels', {value: labels});
	}
}

convert.rgb.hsl = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var min = Math.min(r, g, b);
	var max = Math.max(r, g, b);
	var delta = max - min;
	var h;
	var s;
	var l;

	if (max === min) {
		h = 0;
	} else if (r === max) {
		h = (g - b) / delta;
	} else if (g === max) {
		h = 2 + (b - r) / delta;
	} else if (b === max) {
		h = 4 + (r - g) / delta;
	}

	h = Math.min(h * 60, 360);

	if (h < 0) {
		h += 360;
	}

	l = (min + max) / 2;

	if (max === min) {
		s = 0;
	} else if (l <= 0.5) {
		s = delta / (max + min);
	} else {
		s = delta / (2 - max - min);
	}

	return [h, s * 100, l * 100];
};

convert.rgb.hsv = function (rgb) {
	var rdif;
	var gdif;
	var bdif;
	var h;
	var s;

	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var v = Math.max(r, g, b);
	var diff = v - Math.min(r, g, b);
	var diffc = function (c) {
		return (v - c) / 6 / diff + 1 / 2;
	};

	if (diff === 0) {
		h = s = 0;
	} else {
		s = diff / v;
		rdif = diffc(r);
		gdif = diffc(g);
		bdif = diffc(b);

		if (r === v) {
			h = bdif - gdif;
		} else if (g === v) {
			h = (1 / 3) + rdif - bdif;
		} else if (b === v) {
			h = (2 / 3) + gdif - rdif;
		}
		if (h < 0) {
			h += 1;
		} else if (h > 1) {
			h -= 1;
		}
	}

	return [
		h * 360,
		s * 100,
		v * 100
	];
};

convert.rgb.hwb = function (rgb) {
	var r = rgb[0];
	var g = rgb[1];
	var b = rgb[2];
	var h = convert.rgb.hsl(rgb)[0];
	var w = 1 / 255 * Math.min(r, Math.min(g, b));

	b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));

	return [h, w * 100, b * 100];
};

convert.rgb.cmyk = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var c;
	var m;
	var y;
	var k;

	k = Math.min(1 - r, 1 - g, 1 - b);
	c = (1 - r - k) / (1 - k) || 0;
	m = (1 - g - k) / (1 - k) || 0;
	y = (1 - b - k) / (1 - k) || 0;

	return [c * 100, m * 100, y * 100, k * 100];
};

/**
 * See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
 * */
function comparativeDistance(x, y) {
	return (
		Math.pow(x[0] - y[0], 2) +
		Math.pow(x[1] - y[1], 2) +
		Math.pow(x[2] - y[2], 2)
	);
}

convert.rgb.keyword = function (rgb) {
	var reversed = reverseKeywords[rgb];
	if (reversed) {
		return reversed;
	}

	var currentClosestDistance = Infinity;
	var currentClosestKeyword;

	for (var keyword in cssKeywords) {
		if (cssKeywords.hasOwnProperty(keyword)) {
			var value = cssKeywords[keyword];

			// Compute comparative distance
			var distance = comparativeDistance(rgb, value);

			// Check if its less, if so set as closest
			if (distance < currentClosestDistance) {
				currentClosestDistance = distance;
				currentClosestKeyword = keyword;
			}
		}
	}

	return currentClosestKeyword;
};

convert.keyword.rgb = function (keyword) {
	return cssKeywords[keyword];
};

convert.rgb.xyz = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;

	// assume sRGB
	r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);
	g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);
	b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);

	var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
	var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
	var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);

	return [x * 100, y * 100, z * 100];
};

convert.rgb.lab = function (rgb) {
	var xyz = convert.rgb.xyz(rgb);
	var x = xyz[0];
	var y = xyz[1];
	var z = xyz[2];
	var l;
	var a;
	var b;

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);

	l = (116 * y) - 16;
	a = 500 * (x - y);
	b = 200 * (y - z);

	return [l, a, b];
};

convert.hsl.rgb = function (hsl) {
	var h = hsl[0] / 360;
	var s = hsl[1] / 100;
	var l = hsl[2] / 100;
	var t1;
	var t2;
	var t3;
	var rgb;
	var val;

	if (s === 0) {
		val = l * 255;
		return [val, val, val];
	}

	if (l < 0.5) {
		t2 = l * (1 + s);
	} else {
		t2 = l + s - l * s;
	}

	t1 = 2 * l - t2;

	rgb = [0, 0, 0];
	for (var i = 0; i < 3; i++) {
		t3 = h + 1 / 3 * -(i - 1);
		if (t3 < 0) {
			t3++;
		}
		if (t3 > 1) {
			t3--;
		}

		if (6 * t3 < 1) {
			val = t1 + (t2 - t1) * 6 * t3;
		} else if (2 * t3 < 1) {
			val = t2;
		} else if (3 * t3 < 2) {
			val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
		} else {
			val = t1;
		}

		rgb[i] = val * 255;
	}

	return rgb;
};

convert.hsl.hsv = function (hsl) {
	var h = hsl[0];
	var s = hsl[1] / 100;
	var l = hsl[2] / 100;
	var smin = s;
	var lmin = Math.max(l, 0.01);
	var sv;
	var v;

	l *= 2;
	s *= (l <= 1) ? l : 2 - l;
	smin *= lmin <= 1 ? lmin : 2 - lmin;
	v = (l + s) / 2;
	sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);

	return [h, sv * 100, v * 100];
};

convert.hsv.rgb = function (hsv) {
	var h = hsv[0] / 60;
	var s = hsv[1] / 100;
	var v = hsv[2] / 100;
	var hi = Math.floor(h) % 6;

	var f = h - Math.floor(h);
	var p = 255 * v * (1 - s);
	var q = 255 * v * (1 - (s * f));
	var t = 255 * v * (1 - (s * (1 - f)));
	v *= 255;

	switch (hi) {
		case 0:
			return [v, t, p];
		case 1:
			return [q, v, p];
		case 2:
			return [p, v, t];
		case 3:
			return [p, q, v];
		case 4:
			return [t, p, v];
		case 5:
			return [v, p, q];
	}
};

convert.hsv.hsl = function (hsv) {
	var h = hsv[0];
	var s = hsv[1] / 100;
	var v = hsv[2] / 100;
	var vmin = Math.max(v, 0.01);
	var lmin;
	var sl;
	var l;

	l = (2 - s) * v;
	lmin = (2 - s) * vmin;
	sl = s * vmin;
	sl /= (lmin <= 1) ? lmin : 2 - lmin;
	sl = sl || 0;
	l /= 2;

	return [h, sl * 100, l * 100];
};

// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
convert.hwb.rgb = function (hwb) {
	var h = hwb[0] / 360;
	var wh = hwb[1] / 100;
	var bl = hwb[2] / 100;
	var ratio = wh + bl;
	var i;
	var v;
	var f;
	var n;

	// wh + bl cant be > 1
	if (ratio > 1) {
		wh /= ratio;
		bl /= ratio;
	}

	i = Math.floor(6 * h);
	v = 1 - bl;
	f = 6 * h - i;

	if ((i & 0x01) !== 0) {
		f = 1 - f;
	}

	n = wh + f * (v - wh); // linear interpolation

	var r;
	var g;
	var b;
	switch (i) {
		default:
		case 6:
		case 0: r = v; g = n; b = wh; break;
		case 1: r = n; g = v; b = wh; break;
		case 2: r = wh; g = v; b = n; break;
		case 3: r = wh; g = n; b = v; break;
		case 4: r = n; g = wh; b = v; break;
		case 5: r = v; g = wh; b = n; break;
	}

	return [r * 255, g * 255, b * 255];
};

convert.cmyk.rgb = function (cmyk) {
	var c = cmyk[0] / 100;
	var m = cmyk[1] / 100;
	var y = cmyk[2] / 100;
	var k = cmyk[3] / 100;
	var r;
	var g;
	var b;

	r = 1 - Math.min(1, c * (1 - k) + k);
	g = 1 - Math.min(1, m * (1 - k) + k);
	b = 1 - Math.min(1, y * (1 - k) + k);

	return [r * 255, g * 255, b * 255];
};

convert.xyz.rgb = function (xyz) {
	var x = xyz[0] / 100;
	var y = xyz[1] / 100;
	var z = xyz[2] / 100;
	var r;
	var g;
	var b;

	r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
	g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
	b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);

	// assume sRGB
	r = r > 0.0031308
		? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)
		: r * 12.92;

	g = g > 0.0031308
		? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)
		: g * 12.92;

	b = b > 0.0031308
		? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)
		: b * 12.92;

	r = Math.min(Math.max(0, r), 1);
	g = Math.min(Math.max(0, g), 1);
	b = Math.min(Math.max(0, b), 1);

	return [r * 255, g * 255, b * 255];
};

convert.xyz.lab = function (xyz) {
	var x = xyz[0];
	var y = xyz[1];
	var z = xyz[2];
	var l;
	var a;
	var b;

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);

	l = (116 * y) - 16;
	a = 500 * (x - y);
	b = 200 * (y - z);

	return [l, a, b];
};

convert.lab.xyz = function (lab) {
	var l = lab[0];
	var a = lab[1];
	var b = lab[2];
	var x;
	var y;
	var z;

	y = (l + 16) / 116;
	x = a / 500 + y;
	z = y - b / 200;

	var y2 = Math.pow(y, 3);
	var x2 = Math.pow(x, 3);
	var z2 = Math.pow(z, 3);
	y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
	x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
	z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;

	x *= 95.047;
	y *= 100;
	z *= 108.883;

	return [x, y, z];
};

convert.lab.lch = function (lab) {
	var l = lab[0];
	var a = lab[1];
	var b = lab[2];
	var hr;
	var h;
	var c;

	hr = Math.atan2(b, a);
	h = hr * 360 / 2 / Math.PI;

	if (h < 0) {
		h += 360;
	}

	c = Math.sqrt(a * a + b * b);

	return [l, c, h];
};

convert.lch.lab = function (lch) {
	var l = lch[0];
	var c = lch[1];
	var h = lch[2];
	var a;
	var b;
	var hr;

	hr = h / 360 * 2 * Math.PI;
	a = c * Math.cos(hr);
	b = c * Math.sin(hr);

	return [l, a, b];
};

convert.rgb.ansi16 = function (args) {
	var r = args[0];
	var g = args[1];
	var b = args[2];
	var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2]; // hsv -> ansi16 optimization

	value = Math.round(value / 50);

	if (value === 0) {
		return 30;
	}

	var ansi = 30
		+ ((Math.round(b / 255) << 2)
		| (Math.round(g / 255) << 1)
		| Math.round(r / 255));

	if (value === 2) {
		ansi += 60;
	}

	return ansi;
};

convert.hsv.ansi16 = function (args) {
	// optimization here; we already know the value and don't need to get
	// it converted for us.
	return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
};

convert.rgb.ansi256 = function (args) {
	var r = args[0];
	var g = args[1];
	var b = args[2];

	// we use the extended greyscale palette here, with the exception of
	// black and white. normal palette only has 4 greyscale shades.
	if (r === g && g === b) {
		if (r < 8) {
			return 16;
		}

		if (r > 248) {
			return 231;
		}

		return Math.round(((r - 8) / 247) * 24) + 232;
	}

	var ansi = 16
		+ (36 * Math.round(r / 255 * 5))
		+ (6 * Math.round(g / 255 * 5))
		+ Math.round(b / 255 * 5);

	return ansi;
};

convert.ansi16.rgb = function (args) {
	var color = args % 10;

	// handle greyscale
	if (color === 0 || color === 7) {
		if (args > 50) {
			color += 3.5;
		}

		color = color / 10.5 * 255;

		return [color, color, color];
	}

	var mult = (~~(args > 50) + 1) * 0.5;
	var r = ((color & 1) * mult) * 255;
	var g = (((color >> 1) & 1) * mult) * 255;
	var b = (((color >> 2) & 1) * mult) * 255;

	return [r, g, b];
};

convert.ansi256.rgb = function (args) {
	// handle greyscale
	if (args >= 232) {
		var c = (args - 232) * 10 + 8;
		return [c, c, c];
	}

	args -= 16;

	var rem;
	var r = Math.floor(args / 36) / 5 * 255;
	var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
	var b = (rem % 6) / 5 * 255;

	return [r, g, b];
};

convert.rgb.hex = function (args) {
	var integer = ((Math.round(args[0]) & 0xFF) << 16)
		+ ((Math.round(args[1]) & 0xFF) << 8)
		+ (Math.round(args[2]) & 0xFF);

	var string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert.hex.rgb = function (args) {
	var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
	if (!match) {
		return [0, 0, 0];
	}

	var colorString = match[0];

	if (match[0].length === 3) {
		colorString = colorString.split('').map(function (char) {
			return char + char;
		}).join('');
	}

	var integer = parseInt(colorString, 16);
	var r = (integer >> 16) & 0xFF;
	var g = (integer >> 8) & 0xFF;
	var b = integer & 0xFF;

	return [r, g, b];
};

convert.rgb.hcg = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var max = Math.max(Math.max(r, g), b);
	var min = Math.min(Math.min(r, g), b);
	var chroma = (max - min);
	var grayscale;
	var hue;

	if (chroma < 1) {
		grayscale = min / (1 - chroma);
	} else {
		grayscale = 0;
	}

	if (chroma <= 0) {
		hue = 0;
	} else
	if (max === r) {
		hue = ((g - b) / chroma) % 6;
	} else
	if (max === g) {
		hue = 2 + (b - r) / chroma;
	} else {
		hue = 4 + (r - g) / chroma + 4;
	}

	hue /= 6;
	hue %= 1;

	return [hue * 360, chroma * 100, grayscale * 100];
};

convert.hsl.hcg = function (hsl) {
	var s = hsl[1] / 100;
	var l = hsl[2] / 100;
	var c = 1;
	var f = 0;

	if (l < 0.5) {
		c = 2.0 * s * l;
	} else {
		c = 2.0 * s * (1.0 - l);
	}

	if (c < 1.0) {
		f = (l - 0.5 * c) / (1.0 - c);
	}

	return [hsl[0], c * 100, f * 100];
};

convert.hsv.hcg = function (hsv) {
	var s = hsv[1] / 100;
	var v = hsv[2] / 100;

	var c = s * v;
	var f = 0;

	if (c < 1.0) {
		f = (v - c) / (1 - c);
	}

	return [hsv[0], c * 100, f * 100];
};

convert.hcg.rgb = function (hcg) {
	var h = hcg[0] / 360;
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;

	if (c === 0.0) {
		return [g * 255, g * 255, g * 255];
	}

	var pure = [0, 0, 0];
	var hi = (h % 1) * 6;
	var v = hi % 1;
	var w = 1 - v;
	var mg = 0;

	switch (Math.floor(hi)) {
		case 0:
			pure[0] = 1; pure[1] = v; pure[2] = 0; break;
		case 1:
			pure[0] = w; pure[1] = 1; pure[2] = 0; break;
		case 2:
			pure[0] = 0; pure[1] = 1; pure[2] = v; break;
		case 3:
			pure[0] = 0; pure[1] = w; pure[2] = 1; break;
		case 4:
			pure[0] = v; pure[1] = 0; pure[2] = 1; break;
		default:
			pure[0] = 1; pure[1] = 0; pure[2] = w;
	}

	mg = (1.0 - c) * g;

	return [
		(c * pure[0] + mg) * 255,
		(c * pure[1] + mg) * 255,
		(c * pure[2] + mg) * 255
	];
};

convert.hcg.hsv = function (hcg) {
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;

	var v = c + g * (1.0 - c);
	var f = 0;

	if (v > 0.0) {
		f = c / v;
	}

	return [hcg[0], f * 100, v * 100];
};

convert.hcg.hsl = function (hcg) {
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;

	var l = g * (1.0 - c) + 0.5 * c;
	var s = 0;

	if (l > 0.0 && l < 0.5) {
		s = c / (2 * l);
	} else
	if (l >= 0.5 && l < 1.0) {
		s = c / (2 * (1 - l));
	}

	return [hcg[0], s * 100, l * 100];
};

convert.hcg.hwb = function (hcg) {
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;
	var v = c + g * (1.0 - c);
	return [hcg[0], (v - c) * 100, (1 - v) * 100];
};

convert.hwb.hcg = function (hwb) {
	var w = hwb[1] / 100;
	var b = hwb[2] / 100;
	var v = 1 - b;
	var c = v - w;
	var g = 0;

	if (c < 1) {
		g = (v - c) / (1 - c);
	}

	return [hwb[0], c * 100, g * 100];
};

convert.apple.rgb = function (apple) {
	return [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];
};

convert.rgb.apple = function (rgb) {
	return [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];
};

convert.gray.rgb = function (args) {
	return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
};

convert.gray.hsl = convert.gray.hsv = function (args) {
	return [0, 0, args[0]];
};

convert.gray.hwb = function (gray) {
	return [0, 100, gray[0]];
};

convert.gray.cmyk = function (gray) {
	return [0, 0, 0, gray[0]];
};

convert.gray.lab = function (gray) {
	return [gray[0], 0, 0];
};

convert.gray.hex = function (gray) {
	var val = Math.round(gray[0] / 100 * 255) & 0xFF;
	var integer = (val << 16) + (val << 8) + val;

	var string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert.rgb.gray = function (rgb) {
	var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
	return [val / 255 * 100];
};


/***/ }),

/***/ "./node_modules/color-convert/index.js":
/*!*********************************************!*\
  !*** ./node_modules/color-convert/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var conversions = __webpack_require__(/*! ./conversions */ "./node_modules/color-convert/conversions.js");
var route = __webpack_require__(/*! ./route */ "./node_modules/color-convert/route.js");

var convert = {};

var models = Object.keys(conversions);

function wrapRaw(fn) {
	var wrappedFn = function (args) {
		if (args === undefined || args === null) {
			return args;
		}

		if (arguments.length > 1) {
			args = Array.prototype.slice.call(arguments);
		}

		return fn(args);
	};

	// preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

function wrapRounded(fn) {
	var wrappedFn = function (args) {
		if (args === undefined || args === null) {
			return args;
		}

		if (arguments.length > 1) {
			args = Array.prototype.slice.call(arguments);
		}

		var result = fn(args);

		// we're assuming the result is an array here.
		// see notice in conversions.js; don't use box types
		// in conversion functions.
		if (typeof result === 'object') {
			for (var len = result.length, i = 0; i < len; i++) {
				result[i] = Math.round(result[i]);
			}
		}

		return result;
	};

	// preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

models.forEach(function (fromModel) {
	convert[fromModel] = {};

	Object.defineProperty(convert[fromModel], 'channels', {value: conversions[fromModel].channels});
	Object.defineProperty(convert[fromModel], 'labels', {value: conversions[fromModel].labels});

	var routes = route(fromModel);
	var routeModels = Object.keys(routes);

	routeModels.forEach(function (toModel) {
		var fn = routes[toModel];

		convert[fromModel][toModel] = wrapRounded(fn);
		convert[fromModel][toModel].raw = wrapRaw(fn);
	});
});

module.exports = convert;


/***/ }),

/***/ "./node_modules/color-convert/route.js":
/*!*********************************************!*\
  !*** ./node_modules/color-convert/route.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var conversions = __webpack_require__(/*! ./conversions */ "./node_modules/color-convert/conversions.js");

/*
	this function routes a model to all other models.

	all functions that are routed have a property `.conversion` attached
	to the returned synthetic function. This property is an array
	of strings, each with the steps in between the 'from' and 'to'
	color models (inclusive).

	conversions that are not possible simply are not included.
*/

function buildGraph() {
	var graph = {};
	// https://jsperf.com/object-keys-vs-for-in-with-closure/3
	var models = Object.keys(conversions);

	for (var len = models.length, i = 0; i < len; i++) {
		graph[models[i]] = {
			// http://jsperf.com/1-vs-infinity
			// micro-opt, but this is simple.
			distance: -1,
			parent: null
		};
	}

	return graph;
}

// https://en.wikipedia.org/wiki/Breadth-first_search
function deriveBFS(fromModel) {
	var graph = buildGraph();
	var queue = [fromModel]; // unshift -> queue -> pop

	graph[fromModel].distance = 0;

	while (queue.length) {
		var current = queue.pop();
		var adjacents = Object.keys(conversions[current]);

		for (var len = adjacents.length, i = 0; i < len; i++) {
			var adjacent = adjacents[i];
			var node = graph[adjacent];

			if (node.distance === -1) {
				node.distance = graph[current].distance + 1;
				node.parent = current;
				queue.unshift(adjacent);
			}
		}
	}

	return graph;
}

function link(from, to) {
	return function (args) {
		return to(from(args));
	};
}

function wrapConversion(toModel, graph) {
	var path = [graph[toModel].parent, toModel];
	var fn = conversions[graph[toModel].parent][toModel];

	var cur = graph[toModel].parent;
	while (graph[cur].parent) {
		path.unshift(graph[cur].parent);
		fn = link(conversions[graph[cur].parent][cur], fn);
		cur = graph[cur].parent;
	}

	fn.conversion = path;
	return fn;
}

module.exports = function (fromModel) {
	var graph = deriveBFS(fromModel);
	var conversion = {};

	var models = Object.keys(graph);
	for (var len = models.length, i = 0; i < len; i++) {
		var toModel = models[i];
		var node = graph[toModel];

		if (node.parent === null) {
			// no possible conversion, or this node is the source model.
			continue;
		}

		conversion[toModel] = wrapConversion(toModel, graph);
	}

	return conversion;
};



/***/ }),

/***/ "./node_modules/color-name/index.js":
/*!******************************************!*\
  !*** ./node_modules/color-name/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
	"aliceblue": [240, 248, 255],
	"antiquewhite": [250, 235, 215],
	"aqua": [0, 255, 255],
	"aquamarine": [127, 255, 212],
	"azure": [240, 255, 255],
	"beige": [245, 245, 220],
	"bisque": [255, 228, 196],
	"black": [0, 0, 0],
	"blanchedalmond": [255, 235, 205],
	"blue": [0, 0, 255],
	"blueviolet": [138, 43, 226],
	"brown": [165, 42, 42],
	"burlywood": [222, 184, 135],
	"cadetblue": [95, 158, 160],
	"chartreuse": [127, 255, 0],
	"chocolate": [210, 105, 30],
	"coral": [255, 127, 80],
	"cornflowerblue": [100, 149, 237],
	"cornsilk": [255, 248, 220],
	"crimson": [220, 20, 60],
	"cyan": [0, 255, 255],
	"darkblue": [0, 0, 139],
	"darkcyan": [0, 139, 139],
	"darkgoldenrod": [184, 134, 11],
	"darkgray": [169, 169, 169],
	"darkgreen": [0, 100, 0],
	"darkgrey": [169, 169, 169],
	"darkkhaki": [189, 183, 107],
	"darkmagenta": [139, 0, 139],
	"darkolivegreen": [85, 107, 47],
	"darkorange": [255, 140, 0],
	"darkorchid": [153, 50, 204],
	"darkred": [139, 0, 0],
	"darksalmon": [233, 150, 122],
	"darkseagreen": [143, 188, 143],
	"darkslateblue": [72, 61, 139],
	"darkslategray": [47, 79, 79],
	"darkslategrey": [47, 79, 79],
	"darkturquoise": [0, 206, 209],
	"darkviolet": [148, 0, 211],
	"deeppink": [255, 20, 147],
	"deepskyblue": [0, 191, 255],
	"dimgray": [105, 105, 105],
	"dimgrey": [105, 105, 105],
	"dodgerblue": [30, 144, 255],
	"firebrick": [178, 34, 34],
	"floralwhite": [255, 250, 240],
	"forestgreen": [34, 139, 34],
	"fuchsia": [255, 0, 255],
	"gainsboro": [220, 220, 220],
	"ghostwhite": [248, 248, 255],
	"gold": [255, 215, 0],
	"goldenrod": [218, 165, 32],
	"gray": [128, 128, 128],
	"green": [0, 128, 0],
	"greenyellow": [173, 255, 47],
	"grey": [128, 128, 128],
	"honeydew": [240, 255, 240],
	"hotpink": [255, 105, 180],
	"indianred": [205, 92, 92],
	"indigo": [75, 0, 130],
	"ivory": [255, 255, 240],
	"khaki": [240, 230, 140],
	"lavender": [230, 230, 250],
	"lavenderblush": [255, 240, 245],
	"lawngreen": [124, 252, 0],
	"lemonchiffon": [255, 250, 205],
	"lightblue": [173, 216, 230],
	"lightcoral": [240, 128, 128],
	"lightcyan": [224, 255, 255],
	"lightgoldenrodyellow": [250, 250, 210],
	"lightgray": [211, 211, 211],
	"lightgreen": [144, 238, 144],
	"lightgrey": [211, 211, 211],
	"lightpink": [255, 182, 193],
	"lightsalmon": [255, 160, 122],
	"lightseagreen": [32, 178, 170],
	"lightskyblue": [135, 206, 250],
	"lightslategray": [119, 136, 153],
	"lightslategrey": [119, 136, 153],
	"lightsteelblue": [176, 196, 222],
	"lightyellow": [255, 255, 224],
	"lime": [0, 255, 0],
	"limegreen": [50, 205, 50],
	"linen": [250, 240, 230],
	"magenta": [255, 0, 255],
	"maroon": [128, 0, 0],
	"mediumaquamarine": [102, 205, 170],
	"mediumblue": [0, 0, 205],
	"mediumorchid": [186, 85, 211],
	"mediumpurple": [147, 112, 219],
	"mediumseagreen": [60, 179, 113],
	"mediumslateblue": [123, 104, 238],
	"mediumspringgreen": [0, 250, 154],
	"mediumturquoise": [72, 209, 204],
	"mediumvioletred": [199, 21, 133],
	"midnightblue": [25, 25, 112],
	"mintcream": [245, 255, 250],
	"mistyrose": [255, 228, 225],
	"moccasin": [255, 228, 181],
	"navajowhite": [255, 222, 173],
	"navy": [0, 0, 128],
	"oldlace": [253, 245, 230],
	"olive": [128, 128, 0],
	"olivedrab": [107, 142, 35],
	"orange": [255, 165, 0],
	"orangered": [255, 69, 0],
	"orchid": [218, 112, 214],
	"palegoldenrod": [238, 232, 170],
	"palegreen": [152, 251, 152],
	"paleturquoise": [175, 238, 238],
	"palevioletred": [219, 112, 147],
	"papayawhip": [255, 239, 213],
	"peachpuff": [255, 218, 185],
	"peru": [205, 133, 63],
	"pink": [255, 192, 203],
	"plum": [221, 160, 221],
	"powderblue": [176, 224, 230],
	"purple": [128, 0, 128],
	"rebeccapurple": [102, 51, 153],
	"red": [255, 0, 0],
	"rosybrown": [188, 143, 143],
	"royalblue": [65, 105, 225],
	"saddlebrown": [139, 69, 19],
	"salmon": [250, 128, 114],
	"sandybrown": [244, 164, 96],
	"seagreen": [46, 139, 87],
	"seashell": [255, 245, 238],
	"sienna": [160, 82, 45],
	"silver": [192, 192, 192],
	"skyblue": [135, 206, 235],
	"slateblue": [106, 90, 205],
	"slategray": [112, 128, 144],
	"slategrey": [112, 128, 144],
	"snow": [255, 250, 250],
	"springgreen": [0, 255, 127],
	"steelblue": [70, 130, 180],
	"tan": [210, 180, 140],
	"teal": [0, 128, 128],
	"thistle": [216, 191, 216],
	"tomato": [255, 99, 71],
	"turquoise": [64, 224, 208],
	"violet": [238, 130, 238],
	"wheat": [245, 222, 179],
	"white": [255, 255, 255],
	"whitesmoke": [245, 245, 245],
	"yellow": [255, 255, 0],
	"yellowgreen": [154, 205, 50]
};


/***/ }),

/***/ "./node_modules/content-disposition/index.js":
/*!***************************************************!*\
  !*** ./node_modules/content-disposition/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * content-disposition
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = contentDisposition
module.exports.parse = parse

/**
 * Module dependencies.
 * @private
 */

var basename = __webpack_require__(/*! path */ "path").basename
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

/**
 * RegExp to match non attr-char, *after* encodeURIComponent (i.e. not including "%")
 * @private
 */

var ENCODE_URL_ATTR_CHAR_REGEXP = /[\x00-\x20"'()*,/:;<=>?@[\\\]{}\x7f]/g // eslint-disable-line no-control-regex

/**
 * RegExp to match percent encoding escape.
 * @private
 */

var HEX_ESCAPE_REGEXP = /%[0-9A-Fa-f]{2}/
var HEX_ESCAPE_REPLACE_REGEXP = /%([0-9A-Fa-f]{2})/g

/**
 * RegExp to match non-latin1 characters.
 * @private
 */

var NON_LATIN1_REGEXP = /[^\x20-\x7e\xa0-\xff]/g

/**
 * RegExp to match quoted-pair in RFC 2616
 *
 * quoted-pair = "\" CHAR
 * CHAR        = <any US-ASCII character (octets 0 - 127)>
 * @private
 */

var QESC_REGEXP = /\\([\u0000-\u007f])/g // eslint-disable-line no-control-regex

/**
 * RegExp to match chars that must be quoted-pair in RFC 2616
 * @private
 */

var QUOTE_REGEXP = /([\\"])/g

/**
 * RegExp for various RFC 2616 grammar
 *
 * parameter     = token "=" ( token | quoted-string )
 * token         = 1*<any CHAR except CTLs or separators>
 * separators    = "(" | ")" | "<" | ">" | "@"
 *               | "," | ";" | ":" | "\" | <">
 *               | "/" | "[" | "]" | "?" | "="
 *               | "{" | "}" | SP | HT
 * quoted-string = ( <"> *(qdtext | quoted-pair ) <"> )
 * qdtext        = <any TEXT except <">>
 * quoted-pair   = "\" CHAR
 * CHAR          = <any US-ASCII character (octets 0 - 127)>
 * TEXT          = <any OCTET except CTLs, but including LWS>
 * LWS           = [CRLF] 1*( SP | HT )
 * CRLF          = CR LF
 * CR            = <US-ASCII CR, carriage return (13)>
 * LF            = <US-ASCII LF, linefeed (10)>
 * SP            = <US-ASCII SP, space (32)>
 * HT            = <US-ASCII HT, horizontal-tab (9)>
 * CTL           = <any US-ASCII control character (octets 0 - 31) and DEL (127)>
 * OCTET         = <any 8-bit sequence of data>
 * @private
 */

var PARAM_REGEXP = /;[\x09\x20]*([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*=[\x09\x20]*("(?:[\x20!\x23-\x5b\x5d-\x7e\x80-\xff]|\\[\x20-\x7e])*"|[!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*/g // eslint-disable-line no-control-regex
var TEXT_REGEXP = /^[\x20-\x7e\x80-\xff]+$/
var TOKEN_REGEXP = /^[!#$%&'*+.0-9A-Z^_`a-z|~-]+$/

/**
 * RegExp for various RFC 5987 grammar
 *
 * ext-value     = charset  "'" [ language ] "'" value-chars
 * charset       = "UTF-8" / "ISO-8859-1" / mime-charset
 * mime-charset  = 1*mime-charsetc
 * mime-charsetc = ALPHA / DIGIT
 *               / "!" / "#" / "$" / "%" / "&"
 *               / "+" / "-" / "^" / "_" / "`"
 *               / "{" / "}" / "~"
 * language      = ( 2*3ALPHA [ extlang ] )
 *               / 4ALPHA
 *               / 5*8ALPHA
 * extlang       = *3( "-" 3ALPHA )
 * value-chars   = *( pct-encoded / attr-char )
 * pct-encoded   = "%" HEXDIG HEXDIG
 * attr-char     = ALPHA / DIGIT
 *               / "!" / "#" / "$" / "&" / "+" / "-" / "."
 *               / "^" / "_" / "`" / "|" / "~"
 * @private
 */

var EXT_VALUE_REGEXP = /^([A-Za-z0-9!#$%&+\-^_`{}~]+)'(?:[A-Za-z]{2,3}(?:-[A-Za-z]{3}){0,3}|[A-Za-z]{4,8}|)'((?:%[0-9A-Fa-f]{2}|[A-Za-z0-9!#$&+.^_`|~-])+)$/

/**
 * RegExp for various RFC 6266 grammar
 *
 * disposition-type = "inline" | "attachment" | disp-ext-type
 * disp-ext-type    = token
 * disposition-parm = filename-parm | disp-ext-parm
 * filename-parm    = "filename" "=" value
 *                  | "filename*" "=" ext-value
 * disp-ext-parm    = token "=" value
 *                  | ext-token "=" ext-value
 * ext-token        = <the characters in token, followed by "*">
 * @private
 */

var DISPOSITION_TYPE_REGEXP = /^([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*(?:$|;)/ // eslint-disable-line no-control-regex

/**
 * Create an attachment Content-Disposition header.
 *
 * @param {string} [filename]
 * @param {object} [options]
 * @param {string} [options.type=attachment]
 * @param {string|boolean} [options.fallback=true]
 * @return {string}
 * @public
 */

function contentDisposition (filename, options) {
  var opts = options || {}

  // get type
  var type = opts.type || 'attachment'

  // get parameters
  var params = createparams(filename, opts.fallback)

  // format into string
  return format(new ContentDisposition(type, params))
}

/**
 * Create parameters object from filename and fallback.
 *
 * @param {string} [filename]
 * @param {string|boolean} [fallback=true]
 * @return {object}
 * @private
 */

function createparams (filename, fallback) {
  if (filename === undefined) {
    return
  }

  var params = {}

  if (typeof filename !== 'string') {
    throw new TypeError('filename must be a string')
  }

  // fallback defaults to true
  if (fallback === undefined) {
    fallback = true
  }

  if (typeof fallback !== 'string' && typeof fallback !== 'boolean') {
    throw new TypeError('fallback must be a string or boolean')
  }

  if (typeof fallback === 'string' && NON_LATIN1_REGEXP.test(fallback)) {
    throw new TypeError('fallback must be ISO-8859-1 string')
  }

  // restrict to file base name
  var name = basename(filename)

  // determine if name is suitable for quoted string
  var isQuotedString = TEXT_REGEXP.test(name)

  // generate fallback name
  var fallbackName = typeof fallback !== 'string'
    ? fallback && getlatin1(name)
    : basename(fallback)
  var hasFallback = typeof fallbackName === 'string' && fallbackName !== name

  // set extended filename parameter
  if (hasFallback || !isQuotedString || HEX_ESCAPE_REGEXP.test(name)) {
    params['filename*'] = name
  }

  // set filename parameter
  if (isQuotedString || hasFallback) {
    params.filename = hasFallback
      ? fallbackName
      : name
  }

  return params
}

/**
 * Format object to Content-Disposition header.
 *
 * @param {object} obj
 * @param {string} obj.type
 * @param {object} [obj.parameters]
 * @return {string}
 * @private
 */

function format (obj) {
  var parameters = obj.parameters
  var type = obj.type

  if (!type || typeof type !== 'string' || !TOKEN_REGEXP.test(type)) {
    throw new TypeError('invalid type')
  }

  // start with normalized type
  var string = String(type).toLowerCase()

  // append parameters
  if (parameters && typeof parameters === 'object') {
    var param
    var params = Object.keys(parameters).sort()

    for (var i = 0; i < params.length; i++) {
      param = params[i]

      var val = param.substr(-1) === '*'
        ? ustring(parameters[param])
        : qstring(parameters[param])

      string += '; ' + param + '=' + val
    }
  }

  return string
}

/**
 * Decode a RFC 6987 field value (gracefully).
 *
 * @param {string} str
 * @return {string}
 * @private
 */

function decodefield (str) {
  var match = EXT_VALUE_REGEXP.exec(str)

  if (!match) {
    throw new TypeError('invalid extended field value')
  }

  var charset = match[1].toLowerCase()
  var encoded = match[2]
  var value

  // to binary string
  var binary = encoded.replace(HEX_ESCAPE_REPLACE_REGEXP, pdecode)

  switch (charset) {
    case 'iso-8859-1':
      value = getlatin1(binary)
      break
    case 'utf-8':
      value = Buffer.from(binary, 'binary').toString('utf8')
      break
    default:
      throw new TypeError('unsupported charset in extended field')
  }

  return value
}

/**
 * Get ISO-8859-1 version of string.
 *
 * @param {string} val
 * @return {string}
 * @private
 */

function getlatin1 (val) {
  // simple Unicode -> ISO-8859-1 transformation
  return String(val).replace(NON_LATIN1_REGEXP, '?')
}

/**
 * Parse Content-Disposition header string.
 *
 * @param {string} string
 * @return {object}
 * @public
 */

function parse (string) {
  if (!string || typeof string !== 'string') {
    throw new TypeError('argument string is required')
  }

  var match = DISPOSITION_TYPE_REGEXP.exec(string)

  if (!match) {
    throw new TypeError('invalid type format')
  }

  // normalize type
  var index = match[0].length
  var type = match[1].toLowerCase()

  var key
  var names = []
  var params = {}
  var value

  // calculate index to start at
  index = PARAM_REGEXP.lastIndex = match[0].substr(-1) === ';'
    ? index - 1
    : index

  // match parameters
  while ((match = PARAM_REGEXP.exec(string))) {
    if (match.index !== index) {
      throw new TypeError('invalid parameter format')
    }

    index += match[0].length
    key = match[1].toLowerCase()
    value = match[2]

    if (names.indexOf(key) !== -1) {
      throw new TypeError('invalid duplicate parameter')
    }

    names.push(key)

    if (key.indexOf('*') + 1 === key.length) {
      // decode extended value
      key = key.slice(0, -1)
      value = decodefield(value)

      // overwrite existing value
      params[key] = value
      continue
    }

    if (typeof params[key] === 'string') {
      continue
    }

    if (value[0] === '"') {
      // remove quotes and escapes
      value = value
        .substr(1, value.length - 2)
        .replace(QESC_REGEXP, '$1')
    }

    params[key] = value
  }

  if (index !== -1 && index !== string.length) {
    throw new TypeError('invalid parameter format')
  }

  return new ContentDisposition(type, params)
}

/**
 * Percent decode a single character.
 *
 * @param {string} str
 * @param {string} hex
 * @return {string}
 * @private
 */

function pdecode (str, hex) {
  return String.fromCharCode(parseInt(hex, 16))
}

/**
 * Percent encode a single character.
 *
 * @param {string} char
 * @return {string}
 * @private
 */

function pencode (char) {
  return '%' + String(char)
    .charCodeAt(0)
    .toString(16)
    .toUpperCase()
}

/**
 * Quote a string for HTTP.
 *
 * @param {string} val
 * @return {string}
 * @private
 */

function qstring (val) {
  var str = String(val)

  return '"' + str.replace(QUOTE_REGEXP, '\\$1') + '"'
}

/**
 * Encode a Unicode string for HTTP (RFC 5987).
 *
 * @param {string} val
 * @return {string}
 * @private
 */

function ustring (val) {
  var str = String(val)

  // percent encode as UTF-8
  var encoded = encodeURIComponent(str)
    .replace(ENCODE_URL_ATTR_CHAR_REGEXP, pencode)

  return 'UTF-8\'\'' + encoded
}

/**
 * Class for parsed Content-Disposition header for v8 optimization
 *
 * @public
 * @param {string} type
 * @param {object} parameters
 * @constructor
 */

function ContentDisposition (type, parameters) {
  this.type = type
  this.parameters = parameters
}


/***/ }),

/***/ "./node_modules/content-type/index.js":
/*!********************************************!*\
  !*** ./node_modules/content-type/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * content-type
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * RegExp to match *( ";" parameter ) in RFC 7231 sec 3.1.1.1
 *
 * parameter     = token "=" ( token / quoted-string )
 * token         = 1*tchar
 * tchar         = "!" / "#" / "$" / "%" / "&" / "'" / "*"
 *               / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
 *               / DIGIT / ALPHA
 *               ; any VCHAR, except delimiters
 * quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE
 * qdtext        = HTAB / SP / %x21 / %x23-5B / %x5D-7E / obs-text
 * obs-text      = %x80-FF
 * quoted-pair   = "\" ( HTAB / SP / VCHAR / obs-text )
 */
var PARAM_REGEXP = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g
var TEXT_REGEXP = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/
var TOKEN_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/

/**
 * RegExp to match quoted-pair in RFC 7230 sec 3.2.6
 *
 * quoted-pair = "\" ( HTAB / SP / VCHAR / obs-text )
 * obs-text    = %x80-FF
 */
var QESC_REGEXP = /\\([\u000b\u0020-\u00ff])/g

/**
 * RegExp to match chars that must be quoted-pair in RFC 7230 sec 3.2.6
 */
var QUOTE_REGEXP = /([\\"])/g

/**
 * RegExp to match type in RFC 7231 sec 3.1.1.1
 *
 * media-type = type "/" subtype
 * type       = token
 * subtype    = token
 */
var TYPE_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/

/**
 * Module exports.
 * @public
 */

exports.format = format
exports.parse = parse

/**
 * Format object to media type.
 *
 * @param {object} obj
 * @return {string}
 * @public
 */

function format (obj) {
  if (!obj || typeof obj !== 'object') {
    throw new TypeError('argument obj is required')
  }

  var parameters = obj.parameters
  var type = obj.type

  if (!type || !TYPE_REGEXP.test(type)) {
    throw new TypeError('invalid type')
  }

  var string = type

  // append parameters
  if (parameters && typeof parameters === 'object') {
    var param
    var params = Object.keys(parameters).sort()

    for (var i = 0; i < params.length; i++) {
      param = params[i]

      if (!TOKEN_REGEXP.test(param)) {
        throw new TypeError('invalid parameter name')
      }

      string += '; ' + param + '=' + qstring(parameters[param])
    }
  }

  return string
}

/**
 * Parse media type to object.
 *
 * @param {string|object} string
 * @return {Object}
 * @public
 */

function parse (string) {
  if (!string) {
    throw new TypeError('argument string is required')
  }

  // support req/res-like objects as argument
  var header = typeof string === 'object'
    ? getcontenttype(string)
    : string

  if (typeof header !== 'string') {
    throw new TypeError('argument string is required to be a string')
  }

  var index = header.indexOf(';')
  var type = index !== -1
    ? header.substr(0, index).trim()
    : header.trim()

  if (!TYPE_REGEXP.test(type)) {
    throw new TypeError('invalid media type')
  }

  var obj = new ContentType(type.toLowerCase())

  // parse parameters
  if (index !== -1) {
    var key
    var match
    var value

    PARAM_REGEXP.lastIndex = index

    while ((match = PARAM_REGEXP.exec(header))) {
      if (match.index !== index) {
        throw new TypeError('invalid parameter format')
      }

      index += match[0].length
      key = match[1].toLowerCase()
      value = match[2]

      if (value[0] === '"') {
        // remove quotes and escapes
        value = value
          .substr(1, value.length - 2)
          .replace(QESC_REGEXP, '$1')
      }

      obj.parameters[key] = value
    }

    if (index !== header.length) {
      throw new TypeError('invalid parameter format')
    }
  }

  return obj
}

/**
 * Get content-type from req/res objects.
 *
 * @param {object}
 * @return {Object}
 * @private
 */

function getcontenttype (obj) {
  var header

  if (typeof obj.getHeader === 'function') {
    // res-like
    header = obj.getHeader('content-type')
  } else if (typeof obj.headers === 'object') {
    // req-like
    header = obj.headers && obj.headers['content-type']
  }

  if (typeof header !== 'string') {
    throw new TypeError('content-type header is missing from object')
  }

  return header
}

/**
 * Quote a string if necessary.
 *
 * @param {string} val
 * @return {string}
 * @private
 */

function qstring (val) {
  var str = String(val)

  // no need to quote tokens
  if (TOKEN_REGEXP.test(str)) {
    return str
  }

  if (str.length > 0 && !TEXT_REGEXP.test(str)) {
    throw new TypeError('invalid parameter value')
  }

  return '"' + str.replace(QUOTE_REGEXP, '\\$1') + '"'
}

/**
 * Class to represent a content type.
 * @private
 */
function ContentType (type) {
  this.parameters = Object.create(null)
  this.type = type
}


/***/ }),

/***/ "./node_modules/cookie-signature/index.js":
/*!************************************************!*\
  !*** ./node_modules/cookie-signature/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Module dependencies.
 */

var crypto = __webpack_require__(/*! crypto */ "crypto");

/**
 * Sign the given `val` with `secret`.
 *
 * @param {String} val
 * @param {String} secret
 * @return {String}
 * @api private
 */

exports.sign = function(val, secret){
  if ('string' != typeof val) throw new TypeError("Cookie value must be provided as a string.");
  if ('string' != typeof secret) throw new TypeError("Secret string must be provided.");
  return val + '.' + crypto
    .createHmac('sha256', secret)
    .update(val)
    .digest('base64')
    .replace(/\=+$/, '');
};

/**
 * Unsign and decode the given `val` with `secret`,
 * returning `false` if the signature is invalid.
 *
 * @param {String} val
 * @param {String} secret
 * @return {String|Boolean}
 * @api private
 */

exports.unsign = function(val, secret){
  if ('string' != typeof val) throw new TypeError("Signed cookie string must be provided.");
  if ('string' != typeof secret) throw new TypeError("Secret string must be provided.");
  var str = val.slice(0, val.lastIndexOf('.'))
    , mac = exports.sign(str, secret);
  
  return sha1(mac) == sha1(val) ? str : false;
};

/**
 * Private
 */

function sha1(str){
  return crypto.createHash('sha1').update(str).digest('hex');
}


/***/ }),

/***/ "./node_modules/cookie/index.js":
/*!**************************************!*\
  !*** ./node_modules/cookie/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

exports.parse = parse;
exports.serialize = serialize;

/**
 * Module variables.
 * @private
 */

var decode = decodeURIComponent;
var encode = encodeURIComponent;
var pairSplitRegExp = /; */;

/**
 * RegExp to match field-content in RFC 7230 sec 3.2
 *
 * field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]
 * field-vchar   = VCHAR / obs-text
 * obs-text      = %x80-FF
 */

var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;

/**
 * Parse a cookie header.
 *
 * Parse the given cookie header string into an object
 * The object has the various cookies as keys(names) => values
 *
 * @param {string} str
 * @param {object} [options]
 * @return {object}
 * @public
 */

function parse(str, options) {
  if (typeof str !== 'string') {
    throw new TypeError('argument str must be a string');
  }

  var obj = {}
  var opt = options || {};
  var pairs = str.split(pairSplitRegExp);
  var dec = opt.decode || decode;

  for (var i = 0; i < pairs.length; i++) {
    var pair = pairs[i];
    var eq_idx = pair.indexOf('=');

    // skip things that don't look like key=value
    if (eq_idx < 0) {
      continue;
    }

    var key = pair.substr(0, eq_idx).trim()
    var val = pair.substr(++eq_idx, pair.length).trim();

    // quoted values
    if ('"' == val[0]) {
      val = val.slice(1, -1);
    }

    // only assign once
    if (undefined == obj[key]) {
      obj[key] = tryDecode(val, dec);
    }
  }

  return obj;
}

/**
 * Serialize data into a cookie header.
 *
 * Serialize the a name value pair into a cookie string suitable for
 * http headers. An optional options object specified cookie parameters.
 *
 * serialize('foo', 'bar', { httpOnly: true })
 *   => "foo=bar; httpOnly"
 *
 * @param {string} name
 * @param {string} val
 * @param {object} [options]
 * @return {string}
 * @public
 */

function serialize(name, val, options) {
  var opt = options || {};
  var enc = opt.encode || encode;

  if (typeof enc !== 'function') {
    throw new TypeError('option encode is invalid');
  }

  if (!fieldContentRegExp.test(name)) {
    throw new TypeError('argument name is invalid');
  }

  var value = enc(val);

  if (value && !fieldContentRegExp.test(value)) {
    throw new TypeError('argument val is invalid');
  }

  var str = name + '=' + value;

  if (null != opt.maxAge) {
    var maxAge = opt.maxAge - 0;
    if (isNaN(maxAge)) throw new Error('maxAge should be a Number');
    str += '; Max-Age=' + Math.floor(maxAge);
  }

  if (opt.domain) {
    if (!fieldContentRegExp.test(opt.domain)) {
      throw new TypeError('option domain is invalid');
    }

    str += '; Domain=' + opt.domain;
  }

  if (opt.path) {
    if (!fieldContentRegExp.test(opt.path)) {
      throw new TypeError('option path is invalid');
    }

    str += '; Path=' + opt.path;
  }

  if (opt.expires) {
    if (typeof opt.expires.toUTCString !== 'function') {
      throw new TypeError('option expires is invalid');
    }

    str += '; Expires=' + opt.expires.toUTCString();
  }

  if (opt.httpOnly) {
    str += '; HttpOnly';
  }

  if (opt.secure) {
    str += '; Secure';
  }

  if (opt.sameSite) {
    var sameSite = typeof opt.sameSite === 'string'
      ? opt.sameSite.toLowerCase() : opt.sameSite;

    switch (sameSite) {
      case true:
        str += '; SameSite=Strict';
        break;
      case 'lax':
        str += '; SameSite=Lax';
        break;
      case 'strict':
        str += '; SameSite=Strict';
        break;
      case 'none':
        str += '; SameSite=None';
        break;
      default:
        throw new TypeError('option sameSite is invalid');
    }
  }

  return str;
}

/**
 * Try decoding a string using a decoding function.
 *
 * @param {string} str
 * @param {function} decode
 * @private
 */

function tryDecode(str, decode) {
  try {
    return decode(str);
  } catch (e) {
    return str;
  }
}


/***/ }),

/***/ "./node_modules/depd/index.js":
/*!************************************!*\
  !*** ./node_modules/depd/index.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*!
 * depd
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var callSiteToString = __webpack_require__(/*! ./lib/compat */ "./node_modules/depd/lib/compat/index.js").callSiteToString
var eventListenerCount = __webpack_require__(/*! ./lib/compat */ "./node_modules/depd/lib/compat/index.js").eventListenerCount
var relative = __webpack_require__(/*! path */ "path").relative

/**
 * Module exports.
 */

module.exports = depd

/**
 * Get the path to base files on.
 */

var basePath = process.cwd()

/**
 * Determine if namespace is contained in the string.
 */

function containsNamespace (str, namespace) {
  var vals = str.split(/[ ,]+/)
  var ns = String(namespace).toLowerCase()

  for (var i = 0; i < vals.length; i++) {
    var val = vals[i]

    // namespace contained
    if (val && (val === '*' || val.toLowerCase() === ns)) {
      return true
    }
  }

  return false
}

/**
 * Convert a data descriptor to accessor descriptor.
 */

function convertDataDescriptorToAccessor (obj, prop, message) {
  var descriptor = Object.getOwnPropertyDescriptor(obj, prop)
  var value = descriptor.value

  descriptor.get = function getter () { return value }

  if (descriptor.writable) {
    descriptor.set = function setter (val) { return (value = val) }
  }

  delete descriptor.value
  delete descriptor.writable

  Object.defineProperty(obj, prop, descriptor)

  return descriptor
}

/**
 * Create arguments string to keep arity.
 */

function createArgumentsString (arity) {
  var str = ''

  for (var i = 0; i < arity; i++) {
    str += ', arg' + i
  }

  return str.substr(2)
}

/**
 * Create stack string from stack.
 */

function createStackString (stack) {
  var str = this.name + ': ' + this.namespace

  if (this.message) {
    str += ' deprecated ' + this.message
  }

  for (var i = 0; i < stack.length; i++) {
    str += '\n    at ' + callSiteToString(stack[i])
  }

  return str
}

/**
 * Create deprecate for namespace in caller.
 */

function depd (namespace) {
  if (!namespace) {
    throw new TypeError('argument namespace is required')
  }

  var stack = getStack()
  var site = callSiteLocation(stack[1])
  var file = site[0]

  function deprecate (message) {
    // call to self as log
    log.call(deprecate, message)
  }

  deprecate._file = file
  deprecate._ignored = isignored(namespace)
  deprecate._namespace = namespace
  deprecate._traced = istraced(namespace)
  deprecate._warned = Object.create(null)

  deprecate.function = wrapfunction
  deprecate.property = wrapproperty

  return deprecate
}

/**
 * Determine if namespace is ignored.
 */

function isignored (namespace) {
  /* istanbul ignore next: tested in a child processs */
  if (process.noDeprecation) {
    // --no-deprecation support
    return true
  }

  var str = process.env.NO_DEPRECATION || ''

  // namespace ignored
  return containsNamespace(str, namespace)
}

/**
 * Determine if namespace is traced.
 */

function istraced (namespace) {
  /* istanbul ignore next: tested in a child processs */
  if (process.traceDeprecation) {
    // --trace-deprecation support
    return true
  }

  var str = process.env.TRACE_DEPRECATION || ''

  // namespace traced
  return containsNamespace(str, namespace)
}

/**
 * Display deprecation message.
 */

function log (message, site) {
  var haslisteners = eventListenerCount(process, 'deprecation') !== 0

  // abort early if no destination
  if (!haslisteners && this._ignored) {
    return
  }

  var caller
  var callFile
  var callSite
  var depSite
  var i = 0
  var seen = false
  var stack = getStack()
  var file = this._file

  if (site) {
    // provided site
    depSite = site
    callSite = callSiteLocation(stack[1])
    callSite.name = depSite.name
    file = callSite[0]
  } else {
    // get call site
    i = 2
    depSite = callSiteLocation(stack[i])
    callSite = depSite
  }

  // get caller of deprecated thing in relation to file
  for (; i < stack.length; i++) {
    caller = callSiteLocation(stack[i])
    callFile = caller[0]

    if (callFile === file) {
      seen = true
    } else if (callFile === this._file) {
      file = this._file
    } else if (seen) {
      break
    }
  }

  var key = caller
    ? depSite.join(':') + '__' + caller.join(':')
    : undefined

  if (key !== undefined && key in this._warned) {
    // already warned
    return
  }

  this._warned[key] = true

  // generate automatic message from call site
  var msg = message
  if (!msg) {
    msg = callSite === depSite || !callSite.name
      ? defaultMessage(depSite)
      : defaultMessage(callSite)
  }

  // emit deprecation if listeners exist
  if (haslisteners) {
    var err = DeprecationError(this._namespace, msg, stack.slice(i))
    process.emit('deprecation', err)
    return
  }

  // format and write message
  var format = process.stderr.isTTY
    ? formatColor
    : formatPlain
  var output = format.call(this, msg, caller, stack.slice(i))
  process.stderr.write(output + '\n', 'utf8')
}

/**
 * Get call site location as array.
 */

function callSiteLocation (callSite) {
  var file = callSite.getFileName() || '<anonymous>'
  var line = callSite.getLineNumber()
  var colm = callSite.getColumnNumber()

  if (callSite.isEval()) {
    file = callSite.getEvalOrigin() + ', ' + file
  }

  var site = [file, line, colm]

  site.callSite = callSite
  site.name = callSite.getFunctionName()

  return site
}

/**
 * Generate a default message from the site.
 */

function defaultMessage (site) {
  var callSite = site.callSite
  var funcName = site.name

  // make useful anonymous name
  if (!funcName) {
    funcName = '<anonymous@' + formatLocation(site) + '>'
  }

  var context = callSite.getThis()
  var typeName = context && callSite.getTypeName()

  // ignore useless type name
  if (typeName === 'Object') {
    typeName = undefined
  }

  // make useful type name
  if (typeName === 'Function') {
    typeName = context.name || typeName
  }

  return typeName && callSite.getMethodName()
    ? typeName + '.' + funcName
    : funcName
}

/**
 * Format deprecation message without color.
 */

function formatPlain (msg, caller, stack) {
  var timestamp = new Date().toUTCString()

  var formatted = timestamp +
    ' ' + this._namespace +
    ' deprecated ' + msg

  // add stack trace
  if (this._traced) {
    for (var i = 0; i < stack.length; i++) {
      formatted += '\n    at ' + callSiteToString(stack[i])
    }

    return formatted
  }

  if (caller) {
    formatted += ' at ' + formatLocation(caller)
  }

  return formatted
}

/**
 * Format deprecation message with color.
 */

function formatColor (msg, caller, stack) {
  var formatted = '\x1b[36;1m' + this._namespace + '\x1b[22;39m' + // bold cyan
    ' \x1b[33;1mdeprecated\x1b[22;39m' + // bold yellow
    ' \x1b[0m' + msg + '\x1b[39m' // reset

  // add stack trace
  if (this._traced) {
    for (var i = 0; i < stack.length; i++) {
      formatted += '\n    \x1b[36mat ' + callSiteToString(stack[i]) + '\x1b[39m' // cyan
    }

    return formatted
  }

  if (caller) {
    formatted += ' \x1b[36m' + formatLocation(caller) + '\x1b[39m' // cyan
  }

  return formatted
}

/**
 * Format call site location.
 */

function formatLocation (callSite) {
  return relative(basePath, callSite[0]) +
    ':' + callSite[1] +
    ':' + callSite[2]
}

/**
 * Get the stack as array of call sites.
 */

function getStack () {
  var limit = Error.stackTraceLimit
  var obj = {}
  var prep = Error.prepareStackTrace

  Error.prepareStackTrace = prepareObjectStackTrace
  Error.stackTraceLimit = Math.max(10, limit)

  // capture the stack
  Error.captureStackTrace(obj)

  // slice this function off the top
  var stack = obj.stack.slice(1)

  Error.prepareStackTrace = prep
  Error.stackTraceLimit = limit

  return stack
}

/**
 * Capture call site stack from v8.
 */

function prepareObjectStackTrace (obj, stack) {
  return stack
}

/**
 * Return a wrapped function in a deprecation message.
 */

function wrapfunction (fn, message) {
  if (typeof fn !== 'function') {
    throw new TypeError('argument fn must be a function')
  }

  var args = createArgumentsString(fn.length)
  var deprecate = this // eslint-disable-line no-unused-vars
  var stack = getStack()
  var site = callSiteLocation(stack[1])

  site.name = fn.name

   // eslint-disable-next-line no-eval
  var deprecatedfn = eval('(function (' + args + ') {\n' +
    '"use strict"\n' +
    'log.call(deprecate, message, site)\n' +
    'return fn.apply(this, arguments)\n' +
    '})')

  return deprecatedfn
}

/**
 * Wrap property in a deprecation message.
 */

function wrapproperty (obj, prop, message) {
  if (!obj || (typeof obj !== 'object' && typeof obj !== 'function')) {
    throw new TypeError('argument obj must be object')
  }

  var descriptor = Object.getOwnPropertyDescriptor(obj, prop)

  if (!descriptor) {
    throw new TypeError('must call property on owner object')
  }

  if (!descriptor.configurable) {
    throw new TypeError('property must be configurable')
  }

  var deprecate = this
  var stack = getStack()
  var site = callSiteLocation(stack[1])

  // set site name
  site.name = prop

  // convert data descriptor
  if ('value' in descriptor) {
    descriptor = convertDataDescriptorToAccessor(obj, prop, message)
  }

  var get = descriptor.get
  var set = descriptor.set

  // wrap getter
  if (typeof get === 'function') {
    descriptor.get = function getter () {
      log.call(deprecate, message, site)
      return get.apply(this, arguments)
    }
  }

  // wrap setter
  if (typeof set === 'function') {
    descriptor.set = function setter () {
      log.call(deprecate, message, site)
      return set.apply(this, arguments)
    }
  }

  Object.defineProperty(obj, prop, descriptor)
}

/**
 * Create DeprecationError for deprecation
 */

function DeprecationError (namespace, message, stack) {
  var error = new Error()
  var stackString

  Object.defineProperty(error, 'constructor', {
    value: DeprecationError
  })

  Object.defineProperty(error, 'message', {
    configurable: true,
    enumerable: false,
    value: message,
    writable: true
  })

  Object.defineProperty(error, 'name', {
    enumerable: false,
    configurable: true,
    value: 'DeprecationError',
    writable: true
  })

  Object.defineProperty(error, 'namespace', {
    configurable: true,
    enumerable: false,
    value: namespace,
    writable: true
  })

  Object.defineProperty(error, 'stack', {
    configurable: true,
    enumerable: false,
    get: function () {
      if (stackString !== undefined) {
        return stackString
      }

      // prepare stack trace
      return (stackString = createStackString.call(this, stack))
    },
    set: function setter (val) {
      stackString = val
    }
  })

  return error
}


/***/ }),

/***/ "./node_modules/depd/lib/compat/callsite-tostring.js":
/*!***********************************************************!*\
  !*** ./node_modules/depd/lib/compat/callsite-tostring.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * depd
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 */

module.exports = callSiteToString

/**
 * Format a CallSite file location to a string.
 */

function callSiteFileLocation (callSite) {
  var fileName
  var fileLocation = ''

  if (callSite.isNative()) {
    fileLocation = 'native'
  } else if (callSite.isEval()) {
    fileName = callSite.getScriptNameOrSourceURL()
    if (!fileName) {
      fileLocation = callSite.getEvalOrigin()
    }
  } else {
    fileName = callSite.getFileName()
  }

  if (fileName) {
    fileLocation += fileName

    var lineNumber = callSite.getLineNumber()
    if (lineNumber != null) {
      fileLocation += ':' + lineNumber

      var columnNumber = callSite.getColumnNumber()
      if (columnNumber) {
        fileLocation += ':' + columnNumber
      }
    }
  }

  return fileLocation || 'unknown source'
}

/**
 * Format a CallSite to a string.
 */

function callSiteToString (callSite) {
  var addSuffix = true
  var fileLocation = callSiteFileLocation(callSite)
  var functionName = callSite.getFunctionName()
  var isConstructor = callSite.isConstructor()
  var isMethodCall = !(callSite.isToplevel() || isConstructor)
  var line = ''

  if (isMethodCall) {
    var methodName = callSite.getMethodName()
    var typeName = getConstructorName(callSite)

    if (functionName) {
      if (typeName && functionName.indexOf(typeName) !== 0) {
        line += typeName + '.'
      }

      line += functionName

      if (methodName && functionName.lastIndexOf('.' + methodName) !== functionName.length - methodName.length - 1) {
        line += ' [as ' + methodName + ']'
      }
    } else {
      line += typeName + '.' + (methodName || '<anonymous>')
    }
  } else if (isConstructor) {
    line += 'new ' + (functionName || '<anonymous>')
  } else if (functionName) {
    line += functionName
  } else {
    addSuffix = false
    line += fileLocation
  }

  if (addSuffix) {
    line += ' (' + fileLocation + ')'
  }

  return line
}

/**
 * Get constructor name of reviver.
 */

function getConstructorName (obj) {
  var receiver = obj.receiver
  return (receiver.constructor && receiver.constructor.name) || null
}


/***/ }),

/***/ "./node_modules/depd/lib/compat/event-listener-count.js":
/*!**************************************************************!*\
  !*** ./node_modules/depd/lib/compat/event-listener-count.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * depd
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = eventListenerCount

/**
 * Get the count of listeners on an event emitter of a specific type.
 */

function eventListenerCount (emitter, type) {
  return emitter.listeners(type).length
}


/***/ }),

/***/ "./node_modules/depd/lib/compat/index.js":
/*!***********************************************!*\
  !*** ./node_modules/depd/lib/compat/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * depd
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var EventEmitter = __webpack_require__(/*! events */ "events").EventEmitter

/**
 * Module exports.
 * @public
 */

lazyProperty(module.exports, 'callSiteToString', function callSiteToString () {
  var limit = Error.stackTraceLimit
  var obj = {}
  var prep = Error.prepareStackTrace

  function prepareObjectStackTrace (obj, stack) {
    return stack
  }

  Error.prepareStackTrace = prepareObjectStackTrace
  Error.stackTraceLimit = 2

  // capture the stack
  Error.captureStackTrace(obj)

  // slice the stack
  var stack = obj.stack.slice()

  Error.prepareStackTrace = prep
  Error.stackTraceLimit = limit

  return stack[0].toString ? toString : __webpack_require__(/*! ./callsite-tostring */ "./node_modules/depd/lib/compat/callsite-tostring.js")
})

lazyProperty(module.exports, 'eventListenerCount', function eventListenerCount () {
  return EventEmitter.listenerCount || __webpack_require__(/*! ./event-listener-count */ "./node_modules/depd/lib/compat/event-listener-count.js")
})

/**
 * Define a lazy property.
 */

function lazyProperty (obj, prop, getter) {
  function get () {
    var val = getter()

    Object.defineProperty(obj, prop, {
      configurable: true,
      enumerable: true,
      value: val
    })

    return val
  }

  Object.defineProperty(obj, prop, {
    configurable: true,
    enumerable: true,
    get: get
  })
}

/**
 * Call toString() on the obj
 */

function toString (obj) {
  return obj.toString()
}


/***/ }),

/***/ "./node_modules/destroy/index.js":
/*!***************************************!*\
  !*** ./node_modules/destroy/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * destroy
 * Copyright(c) 2014 Jonathan Ong
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var ReadStream = __webpack_require__(/*! fs */ "fs").ReadStream
var Stream = __webpack_require__(/*! stream */ "stream")

/**
 * Module exports.
 * @public
 */

module.exports = destroy

/**
 * Destroy a stream.
 *
 * @param {object} stream
 * @public
 */

function destroy(stream) {
  if (stream instanceof ReadStream) {
    return destroyReadStream(stream)
  }

  if (!(stream instanceof Stream)) {
    return stream
  }

  if (typeof stream.destroy === 'function') {
    stream.destroy()
  }

  return stream
}

/**
 * Destroy a ReadStream.
 *
 * @param {object} stream
 * @private
 */

function destroyReadStream(stream) {
  stream.destroy()

  if (typeof stream.close === 'function') {
    // node.js core bug work-around
    stream.on('open', onOpenClose)
  }

  return stream
}

/**
 * On open handler to close stream.
 * @private
 */

function onOpenClose() {
  if (typeof this.fd === 'number') {
    // actually close down the fd
    this.close()
  }
}


/***/ }),

/***/ "./node_modules/ee-first/index.js":
/*!****************************************!*\
  !*** ./node_modules/ee-first/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * ee-first
 * Copyright(c) 2014 Jonathan Ong
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = first

/**
 * Get the first event in a set of event emitters and event pairs.
 *
 * @param {array} stuff
 * @param {function} done
 * @public
 */

function first(stuff, done) {
  if (!Array.isArray(stuff))
    throw new TypeError('arg must be an array of [ee, events...] arrays')

  var cleanups = []

  for (var i = 0; i < stuff.length; i++) {
    var arr = stuff[i]

    if (!Array.isArray(arr) || arr.length < 2)
      throw new TypeError('each array member must be [ee, events...]')

    var ee = arr[0]

    for (var j = 1; j < arr.length; j++) {
      var event = arr[j]
      var fn = listener(event, callback)

      // listen to the event
      ee.on(event, fn)
      // push this listener to the list of cleanups
      cleanups.push({
        ee: ee,
        event: event,
        fn: fn,
      })
    }
  }

  function callback() {
    cleanup()
    done.apply(null, arguments)
  }

  function cleanup() {
    var x
    for (var i = 0; i < cleanups.length; i++) {
      x = cleanups[i]
      x.ee.removeListener(x.event, x.fn)
    }
  }

  function thunk(fn) {
    done = fn
  }

  thunk.cancel = cleanup

  return thunk
}

/**
 * Create the event listener.
 * @private
 */

function listener(event, done) {
  return function onevent(arg1) {
    var args = new Array(arguments.length)
    var ee = this
    var err = event === 'error'
      ? arg1
      : null

    // copy args to prevent arguments escaping scope
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i]
    }

    done(err, ee, event, args)
  }
}


/***/ }),

/***/ "./node_modules/encodeurl/index.js":
/*!*****************************************!*\
  !*** ./node_modules/encodeurl/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * encodeurl
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = encodeUrl

/**
 * RegExp to match non-URL code points, *after* encoding (i.e. not including "%")
 * and including invalid escape sequences.
 * @private
 */

var ENCODE_CHARS_REGEXP = /(?:[^\x21\x25\x26-\x3B\x3D\x3F-\x5B\x5D\x5F\x61-\x7A\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]|$))+/g

/**
 * RegExp to match unmatched surrogate pair.
 * @private
 */

var UNMATCHED_SURROGATE_PAIR_REGEXP = /(^|[^\uD800-\uDBFF])[\uDC00-\uDFFF]|[\uD800-\uDBFF]([^\uDC00-\uDFFF]|$)/g

/**
 * String to replace unmatched surrogate pair with.
 * @private
 */

var UNMATCHED_SURROGATE_PAIR_REPLACE = '$1\uFFFD$2'

/**
 * Encode a URL to a percent-encoded form, excluding already-encoded sequences.
 *
 * This function will take an already-encoded URL and encode all the non-URL
 * code points. This function will not encode the "%" character unless it is
 * not part of a valid sequence (`%20` will be left as-is, but `%foo` will
 * be encoded as `%25foo`).
 *
 * This encode is meant to be "safe" and does not throw errors. It will try as
 * hard as it can to properly encode the given URL, including replacing any raw,
 * unpaired surrogate pairs with the Unicode replacement character prior to
 * encoding.
 *
 * @param {string} url
 * @return {string}
 * @public
 */

function encodeUrl (url) {
  return String(url)
    .replace(UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE)
    .replace(ENCODE_CHARS_REGEXP, encodeURI)
}


/***/ }),

/***/ "./node_modules/escape-html/index.js":
/*!*******************************************!*\
  !*** ./node_modules/escape-html/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */



/**
 * Module variables.
 * @private
 */

var matchHtmlRegExp = /["'&<>]/;

/**
 * Module exports.
 * @public
 */

module.exports = escapeHtml;

/**
 * Escape special characters in the given string of html.
 *
 * @param  {string} string The string to escape for inserting into HTML
 * @return {string}
 * @public
 */

function escapeHtml(string) {
  var str = '' + string;
  var match = matchHtmlRegExp.exec(str);

  if (!match) {
    return str;
  }

  var escape;
  var html = '';
  var index = 0;
  var lastIndex = 0;

  for (index = match.index; index < str.length; index++) {
    switch (str.charCodeAt(index)) {
      case 34: // "
        escape = '&quot;';
        break;
      case 38: // &
        escape = '&amp;';
        break;
      case 39: // '
        escape = '&#39;';
        break;
      case 60: // <
        escape = '&lt;';
        break;
      case 62: // >
        escape = '&gt;';
        break;
      default:
        continue;
    }

    if (lastIndex !== index) {
      html += str.substring(lastIndex, index);
    }

    lastIndex = index + 1;
    html += escape;
  }

  return lastIndex !== index
    ? html + str.substring(lastIndex, index)
    : html;
}


/***/ }),

/***/ "./node_modules/escape-string-regexp/index.js":
/*!****************************************************!*\
  !*** ./node_modules/escape-string-regexp/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;

module.exports = function (str) {
	if (typeof str !== 'string') {
		throw new TypeError('Expected a string');
	}

	return str.replace(matchOperatorsRe, '\\$&');
};


/***/ }),

/***/ "./node_modules/etag/index.js":
/*!************************************!*\
  !*** ./node_modules/etag/index.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * etag
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = etag

/**
 * Module dependencies.
 * @private
 */

var crypto = __webpack_require__(/*! crypto */ "crypto")
var Stats = __webpack_require__(/*! fs */ "fs").Stats

/**
 * Module variables.
 * @private
 */

var toString = Object.prototype.toString

/**
 * Generate an entity tag.
 *
 * @param {Buffer|string} entity
 * @return {string}
 * @private
 */

function entitytag (entity) {
  if (entity.length === 0) {
    // fast-path empty
    return '"0-2jmj7l5rSw0yVb/vlWAYkK/YBwk"'
  }

  // compute hash of entity
  var hash = crypto
    .createHash('sha1')
    .update(entity, 'utf8')
    .digest('base64')
    .substring(0, 27)

  // compute length of entity
  var len = typeof entity === 'string'
    ? Buffer.byteLength(entity, 'utf8')
    : entity.length

  return '"' + len.toString(16) + '-' + hash + '"'
}

/**
 * Create a simple ETag.
 *
 * @param {string|Buffer|Stats} entity
 * @param {object} [options]
 * @param {boolean} [options.weak]
 * @return {String}
 * @public
 */

function etag (entity, options) {
  if (entity == null) {
    throw new TypeError('argument entity is required')
  }

  // support fs.Stats object
  var isStats = isstats(entity)
  var weak = options && typeof options.weak === 'boolean'
    ? options.weak
    : isStats

  // validate argument
  if (!isStats && typeof entity !== 'string' && !Buffer.isBuffer(entity)) {
    throw new TypeError('argument entity must be string, Buffer, or fs.Stats')
  }

  // generate entity tag
  var tag = isStats
    ? stattag(entity)
    : entitytag(entity)

  return weak
    ? 'W/' + tag
    : tag
}

/**
 * Determine if object is a Stats object.
 *
 * @param {object} obj
 * @return {boolean}
 * @api private
 */

function isstats (obj) {
  // genuine fs.Stats
  if (typeof Stats === 'function' && obj instanceof Stats) {
    return true
  }

  // quack quack
  return obj && typeof obj === 'object' &&
    'ctime' in obj && toString.call(obj.ctime) === '[object Date]' &&
    'mtime' in obj && toString.call(obj.mtime) === '[object Date]' &&
    'ino' in obj && typeof obj.ino === 'number' &&
    'size' in obj && typeof obj.size === 'number'
}

/**
 * Generate a tag for a stat.
 *
 * @param {object} stat
 * @return {string}
 * @private
 */

function stattag (stat) {
  var mtime = stat.mtime.getTime().toString(16)
  var size = stat.size.toString(16)

  return '"' + size + '-' + mtime + '"'
}


/***/ }),

/***/ "./node_modules/express/index.js":
/*!***************************************!*\
  !*** ./node_modules/express/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



module.exports = __webpack_require__(/*! ./lib/express */ "./node_modules/express/lib/express.js");


/***/ }),

/***/ "./node_modules/express/lib sync recursive":
/*!***************************************!*\
  !*** ./node_modules/express/lib sync ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = function() { return []; };
webpackEmptyContext.resolve = webpackEmptyContext;
module.exports = webpackEmptyContext;
webpackEmptyContext.id = "./node_modules/express/lib sync recursive";

/***/ }),

/***/ "./node_modules/express/lib/application.js":
/*!*************************************************!*\
  !*** ./node_modules/express/lib/application.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var finalhandler = __webpack_require__(/*! finalhandler */ "./node_modules/finalhandler/index.js");
var Router = __webpack_require__(/*! ./router */ "./node_modules/express/lib/router/index.js");
var methods = __webpack_require__(/*! methods */ "./node_modules/methods/index.js");
var middleware = __webpack_require__(/*! ./middleware/init */ "./node_modules/express/lib/middleware/init.js");
var query = __webpack_require__(/*! ./middleware/query */ "./node_modules/express/lib/middleware/query.js");
var debug = __webpack_require__(/*! debug */ "./node_modules/express/node_modules/debug/src/index.js")('express:application');
var View = __webpack_require__(/*! ./view */ "./node_modules/express/lib/view.js");
var http = __webpack_require__(/*! http */ "http");
var compileETag = __webpack_require__(/*! ./utils */ "./node_modules/express/lib/utils.js").compileETag;
var compileQueryParser = __webpack_require__(/*! ./utils */ "./node_modules/express/lib/utils.js").compileQueryParser;
var compileTrust = __webpack_require__(/*! ./utils */ "./node_modules/express/lib/utils.js").compileTrust;
var deprecate = __webpack_require__(/*! depd */ "./node_modules/depd/index.js")('express');
var flatten = __webpack_require__(/*! array-flatten */ "./node_modules/array-flatten/array-flatten.js");
var merge = __webpack_require__(/*! utils-merge */ "./node_modules/utils-merge/index.js");
var resolve = __webpack_require__(/*! path */ "path").resolve;
var setPrototypeOf = __webpack_require__(/*! setprototypeof */ "./node_modules/setprototypeof/index.js")
var slice = Array.prototype.slice;

/**
 * Application prototype.
 */

var app = exports = module.exports = {};

/**
 * Variable for trust proxy inheritance back-compat
 * @private
 */

var trustProxyDefaultSymbol = '@@symbol:trust_proxy_default';

/**
 * Initialize the server.
 *
 *   - setup default configuration
 *   - setup default middleware
 *   - setup route reflection methods
 *
 * @private
 */

app.init = function init() {
  this.cache = {};
  this.engines = {};
  this.settings = {};

  this.defaultConfiguration();
};

/**
 * Initialize application configuration.
 * @private
 */

app.defaultConfiguration = function defaultConfiguration() {
  var env = "development" || false;

  // default settings
  this.enable('x-powered-by');
  this.set('etag', 'weak');
  this.set('env', env);
  this.set('query parser', 'extended');
  this.set('subdomain offset', 2);
  this.set('trust proxy', false);

  // trust proxy inherit back-compat
  Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
    configurable: true,
    value: true
  });

  debug('booting in %s mode', env);

  this.on('mount', function onmount(parent) {
    // inherit trust proxy
    if (this.settings[trustProxyDefaultSymbol] === true
      && typeof parent.settings['trust proxy fn'] === 'function') {
      delete this.settings['trust proxy'];
      delete this.settings['trust proxy fn'];
    }

    // inherit protos
    setPrototypeOf(this.request, parent.request)
    setPrototypeOf(this.response, parent.response)
    setPrototypeOf(this.engines, parent.engines)
    setPrototypeOf(this.settings, parent.settings)
  });

  // setup locals
  this.locals = Object.create(null);

  // top-most app is mounted at /
  this.mountpath = '/';

  // default locals
  this.locals.settings = this.settings;

  // default configuration
  this.set('view', View);
  this.set('views', resolve('views'));
  this.set('jsonp callback name', 'callback');

  if (env === 'production') {
    this.enable('view cache');
  }

  Object.defineProperty(this, 'router', {
    get: function() {
      throw new Error('\'app.router\' is deprecated!\nPlease see the 3.x to 4.x migration guide for details on how to update your app.');
    }
  });
};

/**
 * lazily adds the base router if it has not yet been added.
 *
 * We cannot add the base router in the defaultConfiguration because
 * it reads app settings which might be set after that has run.
 *
 * @private
 */
app.lazyrouter = function lazyrouter() {
  if (!this._router) {
    this._router = new Router({
      caseSensitive: this.enabled('case sensitive routing'),
      strict: this.enabled('strict routing')
    });

    this._router.use(query(this.get('query parser fn')));
    this._router.use(middleware.init(this));
  }
};

/**
 * Dispatch a req, res pair into the application. Starts pipeline processing.
 *
 * If no callback is provided, then default error handlers will respond
 * in the event of an error bubbling through the stack.
 *
 * @private
 */

app.handle = function handle(req, res, callback) {
  var router = this._router;

  // final handler
  var done = callback || finalhandler(req, res, {
    env: this.get('env'),
    onerror: logerror.bind(this)
  });

  // no routes
  if (!router) {
    debug('no routes defined on app');
    done();
    return;
  }

  router.handle(req, res, done);
};

/**
 * Proxy `Router#use()` to add middleware to the app router.
 * See Router#use() documentation for details.
 *
 * If the _fn_ parameter is an express app, then it will be
 * mounted at the _route_ specified.
 *
 * @public
 */

app.use = function use(fn) {
  var offset = 0;
  var path = '/';

  // default path to '/'
  // disambiguate app.use([fn])
  if (typeof fn !== 'function') {
    var arg = fn;

    while (Array.isArray(arg) && arg.length !== 0) {
      arg = arg[0];
    }

    // first arg is the path
    if (typeof arg !== 'function') {
      offset = 1;
      path = fn;
    }
  }

  var fns = flatten(slice.call(arguments, offset));

  if (fns.length === 0) {
    throw new TypeError('app.use() requires a middleware function')
  }

  // setup router
  this.lazyrouter();
  var router = this._router;

  fns.forEach(function (fn) {
    // non-express app
    if (!fn || !fn.handle || !fn.set) {
      return router.use(path, fn);
    }

    debug('.use app under %s', path);
    fn.mountpath = path;
    fn.parent = this;

    // restore .app property on req and res
    router.use(path, function mounted_app(req, res, next) {
      var orig = req.app;
      fn.handle(req, res, function (err) {
        setPrototypeOf(req, orig.request)
        setPrototypeOf(res, orig.response)
        next(err);
      });
    });

    // mounted an app
    fn.emit('mount', this);
  }, this);

  return this;
};

/**
 * Proxy to the app `Router#route()`
 * Returns a new `Route` instance for the _path_.
 *
 * Routes are isolated middleware stacks for specific paths.
 * See the Route api docs for details.
 *
 * @public
 */

app.route = function route(path) {
  this.lazyrouter();
  return this._router.route(path);
};

/**
 * Register the given template engine callback `fn`
 * as `ext`.
 *
 * By default will `require()` the engine based on the
 * file extension. For example if you try to render
 * a "foo.ejs" file Express will invoke the following internally:
 *
 *     app.engine('ejs', require('ejs').__express);
 *
 * For engines that do not provide `.__express` out of the box,
 * or if you wish to "map" a different extension to the template engine
 * you may use this method. For example mapping the EJS template engine to
 * ".html" files:
 *
 *     app.engine('html', require('ejs').renderFile);
 *
 * In this case EJS provides a `.renderFile()` method with
 * the same signature that Express expects: `(path, options, callback)`,
 * though note that it aliases this method as `ejs.__express` internally
 * so if you're using ".ejs" extensions you dont need to do anything.
 *
 * Some template engines do not follow this convention, the
 * [Consolidate.js](https://github.com/tj/consolidate.js)
 * library was created to map all of node's popular template
 * engines to follow this convention, thus allowing them to
 * work seamlessly within Express.
 *
 * @param {String} ext
 * @param {Function} fn
 * @return {app} for chaining
 * @public
 */

app.engine = function engine(ext, fn) {
  if (typeof fn !== 'function') {
    throw new Error('callback function required');
  }

  // get file extension
  var extension = ext[0] !== '.'
    ? '.' + ext
    : ext;

  // store engine
  this.engines[extension] = fn;

  return this;
};

/**
 * Proxy to `Router#param()` with one added api feature. The _name_ parameter
 * can be an array of names.
 *
 * See the Router#param() docs for more details.
 *
 * @param {String|Array} name
 * @param {Function} fn
 * @return {app} for chaining
 * @public
 */

app.param = function param(name, fn) {
  this.lazyrouter();

  if (Array.isArray(name)) {
    for (var i = 0; i < name.length; i++) {
      this.param(name[i], fn);
    }

    return this;
  }

  this._router.param(name, fn);

  return this;
};

/**
 * Assign `setting` to `val`, or return `setting`'s value.
 *
 *    app.set('foo', 'bar');
 *    app.set('foo');
 *    // => "bar"
 *
 * Mounted servers inherit their parent server's settings.
 *
 * @param {String} setting
 * @param {*} [val]
 * @return {Server} for chaining
 * @public
 */

app.set = function set(setting, val) {
  if (arguments.length === 1) {
    // app.get(setting)
    return this.settings[setting];
  }

  debug('set "%s" to %o', setting, val);

  // set value
  this.settings[setting] = val;

  // trigger matched settings
  switch (setting) {
    case 'etag':
      this.set('etag fn', compileETag(val));
      break;
    case 'query parser':
      this.set('query parser fn', compileQueryParser(val));
      break;
    case 'trust proxy':
      this.set('trust proxy fn', compileTrust(val));

      // trust proxy inherit back-compat
      Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
        configurable: true,
        value: false
      });

      break;
  }

  return this;
};

/**
 * Return the app's absolute pathname
 * based on the parent(s) that have
 * mounted it.
 *
 * For example if the application was
 * mounted as "/admin", which itself
 * was mounted as "/blog" then the
 * return value would be "/blog/admin".
 *
 * @return {String}
 * @private
 */

app.path = function path() {
  return this.parent
    ? this.parent.path() + this.mountpath
    : '';
};

/**
 * Check if `setting` is enabled (truthy).
 *
 *    app.enabled('foo')
 *    // => false
 *
 *    app.enable('foo')
 *    app.enabled('foo')
 *    // => true
 *
 * @param {String} setting
 * @return {Boolean}
 * @public
 */

app.enabled = function enabled(setting) {
  return Boolean(this.set(setting));
};

/**
 * Check if `setting` is disabled.
 *
 *    app.disabled('foo')
 *    // => true
 *
 *    app.enable('foo')
 *    app.disabled('foo')
 *    // => false
 *
 * @param {String} setting
 * @return {Boolean}
 * @public
 */

app.disabled = function disabled(setting) {
  return !this.set(setting);
};

/**
 * Enable `setting`.
 *
 * @param {String} setting
 * @return {app} for chaining
 * @public
 */

app.enable = function enable(setting) {
  return this.set(setting, true);
};

/**
 * Disable `setting`.
 *
 * @param {String} setting
 * @return {app} for chaining
 * @public
 */

app.disable = function disable(setting) {
  return this.set(setting, false);
};

/**
 * Delegate `.VERB(...)` calls to `router.VERB(...)`.
 */

methods.forEach(function(method){
  app[method] = function(path){
    if (method === 'get' && arguments.length === 1) {
      // app.get(setting)
      return this.set(path);
    }

    this.lazyrouter();

    var route = this._router.route(path);
    route[method].apply(route, slice.call(arguments, 1));
    return this;
  };
});

/**
 * Special-cased "all" method, applying the given route `path`,
 * middleware, and callback to _every_ HTTP method.
 *
 * @param {String} path
 * @param {Function} ...
 * @return {app} for chaining
 * @public
 */

app.all = function all(path) {
  this.lazyrouter();

  var route = this._router.route(path);
  var args = slice.call(arguments, 1);

  for (var i = 0; i < methods.length; i++) {
    route[methods[i]].apply(route, args);
  }

  return this;
};

// del -> delete alias

app.del = deprecate.function(app.delete, 'app.del: Use app.delete instead');

/**
 * Render the given view `name` name with `options`
 * and a callback accepting an error and the
 * rendered template string.
 *
 * Example:
 *
 *    app.render('email', { name: 'Tobi' }, function(err, html){
 *      // ...
 *    })
 *
 * @param {String} name
 * @param {Object|Function} options or fn
 * @param {Function} callback
 * @public
 */

app.render = function render(name, options, callback) {
  var cache = this.cache;
  var done = callback;
  var engines = this.engines;
  var opts = options;
  var renderOptions = {};
  var view;

  // support callback function as second arg
  if (typeof options === 'function') {
    done = options;
    opts = {};
  }

  // merge app.locals
  merge(renderOptions, this.locals);

  // merge options._locals
  if (opts._locals) {
    merge(renderOptions, opts._locals);
  }

  // merge options
  merge(renderOptions, opts);

  // set .cache unless explicitly provided
  if (renderOptions.cache == null) {
    renderOptions.cache = this.enabled('view cache');
  }

  // primed cache
  if (renderOptions.cache) {
    view = cache[name];
  }

  // view
  if (!view) {
    var View = this.get('view');

    view = new View(name, {
      defaultEngine: this.get('view engine'),
      root: this.get('views'),
      engines: engines
    });

    if (!view.path) {
      var dirs = Array.isArray(view.root) && view.root.length > 1
        ? 'directories "' + view.root.slice(0, -1).join('", "') + '" or "' + view.root[view.root.length - 1] + '"'
        : 'directory "' + view.root + '"'
      var err = new Error('Failed to lookup view "' + name + '" in views ' + dirs);
      err.view = view;
      return done(err);
    }

    // prime the cache
    if (renderOptions.cache) {
      cache[name] = view;
    }
  }

  // render
  tryRender(view, renderOptions, done);
};

/**
 * Listen for connections.
 *
 * A node `http.Server` is returned, with this
 * application (which is a `Function`) as its
 * callback. If you wish to create both an HTTP
 * and HTTPS server you may do so with the "http"
 * and "https" modules as shown here:
 *
 *    var http = require('http')
 *      , https = require('https')
 *      , express = require('express')
 *      , app = express();
 *
 *    http.createServer(app).listen(80);
 *    https.createServer({ ... }, app).listen(443);
 *
 * @return {http.Server}
 * @public
 */

app.listen = function listen() {
  var server = http.createServer(this);
  return server.listen.apply(server, arguments);
};

/**
 * Log error using console.error.
 *
 * @param {Error} err
 * @private
 */

function logerror(err) {
  /* istanbul ignore next */
  if (this.get('env') !== 'test') console.error(err.stack || err.toString());
}

/**
 * Try rendering a view.
 * @private
 */

function tryRender(view, options, callback) {
  try {
    view.render(options, callback);
  } catch (err) {
    callback(err);
  }
}


/***/ }),

/***/ "./node_modules/express/lib/express.js":
/*!*********************************************!*\
  !*** ./node_modules/express/lib/express.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 */

var bodyParser = __webpack_require__(/*! body-parser */ "./node_modules/body-parser/index.js")
var EventEmitter = __webpack_require__(/*! events */ "events").EventEmitter;
var mixin = __webpack_require__(/*! merge-descriptors */ "./node_modules/merge-descriptors/index.js");
var proto = __webpack_require__(/*! ./application */ "./node_modules/express/lib/application.js");
var Route = __webpack_require__(/*! ./router/route */ "./node_modules/express/lib/router/route.js");
var Router = __webpack_require__(/*! ./router */ "./node_modules/express/lib/router/index.js");
var req = __webpack_require__(/*! ./request */ "./node_modules/express/lib/request.js");
var res = __webpack_require__(/*! ./response */ "./node_modules/express/lib/response.js");

/**
 * Expose `createApplication()`.
 */

exports = module.exports = createApplication;

/**
 * Create an express application.
 *
 * @return {Function}
 * @api public
 */

function createApplication() {
  var app = function(req, res, next) {
    app.handle(req, res, next);
  };

  mixin(app, EventEmitter.prototype, false);
  mixin(app, proto, false);

  // expose the prototype that will get set on requests
  app.request = Object.create(req, {
    app: { configurable: true, enumerable: true, writable: true, value: app }
  })

  // expose the prototype that will get set on responses
  app.response = Object.create(res, {
    app: { configurable: true, enumerable: true, writable: true, value: app }
  })

  app.init();
  return app;
}

/**
 * Expose the prototypes.
 */

exports.application = proto;
exports.request = req;
exports.response = res;

/**
 * Expose constructors.
 */

exports.Route = Route;
exports.Router = Router;

/**
 * Expose middleware
 */

exports.json = bodyParser.json
exports.query = __webpack_require__(/*! ./middleware/query */ "./node_modules/express/lib/middleware/query.js");
exports.raw = bodyParser.raw
exports.static = __webpack_require__(/*! serve-static */ "./node_modules/serve-static/index.js");
exports.text = bodyParser.text
exports.urlencoded = bodyParser.urlencoded

/**
 * Replace removed middleware with an appropriate error message.
 */

var removedMiddlewares = [
  'bodyParser',
  'compress',
  'cookieSession',
  'session',
  'logger',
  'cookieParser',
  'favicon',
  'responseTime',
  'errorHandler',
  'timeout',
  'methodOverride',
  'vhost',
  'csrf',
  'directory',
  'limit',
  'multipart',
  'staticCache'
]

removedMiddlewares.forEach(function (name) {
  Object.defineProperty(exports, name, {
    get: function () {
      throw new Error('Most middleware (like ' + name + ') is no longer bundled with Express and must be installed separately. Please see https://github.com/senchalabs/connect#middleware.');
    },
    configurable: true
  });
});


/***/ }),

/***/ "./node_modules/express/lib/middleware/init.js":
/*!*****************************************************!*\
  !*** ./node_modules/express/lib/middleware/init.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var setPrototypeOf = __webpack_require__(/*! setprototypeof */ "./node_modules/setprototypeof/index.js")

/**
 * Initialization middleware, exposing the
 * request and response to each other, as well
 * as defaulting the X-Powered-By header field.
 *
 * @param {Function} app
 * @return {Function}
 * @api private
 */

exports.init = function(app){
  return function expressInit(req, res, next){
    if (app.enabled('x-powered-by')) res.setHeader('X-Powered-By', 'Express');
    req.res = res;
    res.req = req;
    req.next = next;

    setPrototypeOf(req, app.request)
    setPrototypeOf(res, app.response)

    res.locals = res.locals || Object.create(null);

    next();
  };
};



/***/ }),

/***/ "./node_modules/express/lib/middleware/query.js":
/*!******************************************************!*\
  !*** ./node_modules/express/lib/middleware/query.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 */

var merge = __webpack_require__(/*! utils-merge */ "./node_modules/utils-merge/index.js")
var parseUrl = __webpack_require__(/*! parseurl */ "./node_modules/parseurl/index.js");
var qs = __webpack_require__(/*! qs */ "./node_modules/express/node_modules/qs/lib/index.js");

/**
 * @param {Object} options
 * @return {Function}
 * @api public
 */

module.exports = function query(options) {
  var opts = merge({}, options)
  var queryparse = qs.parse;

  if (typeof options === 'function') {
    queryparse = options;
    opts = undefined;
  }

  if (opts !== undefined && opts.allowPrototypes === undefined) {
    // back-compat for qs module
    opts.allowPrototypes = true;
  }

  return function query(req, res, next){
    if (!req.query) {
      var val = parseUrl(req).query;
      req.query = queryparse(val, opts);
    }

    next();
  };
};


/***/ }),

/***/ "./node_modules/express/lib/request.js":
/*!*********************************************!*\
  !*** ./node_modules/express/lib/request.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var accepts = __webpack_require__(/*! accepts */ "./node_modules/accepts/index.js");
var deprecate = __webpack_require__(/*! depd */ "./node_modules/depd/index.js")('express');
var isIP = __webpack_require__(/*! net */ "net").isIP;
var typeis = __webpack_require__(/*! type-is */ "./node_modules/type-is/index.js");
var http = __webpack_require__(/*! http */ "http");
var fresh = __webpack_require__(/*! fresh */ "./node_modules/fresh/index.js");
var parseRange = __webpack_require__(/*! range-parser */ "./node_modules/range-parser/index.js");
var parse = __webpack_require__(/*! parseurl */ "./node_modules/parseurl/index.js");
var proxyaddr = __webpack_require__(/*! proxy-addr */ "./node_modules/proxy-addr/index.js");

/**
 * Request prototype.
 * @public
 */

var req = Object.create(http.IncomingMessage.prototype)

/**
 * Module exports.
 * @public
 */

module.exports = req

/**
 * Return request header.
 *
 * The `Referrer` header field is special-cased,
 * both `Referrer` and `Referer` are interchangeable.
 *
 * Examples:
 *
 *     req.get('Content-Type');
 *     // => "text/plain"
 *
 *     req.get('content-type');
 *     // => "text/plain"
 *
 *     req.get('Something');
 *     // => undefined
 *
 * Aliased as `req.header()`.
 *
 * @param {String} name
 * @return {String}
 * @public
 */

req.get =
req.header = function header(name) {
  if (!name) {
    throw new TypeError('name argument is required to req.get');
  }

  if (typeof name !== 'string') {
    throw new TypeError('name must be a string to req.get');
  }

  var lc = name.toLowerCase();

  switch (lc) {
    case 'referer':
    case 'referrer':
      return this.headers.referrer
        || this.headers.referer;
    default:
      return this.headers[lc];
  }
};

/**
 * To do: update docs.
 *
 * Check if the given `type(s)` is acceptable, returning
 * the best match when true, otherwise `undefined`, in which
 * case you should respond with 406 "Not Acceptable".
 *
 * The `type` value may be a single MIME type string
 * such as "application/json", an extension name
 * such as "json", a comma-delimited list such as "json, html, text/plain",
 * an argument list such as `"json", "html", "text/plain"`,
 * or an array `["json", "html", "text/plain"]`. When a list
 * or array is given, the _best_ match, if any is returned.
 *
 * Examples:
 *
 *     // Accept: text/html
 *     req.accepts('html');
 *     // => "html"
 *
 *     // Accept: text/*, application/json
 *     req.accepts('html');
 *     // => "html"
 *     req.accepts('text/html');
 *     // => "text/html"
 *     req.accepts('json, text');
 *     // => "json"
 *     req.accepts('application/json');
 *     // => "application/json"
 *
 *     // Accept: text/*, application/json
 *     req.accepts('image/png');
 *     req.accepts('png');
 *     // => undefined
 *
 *     // Accept: text/*;q=.5, application/json
 *     req.accepts(['html', 'json']);
 *     req.accepts('html', 'json');
 *     req.accepts('html, json');
 *     // => "json"
 *
 * @param {String|Array} type(s)
 * @return {String|Array|Boolean}
 * @public
 */

req.accepts = function(){
  var accept = accepts(this);
  return accept.types.apply(accept, arguments);
};

/**
 * Check if the given `encoding`s are accepted.
 *
 * @param {String} ...encoding
 * @return {String|Array}
 * @public
 */

req.acceptsEncodings = function(){
  var accept = accepts(this);
  return accept.encodings.apply(accept, arguments);
};

req.acceptsEncoding = deprecate.function(req.acceptsEncodings,
  'req.acceptsEncoding: Use acceptsEncodings instead');

/**
 * Check if the given `charset`s are acceptable,
 * otherwise you should respond with 406 "Not Acceptable".
 *
 * @param {String} ...charset
 * @return {String|Array}
 * @public
 */

req.acceptsCharsets = function(){
  var accept = accepts(this);
  return accept.charsets.apply(accept, arguments);
};

req.acceptsCharset = deprecate.function(req.acceptsCharsets,
  'req.acceptsCharset: Use acceptsCharsets instead');

/**
 * Check if the given `lang`s are acceptable,
 * otherwise you should respond with 406 "Not Acceptable".
 *
 * @param {String} ...lang
 * @return {String|Array}
 * @public
 */

req.acceptsLanguages = function(){
  var accept = accepts(this);
  return accept.languages.apply(accept, arguments);
};

req.acceptsLanguage = deprecate.function(req.acceptsLanguages,
  'req.acceptsLanguage: Use acceptsLanguages instead');

/**
 * Parse Range header field, capping to the given `size`.
 *
 * Unspecified ranges such as "0-" require knowledge of your resource length. In
 * the case of a byte range this is of course the total number of bytes. If the
 * Range header field is not given `undefined` is returned, `-1` when unsatisfiable,
 * and `-2` when syntactically invalid.
 *
 * When ranges are returned, the array has a "type" property which is the type of
 * range that is required (most commonly, "bytes"). Each array element is an object
 * with a "start" and "end" property for the portion of the range.
 *
 * The "combine" option can be set to `true` and overlapping & adjacent ranges
 * will be combined into a single range.
 *
 * NOTE: remember that ranges are inclusive, so for example "Range: users=0-3"
 * should respond with 4 users when available, not 3.
 *
 * @param {number} size
 * @param {object} [options]
 * @param {boolean} [options.combine=false]
 * @return {number|array}
 * @public
 */

req.range = function range(size, options) {
  var range = this.get('Range');
  if (!range) return;
  return parseRange(size, range, options);
};

/**
 * Return the value of param `name` when present or `defaultValue`.
 *
 *  - Checks route placeholders, ex: _/user/:id_
 *  - Checks body params, ex: id=12, {"id":12}
 *  - Checks query string params, ex: ?id=12
 *
 * To utilize request bodies, `req.body`
 * should be an object. This can be done by using
 * the `bodyParser()` middleware.
 *
 * @param {String} name
 * @param {Mixed} [defaultValue]
 * @return {String}
 * @public
 */

req.param = function param(name, defaultValue) {
  var params = this.params || {};
  var body = this.body || {};
  var query = this.query || {};

  var args = arguments.length === 1
    ? 'name'
    : 'name, default';
  deprecate('req.param(' + args + '): Use req.params, req.body, or req.query instead');

  if (null != params[name] && params.hasOwnProperty(name)) return params[name];
  if (null != body[name]) return body[name];
  if (null != query[name]) return query[name];

  return defaultValue;
};

/**
 * Check if the incoming request contains the "Content-Type"
 * header field, and it contains the give mime `type`.
 *
 * Examples:
 *
 *      // With Content-Type: text/html; charset=utf-8
 *      req.is('html');
 *      req.is('text/html');
 *      req.is('text/*');
 *      // => true
 *
 *      // When Content-Type is application/json
 *      req.is('json');
 *      req.is('application/json');
 *      req.is('application/*');
 *      // => true
 *
 *      req.is('html');
 *      // => false
 *
 * @param {String|Array} types...
 * @return {String|false|null}
 * @public
 */

req.is = function is(types) {
  var arr = types;

  // support flattened arguments
  if (!Array.isArray(types)) {
    arr = new Array(arguments.length);
    for (var i = 0; i < arr.length; i++) {
      arr[i] = arguments[i];
    }
  }

  return typeis(this, arr);
};

/**
 * Return the protocol string "http" or "https"
 * when requested with TLS. When the "trust proxy"
 * setting trusts the socket address, the
 * "X-Forwarded-Proto" header field will be trusted
 * and used if present.
 *
 * If you're running behind a reverse proxy that
 * supplies https for you this may be enabled.
 *
 * @return {String}
 * @public
 */

defineGetter(req, 'protocol', function protocol(){
  var proto = this.connection.encrypted
    ? 'https'
    : 'http';
  var trust = this.app.get('trust proxy fn');

  if (!trust(this.connection.remoteAddress, 0)) {
    return proto;
  }

  // Note: X-Forwarded-Proto is normally only ever a
  //       single value, but this is to be safe.
  var header = this.get('X-Forwarded-Proto') || proto
  var index = header.indexOf(',')

  return index !== -1
    ? header.substring(0, index).trim()
    : header.trim()
});

/**
 * Short-hand for:
 *
 *    req.protocol === 'https'
 *
 * @return {Boolean}
 * @public
 */

defineGetter(req, 'secure', function secure(){
  return this.protocol === 'https';
});

/**
 * Return the remote address from the trusted proxy.
 *
 * The is the remote address on the socket unless
 * "trust proxy" is set.
 *
 * @return {String}
 * @public
 */

defineGetter(req, 'ip', function ip(){
  var trust = this.app.get('trust proxy fn');
  return proxyaddr(this, trust);
});

/**
 * When "trust proxy" is set, trusted proxy addresses + client.
 *
 * For example if the value were "client, proxy1, proxy2"
 * you would receive the array `["client", "proxy1", "proxy2"]`
 * where "proxy2" is the furthest down-stream and "proxy1" and
 * "proxy2" were trusted.
 *
 * @return {Array}
 * @public
 */

defineGetter(req, 'ips', function ips() {
  var trust = this.app.get('trust proxy fn');
  var addrs = proxyaddr.all(this, trust);

  // reverse the order (to farthest -> closest)
  // and remove socket address
  addrs.reverse().pop()

  return addrs
});

/**
 * Return subdomains as an array.
 *
 * Subdomains are the dot-separated parts of the host before the main domain of
 * the app. By default, the domain of the app is assumed to be the last two
 * parts of the host. This can be changed by setting "subdomain offset".
 *
 * For example, if the domain is "tobi.ferrets.example.com":
 * If "subdomain offset" is not set, req.subdomains is `["ferrets", "tobi"]`.
 * If "subdomain offset" is 3, req.subdomains is `["tobi"]`.
 *
 * @return {Array}
 * @public
 */

defineGetter(req, 'subdomains', function subdomains() {
  var hostname = this.hostname;

  if (!hostname) return [];

  var offset = this.app.get('subdomain offset');
  var subdomains = !isIP(hostname)
    ? hostname.split('.').reverse()
    : [hostname];

  return subdomains.slice(offset);
});

/**
 * Short-hand for `url.parse(req.url).pathname`.
 *
 * @return {String}
 * @public
 */

defineGetter(req, 'path', function path() {
  return parse(this).pathname;
});

/**
 * Parse the "Host" header field to a hostname.
 *
 * When the "trust proxy" setting trusts the socket
 * address, the "X-Forwarded-Host" header field will
 * be trusted.
 *
 * @return {String}
 * @public
 */

defineGetter(req, 'hostname', function hostname(){
  var trust = this.app.get('trust proxy fn');
  var host = this.get('X-Forwarded-Host');

  if (!host || !trust(this.connection.remoteAddress, 0)) {
    host = this.get('Host');
  } else if (host.indexOf(',') !== -1) {
    // Note: X-Forwarded-Host is normally only ever a
    //       single value, but this is to be safe.
    host = host.substring(0, host.indexOf(',')).trimRight()
  }

  if (!host) return;

  // IPv6 literal support
  var offset = host[0] === '['
    ? host.indexOf(']') + 1
    : 0;
  var index = host.indexOf(':', offset);

  return index !== -1
    ? host.substring(0, index)
    : host;
});

// TODO: change req.host to return host in next major

defineGetter(req, 'host', deprecate.function(function host(){
  return this.hostname;
}, 'req.host: Use req.hostname instead'));

/**
 * Check if the request is fresh, aka
 * Last-Modified and/or the ETag
 * still match.
 *
 * @return {Boolean}
 * @public
 */

defineGetter(req, 'fresh', function(){
  var method = this.method;
  var res = this.res
  var status = res.statusCode

  // GET or HEAD for weak freshness validation only
  if ('GET' !== method && 'HEAD' !== method) return false;

  // 2xx or 304 as per rfc2616 14.26
  if ((status >= 200 && status < 300) || 304 === status) {
    return fresh(this.headers, {
      'etag': res.get('ETag'),
      'last-modified': res.get('Last-Modified')
    })
  }

  return false;
});

/**
 * Check if the request is stale, aka
 * "Last-Modified" and / or the "ETag" for the
 * resource has changed.
 *
 * @return {Boolean}
 * @public
 */

defineGetter(req, 'stale', function stale(){
  return !this.fresh;
});

/**
 * Check if the request was an _XMLHttpRequest_.
 *
 * @return {Boolean}
 * @public
 */

defineGetter(req, 'xhr', function xhr(){
  var val = this.get('X-Requested-With') || '';
  return val.toLowerCase() === 'xmlhttprequest';
});

/**
 * Helper function for creating a getter on an object.
 *
 * @param {Object} obj
 * @param {String} name
 * @param {Function} getter
 * @private
 */
function defineGetter(obj, name, getter) {
  Object.defineProperty(obj, name, {
    configurable: true,
    enumerable: true,
    get: getter
  });
}


/***/ }),

/***/ "./node_modules/express/lib/response.js":
/*!**********************************************!*\
  !*** ./node_modules/express/lib/response.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer
var contentDisposition = __webpack_require__(/*! content-disposition */ "./node_modules/content-disposition/index.js");
var deprecate = __webpack_require__(/*! depd */ "./node_modules/depd/index.js")('express');
var encodeUrl = __webpack_require__(/*! encodeurl */ "./node_modules/encodeurl/index.js");
var escapeHtml = __webpack_require__(/*! escape-html */ "./node_modules/escape-html/index.js");
var http = __webpack_require__(/*! http */ "http");
var isAbsolute = __webpack_require__(/*! ./utils */ "./node_modules/express/lib/utils.js").isAbsolute;
var onFinished = __webpack_require__(/*! on-finished */ "./node_modules/on-finished/index.js");
var path = __webpack_require__(/*! path */ "path");
var statuses = __webpack_require__(/*! statuses */ "./node_modules/statuses/index.js")
var merge = __webpack_require__(/*! utils-merge */ "./node_modules/utils-merge/index.js");
var sign = __webpack_require__(/*! cookie-signature */ "./node_modules/cookie-signature/index.js").sign;
var normalizeType = __webpack_require__(/*! ./utils */ "./node_modules/express/lib/utils.js").normalizeType;
var normalizeTypes = __webpack_require__(/*! ./utils */ "./node_modules/express/lib/utils.js").normalizeTypes;
var setCharset = __webpack_require__(/*! ./utils */ "./node_modules/express/lib/utils.js").setCharset;
var cookie = __webpack_require__(/*! cookie */ "./node_modules/cookie/index.js");
var send = __webpack_require__(/*! send */ "./node_modules/send/index.js");
var extname = path.extname;
var mime = send.mime;
var resolve = path.resolve;
var vary = __webpack_require__(/*! vary */ "./node_modules/vary/index.js");

/**
 * Response prototype.
 * @public
 */

var res = Object.create(http.ServerResponse.prototype)

/**
 * Module exports.
 * @public
 */

module.exports = res

/**
 * Module variables.
 * @private
 */

var charsetRegExp = /;\s*charset\s*=/;

/**
 * Set status `code`.
 *
 * @param {Number} code
 * @return {ServerResponse}
 * @public
 */

res.status = function status(code) {
  this.statusCode = code;
  return this;
};

/**
 * Set Link header field with the given `links`.
 *
 * Examples:
 *
 *    res.links({
 *      next: 'http://api.example.com/users?page=2',
 *      last: 'http://api.example.com/users?page=5'
 *    });
 *
 * @param {Object} links
 * @return {ServerResponse}
 * @public
 */

res.links = function(links){
  var link = this.get('Link') || '';
  if (link) link += ', ';
  return this.set('Link', link + Object.keys(links).map(function(rel){
    return '<' + links[rel] + '>; rel="' + rel + '"';
  }).join(', '));
};

/**
 * Send a response.
 *
 * Examples:
 *
 *     res.send(Buffer.from('wahoo'));
 *     res.send({ some: 'json' });
 *     res.send('<p>some html</p>');
 *
 * @param {string|number|boolean|object|Buffer} body
 * @public
 */

res.send = function send(body) {
  var chunk = body;
  var encoding;
  var req = this.req;
  var type;

  // settings
  var app = this.app;

  // allow status / body
  if (arguments.length === 2) {
    // res.send(body, status) backwards compat
    if (typeof arguments[0] !== 'number' && typeof arguments[1] === 'number') {
      deprecate('res.send(body, status): Use res.status(status).send(body) instead');
      this.statusCode = arguments[1];
    } else {
      deprecate('res.send(status, body): Use res.status(status).send(body) instead');
      this.statusCode = arguments[0];
      chunk = arguments[1];
    }
  }

  // disambiguate res.send(status) and res.send(status, num)
  if (typeof chunk === 'number' && arguments.length === 1) {
    // res.send(status) will set status message as text string
    if (!this.get('Content-Type')) {
      this.type('txt');
    }

    deprecate('res.send(status): Use res.sendStatus(status) instead');
    this.statusCode = chunk;
    chunk = statuses[chunk]
  }

  switch (typeof chunk) {
    // string defaulting to html
    case 'string':
      if (!this.get('Content-Type')) {
        this.type('html');
      }
      break;
    case 'boolean':
    case 'number':
    case 'object':
      if (chunk === null) {
        chunk = '';
      } else if (Buffer.isBuffer(chunk)) {
        if (!this.get('Content-Type')) {
          this.type('bin');
        }
      } else {
        return this.json(chunk);
      }
      break;
  }

  // write strings in utf-8
  if (typeof chunk === 'string') {
    encoding = 'utf8';
    type = this.get('Content-Type');

    // reflect this in content-type
    if (typeof type === 'string') {
      this.set('Content-Type', setCharset(type, 'utf-8'));
    }
  }

  // determine if ETag should be generated
  var etagFn = app.get('etag fn')
  var generateETag = !this.get('ETag') && typeof etagFn === 'function'

  // populate Content-Length
  var len
  if (chunk !== undefined) {
    if (Buffer.isBuffer(chunk)) {
      // get length of Buffer
      len = chunk.length
    } else if (!generateETag && chunk.length < 1000) {
      // just calculate length when no ETag + small chunk
      len = Buffer.byteLength(chunk, encoding)
    } else {
      // convert chunk to Buffer and calculate
      chunk = Buffer.from(chunk, encoding)
      encoding = undefined;
      len = chunk.length
    }

    this.set('Content-Length', len);
  }

  // populate ETag
  var etag;
  if (generateETag && len !== undefined) {
    if ((etag = etagFn(chunk, encoding))) {
      this.set('ETag', etag);
    }
  }

  // freshness
  if (req.fresh) this.statusCode = 304;

  // strip irrelevant headers
  if (204 === this.statusCode || 304 === this.statusCode) {
    this.removeHeader('Content-Type');
    this.removeHeader('Content-Length');
    this.removeHeader('Transfer-Encoding');
    chunk = '';
  }

  if (req.method === 'HEAD') {
    // skip body for HEAD
    this.end();
  } else {
    // respond
    this.end(chunk, encoding);
  }

  return this;
};

/**
 * Send JSON response.
 *
 * Examples:
 *
 *     res.json(null);
 *     res.json({ user: 'tj' });
 *
 * @param {string|number|boolean|object} obj
 * @public
 */

res.json = function json(obj) {
  var val = obj;

  // allow status / body
  if (arguments.length === 2) {
    // res.json(body, status) backwards compat
    if (typeof arguments[1] === 'number') {
      deprecate('res.json(obj, status): Use res.status(status).json(obj) instead');
      this.statusCode = arguments[1];
    } else {
      deprecate('res.json(status, obj): Use res.status(status).json(obj) instead');
      this.statusCode = arguments[0];
      val = arguments[1];
    }
  }

  // settings
  var app = this.app;
  var escape = app.get('json escape')
  var replacer = app.get('json replacer');
  var spaces = app.get('json spaces');
  var body = stringify(val, replacer, spaces, escape)

  // content-type
  if (!this.get('Content-Type')) {
    this.set('Content-Type', 'application/json');
  }

  return this.send(body);
};

/**
 * Send JSON response with JSONP callback support.
 *
 * Examples:
 *
 *     res.jsonp(null);
 *     res.jsonp({ user: 'tj' });
 *
 * @param {string|number|boolean|object} obj
 * @public
 */

res.jsonp = function jsonp(obj) {
  var val = obj;

  // allow status / body
  if (arguments.length === 2) {
    // res.json(body, status) backwards compat
    if (typeof arguments[1] === 'number') {
      deprecate('res.jsonp(obj, status): Use res.status(status).json(obj) instead');
      this.statusCode = arguments[1];
    } else {
      deprecate('res.jsonp(status, obj): Use res.status(status).jsonp(obj) instead');
      this.statusCode = arguments[0];
      val = arguments[1];
    }
  }

  // settings
  var app = this.app;
  var escape = app.get('json escape')
  var replacer = app.get('json replacer');
  var spaces = app.get('json spaces');
  var body = stringify(val, replacer, spaces, escape)
  var callback = this.req.query[app.get('jsonp callback name')];

  // content-type
  if (!this.get('Content-Type')) {
    this.set('X-Content-Type-Options', 'nosniff');
    this.set('Content-Type', 'application/json');
  }

  // fixup callback
  if (Array.isArray(callback)) {
    callback = callback[0];
  }

  // jsonp
  if (typeof callback === 'string' && callback.length !== 0) {
    this.set('X-Content-Type-Options', 'nosniff');
    this.set('Content-Type', 'text/javascript');

    // restrict callback charset
    callback = callback.replace(/[^\[\]\w$.]/g, '');

    // replace chars not allowed in JavaScript that are in JSON
    body = body
      .replace(/\u2028/g, '\\u2028')
      .replace(/\u2029/g, '\\u2029');

    // the /**/ is a specific security mitigation for "Rosetta Flash JSONP abuse"
    // the typeof check is just to reduce client error noise
    body = '/**/ typeof ' + callback + ' === \'function\' && ' + callback + '(' + body + ');';
  }

  return this.send(body);
};

/**
 * Send given HTTP status code.
 *
 * Sets the response status to `statusCode` and the body of the
 * response to the standard description from node's http.STATUS_CODES
 * or the statusCode number if no description.
 *
 * Examples:
 *
 *     res.sendStatus(200);
 *
 * @param {number} statusCode
 * @public
 */

res.sendStatus = function sendStatus(statusCode) {
  var body = statuses[statusCode] || String(statusCode)

  this.statusCode = statusCode;
  this.type('txt');

  return this.send(body);
};

/**
 * Transfer the file at the given `path`.
 *
 * Automatically sets the _Content-Type_ response header field.
 * The callback `callback(err)` is invoked when the transfer is complete
 * or when an error occurs. Be sure to check `res.sentHeader`
 * if you wish to attempt responding, as the header and some data
 * may have already been transferred.
 *
 * Options:
 *
 *   - `maxAge`   defaulting to 0 (can be string converted by `ms`)
 *   - `root`     root directory for relative filenames
 *   - `headers`  object of headers to serve with file
 *   - `dotfiles` serve dotfiles, defaulting to false; can be `"allow"` to send them
 *
 * Other options are passed along to `send`.
 *
 * Examples:
 *
 *  The following example illustrates how `res.sendFile()` may
 *  be used as an alternative for the `static()` middleware for
 *  dynamic situations. The code backing `res.sendFile()` is actually
 *  the same code, so HTTP cache support etc is identical.
 *
 *     app.get('/user/:uid/photos/:file', function(req, res){
 *       var uid = req.params.uid
 *         , file = req.params.file;
 *
 *       req.user.mayViewFilesFrom(uid, function(yes){
 *         if (yes) {
 *           res.sendFile('/uploads/' + uid + '/' + file);
 *         } else {
 *           res.send(403, 'Sorry! you cant see that.');
 *         }
 *       });
 *     });
 *
 * @public
 */

res.sendFile = function sendFile(path, options, callback) {
  var done = callback;
  var req = this.req;
  var res = this;
  var next = req.next;
  var opts = options || {};

  if (!path) {
    throw new TypeError('path argument is required to res.sendFile');
  }

  if (typeof path !== 'string') {
    throw new TypeError('path must be a string to res.sendFile')
  }

  // support function as second arg
  if (typeof options === 'function') {
    done = options;
    opts = {};
  }

  if (!opts.root && !isAbsolute(path)) {
    throw new TypeError('path must be absolute or specify root to res.sendFile');
  }

  // create file stream
  var pathname = encodeURI(path);
  var file = send(req, pathname, opts);

  // transfer
  sendfile(res, file, opts, function (err) {
    if (done) return done(err);
    if (err && err.code === 'EISDIR') return next();

    // next() all but write errors
    if (err && err.code !== 'ECONNABORTED' && err.syscall !== 'write') {
      next(err);
    }
  });
};

/**
 * Transfer the file at the given `path`.
 *
 * Automatically sets the _Content-Type_ response header field.
 * The callback `callback(err)` is invoked when the transfer is complete
 * or when an error occurs. Be sure to check `res.sentHeader`
 * if you wish to attempt responding, as the header and some data
 * may have already been transferred.
 *
 * Options:
 *
 *   - `maxAge`   defaulting to 0 (can be string converted by `ms`)
 *   - `root`     root directory for relative filenames
 *   - `headers`  object of headers to serve with file
 *   - `dotfiles` serve dotfiles, defaulting to false; can be `"allow"` to send them
 *
 * Other options are passed along to `send`.
 *
 * Examples:
 *
 *  The following example illustrates how `res.sendfile()` may
 *  be used as an alternative for the `static()` middleware for
 *  dynamic situations. The code backing `res.sendfile()` is actually
 *  the same code, so HTTP cache support etc is identical.
 *
 *     app.get('/user/:uid/photos/:file', function(req, res){
 *       var uid = req.params.uid
 *         , file = req.params.file;
 *
 *       req.user.mayViewFilesFrom(uid, function(yes){
 *         if (yes) {
 *           res.sendfile('/uploads/' + uid + '/' + file);
 *         } else {
 *           res.send(403, 'Sorry! you cant see that.');
 *         }
 *       });
 *     });
 *
 * @public
 */

res.sendfile = function (path, options, callback) {
  var done = callback;
  var req = this.req;
  var res = this;
  var next = req.next;
  var opts = options || {};

  // support function as second arg
  if (typeof options === 'function') {
    done = options;
    opts = {};
  }

  // create file stream
  var file = send(req, path, opts);

  // transfer
  sendfile(res, file, opts, function (err) {
    if (done) return done(err);
    if (err && err.code === 'EISDIR') return next();

    // next() all but write errors
    if (err && err.code !== 'ECONNABORTED' && err.syscall !== 'write') {
      next(err);
    }
  });
};

res.sendfile = deprecate.function(res.sendfile,
  'res.sendfile: Use res.sendFile instead');

/**
 * Transfer the file at the given `path` as an attachment.
 *
 * Optionally providing an alternate attachment `filename`,
 * and optional callback `callback(err)`. The callback is invoked
 * when the data transfer is complete, or when an error has
 * ocurred. Be sure to check `res.headersSent` if you plan to respond.
 *
 * Optionally providing an `options` object to use with `res.sendFile()`.
 * This function will set the `Content-Disposition` header, overriding
 * any `Content-Disposition` header passed as header options in order
 * to set the attachment and filename.
 *
 * This method uses `res.sendFile()`.
 *
 * @public
 */

res.download = function download (path, filename, options, callback) {
  var done = callback;
  var name = filename;
  var opts = options || null

  // support function as second or third arg
  if (typeof filename === 'function') {
    done = filename;
    name = null;
    opts = null
  } else if (typeof options === 'function') {
    done = options
    opts = null
  }

  // set Content-Disposition when file is sent
  var headers = {
    'Content-Disposition': contentDisposition(name || path)
  };

  // merge user-provided headers
  if (opts && opts.headers) {
    var keys = Object.keys(opts.headers)
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i]
      if (key.toLowerCase() !== 'content-disposition') {
        headers[key] = opts.headers[key]
      }
    }
  }

  // merge user-provided options
  opts = Object.create(opts)
  opts.headers = headers

  // Resolve the full path for sendFile
  var fullPath = resolve(path);

  // send file
  return this.sendFile(fullPath, opts, done)
};

/**
 * Set _Content-Type_ response header with `type` through `mime.lookup()`
 * when it does not contain "/", or set the Content-Type to `type` otherwise.
 *
 * Examples:
 *
 *     res.type('.html');
 *     res.type('html');
 *     res.type('json');
 *     res.type('application/json');
 *     res.type('png');
 *
 * @param {String} type
 * @return {ServerResponse} for chaining
 * @public
 */

res.contentType =
res.type = function contentType(type) {
  var ct = type.indexOf('/') === -1
    ? mime.lookup(type)
    : type;

  return this.set('Content-Type', ct);
};

/**
 * Respond to the Acceptable formats using an `obj`
 * of mime-type callbacks.
 *
 * This method uses `req.accepted`, an array of
 * acceptable types ordered by their quality values.
 * When "Accept" is not present the _first_ callback
 * is invoked, otherwise the first match is used. When
 * no match is performed the server responds with
 * 406 "Not Acceptable".
 *
 * Content-Type is set for you, however if you choose
 * you may alter this within the callback using `res.type()`
 * or `res.set('Content-Type', ...)`.
 *
 *    res.format({
 *      'text/plain': function(){
 *        res.send('hey');
 *      },
 *
 *      'text/html': function(){
 *        res.send('<p>hey</p>');
 *      },
 *
 *      'appliation/json': function(){
 *        res.send({ message: 'hey' });
 *      }
 *    });
 *
 * In addition to canonicalized MIME types you may
 * also use extnames mapped to these types:
 *
 *    res.format({
 *      text: function(){
 *        res.send('hey');
 *      },
 *
 *      html: function(){
 *        res.send('<p>hey</p>');
 *      },
 *
 *      json: function(){
 *        res.send({ message: 'hey' });
 *      }
 *    });
 *
 * By default Express passes an `Error`
 * with a `.status` of 406 to `next(err)`
 * if a match is not made. If you provide
 * a `.default` callback it will be invoked
 * instead.
 *
 * @param {Object} obj
 * @return {ServerResponse} for chaining
 * @public
 */

res.format = function(obj){
  var req = this.req;
  var next = req.next;

  var fn = obj.default;
  if (fn) delete obj.default;
  var keys = Object.keys(obj);

  var key = keys.length > 0
    ? req.accepts(keys)
    : false;

  this.vary("Accept");

  if (key) {
    this.set('Content-Type', normalizeType(key).value);
    obj[key](req, this, next);
  } else if (fn) {
    fn();
  } else {
    var err = new Error('Not Acceptable');
    err.status = err.statusCode = 406;
    err.types = normalizeTypes(keys).map(function(o){ return o.value });
    next(err);
  }

  return this;
};

/**
 * Set _Content-Disposition_ header to _attachment_ with optional `filename`.
 *
 * @param {String} filename
 * @return {ServerResponse}
 * @public
 */

res.attachment = function attachment(filename) {
  if (filename) {
    this.type(extname(filename));
  }

  this.set('Content-Disposition', contentDisposition(filename));

  return this;
};

/**
 * Append additional header `field` with value `val`.
 *
 * Example:
 *
 *    res.append('Link', ['<http://localhost/>', '<http://localhost:3000/>']);
 *    res.append('Set-Cookie', 'foo=bar; Path=/; HttpOnly');
 *    res.append('Warning', '199 Miscellaneous warning');
 *
 * @param {String} field
 * @param {String|Array} val
 * @return {ServerResponse} for chaining
 * @public
 */

res.append = function append(field, val) {
  var prev = this.get(field);
  var value = val;

  if (prev) {
    // concat the new and prev vals
    value = Array.isArray(prev) ? prev.concat(val)
      : Array.isArray(val) ? [prev].concat(val)
      : [prev, val];
  }

  return this.set(field, value);
};

/**
 * Set header `field` to `val`, or pass
 * an object of header fields.
 *
 * Examples:
 *
 *    res.set('Foo', ['bar', 'baz']);
 *    res.set('Accept', 'application/json');
 *    res.set({ Accept: 'text/plain', 'X-API-Key': 'tobi' });
 *
 * Aliased as `res.header()`.
 *
 * @param {String|Object} field
 * @param {String|Array} val
 * @return {ServerResponse} for chaining
 * @public
 */

res.set =
res.header = function header(field, val) {
  if (arguments.length === 2) {
    var value = Array.isArray(val)
      ? val.map(String)
      : String(val);

    // add charset to content-type
    if (field.toLowerCase() === 'content-type') {
      if (Array.isArray(value)) {
        throw new TypeError('Content-Type cannot be set to an Array');
      }
      if (!charsetRegExp.test(value)) {
        var charset = mime.charsets.lookup(value.split(';')[0]);
        if (charset) value += '; charset=' + charset.toLowerCase();
      }
    }

    this.setHeader(field, value);
  } else {
    for (var key in field) {
      this.set(key, field[key]);
    }
  }
  return this;
};

/**
 * Get value for header `field`.
 *
 * @param {String} field
 * @return {String}
 * @public
 */

res.get = function(field){
  return this.getHeader(field);
};

/**
 * Clear cookie `name`.
 *
 * @param {String} name
 * @param {Object} [options]
 * @return {ServerResponse} for chaining
 * @public
 */

res.clearCookie = function clearCookie(name, options) {
  var opts = merge({ expires: new Date(1), path: '/' }, options);

  return this.cookie(name, '', opts);
};

/**
 * Set cookie `name` to `value`, with the given `options`.
 *
 * Options:
 *
 *    - `maxAge`   max-age in milliseconds, converted to `expires`
 *    - `signed`   sign the cookie
 *    - `path`     defaults to "/"
 *
 * Examples:
 *
 *    // "Remember Me" for 15 minutes
 *    res.cookie('rememberme', '1', { expires: new Date(Date.now() + 900000), httpOnly: true });
 *
 *    // same as above
 *    res.cookie('rememberme', '1', { maxAge: 900000, httpOnly: true })
 *
 * @param {String} name
 * @param {String|Object} value
 * @param {Object} [options]
 * @return {ServerResponse} for chaining
 * @public
 */

res.cookie = function (name, value, options) {
  var opts = merge({}, options);
  var secret = this.req.secret;
  var signed = opts.signed;

  if (signed && !secret) {
    throw new Error('cookieParser("secret") required for signed cookies');
  }

  var val = typeof value === 'object'
    ? 'j:' + JSON.stringify(value)
    : String(value);

  if (signed) {
    val = 's:' + sign(val, secret);
  }

  if ('maxAge' in opts) {
    opts.expires = new Date(Date.now() + opts.maxAge);
    opts.maxAge /= 1000;
  }

  if (opts.path == null) {
    opts.path = '/';
  }

  this.append('Set-Cookie', cookie.serialize(name, String(val), opts));

  return this;
};

/**
 * Set the location header to `url`.
 *
 * The given `url` can also be "back", which redirects
 * to the _Referrer_ or _Referer_ headers or "/".
 *
 * Examples:
 *
 *    res.location('/foo/bar').;
 *    res.location('http://example.com');
 *    res.location('../login');
 *
 * @param {String} url
 * @return {ServerResponse} for chaining
 * @public
 */

res.location = function location(url) {
  var loc = url;

  // "back" is an alias for the referrer
  if (url === 'back') {
    loc = this.req.get('Referrer') || '/';
  }

  // set location
  return this.set('Location', encodeUrl(loc));
};

/**
 * Redirect to the given `url` with optional response `status`
 * defaulting to 302.
 *
 * The resulting `url` is determined by `res.location()`, so
 * it will play nicely with mounted apps, relative paths,
 * `"back"` etc.
 *
 * Examples:
 *
 *    res.redirect('/foo/bar');
 *    res.redirect('http://example.com');
 *    res.redirect(301, 'http://example.com');
 *    res.redirect('../login'); // /blog/post/1 -> /blog/login
 *
 * @public
 */

res.redirect = function redirect(url) {
  var address = url;
  var body;
  var status = 302;

  // allow status / url
  if (arguments.length === 2) {
    if (typeof arguments[0] === 'number') {
      status = arguments[0];
      address = arguments[1];
    } else {
      deprecate('res.redirect(url, status): Use res.redirect(status, url) instead');
      status = arguments[1];
    }
  }

  // Set location header
  address = this.location(address).get('Location');

  // Support text/{plain,html} by default
  this.format({
    text: function(){
      body = statuses[status] + '. Redirecting to ' + address
    },

    html: function(){
      var u = escapeHtml(address);
      body = '<p>' + statuses[status] + '. Redirecting to <a href="' + u + '">' + u + '</a></p>'
    },

    default: function(){
      body = '';
    }
  });

  // Respond
  this.statusCode = status;
  this.set('Content-Length', Buffer.byteLength(body));

  if (this.req.method === 'HEAD') {
    this.end();
  } else {
    this.end(body);
  }
};

/**
 * Add `field` to Vary. If already present in the Vary set, then
 * this call is simply ignored.
 *
 * @param {Array|String} field
 * @return {ServerResponse} for chaining
 * @public
 */

res.vary = function(field){
  // checks for back-compat
  if (!field || (Array.isArray(field) && !field.length)) {
    deprecate('res.vary(): Provide a field name');
    return this;
  }

  vary(this, field);

  return this;
};

/**
 * Render `view` with the given `options` and optional callback `fn`.
 * When a callback function is given a response will _not_ be made
 * automatically, otherwise a response of _200_ and _text/html_ is given.
 *
 * Options:
 *
 *  - `cache`     boolean hinting to the engine it should cache
 *  - `filename`  filename of the view being rendered
 *
 * @public
 */

res.render = function render(view, options, callback) {
  var app = this.req.app;
  var done = callback;
  var opts = options || {};
  var req = this.req;
  var self = this;

  // support callback function as second arg
  if (typeof options === 'function') {
    done = options;
    opts = {};
  }

  // merge res.locals
  opts._locals = self.locals;

  // default callback to respond
  done = done || function (err, str) {
    if (err) return req.next(err);
    self.send(str);
  };

  // render
  app.render(view, opts, done);
};

// pipe the send file stream
function sendfile(res, file, options, callback) {
  var done = false;
  var streaming;

  // request aborted
  function onaborted() {
    if (done) return;
    done = true;

    var err = new Error('Request aborted');
    err.code = 'ECONNABORTED';
    callback(err);
  }

  // directory
  function ondirectory() {
    if (done) return;
    done = true;

    var err = new Error('EISDIR, read');
    err.code = 'EISDIR';
    callback(err);
  }

  // errors
  function onerror(err) {
    if (done) return;
    done = true;
    callback(err);
  }

  // ended
  function onend() {
    if (done) return;
    done = true;
    callback();
  }

  // file
  function onfile() {
    streaming = false;
  }

  // finished
  function onfinish(err) {
    if (err && err.code === 'ECONNRESET') return onaborted();
    if (err) return onerror(err);
    if (done) return;

    setImmediate(function () {
      if (streaming !== false && !done) {
        onaborted();
        return;
      }

      if (done) return;
      done = true;
      callback();
    });
  }

  // streaming
  function onstream() {
    streaming = true;
  }

  file.on('directory', ondirectory);
  file.on('end', onend);
  file.on('error', onerror);
  file.on('file', onfile);
  file.on('stream', onstream);
  onFinished(res, onfinish);

  if (options.headers) {
    // set headers on successful transfer
    file.on('headers', function headers(res) {
      var obj = options.headers;
      var keys = Object.keys(obj);

      for (var i = 0; i < keys.length; i++) {
        var k = keys[i];
        res.setHeader(k, obj[k]);
      }
    });
  }

  // pipe
  file.pipe(res);
}

/**
 * Stringify JSON, like JSON.stringify, but v8 optimized, with the
 * ability to escape characters that can trigger HTML sniffing.
 *
 * @param {*} value
 * @param {function} replaces
 * @param {number} spaces
 * @param {boolean} escape
 * @returns {string}
 * @private
 */

function stringify (value, replacer, spaces, escape) {
  // v8 checks arguments.length for optimizing simple call
  // https://bugs.chromium.org/p/v8/issues/detail?id=4730
  var json = replacer || spaces
    ? JSON.stringify(value, replacer, spaces)
    : JSON.stringify(value);

  if (escape) {
    json = json.replace(/[<>&]/g, function (c) {
      switch (c.charCodeAt(0)) {
        case 0x3c:
          return '\\u003c'
        case 0x3e:
          return '\\u003e'
        case 0x26:
          return '\\u0026'
        /* istanbul ignore next: unreachable default */
        default:
          return c
      }
    })
  }

  return json
}


/***/ }),

/***/ "./node_modules/express/lib/router/index.js":
/*!**************************************************!*\
  !*** ./node_modules/express/lib/router/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var Route = __webpack_require__(/*! ./route */ "./node_modules/express/lib/router/route.js");
var Layer = __webpack_require__(/*! ./layer */ "./node_modules/express/lib/router/layer.js");
var methods = __webpack_require__(/*! methods */ "./node_modules/methods/index.js");
var mixin = __webpack_require__(/*! utils-merge */ "./node_modules/utils-merge/index.js");
var debug = __webpack_require__(/*! debug */ "./node_modules/express/node_modules/debug/src/index.js")('express:router');
var deprecate = __webpack_require__(/*! depd */ "./node_modules/depd/index.js")('express');
var flatten = __webpack_require__(/*! array-flatten */ "./node_modules/array-flatten/array-flatten.js");
var parseUrl = __webpack_require__(/*! parseurl */ "./node_modules/parseurl/index.js");
var setPrototypeOf = __webpack_require__(/*! setprototypeof */ "./node_modules/setprototypeof/index.js")

/**
 * Module variables.
 * @private
 */

var objectRegExp = /^\[object (\S+)\]$/;
var slice = Array.prototype.slice;
var toString = Object.prototype.toString;

/**
 * Initialize a new `Router` with the given `options`.
 *
 * @param {Object} [options]
 * @return {Router} which is an callable function
 * @public
 */

var proto = module.exports = function(options) {
  var opts = options || {};

  function router(req, res, next) {
    router.handle(req, res, next);
  }

  // mixin Router class functions
  setPrototypeOf(router, proto)

  router.params = {};
  router._params = [];
  router.caseSensitive = opts.caseSensitive;
  router.mergeParams = opts.mergeParams;
  router.strict = opts.strict;
  router.stack = [];

  return router;
};

/**
 * Map the given param placeholder `name`(s) to the given callback.
 *
 * Parameter mapping is used to provide pre-conditions to routes
 * which use normalized placeholders. For example a _:user_id_ parameter
 * could automatically load a user's information from the database without
 * any additional code,
 *
 * The callback uses the same signature as middleware, the only difference
 * being that the value of the placeholder is passed, in this case the _id_
 * of the user. Once the `next()` function is invoked, just like middleware
 * it will continue on to execute the route, or subsequent parameter functions.
 *
 * Just like in middleware, you must either respond to the request or call next
 * to avoid stalling the request.
 *
 *  app.param('user_id', function(req, res, next, id){
 *    User.find(id, function(err, user){
 *      if (err) {
 *        return next(err);
 *      } else if (!user) {
 *        return next(new Error('failed to load user'));
 *      }
 *      req.user = user;
 *      next();
 *    });
 *  });
 *
 * @param {String} name
 * @param {Function} fn
 * @return {app} for chaining
 * @public
 */

proto.param = function param(name, fn) {
  // param logic
  if (typeof name === 'function') {
    deprecate('router.param(fn): Refactor to use path params');
    this._params.push(name);
    return;
  }

  // apply param functions
  var params = this._params;
  var len = params.length;
  var ret;

  if (name[0] === ':') {
    deprecate('router.param(' + JSON.stringify(name) + ', fn): Use router.param(' + JSON.stringify(name.substr(1)) + ', fn) instead');
    name = name.substr(1);
  }

  for (var i = 0; i < len; ++i) {
    if (ret = params[i](name, fn)) {
      fn = ret;
    }
  }

  // ensure we end up with a
  // middleware function
  if ('function' !== typeof fn) {
    throw new Error('invalid param() call for ' + name + ', got ' + fn);
  }

  (this.params[name] = this.params[name] || []).push(fn);
  return this;
};

/**
 * Dispatch a req, res into the router.
 * @private
 */

proto.handle = function handle(req, res, out) {
  var self = this;

  debug('dispatching %s %s', req.method, req.url);

  var idx = 0;
  var protohost = getProtohost(req.url) || ''
  var removed = '';
  var slashAdded = false;
  var paramcalled = {};

  // store options for OPTIONS request
  // only used if OPTIONS request
  var options = [];

  // middleware and routes
  var stack = self.stack;

  // manage inter-router variables
  var parentParams = req.params;
  var parentUrl = req.baseUrl || '';
  var done = restore(out, req, 'baseUrl', 'next', 'params');

  // setup next layer
  req.next = next;

  // for options requests, respond with a default if nothing else responds
  if (req.method === 'OPTIONS') {
    done = wrap(done, function(old, err) {
      if (err || options.length === 0) return old(err);
      sendOptionsResponse(res, options, old);
    });
  }

  // setup basic req values
  req.baseUrl = parentUrl;
  req.originalUrl = req.originalUrl || req.url;

  next();

  function next(err) {
    var layerError = err === 'route'
      ? null
      : err;

    // remove added slash
    if (slashAdded) {
      req.url = req.url.substr(1);
      slashAdded = false;
    }

    // restore altered req.url
    if (removed.length !== 0) {
      req.baseUrl = parentUrl;
      req.url = protohost + removed + req.url.substr(protohost.length);
      removed = '';
    }

    // signal to exit router
    if (layerError === 'router') {
      setImmediate(done, null)
      return
    }

    // no more matching layers
    if (idx >= stack.length) {
      setImmediate(done, layerError);
      return;
    }

    // get pathname of request
    var path = getPathname(req);

    if (path == null) {
      return done(layerError);
    }

    // find next matching layer
    var layer;
    var match;
    var route;

    while (match !== true && idx < stack.length) {
      layer = stack[idx++];
      match = matchLayer(layer, path);
      route = layer.route;

      if (typeof match !== 'boolean') {
        // hold on to layerError
        layerError = layerError || match;
      }

      if (match !== true) {
        continue;
      }

      if (!route) {
        // process non-route handlers normally
        continue;
      }

      if (layerError) {
        // routes do not match with a pending error
        match = false;
        continue;
      }

      var method = req.method;
      var has_method = route._handles_method(method);

      // build up automatic options response
      if (!has_method && method === 'OPTIONS') {
        appendMethods(options, route._options());
      }

      // don't even bother matching route
      if (!has_method && method !== 'HEAD') {
        match = false;
        continue;
      }
    }

    // no match
    if (match !== true) {
      return done(layerError);
    }

    // store route for dispatch on change
    if (route) {
      req.route = route;
    }

    // Capture one-time layer values
    req.params = self.mergeParams
      ? mergeParams(layer.params, parentParams)
      : layer.params;
    var layerPath = layer.path;

    // this should be done for the layer
    self.process_params(layer, paramcalled, req, res, function (err) {
      if (err) {
        return next(layerError || err);
      }

      if (route) {
        return layer.handle_request(req, res, next);
      }

      trim_prefix(layer, layerError, layerPath, path);
    });
  }

  function trim_prefix(layer, layerError, layerPath, path) {
    if (layerPath.length !== 0) {
      // Validate path breaks on a path separator
      var c = path[layerPath.length]
      if (c && c !== '/' && c !== '.') return next(layerError)

      // Trim off the part of the url that matches the route
      // middleware (.use stuff) needs to have the path stripped
      debug('trim prefix (%s) from url %s', layerPath, req.url);
      removed = layerPath;
      req.url = protohost + req.url.substr(protohost.length + removed.length);

      // Ensure leading slash
      if (!protohost && req.url[0] !== '/') {
        req.url = '/' + req.url;
        slashAdded = true;
      }

      // Setup base URL (no trailing slash)
      req.baseUrl = parentUrl + (removed[removed.length - 1] === '/'
        ? removed.substring(0, removed.length - 1)
        : removed);
    }

    debug('%s %s : %s', layer.name, layerPath, req.originalUrl);

    if (layerError) {
      layer.handle_error(layerError, req, res, next);
    } else {
      layer.handle_request(req, res, next);
    }
  }
};

/**
 * Process any parameters for the layer.
 * @private
 */

proto.process_params = function process_params(layer, called, req, res, done) {
  var params = this.params;

  // captured parameters from the layer, keys and values
  var keys = layer.keys;

  // fast track
  if (!keys || keys.length === 0) {
    return done();
  }

  var i = 0;
  var name;
  var paramIndex = 0;
  var key;
  var paramVal;
  var paramCallbacks;
  var paramCalled;

  // process params in order
  // param callbacks can be async
  function param(err) {
    if (err) {
      return done(err);
    }

    if (i >= keys.length ) {
      return done();
    }

    paramIndex = 0;
    key = keys[i++];
    name = key.name;
    paramVal = req.params[name];
    paramCallbacks = params[name];
    paramCalled = called[name];

    if (paramVal === undefined || !paramCallbacks) {
      return param();
    }

    // param previously called with same value or error occurred
    if (paramCalled && (paramCalled.match === paramVal
      || (paramCalled.error && paramCalled.error !== 'route'))) {
      // restore value
      req.params[name] = paramCalled.value;

      // next param
      return param(paramCalled.error);
    }

    called[name] = paramCalled = {
      error: null,
      match: paramVal,
      value: paramVal
    };

    paramCallback();
  }

  // single param callbacks
  function paramCallback(err) {
    var fn = paramCallbacks[paramIndex++];

    // store updated value
    paramCalled.value = req.params[key.name];

    if (err) {
      // store error
      paramCalled.error = err;
      param(err);
      return;
    }

    if (!fn) return param();

    try {
      fn(req, res, paramCallback, paramVal, key.name);
    } catch (e) {
      paramCallback(e);
    }
  }

  param();
};

/**
 * Use the given middleware function, with optional path, defaulting to "/".
 *
 * Use (like `.all`) will run for any http METHOD, but it will not add
 * handlers for those methods so OPTIONS requests will not consider `.use`
 * functions even if they could respond.
 *
 * The other difference is that _route_ path is stripped and not visible
 * to the handler function. The main effect of this feature is that mounted
 * handlers can operate without any code changes regardless of the "prefix"
 * pathname.
 *
 * @public
 */

proto.use = function use(fn) {
  var offset = 0;
  var path = '/';

  // default path to '/'
  // disambiguate router.use([fn])
  if (typeof fn !== 'function') {
    var arg = fn;

    while (Array.isArray(arg) && arg.length !== 0) {
      arg = arg[0];
    }

    // first arg is the path
    if (typeof arg !== 'function') {
      offset = 1;
      path = fn;
    }
  }

  var callbacks = flatten(slice.call(arguments, offset));

  if (callbacks.length === 0) {
    throw new TypeError('Router.use() requires a middleware function')
  }

  for (var i = 0; i < callbacks.length; i++) {
    var fn = callbacks[i];

    if (typeof fn !== 'function') {
      throw new TypeError('Router.use() requires a middleware function but got a ' + gettype(fn))
    }

    // add the middleware
    debug('use %o %s', path, fn.name || '<anonymous>')

    var layer = new Layer(path, {
      sensitive: this.caseSensitive,
      strict: false,
      end: false
    }, fn);

    layer.route = undefined;

    this.stack.push(layer);
  }

  return this;
};

/**
 * Create a new Route for the given path.
 *
 * Each route contains a separate middleware stack and VERB handlers.
 *
 * See the Route api documentation for details on adding handlers
 * and middleware to routes.
 *
 * @param {String} path
 * @return {Route}
 * @public
 */

proto.route = function route(path) {
  var route = new Route(path);

  var layer = new Layer(path, {
    sensitive: this.caseSensitive,
    strict: this.strict,
    end: true
  }, route.dispatch.bind(route));

  layer.route = route;

  this.stack.push(layer);
  return route;
};

// create Router#VERB functions
methods.concat('all').forEach(function(method){
  proto[method] = function(path){
    var route = this.route(path)
    route[method].apply(route, slice.call(arguments, 1));
    return this;
  };
});

// append methods to a list of methods
function appendMethods(list, addition) {
  for (var i = 0; i < addition.length; i++) {
    var method = addition[i];
    if (list.indexOf(method) === -1) {
      list.push(method);
    }
  }
}

// get pathname of request
function getPathname(req) {
  try {
    return parseUrl(req).pathname;
  } catch (err) {
    return undefined;
  }
}

// Get get protocol + host for a URL
function getProtohost(url) {
  if (typeof url !== 'string' || url.length === 0 || url[0] === '/') {
    return undefined
  }

  var searchIndex = url.indexOf('?')
  var pathLength = searchIndex !== -1
    ? searchIndex
    : url.length
  var fqdnIndex = url.substr(0, pathLength).indexOf('://')

  return fqdnIndex !== -1
    ? url.substr(0, url.indexOf('/', 3 + fqdnIndex))
    : undefined
}

// get type for error message
function gettype(obj) {
  var type = typeof obj;

  if (type !== 'object') {
    return type;
  }

  // inspect [[Class]] for objects
  return toString.call(obj)
    .replace(objectRegExp, '$1');
}

/**
 * Match path to a layer.
 *
 * @param {Layer} layer
 * @param {string} path
 * @private
 */

function matchLayer(layer, path) {
  try {
    return layer.match(path);
  } catch (err) {
    return err;
  }
}

// merge params with parent params
function mergeParams(params, parent) {
  if (typeof parent !== 'object' || !parent) {
    return params;
  }

  // make copy of parent for base
  var obj = mixin({}, parent);

  // simple non-numeric merging
  if (!(0 in params) || !(0 in parent)) {
    return mixin(obj, params);
  }

  var i = 0;
  var o = 0;

  // determine numeric gaps
  while (i in params) {
    i++;
  }

  while (o in parent) {
    o++;
  }

  // offset numeric indices in params before merge
  for (i--; i >= 0; i--) {
    params[i + o] = params[i];

    // create holes for the merge when necessary
    if (i < o) {
      delete params[i];
    }
  }

  return mixin(obj, params);
}

// restore obj props after function
function restore(fn, obj) {
  var props = new Array(arguments.length - 2);
  var vals = new Array(arguments.length - 2);

  for (var i = 0; i < props.length; i++) {
    props[i] = arguments[i + 2];
    vals[i] = obj[props[i]];
  }

  return function () {
    // restore vals
    for (var i = 0; i < props.length; i++) {
      obj[props[i]] = vals[i];
    }

    return fn.apply(this, arguments);
  };
}

// send an OPTIONS response
function sendOptionsResponse(res, options, next) {
  try {
    var body = options.join(',');
    res.set('Allow', body);
    res.send(body);
  } catch (err) {
    next(err);
  }
}

// wrap a function
function wrap(old, fn) {
  return function proxy() {
    var args = new Array(arguments.length + 1);

    args[0] = old;
    for (var i = 0, len = arguments.length; i < len; i++) {
      args[i + 1] = arguments[i];
    }

    fn.apply(this, args);
  };
}


/***/ }),

/***/ "./node_modules/express/lib/router/layer.js":
/*!**************************************************!*\
  !*** ./node_modules/express/lib/router/layer.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var pathRegexp = __webpack_require__(/*! path-to-regexp */ "./node_modules/path-to-regexp/index.js");
var debug = __webpack_require__(/*! debug */ "./node_modules/express/node_modules/debug/src/index.js")('express:router:layer');

/**
 * Module variables.
 * @private
 */

var hasOwnProperty = Object.prototype.hasOwnProperty;

/**
 * Module exports.
 * @public
 */

module.exports = Layer;

function Layer(path, options, fn) {
  if (!(this instanceof Layer)) {
    return new Layer(path, options, fn);
  }

  debug('new %o', path)
  var opts = options || {};

  this.handle = fn;
  this.name = fn.name || '<anonymous>';
  this.params = undefined;
  this.path = undefined;
  this.regexp = pathRegexp(path, this.keys = [], opts);

  // set fast path flags
  this.regexp.fast_star = path === '*'
  this.regexp.fast_slash = path === '/' && opts.end === false
}

/**
 * Handle the error for the layer.
 *
 * @param {Error} error
 * @param {Request} req
 * @param {Response} res
 * @param {function} next
 * @api private
 */

Layer.prototype.handle_error = function handle_error(error, req, res, next) {
  var fn = this.handle;

  if (fn.length !== 4) {
    // not a standard error handler
    return next(error);
  }

  try {
    fn(error, req, res, next);
  } catch (err) {
    next(err);
  }
};

/**
 * Handle the request for the layer.
 *
 * @param {Request} req
 * @param {Response} res
 * @param {function} next
 * @api private
 */

Layer.prototype.handle_request = function handle(req, res, next) {
  var fn = this.handle;

  if (fn.length > 3) {
    // not a standard request handler
    return next();
  }

  try {
    fn(req, res, next);
  } catch (err) {
    next(err);
  }
};

/**
 * Check if this route matches `path`, if so
 * populate `.params`.
 *
 * @param {String} path
 * @return {Boolean}
 * @api private
 */

Layer.prototype.match = function match(path) {
  var match

  if (path != null) {
    // fast path non-ending match for / (any path matches)
    if (this.regexp.fast_slash) {
      this.params = {}
      this.path = ''
      return true
    }

    // fast path for * (everything matched in a param)
    if (this.regexp.fast_star) {
      this.params = {'0': decode_param(path)}
      this.path = path
      return true
    }

    // match the path
    match = this.regexp.exec(path)
  }

  if (!match) {
    this.params = undefined;
    this.path = undefined;
    return false;
  }

  // store values
  this.params = {};
  this.path = match[0]

  var keys = this.keys;
  var params = this.params;

  for (var i = 1; i < match.length; i++) {
    var key = keys[i - 1];
    var prop = key.name;
    var val = decode_param(match[i])

    if (val !== undefined || !(hasOwnProperty.call(params, prop))) {
      params[prop] = val;
    }
  }

  return true;
};

/**
 * Decode param value.
 *
 * @param {string} val
 * @return {string}
 * @private
 */

function decode_param(val) {
  if (typeof val !== 'string' || val.length === 0) {
    return val;
  }

  try {
    return decodeURIComponent(val);
  } catch (err) {
    if (err instanceof URIError) {
      err.message = 'Failed to decode param \'' + val + '\'';
      err.status = err.statusCode = 400;
    }

    throw err;
  }
}


/***/ }),

/***/ "./node_modules/express/lib/router/route.js":
/*!**************************************************!*\
  !*** ./node_modules/express/lib/router/route.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var debug = __webpack_require__(/*! debug */ "./node_modules/express/node_modules/debug/src/index.js")('express:router:route');
var flatten = __webpack_require__(/*! array-flatten */ "./node_modules/array-flatten/array-flatten.js");
var Layer = __webpack_require__(/*! ./layer */ "./node_modules/express/lib/router/layer.js");
var methods = __webpack_require__(/*! methods */ "./node_modules/methods/index.js");

/**
 * Module variables.
 * @private
 */

var slice = Array.prototype.slice;
var toString = Object.prototype.toString;

/**
 * Module exports.
 * @public
 */

module.exports = Route;

/**
 * Initialize `Route` with the given `path`,
 *
 * @param {String} path
 * @public
 */

function Route(path) {
  this.path = path;
  this.stack = [];

  debug('new %o', path)

  // route handlers for various http methods
  this.methods = {};
}

/**
 * Determine if the route handles a given method.
 * @private
 */

Route.prototype._handles_method = function _handles_method(method) {
  if (this.methods._all) {
    return true;
  }

  var name = method.toLowerCase();

  if (name === 'head' && !this.methods['head']) {
    name = 'get';
  }

  return Boolean(this.methods[name]);
};

/**
 * @return {Array} supported HTTP methods
 * @private
 */

Route.prototype._options = function _options() {
  var methods = Object.keys(this.methods);

  // append automatic head
  if (this.methods.get && !this.methods.head) {
    methods.push('head');
  }

  for (var i = 0; i < methods.length; i++) {
    // make upper case
    methods[i] = methods[i].toUpperCase();
  }

  return methods;
};

/**
 * dispatch req, res into this route
 * @private
 */

Route.prototype.dispatch = function dispatch(req, res, done) {
  var idx = 0;
  var stack = this.stack;
  if (stack.length === 0) {
    return done();
  }

  var method = req.method.toLowerCase();
  if (method === 'head' && !this.methods['head']) {
    method = 'get';
  }

  req.route = this;

  next();

  function next(err) {
    // signal to exit route
    if (err && err === 'route') {
      return done();
    }

    // signal to exit router
    if (err && err === 'router') {
      return done(err)
    }

    var layer = stack[idx++];
    if (!layer) {
      return done(err);
    }

    if (layer.method && layer.method !== method) {
      return next(err);
    }

    if (err) {
      layer.handle_error(err, req, res, next);
    } else {
      layer.handle_request(req, res, next);
    }
  }
};

/**
 * Add a handler for all HTTP verbs to this route.
 *
 * Behaves just like middleware and can respond or call `next`
 * to continue processing.
 *
 * You can use multiple `.all` call to add multiple handlers.
 *
 *   function check_something(req, res, next){
 *     next();
 *   };
 *
 *   function validate_user(req, res, next){
 *     next();
 *   };
 *
 *   route
 *   .all(validate_user)
 *   .all(check_something)
 *   .get(function(req, res, next){
 *     res.send('hello world');
 *   });
 *
 * @param {function} handler
 * @return {Route} for chaining
 * @api public
 */

Route.prototype.all = function all() {
  var handles = flatten(slice.call(arguments));

  for (var i = 0; i < handles.length; i++) {
    var handle = handles[i];

    if (typeof handle !== 'function') {
      var type = toString.call(handle);
      var msg = 'Route.all() requires a callback function but got a ' + type
      throw new TypeError(msg);
    }

    var layer = Layer('/', {}, handle);
    layer.method = undefined;

    this.methods._all = true;
    this.stack.push(layer);
  }

  return this;
};

methods.forEach(function(method){
  Route.prototype[method] = function(){
    var handles = flatten(slice.call(arguments));

    for (var i = 0; i < handles.length; i++) {
      var handle = handles[i];

      if (typeof handle !== 'function') {
        var type = toString.call(handle);
        var msg = 'Route.' + method + '() requires a callback function but got a ' + type
        throw new Error(msg);
      }

      debug('%s %o', method, this.path)

      var layer = Layer('/', {}, handle);
      layer.method = method;

      this.methods[method] = true;
      this.stack.push(layer);
    }

    return this;
  };
});


/***/ }),

/***/ "./node_modules/express/lib/utils.js":
/*!*******************************************!*\
  !*** ./node_modules/express/lib/utils.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @api private
 */

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer
var contentDisposition = __webpack_require__(/*! content-disposition */ "./node_modules/content-disposition/index.js");
var contentType = __webpack_require__(/*! content-type */ "./node_modules/content-type/index.js");
var deprecate = __webpack_require__(/*! depd */ "./node_modules/depd/index.js")('express');
var flatten = __webpack_require__(/*! array-flatten */ "./node_modules/array-flatten/array-flatten.js");
var mime = __webpack_require__(/*! send */ "./node_modules/send/index.js").mime;
var etag = __webpack_require__(/*! etag */ "./node_modules/etag/index.js");
var proxyaddr = __webpack_require__(/*! proxy-addr */ "./node_modules/proxy-addr/index.js");
var qs = __webpack_require__(/*! qs */ "./node_modules/express/node_modules/qs/lib/index.js");
var querystring = __webpack_require__(/*! querystring */ "querystring");

/**
 * Return strong ETag for `body`.
 *
 * @param {String|Buffer} body
 * @param {String} [encoding]
 * @return {String}
 * @api private
 */

exports.etag = createETagGenerator({ weak: false })

/**
 * Return weak ETag for `body`.
 *
 * @param {String|Buffer} body
 * @param {String} [encoding]
 * @return {String}
 * @api private
 */

exports.wetag = createETagGenerator({ weak: true })

/**
 * Check if `path` looks absolute.
 *
 * @param {String} path
 * @return {Boolean}
 * @api private
 */

exports.isAbsolute = function(path){
  if ('/' === path[0]) return true;
  if (':' === path[1] && ('\\' === path[2] || '/' === path[2])) return true; // Windows device path
  if ('\\\\' === path.substring(0, 2)) return true; // Microsoft Azure absolute path
};

/**
 * Flatten the given `arr`.
 *
 * @param {Array} arr
 * @return {Array}
 * @api private
 */

exports.flatten = deprecate.function(flatten,
  'utils.flatten: use array-flatten npm module instead');

/**
 * Normalize the given `type`, for example "html" becomes "text/html".
 *
 * @param {String} type
 * @return {Object}
 * @api private
 */

exports.normalizeType = function(type){
  return ~type.indexOf('/')
    ? acceptParams(type)
    : { value: mime.lookup(type), params: {} };
};

/**
 * Normalize `types`, for example "html" becomes "text/html".
 *
 * @param {Array} types
 * @return {Array}
 * @api private
 */

exports.normalizeTypes = function(types){
  var ret = [];

  for (var i = 0; i < types.length; ++i) {
    ret.push(exports.normalizeType(types[i]));
  }

  return ret;
};

/**
 * Generate Content-Disposition header appropriate for the filename.
 * non-ascii filenames are urlencoded and a filename* parameter is added
 *
 * @param {String} filename
 * @return {String}
 * @api private
 */

exports.contentDisposition = deprecate.function(contentDisposition,
  'utils.contentDisposition: use content-disposition npm module instead');

/**
 * Parse accept params `str` returning an
 * object with `.value`, `.quality` and `.params`.
 * also includes `.originalIndex` for stable sorting
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function acceptParams(str, index) {
  var parts = str.split(/ *; */);
  var ret = { value: parts[0], quality: 1, params: {}, originalIndex: index };

  for (var i = 1; i < parts.length; ++i) {
    var pms = parts[i].split(/ *= */);
    if ('q' === pms[0]) {
      ret.quality = parseFloat(pms[1]);
    } else {
      ret.params[pms[0]] = pms[1];
    }
  }

  return ret;
}

/**
 * Compile "etag" value to function.
 *
 * @param  {Boolean|String|Function} val
 * @return {Function}
 * @api private
 */

exports.compileETag = function(val) {
  var fn;

  if (typeof val === 'function') {
    return val;
  }

  switch (val) {
    case true:
      fn = exports.wetag;
      break;
    case false:
      break;
    case 'strong':
      fn = exports.etag;
      break;
    case 'weak':
      fn = exports.wetag;
      break;
    default:
      throw new TypeError('unknown value for etag function: ' + val);
  }

  return fn;
}

/**
 * Compile "query parser" value to function.
 *
 * @param  {String|Function} val
 * @return {Function}
 * @api private
 */

exports.compileQueryParser = function compileQueryParser(val) {
  var fn;

  if (typeof val === 'function') {
    return val;
  }

  switch (val) {
    case true:
      fn = querystring.parse;
      break;
    case false:
      fn = newObject;
      break;
    case 'extended':
      fn = parseExtendedQueryString;
      break;
    case 'simple':
      fn = querystring.parse;
      break;
    default:
      throw new TypeError('unknown value for query parser function: ' + val);
  }

  return fn;
}

/**
 * Compile "proxy trust" value to function.
 *
 * @param  {Boolean|String|Number|Array|Function} val
 * @return {Function}
 * @api private
 */

exports.compileTrust = function(val) {
  if (typeof val === 'function') return val;

  if (val === true) {
    // Support plain true/false
    return function(){ return true };
  }

  if (typeof val === 'number') {
    // Support trusting hop count
    return function(a, i){ return i < val };
  }

  if (typeof val === 'string') {
    // Support comma-separated values
    val = val.split(/ *, */);
  }

  return proxyaddr.compile(val || []);
}

/**
 * Set the charset in a given Content-Type string.
 *
 * @param {String} type
 * @param {String} charset
 * @return {String}
 * @api private
 */

exports.setCharset = function setCharset(type, charset) {
  if (!type || !charset) {
    return type;
  }

  // parse type
  var parsed = contentType.parse(type);

  // set charset
  parsed.parameters.charset = charset;

  // format type
  return contentType.format(parsed);
};

/**
 * Create an ETag generator function, generating ETags with
 * the given options.
 *
 * @param {object} options
 * @return {function}
 * @private
 */

function createETagGenerator (options) {
  return function generateETag (body, encoding) {
    var buf = !Buffer.isBuffer(body)
      ? Buffer.from(body, encoding)
      : body

    return etag(buf, options)
  }
}

/**
 * Parse an extended query string with qs.
 *
 * @return {Object}
 * @private
 */

function parseExtendedQueryString(str) {
  return qs.parse(str, {
    allowPrototypes: true
  });
}

/**
 * Return new empty object.
 *
 * @return {Object}
 * @api private
 */

function newObject() {
  return {};
}


/***/ }),

/***/ "./node_modules/express/lib/view.js":
/*!******************************************!*\
  !*** ./node_modules/express/lib/view.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var debug = __webpack_require__(/*! debug */ "./node_modules/express/node_modules/debug/src/index.js")('express:view');
var path = __webpack_require__(/*! path */ "path");
var fs = __webpack_require__(/*! fs */ "fs");

/**
 * Module variables.
 * @private
 */

var dirname = path.dirname;
var basename = path.basename;
var extname = path.extname;
var join = path.join;
var resolve = path.resolve;

/**
 * Module exports.
 * @public
 */

module.exports = View;

/**
 * Initialize a new `View` with the given `name`.
 *
 * Options:
 *
 *   - `defaultEngine` the default template engine name
 *   - `engines` template engine require() cache
 *   - `root` root path for view lookup
 *
 * @param {string} name
 * @param {object} options
 * @public
 */

function View(name, options) {
  var opts = options || {};

  this.defaultEngine = opts.defaultEngine;
  this.ext = extname(name);
  this.name = name;
  this.root = opts.root;

  if (!this.ext && !this.defaultEngine) {
    throw new Error('No default engine was specified and no extension was provided.');
  }

  var fileName = name;

  if (!this.ext) {
    // get extension from default engine name
    this.ext = this.defaultEngine[0] !== '.'
      ? '.' + this.defaultEngine
      : this.defaultEngine;

    fileName += this.ext;
  }

  if (!opts.engines[this.ext]) {
    // load engine
    var mod = this.ext.substr(1)
    debug('require "%s"', mod)

    // default engine export
    var fn = __webpack_require__("./node_modules/express/lib sync recursive")(mod).__express

    if (typeof fn !== 'function') {
      throw new Error('Module "' + mod + '" does not provide a view engine.')
    }

    opts.engines[this.ext] = fn
  }

  // store loaded engine
  this.engine = opts.engines[this.ext];

  // lookup path
  this.path = this.lookup(fileName);
}

/**
 * Lookup view by the given `name`
 *
 * @param {string} name
 * @private
 */

View.prototype.lookup = function lookup(name) {
  var path;
  var roots = [].concat(this.root);

  debug('lookup "%s"', name);

  for (var i = 0; i < roots.length && !path; i++) {
    var root = roots[i];

    // resolve the path
    var loc = resolve(root, name);
    var dir = dirname(loc);
    var file = basename(loc);

    // resolve the file
    path = this.resolve(dir, file);
  }

  return path;
};

/**
 * Render with the given options.
 *
 * @param {object} options
 * @param {function} callback
 * @private
 */

View.prototype.render = function render(options, callback) {
  debug('render "%s"', this.path);
  this.engine(this.path, options, callback);
};

/**
 * Resolve the file within the given directory.
 *
 * @param {string} dir
 * @param {string} file
 * @private
 */

View.prototype.resolve = function resolve(dir, file) {
  var ext = this.ext;

  // <path>.<ext>
  var path = join(dir, file);
  var stat = tryStat(path);

  if (stat && stat.isFile()) {
    return path;
  }

  // <path>/index.<ext>
  path = join(dir, basename(file, ext), 'index' + ext);
  stat = tryStat(path);

  if (stat && stat.isFile()) {
    return path;
  }
};

/**
 * Return a stat, maybe.
 *
 * @param {string} path
 * @return {fs.Stats}
 * @private
 */

function tryStat(path) {
  debug('stat "%s"', path);

  try {
    return fs.statSync(path);
  } catch (e) {
    return undefined;
  }
}


/***/ }),

/***/ "./node_modules/express/node_modules/debug/src/browser.js":
/*!****************************************************************!*\
  !*** ./node_modules/express/node_modules/debug/src/browser.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __webpack_require__(/*! ./debug */ "./node_modules/express/node_modules/debug/src/debug.js");
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}


/***/ }),

/***/ "./node_modules/express/node_modules/debug/src/debug.js":
/*!**************************************************************!*\
  !*** ./node_modules/express/node_modules/debug/src/debug.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = __webpack_require__(/*! ms */ "./node_modules/ms/index.js");

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  return debug;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}


/***/ }),

/***/ "./node_modules/express/node_modules/debug/src/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/express/node_modules/debug/src/index.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Detect Electron renderer process, which is node, but we should
 * treat as a browser.
 */

if (typeof process !== 'undefined' && process.type === 'renderer') {
  module.exports = __webpack_require__(/*! ./browser.js */ "./node_modules/express/node_modules/debug/src/browser.js");
} else {
  module.exports = __webpack_require__(/*! ./node.js */ "./node_modules/express/node_modules/debug/src/node.js");
}


/***/ }),

/***/ "./node_modules/express/node_modules/debug/src/node.js":
/*!*************************************************************!*\
  !*** ./node_modules/express/node_modules/debug/src/node.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Module dependencies.
 */

var tty = __webpack_require__(/*! tty */ "tty");
var util = __webpack_require__(/*! util */ "util");

/**
 * This is the Node.js implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __webpack_require__(/*! ./debug */ "./node_modules/express/node_modules/debug/src/debug.js");
exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(function (key) {
  return /^debug_/i.test(key);
}).reduce(function (obj, key) {
  // camel-case
  var prop = key
    .substring(6)
    .toLowerCase()
    .replace(/_([a-z])/g, function (_, k) { return k.toUpperCase() });

  // coerce string value into JS value
  var val = process.env[key];
  if (/^(yes|on|true|enabled)$/i.test(val)) val = true;
  else if (/^(no|off|false|disabled)$/i.test(val)) val = false;
  else if (val === 'null') val = null;
  else val = Number(val);

  obj[prop] = val;
  return obj;
}, {});

/**
 * The file descriptor to write the `debug()` calls to.
 * Set the `DEBUG_FD` env variable to override with another value. i.e.:
 *
 *   $ DEBUG_FD=3 node script.js 3>debug.log
 */

var fd = parseInt(process.env.DEBUG_FD, 10) || 2;

if (1 !== fd && 2 !== fd) {
  util.deprecate(function(){}, 'except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)')()
}

var stream = 1 === fd ? process.stdout :
             2 === fd ? process.stderr :
             createWritableStdioStream(fd);

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
  return 'colors' in exports.inspectOpts
    ? Boolean(exports.inspectOpts.colors)
    : tty.isatty(fd);
}

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

exports.formatters.o = function(v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts)
    .split('\n').map(function(str) {
      return str.trim()
    }).join(' ');
};

/**
 * Map %o to `util.inspect()`, allowing multiple lines if needed.
 */

exports.formatters.O = function(v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts);
};

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var name = this.namespace;
  var useColors = this.useColors;

  if (useColors) {
    var c = this.color;
    var prefix = '  \u001b[3' + c + ';1m' + name + ' ' + '\u001b[0m';

    args[0] = prefix + args[0].split('\n').join('\n' + prefix);
    args.push('\u001b[3' + c + 'm+' + exports.humanize(this.diff) + '\u001b[0m');
  } else {
    args[0] = new Date().toUTCString()
      + ' ' + name + ' ' + args[0];
  }
}

/**
 * Invokes `util.format()` with the specified arguments and writes to `stream`.
 */

function log() {
  return stream.write(util.format.apply(util, arguments) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  if (null == namespaces) {
    // If you set a process.env field to null or undefined, it gets cast to the
    // string 'null' or 'undefined'. Just delete instead.
    delete process.env.DEBUG;
  } else {
    process.env.DEBUG = namespaces;
  }
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  return process.env.DEBUG;
}

/**
 * Copied from `node/src/node.js`.
 *
 * XXX: It's lame that node doesn't expose this API out-of-the-box. It also
 * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.
 */

function createWritableStdioStream (fd) {
  var stream;
  var tty_wrap = process.binding('tty_wrap');

  // Note stream._type is used for test-module-load-list.js

  switch (tty_wrap.guessHandleType(fd)) {
    case 'TTY':
      stream = new tty.WriteStream(fd);
      stream._type = 'tty';

      // Hack to have stream not keep the event loop alive.
      // See https://github.com/joyent/node/issues/1726
      if (stream._handle && stream._handle.unref) {
        stream._handle.unref();
      }
      break;

    case 'FILE':
      var fs = __webpack_require__(/*! fs */ "fs");
      stream = new fs.SyncWriteStream(fd, { autoClose: false });
      stream._type = 'fs';
      break;

    case 'PIPE':
    case 'TCP':
      var net = __webpack_require__(/*! net */ "net");
      stream = new net.Socket({
        fd: fd,
        readable: false,
        writable: true
      });

      // FIXME Should probably have an option in net.Socket to create a
      // stream from an existing fd which is writable only. But for now
      // we'll just add this hack and set the `readable` member to false.
      // Test: ./node test/fixtures/echo.js < /etc/passwd
      stream.readable = false;
      stream.read = null;
      stream._type = 'pipe';

      // FIXME Hack to have stream not keep the event loop alive.
      // See https://github.com/joyent/node/issues/1726
      if (stream._handle && stream._handle.unref) {
        stream._handle.unref();
      }
      break;

    default:
      // Probably an error on in uv_guess_handle()
      throw new Error('Implement me. Unknown stream file type!');
  }

  // For supporting legacy API we put the FD here.
  stream.fd = fd;

  stream._isStdio = true;

  return stream;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init (debug) {
  debug.inspectOpts = {};

  var keys = Object.keys(exports.inspectOpts);
  for (var i = 0; i < keys.length; i++) {
    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
  }
}

/**
 * Enable namespaces listed in `process.env.DEBUG` initially.
 */

exports.enable(load());


/***/ }),

/***/ "./node_modules/express/node_modules/qs/lib/formats.js":
/*!*************************************************************!*\
  !*** ./node_modules/express/node_modules/qs/lib/formats.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var replace = String.prototype.replace;
var percentTwenties = /%20/g;

module.exports = {
    'default': 'RFC3986',
    formatters: {
        RFC1738: function (value) {
            return replace.call(value, percentTwenties, '+');
        },
        RFC3986: function (value) {
            return value;
        }
    },
    RFC1738: 'RFC1738',
    RFC3986: 'RFC3986'
};


/***/ }),

/***/ "./node_modules/express/node_modules/qs/lib/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/express/node_modules/qs/lib/index.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var stringify = __webpack_require__(/*! ./stringify */ "./node_modules/express/node_modules/qs/lib/stringify.js");
var parse = __webpack_require__(/*! ./parse */ "./node_modules/express/node_modules/qs/lib/parse.js");
var formats = __webpack_require__(/*! ./formats */ "./node_modules/express/node_modules/qs/lib/formats.js");

module.exports = {
    formats: formats,
    parse: parse,
    stringify: stringify
};


/***/ }),

/***/ "./node_modules/express/node_modules/qs/lib/parse.js":
/*!***********************************************************!*\
  !*** ./node_modules/express/node_modules/qs/lib/parse.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/express/node_modules/qs/lib/utils.js");

var has = Object.prototype.hasOwnProperty;

var defaults = {
    allowDots: false,
    allowPrototypes: false,
    arrayLimit: 20,
    charset: 'utf-8',
    charsetSentinel: false,
    comma: false,
    decoder: utils.decode,
    delimiter: '&',
    depth: 5,
    ignoreQueryPrefix: false,
    interpretNumericEntities: false,
    parameterLimit: 1000,
    parseArrays: true,
    plainObjects: false,
    strictNullHandling: false
};

var interpretNumericEntities = function (str) {
    return str.replace(/&#(\d+);/g, function ($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
    });
};

// This is what browsers will submit when the  character occurs in an
// application/x-www-form-urlencoded body and the encoding of the page containing
// the form is iso-8859-1, or when the submitted form has an accept-charset
// attribute of iso-8859-1. Presumably also with other charsets that do not contain
// the  character, such as us-ascii.
var isoSentinel = 'utf8=%26%2310003%3B'; // encodeURIComponent('&#10003;')

// These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.
var charsetSentinel = 'utf8=%E2%9C%93'; // encodeURIComponent('')

var parseValues = function parseQueryStringValues(str, options) {
    var obj = {};
    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
    var parts = cleanStr.split(options.delimiter, limit);
    var skipIndex = -1; // Keep track of where the utf8 sentinel was found
    var i;

    var charset = options.charset;
    if (options.charsetSentinel) {
        for (i = 0; i < parts.length; ++i) {
            if (parts[i].indexOf('utf8=') === 0) {
                if (parts[i] === charsetSentinel) {
                    charset = 'utf-8';
                } else if (parts[i] === isoSentinel) {
                    charset = 'iso-8859-1';
                }
                skipIndex = i;
                i = parts.length; // The eslint settings do not allow break;
            }
        }
    }

    for (i = 0; i < parts.length; ++i) {
        if (i === skipIndex) {
            continue;
        }
        var part = parts[i];

        var bracketEqualsPos = part.indexOf(']=');
        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;

        var key, val;
        if (pos === -1) {
            key = options.decoder(part, defaults.decoder, charset);
            val = options.strictNullHandling ? null : '';
        } else {
            key = options.decoder(part.slice(0, pos), defaults.decoder, charset);
            val = options.decoder(part.slice(pos + 1), defaults.decoder, charset);
        }

        if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {
            val = interpretNumericEntities(val);
        }

        if (val && options.comma && val.indexOf(',') > -1) {
            val = val.split(',');
        }

        if (has.call(obj, key)) {
            obj[key] = utils.combine(obj[key], val);
        } else {
            obj[key] = val;
        }
    }

    return obj;
};

var parseObject = function (chain, val, options) {
    var leaf = val;

    for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];

        if (root === '[]' && options.parseArrays) {
            obj = [].concat(leaf);
        } else {
            obj = options.plainObjects ? Object.create(null) : {};
            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
            var index = parseInt(cleanRoot, 10);
            if (!options.parseArrays && cleanRoot === '') {
                obj = { 0: leaf };
            } else if (
                !isNaN(index)
                && root !== cleanRoot
                && String(index) === cleanRoot
                && index >= 0
                && (options.parseArrays && index <= options.arrayLimit)
            ) {
                obj = [];
                obj[index] = leaf;
            } else {
                obj[cleanRoot] = leaf;
            }
        }

        leaf = obj;
    }

    return leaf;
};

var parseKeys = function parseQueryStringKeys(givenKey, val, options) {
    if (!givenKey) {
        return;
    }

    // Transform dot notation to bracket notation
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;

    // The regex chunks

    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;

    // Get the parent

    var segment = brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;

    // Stash the parent if it exists

    var keys = [];
    if (parent) {
        // If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
            if (!options.allowPrototypes) {
                return;
            }
        }

        keys.push(parent);
    }

    // Loop through children appending to the array until we hit depth

    var i = 0;
    while ((segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
            if (!options.allowPrototypes) {
                return;
            }
        }
        keys.push(segment[1]);
    }

    // If there's a remainder, just add whatever is left

    if (segment) {
        keys.push('[' + key.slice(segment.index) + ']');
    }

    return parseObject(keys, val, options);
};

var normalizeParseOptions = function normalizeParseOptions(opts) {
    if (!opts) {
        return defaults;
    }

    if (opts.decoder !== null && opts.decoder !== undefined && typeof opts.decoder !== 'function') {
        throw new TypeError('Decoder has to be a function.');
    }

    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new Error('The charset option must be either utf-8, iso-8859-1, or undefined');
    }
    var charset = typeof opts.charset === 'undefined' ? defaults.charset : opts.charset;

    return {
        allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,
        allowPrototypes: typeof opts.allowPrototypes === 'boolean' ? opts.allowPrototypes : defaults.allowPrototypes,
        arrayLimit: typeof opts.arrayLimit === 'number' ? opts.arrayLimit : defaults.arrayLimit,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === 'boolean' ? opts.comma : defaults.comma,
        decoder: typeof opts.decoder === 'function' ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === 'string' || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        depth: typeof opts.depth === 'number' ? opts.depth : defaults.depth,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === 'boolean' ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === 'number' ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === 'boolean' ? opts.plainObjects : defaults.plainObjects,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
};

module.exports = function (str, opts) {
    var options = normalizeParseOptions(opts);

    if (str === '' || str === null || typeof str === 'undefined') {
        return options.plainObjects ? Object.create(null) : {};
    }

    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
    var obj = options.plainObjects ? Object.create(null) : {};

    // Iterate over the keys and setup the new object

    var keys = Object.keys(tempObj);
    for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options);
        obj = utils.merge(obj, newObj, options);
    }

    return utils.compact(obj);
};


/***/ }),

/***/ "./node_modules/express/node_modules/qs/lib/stringify.js":
/*!***************************************************************!*\
  !*** ./node_modules/express/node_modules/qs/lib/stringify.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/express/node_modules/qs/lib/utils.js");
var formats = __webpack_require__(/*! ./formats */ "./node_modules/express/node_modules/qs/lib/formats.js");
var has = Object.prototype.hasOwnProperty;

var arrayPrefixGenerators = {
    brackets: function brackets(prefix) { // eslint-disable-line func-name-matching
        return prefix + '[]';
    },
    comma: 'comma',
    indices: function indices(prefix, key) { // eslint-disable-line func-name-matching
        return prefix + '[' + key + ']';
    },
    repeat: function repeat(prefix) { // eslint-disable-line func-name-matching
        return prefix;
    }
};

var isArray = Array.isArray;
var push = Array.prototype.push;
var pushToArray = function (arr, valueOrArray) {
    push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
};

var toISO = Date.prototype.toISOString;

var defaults = {
    addQueryPrefix: false,
    allowDots: false,
    charset: 'utf-8',
    charsetSentinel: false,
    delimiter: '&',
    encode: true,
    encoder: utils.encode,
    encodeValuesOnly: false,
    formatter: formats.formatters[formats['default']],
    // deprecated
    indices: false,
    serializeDate: function serializeDate(date) { // eslint-disable-line func-name-matching
        return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
};

var stringify = function stringify( // eslint-disable-line func-name-matching
    object,
    prefix,
    generateArrayPrefix,
    strictNullHandling,
    skipNulls,
    encoder,
    filter,
    sort,
    allowDots,
    serializeDate,
    formatter,
    encodeValuesOnly,
    charset
) {
    var obj = object;
    if (typeof filter === 'function') {
        obj = filter(prefix, obj);
    } else if (obj instanceof Date) {
        obj = serializeDate(obj);
    } else if (generateArrayPrefix === 'comma' && isArray(obj)) {
        obj = obj.join(',');
    }

    if (obj === null) {
        if (strictNullHandling) {
            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset) : prefix;
        }

        obj = '';
    }

    if (typeof obj === 'string' || typeof obj === 'number' || typeof obj === 'boolean' || utils.isBuffer(obj)) {
        if (encoder) {
            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset);
            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder, charset))];
        }
        return [formatter(prefix) + '=' + formatter(String(obj))];
    }

    var values = [];

    if (typeof obj === 'undefined') {
        return values;
    }

    var objKeys;
    if (isArray(filter)) {
        objKeys = filter;
    } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
    }

    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];

        if (skipNulls && obj[key] === null) {
            continue;
        }

        if (isArray(obj)) {
            pushToArray(values, stringify(
                obj[key],
                typeof generateArrayPrefix === 'function' ? generateArrayPrefix(prefix, key) : prefix,
                generateArrayPrefix,
                strictNullHandling,
                skipNulls,
                encoder,
                filter,
                sort,
                allowDots,
                serializeDate,
                formatter,
                encodeValuesOnly,
                charset
            ));
        } else {
            pushToArray(values, stringify(
                obj[key],
                prefix + (allowDots ? '.' + key : '[' + key + ']'),
                generateArrayPrefix,
                strictNullHandling,
                skipNulls,
                encoder,
                filter,
                sort,
                allowDots,
                serializeDate,
                formatter,
                encodeValuesOnly,
                charset
            ));
        }
    }

    return values;
};

var normalizeStringifyOptions = function normalizeStringifyOptions(opts) {
    if (!opts) {
        return defaults;
    }

    if (opts.encoder !== null && opts.encoder !== undefined && typeof opts.encoder !== 'function') {
        throw new TypeError('Encoder has to be a function.');
    }

    var charset = opts.charset || defaults.charset;
    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }

    var format = formats['default'];
    if (typeof opts.format !== 'undefined') {
        if (!has.call(formats.formatters, opts.format)) {
            throw new TypeError('Unknown format option provided.');
        }
        format = opts.format;
    }
    var formatter = formats.formatters[format];

    var filter = defaults.filter;
    if (typeof opts.filter === 'function' || isArray(opts.filter)) {
        filter = opts.filter;
    }

    return {
        addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,
        encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter: filter,
        formatter: formatter,
        serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === 'function' ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
};

module.exports = function (object, opts) {
    var obj = object;
    var options = normalizeStringifyOptions(opts);

    var objKeys;
    var filter;

    if (typeof options.filter === 'function') {
        filter = options.filter;
        obj = filter('', obj);
    } else if (isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
    }

    var keys = [];

    if (typeof obj !== 'object' || obj === null) {
        return '';
    }

    var arrayFormat;
    if (opts && opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
    } else if (opts && 'indices' in opts) {
        arrayFormat = opts.indices ? 'indices' : 'repeat';
    } else {
        arrayFormat = 'indices';
    }

    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];

    if (!objKeys) {
        objKeys = Object.keys(obj);
    }

    if (options.sort) {
        objKeys.sort(options.sort);
    }

    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];

        if (options.skipNulls && obj[key] === null) {
            continue;
        }
        pushToArray(keys, stringify(
            obj[key],
            key,
            generateArrayPrefix,
            options.strictNullHandling,
            options.skipNulls,
            options.encode ? options.encoder : null,
            options.filter,
            options.sort,
            options.allowDots,
            options.serializeDate,
            options.formatter,
            options.encodeValuesOnly,
            options.charset
        ));
    }

    var joined = keys.join(options.delimiter);
    var prefix = options.addQueryPrefix === true ? '?' : '';

    if (options.charsetSentinel) {
        if (options.charset === 'iso-8859-1') {
            // encodeURIComponent('&#10003;'), the "numeric entity" representation of a checkmark
            prefix += 'utf8=%26%2310003%3B&';
        } else {
            // encodeURIComponent('')
            prefix += 'utf8=%E2%9C%93&';
        }
    }

    return joined.length > 0 ? prefix + joined : '';
};


/***/ }),

/***/ "./node_modules/express/node_modules/qs/lib/utils.js":
/*!***********************************************************!*\
  !*** ./node_modules/express/node_modules/qs/lib/utils.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;

var hexTable = (function () {
    var array = [];
    for (var i = 0; i < 256; ++i) {
        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
    }

    return array;
}());

var compactQueue = function compactQueue(queue) {
    while (queue.length > 1) {
        var item = queue.pop();
        var obj = item.obj[item.prop];

        if (isArray(obj)) {
            var compacted = [];

            for (var j = 0; j < obj.length; ++j) {
                if (typeof obj[j] !== 'undefined') {
                    compacted.push(obj[j]);
                }
            }

            item.obj[item.prop] = compacted;
        }
    }
};

var arrayToObject = function arrayToObject(source, options) {
    var obj = options && options.plainObjects ? Object.create(null) : {};
    for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== 'undefined') {
            obj[i] = source[i];
        }
    }

    return obj;
};

var merge = function merge(target, source, options) {
    if (!source) {
        return target;
    }

    if (typeof source !== 'object') {
        if (isArray(target)) {
            target.push(source);
        } else if (target && typeof target === 'object') {
            if ((options && (options.plainObjects || options.allowPrototypes)) || !has.call(Object.prototype, source)) {
                target[source] = true;
            }
        } else {
            return [target, source];
        }

        return target;
    }

    if (!target || typeof target !== 'object') {
        return [target].concat(source);
    }

    var mergeTarget = target;
    if (isArray(target) && !isArray(source)) {
        mergeTarget = arrayToObject(target, options);
    }

    if (isArray(target) && isArray(source)) {
        source.forEach(function (item, i) {
            if (has.call(target, i)) {
                var targetItem = target[i];
                if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {
                    target[i] = merge(targetItem, item, options);
                } else {
                    target.push(item);
                }
            } else {
                target[i] = item;
            }
        });
        return target;
    }

    return Object.keys(source).reduce(function (acc, key) {
        var value = source[key];

        if (has.call(acc, key)) {
            acc[key] = merge(acc[key], value, options);
        } else {
            acc[key] = value;
        }
        return acc;
    }, mergeTarget);
};

var assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function (acc, key) {
        acc[key] = source[key];
        return acc;
    }, target);
};

var decode = function (str, decoder, charset) {
    var strWithoutPlus = str.replace(/\+/g, ' ');
    if (charset === 'iso-8859-1') {
        // unescape never throws, no try...catch needed:
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
    }
    // utf-8
    try {
        return decodeURIComponent(strWithoutPlus);
    } catch (e) {
        return strWithoutPlus;
    }
};

var encode = function encode(str, defaultEncoder, charset) {
    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
    // It has been adapted here for stricter adherence to RFC 3986
    if (str.length === 0) {
        return str;
    }

    var string = typeof str === 'string' ? str : String(str);

    if (charset === 'iso-8859-1') {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {
            return '%26%23' + parseInt($0.slice(2), 16) + '%3B';
        });
    }

    var out = '';
    for (var i = 0; i < string.length; ++i) {
        var c = string.charCodeAt(i);

        if (
            c === 0x2D // -
            || c === 0x2E // .
            || c === 0x5F // _
            || c === 0x7E // ~
            || (c >= 0x30 && c <= 0x39) // 0-9
            || (c >= 0x41 && c <= 0x5A) // a-z
            || (c >= 0x61 && c <= 0x7A) // A-Z
        ) {
            out += string.charAt(i);
            continue;
        }

        if (c < 0x80) {
            out = out + hexTable[c];
            continue;
        }

        if (c < 0x800) {
            out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);
            continue;
        }

        if (c < 0xD800 || c >= 0xE000) {
            out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);
            continue;
        }

        i += 1;
        c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));
        out += hexTable[0xF0 | (c >> 18)]
            + hexTable[0x80 | ((c >> 12) & 0x3F)]
            + hexTable[0x80 | ((c >> 6) & 0x3F)]
            + hexTable[0x80 | (c & 0x3F)];
    }

    return out;
};

var compact = function compact(value) {
    var queue = [{ obj: { o: value }, prop: 'o' }];
    var refs = [];

    for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];

        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
            var key = keys[j];
            var val = obj[key];
            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {
                queue.push({ obj: obj, prop: key });
                refs.push(val);
            }
        }
    }

    compactQueue(queue);

    return value;
};

var isRegExp = function isRegExp(obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
};

var isBuffer = function isBuffer(obj) {
    if (!obj || typeof obj !== 'object') {
        return false;
    }

    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};

var combine = function combine(a, b) {
    return [].concat(a, b);
};

module.exports = {
    arrayToObject: arrayToObject,
    assign: assign,
    combine: combine,
    compact: compact,
    decode: decode,
    encode: encode,
    isBuffer: isBuffer,
    isRegExp: isRegExp,
    merge: merge
};


/***/ }),

/***/ "./node_modules/fill-range/index.js":
/*!******************************************!*\
  !*** ./node_modules/fill-range/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * fill-range <https://github.com/jonschlinkert/fill-range>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Licensed under the MIT License.
 */



const util = __webpack_require__(/*! util */ "util");
const toRegexRange = __webpack_require__(/*! to-regex-range */ "./node_modules/to-regex-range/index.js");

const isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);

const transform = toNumber => {
  return value => toNumber === true ? Number(value) : String(value);
};

const isValidValue = value => {
  return typeof value === 'number' || (typeof value === 'string' && value !== '');
};

const isNumber = num => Number.isInteger(+num);

const zeros = input => {
  let value = `${input}`;
  let index = -1;
  if (value[0] === '-') value = value.slice(1);
  if (value === '0') return false;
  while (value[++index] === '0');
  return index > 0;
};

const stringify = (start, end, options) => {
  if (typeof start === 'string' || typeof end === 'string') {
    return true;
  }
  return options.stringify === true;
};

const pad = (input, maxLength, toNumber) => {
  if (maxLength > 0) {
    let dash = input[0] === '-' ? '-' : '';
    if (dash) input = input.slice(1);
    input = (dash + input.padStart(dash ? maxLength - 1 : maxLength, '0'));
  }
  if (toNumber === false) {
    return String(input);
  }
  return input;
};

const toMaxLen = (input, maxLength) => {
  let negative = input[0] === '-' ? '-' : '';
  if (negative) {
    input = input.slice(1);
    maxLength--;
  }
  while (input.length < maxLength) input = '0' + input;
  return negative ? ('-' + input) : input;
};

const toSequence = (parts, options) => {
  parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
  parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);

  let prefix = options.capture ? '' : '?:';
  let positives = '';
  let negatives = '';
  let result;

  if (parts.positives.length) {
    positives = parts.positives.join('|');
  }

  if (parts.negatives.length) {
    negatives = `-(${prefix}${parts.negatives.join('|')})`;
  }

  if (positives && negatives) {
    result = `${positives}|${negatives}`;
  } else {
    result = positives || negatives;
  }

  if (options.wrap) {
    return `(${prefix}${result})`;
  }

  return result;
};

const toRange = (a, b, isNumbers, options) => {
  if (isNumbers) {
    return toRegexRange(a, b, { wrap: false, ...options });
  }

  let start = String.fromCharCode(a);
  if (a === b) return start;

  let stop = String.fromCharCode(b);
  return `[${start}-${stop}]`;
};

const toRegex = (start, end, options) => {
  if (Array.isArray(start)) {
    let wrap = options.wrap === true;
    let prefix = options.capture ? '' : '?:';
    return wrap ? `(${prefix}${start.join('|')})` : start.join('|');
  }
  return toRegexRange(start, end, options);
};

const rangeError = (...args) => {
  return new RangeError('Invalid range arguments: ' + util.inspect(...args));
};

const invalidRange = (start, end, options) => {
  if (options.strictRanges === true) throw rangeError([start, end]);
  return [];
};

const invalidStep = (step, options) => {
  if (options.strictRanges === true) {
    throw new TypeError(`Expected step "${step}" to be a number`);
  }
  return [];
};

const fillNumbers = (start, end, step = 1, options = {}) => {
  let a = Number(start);
  let b = Number(end);

  if (!Number.isInteger(a) || !Number.isInteger(b)) {
    if (options.strictRanges === true) throw rangeError([start, end]);
    return [];
  }

  // fix negative zero
  if (a === 0) a = 0;
  if (b === 0) b = 0;

  let descending = a > b;
  let startString = String(start);
  let endString = String(end);
  let stepString = String(step);
  step = Math.max(Math.abs(step), 1);

  let padded = zeros(startString) || zeros(endString) || zeros(stepString);
  let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
  let toNumber = padded === false && stringify(start, end, options) === false;
  let format = options.transform || transform(toNumber);

  if (options.toRegex && step === 1) {
    return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);
  }

  let parts = { negatives: [], positives: [] };
  let push = num => parts[num < 0 ? 'negatives' : 'positives'].push(Math.abs(num));
  let range = [];
  let index = 0;

  while (descending ? a >= b : a <= b) {
    if (options.toRegex === true && step > 1) {
      push(a);
    } else {
      range.push(pad(format(a, index), maxLen, toNumber));
    }
    a = descending ? a - step : a + step;
    index++;
  }

  if (options.toRegex === true) {
    return step > 1
      ? toSequence(parts, options)
      : toRegex(range, null, { wrap: false, ...options });
  }

  return range;
};

const fillLetters = (start, end, step = 1, options = {}) => {
  if ((!isNumber(start) && start.length > 1) || (!isNumber(end) && end.length > 1)) {
    return invalidRange(start, end, options);
  }


  let format = options.transform || (val => String.fromCharCode(val));
  let a = `${start}`.charCodeAt(0);
  let b = `${end}`.charCodeAt(0);

  let descending = a > b;
  let min = Math.min(a, b);
  let max = Math.max(a, b);

  if (options.toRegex && step === 1) {
    return toRange(min, max, false, options);
  }

  let range = [];
  let index = 0;

  while (descending ? a >= b : a <= b) {
    range.push(format(a, index));
    a = descending ? a - step : a + step;
    index++;
  }

  if (options.toRegex === true) {
    return toRegex(range, null, { wrap: false, options });
  }

  return range;
};

const fill = (start, end, step, options = {}) => {
  if (end == null && isValidValue(start)) {
    return [start];
  }

  if (!isValidValue(start) || !isValidValue(end)) {
    return invalidRange(start, end, options);
  }

  if (typeof step === 'function') {
    return fill(start, end, 1, { transform: step });
  }

  if (isObject(step)) {
    return fill(start, end, 0, step);
  }

  let opts = { ...options };
  if (opts.capture === true) opts.wrap = true;
  step = step || opts.step || 1;

  if (!isNumber(step)) {
    if (step != null && !isObject(step)) return invalidStep(step, opts);
    return fill(start, end, 1, step);
  }

  if (isNumber(start) && isNumber(end)) {
    return fillNumbers(start, end, step, opts);
  }

  return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
};

module.exports = fill;


/***/ }),

/***/ "./node_modules/finalhandler/index.js":
/*!********************************************!*\
  !*** ./node_modules/finalhandler/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * finalhandler
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var debug = __webpack_require__(/*! debug */ "./node_modules/finalhandler/node_modules/debug/src/index.js")('finalhandler')
var encodeUrl = __webpack_require__(/*! encodeurl */ "./node_modules/encodeurl/index.js")
var escapeHtml = __webpack_require__(/*! escape-html */ "./node_modules/escape-html/index.js")
var onFinished = __webpack_require__(/*! on-finished */ "./node_modules/on-finished/index.js")
var parseUrl = __webpack_require__(/*! parseurl */ "./node_modules/parseurl/index.js")
var statuses = __webpack_require__(/*! statuses */ "./node_modules/statuses/index.js")
var unpipe = __webpack_require__(/*! unpipe */ "./node_modules/unpipe/index.js")

/**
 * Module variables.
 * @private
 */

var DOUBLE_SPACE_REGEXP = /\x20{2}/g
var NEWLINE_REGEXP = /\n/g

/* istanbul ignore next */
var defer = typeof setImmediate === 'function'
  ? setImmediate
  : function (fn) { process.nextTick(fn.bind.apply(fn, arguments)) }
var isFinished = onFinished.isFinished

/**
 * Create a minimal HTML document.
 *
 * @param {string} message
 * @private
 */

function createHtmlDocument (message) {
  var body = escapeHtml(message)
    .replace(NEWLINE_REGEXP, '<br>')
    .replace(DOUBLE_SPACE_REGEXP, ' &nbsp;')

  return '<!DOCTYPE html>\n' +
    '<html lang="en">\n' +
    '<head>\n' +
    '<meta charset="utf-8">\n' +
    '<title>Error</title>\n' +
    '</head>\n' +
    '<body>\n' +
    '<pre>' + body + '</pre>\n' +
    '</body>\n' +
    '</html>\n'
}

/**
 * Module exports.
 * @public
 */

module.exports = finalhandler

/**
 * Create a function to handle the final response.
 *
 * @param {Request} req
 * @param {Response} res
 * @param {Object} [options]
 * @return {Function}
 * @public
 */

function finalhandler (req, res, options) {
  var opts = options || {}

  // get environment
  var env = opts.env || "development" || 'development'

  // get error callback
  var onerror = opts.onerror

  return function (err) {
    var headers
    var msg
    var status

    // ignore 404 on in-flight response
    if (!err && headersSent(res)) {
      debug('cannot 404 after headers sent')
      return
    }

    // unhandled error
    if (err) {
      // respect status code from error
      status = getErrorStatusCode(err)

      if (status === undefined) {
        // fallback to status code on response
        status = getResponseStatusCode(res)
      } else {
        // respect headers from error
        headers = getErrorHeaders(err)
      }

      // get error message
      msg = getErrorMessage(err, status, env)
    } else {
      // not found
      status = 404
      msg = 'Cannot ' + req.method + ' ' + encodeUrl(getResourceName(req))
    }

    debug('default %s', status)

    // schedule onerror callback
    if (err && onerror) {
      defer(onerror, err, req, res)
    }

    // cannot actually respond
    if (headersSent(res)) {
      debug('cannot %d after headers sent', status)
      req.socket.destroy()
      return
    }

    // send response
    send(req, res, status, headers, msg)
  }
}

/**
 * Get headers from Error object.
 *
 * @param {Error} err
 * @return {object}
 * @private
 */

function getErrorHeaders (err) {
  if (!err.headers || typeof err.headers !== 'object') {
    return undefined
  }

  var headers = Object.create(null)
  var keys = Object.keys(err.headers)

  for (var i = 0; i < keys.length; i++) {
    var key = keys[i]
    headers[key] = err.headers[key]
  }

  return headers
}

/**
 * Get message from Error object, fallback to status message.
 *
 * @param {Error} err
 * @param {number} status
 * @param {string} env
 * @return {string}
 * @private
 */

function getErrorMessage (err, status, env) {
  var msg

  if (env !== 'production') {
    // use err.stack, which typically includes err.message
    msg = err.stack

    // fallback to err.toString() when possible
    if (!msg && typeof err.toString === 'function') {
      msg = err.toString()
    }
  }

  return msg || statuses[status]
}

/**
 * Get status code from Error object.
 *
 * @param {Error} err
 * @return {number}
 * @private
 */

function getErrorStatusCode (err) {
  // check err.status
  if (typeof err.status === 'number' && err.status >= 400 && err.status < 600) {
    return err.status
  }

  // check err.statusCode
  if (typeof err.statusCode === 'number' && err.statusCode >= 400 && err.statusCode < 600) {
    return err.statusCode
  }

  return undefined
}

/**
 * Get resource name for the request.
 *
 * This is typically just the original pathname of the request
 * but will fallback to "resource" is that cannot be determined.
 *
 * @param {IncomingMessage} req
 * @return {string}
 * @private
 */

function getResourceName (req) {
  try {
    return parseUrl.original(req).pathname
  } catch (e) {
    return 'resource'
  }
}

/**
 * Get status code from response.
 *
 * @param {OutgoingMessage} res
 * @return {number}
 * @private
 */

function getResponseStatusCode (res) {
  var status = res.statusCode

  // default status code to 500 if outside valid range
  if (typeof status !== 'number' || status < 400 || status > 599) {
    status = 500
  }

  return status
}

/**
 * Determine if the response headers have been sent.
 *
 * @param {object} res
 * @returns {boolean}
 * @private
 */

function headersSent (res) {
  return typeof res.headersSent !== 'boolean'
    ? Boolean(res._header)
    : res.headersSent
}

/**
 * Send response.
 *
 * @param {IncomingMessage} req
 * @param {OutgoingMessage} res
 * @param {number} status
 * @param {object} headers
 * @param {string} message
 * @private
 */

function send (req, res, status, headers, message) {
  function write () {
    // response body
    var body = createHtmlDocument(message)

    // response status
    res.statusCode = status
    res.statusMessage = statuses[status]

    // response headers
    setHeaders(res, headers)

    // security headers
    res.setHeader('Content-Security-Policy', "default-src 'none'")
    res.setHeader('X-Content-Type-Options', 'nosniff')

    // standard headers
    res.setHeader('Content-Type', 'text/html; charset=utf-8')
    res.setHeader('Content-Length', Buffer.byteLength(body, 'utf8'))

    if (req.method === 'HEAD') {
      res.end()
      return
    }

    res.end(body, 'utf8')
  }

  if (isFinished(req)) {
    write()
    return
  }

  // unpipe everything from the request
  unpipe(req)

  // flush the request
  onFinished(req, write)
  req.resume()
}

/**
 * Set response headers from an object.
 *
 * @param {OutgoingMessage} res
 * @param {object} headers
 * @private
 */

function setHeaders (res, headers) {
  if (!headers) {
    return
  }

  var keys = Object.keys(headers)
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i]
    res.setHeader(key, headers[key])
  }
}


/***/ }),

/***/ "./node_modules/finalhandler/node_modules/debug/src/browser.js":
/*!*********************************************************************!*\
  !*** ./node_modules/finalhandler/node_modules/debug/src/browser.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __webpack_require__(/*! ./debug */ "./node_modules/finalhandler/node_modules/debug/src/debug.js");
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}


/***/ }),

/***/ "./node_modules/finalhandler/node_modules/debug/src/debug.js":
/*!*******************************************************************!*\
  !*** ./node_modules/finalhandler/node_modules/debug/src/debug.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = __webpack_require__(/*! ms */ "./node_modules/ms/index.js");

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  return debug;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}


/***/ }),

/***/ "./node_modules/finalhandler/node_modules/debug/src/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/finalhandler/node_modules/debug/src/index.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Detect Electron renderer process, which is node, but we should
 * treat as a browser.
 */

if (typeof process !== 'undefined' && process.type === 'renderer') {
  module.exports = __webpack_require__(/*! ./browser.js */ "./node_modules/finalhandler/node_modules/debug/src/browser.js");
} else {
  module.exports = __webpack_require__(/*! ./node.js */ "./node_modules/finalhandler/node_modules/debug/src/node.js");
}


/***/ }),

/***/ "./node_modules/finalhandler/node_modules/debug/src/node.js":
/*!******************************************************************!*\
  !*** ./node_modules/finalhandler/node_modules/debug/src/node.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Module dependencies.
 */

var tty = __webpack_require__(/*! tty */ "tty");
var util = __webpack_require__(/*! util */ "util");

/**
 * This is the Node.js implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __webpack_require__(/*! ./debug */ "./node_modules/finalhandler/node_modules/debug/src/debug.js");
exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(function (key) {
  return /^debug_/i.test(key);
}).reduce(function (obj, key) {
  // camel-case
  var prop = key
    .substring(6)
    .toLowerCase()
    .replace(/_([a-z])/g, function (_, k) { return k.toUpperCase() });

  // coerce string value into JS value
  var val = process.env[key];
  if (/^(yes|on|true|enabled)$/i.test(val)) val = true;
  else if (/^(no|off|false|disabled)$/i.test(val)) val = false;
  else if (val === 'null') val = null;
  else val = Number(val);

  obj[prop] = val;
  return obj;
}, {});

/**
 * The file descriptor to write the `debug()` calls to.
 * Set the `DEBUG_FD` env variable to override with another value. i.e.:
 *
 *   $ DEBUG_FD=3 node script.js 3>debug.log
 */

var fd = parseInt(process.env.DEBUG_FD, 10) || 2;

if (1 !== fd && 2 !== fd) {
  util.deprecate(function(){}, 'except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)')()
}

var stream = 1 === fd ? process.stdout :
             2 === fd ? process.stderr :
             createWritableStdioStream(fd);

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
  return 'colors' in exports.inspectOpts
    ? Boolean(exports.inspectOpts.colors)
    : tty.isatty(fd);
}

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

exports.formatters.o = function(v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts)
    .split('\n').map(function(str) {
      return str.trim()
    }).join(' ');
};

/**
 * Map %o to `util.inspect()`, allowing multiple lines if needed.
 */

exports.formatters.O = function(v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts);
};

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var name = this.namespace;
  var useColors = this.useColors;

  if (useColors) {
    var c = this.color;
    var prefix = '  \u001b[3' + c + ';1m' + name + ' ' + '\u001b[0m';

    args[0] = prefix + args[0].split('\n').join('\n' + prefix);
    args.push('\u001b[3' + c + 'm+' + exports.humanize(this.diff) + '\u001b[0m');
  } else {
    args[0] = new Date().toUTCString()
      + ' ' + name + ' ' + args[0];
  }
}

/**
 * Invokes `util.format()` with the specified arguments and writes to `stream`.
 */

function log() {
  return stream.write(util.format.apply(util, arguments) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  if (null == namespaces) {
    // If you set a process.env field to null or undefined, it gets cast to the
    // string 'null' or 'undefined'. Just delete instead.
    delete process.env.DEBUG;
  } else {
    process.env.DEBUG = namespaces;
  }
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  return process.env.DEBUG;
}

/**
 * Copied from `node/src/node.js`.
 *
 * XXX: It's lame that node doesn't expose this API out-of-the-box. It also
 * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.
 */

function createWritableStdioStream (fd) {
  var stream;
  var tty_wrap = process.binding('tty_wrap');

  // Note stream._type is used for test-module-load-list.js

  switch (tty_wrap.guessHandleType(fd)) {
    case 'TTY':
      stream = new tty.WriteStream(fd);
      stream._type = 'tty';

      // Hack to have stream not keep the event loop alive.
      // See https://github.com/joyent/node/issues/1726
      if (stream._handle && stream._handle.unref) {
        stream._handle.unref();
      }
      break;

    case 'FILE':
      var fs = __webpack_require__(/*! fs */ "fs");
      stream = new fs.SyncWriteStream(fd, { autoClose: false });
      stream._type = 'fs';
      break;

    case 'PIPE':
    case 'TCP':
      var net = __webpack_require__(/*! net */ "net");
      stream = new net.Socket({
        fd: fd,
        readable: false,
        writable: true
      });

      // FIXME Should probably have an option in net.Socket to create a
      // stream from an existing fd which is writable only. But for now
      // we'll just add this hack and set the `readable` member to false.
      // Test: ./node test/fixtures/echo.js < /etc/passwd
      stream.readable = false;
      stream.read = null;
      stream._type = 'pipe';

      // FIXME Hack to have stream not keep the event loop alive.
      // See https://github.com/joyent/node/issues/1726
      if (stream._handle && stream._handle.unref) {
        stream._handle.unref();
      }
      break;

    default:
      // Probably an error on in uv_guess_handle()
      throw new Error('Implement me. Unknown stream file type!');
  }

  // For supporting legacy API we put the FD here.
  stream.fd = fd;

  stream._isStdio = true;

  return stream;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init (debug) {
  debug.inspectOpts = {};

  var keys = Object.keys(exports.inspectOpts);
  for (var i = 0; i < keys.length; i++) {
    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
  }
}

/**
 * Enable namespaces listed in `process.env.DEBUG` initially.
 */

exports.enable(load());


/***/ }),

/***/ "./node_modules/forwarded/index.js":
/*!*****************************************!*\
  !*** ./node_modules/forwarded/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * forwarded
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = forwarded

/**
 * Get all addresses in the request, using the `X-Forwarded-For` header.
 *
 * @param {object} req
 * @return {array}
 * @public
 */

function forwarded (req) {
  if (!req) {
    throw new TypeError('argument req is required')
  }

  // simple header parsing
  var proxyAddrs = parse(req.headers['x-forwarded-for'] || '')
  var socketAddr = req.connection.remoteAddress
  var addrs = [socketAddr].concat(proxyAddrs)

  // return all addresses
  return addrs
}

/**
 * Parse the X-Forwarded-For header.
 *
 * @param {string} header
 * @private
 */

function parse (header) {
  var end = header.length
  var list = []
  var start = header.length

  // gather addresses, backwards
  for (var i = header.length - 1; i >= 0; i--) {
    switch (header.charCodeAt(i)) {
      case 0x20: /*   */
        if (start === end) {
          start = end = i
        }
        break
      case 0x2c: /* , */
        if (start !== end) {
          list.push(header.substring(start, end))
        }
        start = end = i
        break
      default:
        start = i
        break
    }
  }

  // final address
  if (start !== end) {
    list.push(header.substring(start, end))
  }

  return list
}


/***/ }),

/***/ "./node_modules/fresh/index.js":
/*!*************************************!*\
  !*** ./node_modules/fresh/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * fresh
 * Copyright(c) 2012 TJ Holowaychuk
 * Copyright(c) 2016-2017 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * RegExp to check for no-cache token in Cache-Control.
 * @private
 */

var CACHE_CONTROL_NO_CACHE_REGEXP = /(?:^|,)\s*?no-cache\s*?(?:,|$)/

/**
 * Module exports.
 * @public
 */

module.exports = fresh

/**
 * Check freshness of the response using request and response headers.
 *
 * @param {Object} reqHeaders
 * @param {Object} resHeaders
 * @return {Boolean}
 * @public
 */

function fresh (reqHeaders, resHeaders) {
  // fields
  var modifiedSince = reqHeaders['if-modified-since']
  var noneMatch = reqHeaders['if-none-match']

  // unconditional request
  if (!modifiedSince && !noneMatch) {
    return false
  }

  // Always return stale when Cache-Control: no-cache
  // to support end-to-end reload requests
  // https://tools.ietf.org/html/rfc2616#section-14.9.4
  var cacheControl = reqHeaders['cache-control']
  if (cacheControl && CACHE_CONTROL_NO_CACHE_REGEXP.test(cacheControl)) {
    return false
  }

  // if-none-match
  if (noneMatch && noneMatch !== '*') {
    var etag = resHeaders['etag']

    if (!etag) {
      return false
    }

    var etagStale = true
    var matches = parseTokenList(noneMatch)
    for (var i = 0; i < matches.length; i++) {
      var match = matches[i]
      if (match === etag || match === 'W/' + etag || 'W/' + match === etag) {
        etagStale = false
        break
      }
    }

    if (etagStale) {
      return false
    }
  }

  // if-modified-since
  if (modifiedSince) {
    var lastModified = resHeaders['last-modified']
    var modifiedStale = !lastModified || !(parseHttpDate(lastModified) <= parseHttpDate(modifiedSince))

    if (modifiedStale) {
      return false
    }
  }

  return true
}

/**
 * Parse an HTTP Date into a number.
 *
 * @param {string} date
 * @private
 */

function parseHttpDate (date) {
  var timestamp = date && Date.parse(date)

  // istanbul ignore next: guard against date.js Date.parse patching
  return typeof timestamp === 'number'
    ? timestamp
    : NaN
}

/**
 * Parse a HTTP token list.
 *
 * @param {string} str
 * @private
 */

function parseTokenList (str) {
  var end = 0
  var list = []
  var start = 0

  // gather tokens
  for (var i = 0, len = str.length; i < len; i++) {
    switch (str.charCodeAt(i)) {
      case 0x20: /*   */
        if (start === end) {
          start = end = i + 1
        }
        break
      case 0x2c: /* , */
        list.push(str.substring(start, end))
        start = end = i + 1
        break
      default:
        end = i + 1
        break
    }
  }

  // final token
  list.push(str.substring(start, end))

  return list
}


/***/ }),

/***/ "./node_modules/glob-parent/index.js":
/*!*******************************************!*\
  !*** ./node_modules/glob-parent/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isGlob = __webpack_require__(/*! is-glob */ "./node_modules/is-glob/index.js");
var pathPosixDirname = __webpack_require__(/*! path */ "path").posix.dirname;
var isWin32 = __webpack_require__(/*! os */ "os").platform() === 'win32';

var slash = '/';
var backslash = /\\/g;
var enclosure = /[\{\[].*[\/]*.*[\}\]]$/;
var globby = /(^|[^\\])([\{\[]|\([^\)]+$)/;
var escaped = /\\([\*\?\|\[\]\(\)\{\}])/g;

module.exports = function globParent(str) {
  // flip windows path separators
  if (isWin32 && str.indexOf(slash) < 0) {
    str = str.replace(backslash, slash);
  }

  // special case for strings ending in enclosure containing path separator
  if (enclosure.test(str)) {
    str += slash;
  }

  // preserves full path in case of trailing path separator
  str += 'a';

  // remove path parts that are globby
  do {
    str = pathPosixDirname(str);
  } while (isGlob(str) || globby.test(str));

  // remove escape chars and return result
  return str.replace(escaped, '$1');
};


/***/ }),

/***/ "./node_modules/http-errors/index.js":
/*!*******************************************!*\
  !*** ./node_modules/http-errors/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * http-errors
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var deprecate = __webpack_require__(/*! depd */ "./node_modules/depd/index.js")('http-errors')
var setPrototypeOf = __webpack_require__(/*! setprototypeof */ "./node_modules/setprototypeof/index.js")
var statuses = __webpack_require__(/*! statuses */ "./node_modules/statuses/index.js")
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits.js")
var toIdentifier = __webpack_require__(/*! toidentifier */ "./node_modules/toidentifier/index.js")

/**
 * Module exports.
 * @public
 */

module.exports = createError
module.exports.HttpError = createHttpErrorConstructor()

// Populate exports for all constructors
populateConstructorExports(module.exports, statuses.codes, module.exports.HttpError)

/**
 * Get the code class of a status code.
 * @private
 */

function codeClass (status) {
  return Number(String(status).charAt(0) + '00')
}

/**
 * Create a new HTTP Error.
 *
 * @returns {Error}
 * @public
 */

function createError () {
  // so much arity going on ~_~
  var err
  var msg
  var status = 500
  var props = {}
  for (var i = 0; i < arguments.length; i++) {
    var arg = arguments[i]
    if (arg instanceof Error) {
      err = arg
      status = err.status || err.statusCode || status
      continue
    }
    switch (typeof arg) {
      case 'string':
        msg = arg
        break
      case 'number':
        status = arg
        if (i !== 0) {
          deprecate('non-first-argument status code; replace with createError(' + arg + ', ...)')
        }
        break
      case 'object':
        props = arg
        break
    }
  }

  if (typeof status === 'number' && (status < 400 || status >= 600)) {
    deprecate('non-error status code; use only 4xx or 5xx status codes')
  }

  if (typeof status !== 'number' ||
    (!statuses[status] && (status < 400 || status >= 600))) {
    status = 500
  }

  // constructor
  var HttpError = createError[status] || createError[codeClass(status)]

  if (!err) {
    // create error
    err = HttpError
      ? new HttpError(msg)
      : new Error(msg || statuses[status])
    Error.captureStackTrace(err, createError)
  }

  if (!HttpError || !(err instanceof HttpError) || err.status !== status) {
    // add properties to generic error
    err.expose = status < 500
    err.status = err.statusCode = status
  }

  for (var key in props) {
    if (key !== 'status' && key !== 'statusCode') {
      err[key] = props[key]
    }
  }

  return err
}

/**
 * Create HTTP error abstract base class.
 * @private
 */

function createHttpErrorConstructor () {
  function HttpError () {
    throw new TypeError('cannot construct abstract class')
  }

  inherits(HttpError, Error)

  return HttpError
}

/**
 * Create a constructor for a client error.
 * @private
 */

function createClientErrorConstructor (HttpError, name, code) {
  var className = name.match(/Error$/) ? name : name + 'Error'

  function ClientError (message) {
    // create the error object
    var msg = message != null ? message : statuses[code]
    var err = new Error(msg)

    // capture a stack trace to the construction point
    Error.captureStackTrace(err, ClientError)

    // adjust the [[Prototype]]
    setPrototypeOf(err, ClientError.prototype)

    // redefine the error message
    Object.defineProperty(err, 'message', {
      enumerable: true,
      configurable: true,
      value: msg,
      writable: true
    })

    // redefine the error name
    Object.defineProperty(err, 'name', {
      enumerable: false,
      configurable: true,
      value: className,
      writable: true
    })

    return err
  }

  inherits(ClientError, HttpError)
  nameFunc(ClientError, className)

  ClientError.prototype.status = code
  ClientError.prototype.statusCode = code
  ClientError.prototype.expose = true

  return ClientError
}

/**
 * Create a constructor for a server error.
 * @private
 */

function createServerErrorConstructor (HttpError, name, code) {
  var className = name.match(/Error$/) ? name : name + 'Error'

  function ServerError (message) {
    // create the error object
    var msg = message != null ? message : statuses[code]
    var err = new Error(msg)

    // capture a stack trace to the construction point
    Error.captureStackTrace(err, ServerError)

    // adjust the [[Prototype]]
    setPrototypeOf(err, ServerError.prototype)

    // redefine the error message
    Object.defineProperty(err, 'message', {
      enumerable: true,
      configurable: true,
      value: msg,
      writable: true
    })

    // redefine the error name
    Object.defineProperty(err, 'name', {
      enumerable: false,
      configurable: true,
      value: className,
      writable: true
    })

    return err
  }

  inherits(ServerError, HttpError)
  nameFunc(ServerError, className)

  ServerError.prototype.status = code
  ServerError.prototype.statusCode = code
  ServerError.prototype.expose = false

  return ServerError
}

/**
 * Set the name of a function, if possible.
 * @private
 */

function nameFunc (func, name) {
  var desc = Object.getOwnPropertyDescriptor(func, 'name')

  if (desc && desc.configurable) {
    desc.value = name
    Object.defineProperty(func, 'name', desc)
  }
}

/**
 * Populate the exports object with constructors for every error class.
 * @private
 */

function populateConstructorExports (exports, codes, HttpError) {
  codes.forEach(function forEachCode (code) {
    var CodeError
    var name = toIdentifier(statuses[code])

    switch (codeClass(code)) {
      case 400:
        CodeError = createClientErrorConstructor(HttpError, name, code)
        break
      case 500:
        CodeError = createServerErrorConstructor(HttpError, name, code)
        break
    }

    if (CodeError) {
      // export the constructor
      exports[code] = CodeError
      exports[name] = CodeError
    }
  })

  // backwards-compatibility
  exports["I'mateapot"] = deprecate.function(exports.ImATeapot,
    '"I\'mateapot"; use "ImATeapot" instead')
}


/***/ }),

/***/ "./node_modules/iconv-lite/encodings/dbcs-codec.js":
/*!*********************************************************!*\
  !*** ./node_modules/iconv-lite/encodings/dbcs-codec.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Buffer = __webpack_require__(/*! safer-buffer */ "./node_modules/safer-buffer/safer.js").Buffer;

// Multibyte codec. In this scheme, a character is represented by 1 or more bytes.
// Our codec supports UTF-16 surrogates, extensions for GB18030 and unicode sequences.
// To save memory and loading time, we read table files only when requested.

exports._dbcs = DBCSCodec;

var UNASSIGNED = -1,
    GB18030_CODE = -2,
    SEQ_START  = -10,
    NODE_START = -1000,
    UNASSIGNED_NODE = new Array(0x100),
    DEF_CHAR = -1;

for (var i = 0; i < 0x100; i++)
    UNASSIGNED_NODE[i] = UNASSIGNED;


// Class DBCSCodec reads and initializes mapping tables.
function DBCSCodec(codecOptions, iconv) {
    this.encodingName = codecOptions.encodingName;
    if (!codecOptions)
        throw new Error("DBCS codec is called without the data.")
    if (!codecOptions.table)
        throw new Error("Encoding '" + this.encodingName + "' has no data.");

    // Load tables.
    var mappingTable = codecOptions.table();


    // Decode tables: MBCS -> Unicode.

    // decodeTables is a trie, encoded as an array of arrays of integers. Internal arrays are trie nodes and all have len = 256.
    // Trie root is decodeTables[0].
    // Values: >=  0 -> unicode character code. can be > 0xFFFF
    //         == UNASSIGNED -> unknown/unassigned sequence.
    //         == GB18030_CODE -> this is the end of a GB18030 4-byte sequence.
    //         <= NODE_START -> index of the next node in our trie to process next byte.
    //         <= SEQ_START  -> index of the start of a character code sequence, in decodeTableSeq.
    this.decodeTables = [];
    this.decodeTables[0] = UNASSIGNED_NODE.slice(0); // Create root node.

    // Sometimes a MBCS char corresponds to a sequence of unicode chars. We store them as arrays of integers here. 
    this.decodeTableSeq = [];

    // Actual mapping tables consist of chunks. Use them to fill up decode tables.
    for (var i = 0; i < mappingTable.length; i++)
        this._addDecodeChunk(mappingTable[i]);

    this.defaultCharUnicode = iconv.defaultCharUnicode;

    
    // Encode tables: Unicode -> DBCS.

    // `encodeTable` is array mapping from unicode char to encoded char. All its values are integers for performance.
    // Because it can be sparse, it is represented as array of buckets by 256 chars each. Bucket can be null.
    // Values: >=  0 -> it is a normal char. Write the value (if <=256 then 1 byte, if <=65536 then 2 bytes, etc.).
    //         == UNASSIGNED -> no conversion found. Output a default char.
    //         <= SEQ_START  -> it's an index in encodeTableSeq, see below. The character starts a sequence.
    this.encodeTable = [];
    
    // `encodeTableSeq` is used when a sequence of unicode characters is encoded as a single code. We use a tree of
    // objects where keys correspond to characters in sequence and leafs are the encoded dbcs values. A special DEF_CHAR key
    // means end of sequence (needed when one sequence is a strict subsequence of another).
    // Objects are kept separately from encodeTable to increase performance.
    this.encodeTableSeq = [];

    // Some chars can be decoded, but need not be encoded.
    var skipEncodeChars = {};
    if (codecOptions.encodeSkipVals)
        for (var i = 0; i < codecOptions.encodeSkipVals.length; i++) {
            var val = codecOptions.encodeSkipVals[i];
            if (typeof val === 'number')
                skipEncodeChars[val] = true;
            else
                for (var j = val.from; j <= val.to; j++)
                    skipEncodeChars[j] = true;
        }
        
    // Use decode trie to recursively fill out encode tables.
    this._fillEncodeTable(0, 0, skipEncodeChars);

    // Add more encoding pairs when needed.
    if (codecOptions.encodeAdd) {
        for (var uChar in codecOptions.encodeAdd)
            if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar))
                this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
    }

    this.defCharSB  = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
    if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]['?'];
    if (this.defCharSB === UNASSIGNED) this.defCharSB = "?".charCodeAt(0);


    // Load & create GB18030 tables when needed.
    if (typeof codecOptions.gb18030 === 'function') {
        this.gb18030 = codecOptions.gb18030(); // Load GB18030 ranges.

        // Add GB18030 decode tables.
        var thirdByteNodeIdx = this.decodeTables.length;
        var thirdByteNode = this.decodeTables[thirdByteNodeIdx] = UNASSIGNED_NODE.slice(0);

        var fourthByteNodeIdx = this.decodeTables.length;
        var fourthByteNode = this.decodeTables[fourthByteNodeIdx] = UNASSIGNED_NODE.slice(0);

        for (var i = 0x81; i <= 0xFE; i++) {
            var secondByteNodeIdx = NODE_START - this.decodeTables[0][i];
            var secondByteNode = this.decodeTables[secondByteNodeIdx];
            for (var j = 0x30; j <= 0x39; j++)
                secondByteNode[j] = NODE_START - thirdByteNodeIdx;
        }
        for (var i = 0x81; i <= 0xFE; i++)
            thirdByteNode[i] = NODE_START - fourthByteNodeIdx;
        for (var i = 0x30; i <= 0x39; i++)
            fourthByteNode[i] = GB18030_CODE
    }        
}

DBCSCodec.prototype.encoder = DBCSEncoder;
DBCSCodec.prototype.decoder = DBCSDecoder;

// Decoder helpers
DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
    var bytes = [];
    for (; addr > 0; addr >>= 8)
        bytes.push(addr & 0xFF);
    if (bytes.length == 0)
        bytes.push(0);

    var node = this.decodeTables[0];
    for (var i = bytes.length-1; i > 0; i--) { // Traverse nodes deeper into the trie.
        var val = node[bytes[i]];

        if (val == UNASSIGNED) { // Create new node.
            node[bytes[i]] = NODE_START - this.decodeTables.length;
            this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));
        }
        else if (val <= NODE_START) { // Existing node.
            node = this.decodeTables[NODE_START - val];
        }
        else
            throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
    }
    return node;
}


DBCSCodec.prototype._addDecodeChunk = function(chunk) {
    // First element of chunk is the hex mbcs code where we start.
    var curAddr = parseInt(chunk[0], 16);

    // Choose the decoding node where we'll write our chars.
    var writeTable = this._getDecodeTrieNode(curAddr);
    curAddr = curAddr & 0xFF;

    // Write all other elements of the chunk to the table.
    for (var k = 1; k < chunk.length; k++) {
        var part = chunk[k];
        if (typeof part === "string") { // String, write as-is.
            for (var l = 0; l < part.length;) {
                var code = part.charCodeAt(l++);
                if (0xD800 <= code && code < 0xDC00) { // Decode surrogate
                    var codeTrail = part.charCodeAt(l++);
                    if (0xDC00 <= codeTrail && codeTrail < 0xE000)
                        writeTable[curAddr++] = 0x10000 + (code - 0xD800) * 0x400 + (codeTrail - 0xDC00);
                    else
                        throw new Error("Incorrect surrogate pair in "  + this.encodingName + " at chunk " + chunk[0]);
                }
                else if (0x0FF0 < code && code <= 0x0FFF) { // Character sequence (our own encoding used)
                    var len = 0xFFF - code + 2;
                    var seq = [];
                    for (var m = 0; m < len; m++)
                        seq.push(part.charCodeAt(l++)); // Simple variation: don't support surrogates or subsequences in seq.

                    writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
                    this.decodeTableSeq.push(seq);
                }
                else
                    writeTable[curAddr++] = code; // Basic char
            }
        } 
        else if (typeof part === "number") { // Integer, meaning increasing sequence starting with prev character.
            var charCode = writeTable[curAddr - 1] + 1;
            for (var l = 0; l < part; l++)
                writeTable[curAddr++] = charCode++;
        }
        else
            throw new Error("Incorrect type '" + typeof part + "' given in "  + this.encodingName + " at chunk " + chunk[0]);
    }
    if (curAddr > 0xFF)
        throw new Error("Incorrect chunk in "  + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
}

// Encoder helpers
DBCSCodec.prototype._getEncodeBucket = function(uCode) {
    var high = uCode >> 8; // This could be > 0xFF because of astral characters.
    if (this.encodeTable[high] === undefined)
        this.encodeTable[high] = UNASSIGNED_NODE.slice(0); // Create bucket on demand.
    return this.encodeTable[high];
}

DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 0xFF;
    if (bucket[low] <= SEQ_START)
        this.encodeTableSeq[SEQ_START-bucket[low]][DEF_CHAR] = dbcsCode; // There's already a sequence, set a single-char subsequence of it.
    else if (bucket[low] == UNASSIGNED)
        bucket[low] = dbcsCode;
}

DBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {
    
    // Get the root of character tree according to first character of the sequence.
    var uCode = seq[0];
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 0xFF;

    var node;
    if (bucket[low] <= SEQ_START) {
        // There's already a sequence with  - use it.
        node = this.encodeTableSeq[SEQ_START-bucket[low]];
    }
    else {
        // There was no sequence object - allocate a new one.
        node = {};
        if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low]; // If a char was set before - make it a single-char subsequence.
        bucket[low] = SEQ_START - this.encodeTableSeq.length;
        this.encodeTableSeq.push(node);
    }

    // Traverse the character tree, allocating new nodes as needed.
    for (var j = 1; j < seq.length-1; j++) {
        var oldVal = node[uCode];
        if (typeof oldVal === 'object')
            node = oldVal;
        else {
            node = node[uCode] = {}
            if (oldVal !== undefined)
                node[DEF_CHAR] = oldVal
        }
    }

    // Set the leaf to given dbcsCode.
    uCode = seq[seq.length-1];
    node[uCode] = dbcsCode;
}

DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {
    var node = this.decodeTables[nodeIdx];
    for (var i = 0; i < 0x100; i++) {
        var uCode = node[i];
        var mbCode = prefix + i;
        if (skipEncodeChars[mbCode])
            continue;

        if (uCode >= 0)
            this._setEncodeChar(uCode, mbCode);
        else if (uCode <= NODE_START)
            this._fillEncodeTable(NODE_START - uCode, mbCode << 8, skipEncodeChars);
        else if (uCode <= SEQ_START)
            this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
    }
}



// == Encoder ==================================================================

function DBCSEncoder(options, codec) {
    // Encoder state
    this.leadSurrogate = -1;
    this.seqObj = undefined;
    
    // Static data
    this.encodeTable = codec.encodeTable;
    this.encodeTableSeq = codec.encodeTableSeq;
    this.defaultCharSingleByte = codec.defCharSB;
    this.gb18030 = codec.gb18030;
}

DBCSEncoder.prototype.write = function(str) {
    var newBuf = Buffer.alloc(str.length * (this.gb18030 ? 4 : 3)),
        leadSurrogate = this.leadSurrogate,
        seqObj = this.seqObj, nextChar = -1,
        i = 0, j = 0;

    while (true) {
        // 0. Get next character.
        if (nextChar === -1) {
            if (i == str.length) break;
            var uCode = str.charCodeAt(i++);
        }
        else {
            var uCode = nextChar;
            nextChar = -1;    
        }

        // 1. Handle surrogates.
        if (0xD800 <= uCode && uCode < 0xE000) { // Char is one of surrogates.
            if (uCode < 0xDC00) { // We've got lead surrogate.
                if (leadSurrogate === -1) {
                    leadSurrogate = uCode;
                    continue;
                } else {
                    leadSurrogate = uCode;
                    // Double lead surrogate found.
                    uCode = UNASSIGNED;
                }
            } else { // We've got trail surrogate.
                if (leadSurrogate !== -1) {
                    uCode = 0x10000 + (leadSurrogate - 0xD800) * 0x400 + (uCode - 0xDC00);
                    leadSurrogate = -1;
                } else {
                    // Incomplete surrogate pair - only trail surrogate found.
                    uCode = UNASSIGNED;
                }
                
            }
        }
        else if (leadSurrogate !== -1) {
            // Incomplete surrogate pair - only lead surrogate found.
            nextChar = uCode; uCode = UNASSIGNED; // Write an error, then current char.
            leadSurrogate = -1;
        }

        // 2. Convert uCode character.
        var dbcsCode = UNASSIGNED;
        if (seqObj !== undefined && uCode != UNASSIGNED) { // We are in the middle of the sequence
            var resCode = seqObj[uCode];
            if (typeof resCode === 'object') { // Sequence continues.
                seqObj = resCode;
                continue;

            } else if (typeof resCode == 'number') { // Sequence finished. Write it.
                dbcsCode = resCode;

            } else if (resCode == undefined) { // Current character is not part of the sequence.

                // Try default character for this sequence
                resCode = seqObj[DEF_CHAR];
                if (resCode !== undefined) {
                    dbcsCode = resCode; // Found. Write it.
                    nextChar = uCode; // Current character will be written too in the next iteration.

                } else {
                    // TODO: What if we have no default? (resCode == undefined)
                    // Then, we should write first char of the sequence as-is and try the rest recursively.
                    // Didn't do it for now because no encoding has this situation yet.
                    // Currently, just skip the sequence and write current char.
                }
            }
            seqObj = undefined;
        }
        else if (uCode >= 0) {  // Regular character
            var subtable = this.encodeTable[uCode >> 8];
            if (subtable !== undefined)
                dbcsCode = subtable[uCode & 0xFF];
            
            if (dbcsCode <= SEQ_START) { // Sequence start
                seqObj = this.encodeTableSeq[SEQ_START-dbcsCode];
                continue;
            }

            if (dbcsCode == UNASSIGNED && this.gb18030) {
                // Use GB18030 algorithm to find character(s) to write.
                var idx = findIdx(this.gb18030.uChars, uCode);
                if (idx != -1) {
                    var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
                    newBuf[j++] = 0x81 + Math.floor(dbcsCode / 12600); dbcsCode = dbcsCode % 12600;
                    newBuf[j++] = 0x30 + Math.floor(dbcsCode / 1260); dbcsCode = dbcsCode % 1260;
                    newBuf[j++] = 0x81 + Math.floor(dbcsCode / 10); dbcsCode = dbcsCode % 10;
                    newBuf[j++] = 0x30 + dbcsCode;
                    continue;
                }
            }
        }

        // 3. Write dbcsCode character.
        if (dbcsCode === UNASSIGNED)
            dbcsCode = this.defaultCharSingleByte;
        
        if (dbcsCode < 0x100) {
            newBuf[j++] = dbcsCode;
        }
        else if (dbcsCode < 0x10000) {
            newBuf[j++] = dbcsCode >> 8;   // high byte
            newBuf[j++] = dbcsCode & 0xFF; // low byte
        }
        else {
            newBuf[j++] = dbcsCode >> 16;
            newBuf[j++] = (dbcsCode >> 8) & 0xFF;
            newBuf[j++] = dbcsCode & 0xFF;
        }
    }

    this.seqObj = seqObj;
    this.leadSurrogate = leadSurrogate;
    return newBuf.slice(0, j);
}

DBCSEncoder.prototype.end = function() {
    if (this.leadSurrogate === -1 && this.seqObj === undefined)
        return; // All clean. Most often case.

    var newBuf = Buffer.alloc(10), j = 0;

    if (this.seqObj) { // We're in the sequence.
        var dbcsCode = this.seqObj[DEF_CHAR];
        if (dbcsCode !== undefined) { // Write beginning of the sequence.
            if (dbcsCode < 0x100) {
                newBuf[j++] = dbcsCode;
            }
            else {
                newBuf[j++] = dbcsCode >> 8;   // high byte
                newBuf[j++] = dbcsCode & 0xFF; // low byte
            }
        } else {
            // See todo above.
        }
        this.seqObj = undefined;
    }

    if (this.leadSurrogate !== -1) {
        // Incomplete surrogate pair - only lead surrogate found.
        newBuf[j++] = this.defaultCharSingleByte;
        this.leadSurrogate = -1;
    }
    
    return newBuf.slice(0, j);
}

// Export for testing
DBCSEncoder.prototype.findIdx = findIdx;


// == Decoder ==================================================================

function DBCSDecoder(options, codec) {
    // Decoder state
    this.nodeIdx = 0;
    this.prevBuf = Buffer.alloc(0);

    // Static data
    this.decodeTables = codec.decodeTables;
    this.decodeTableSeq = codec.decodeTableSeq;
    this.defaultCharUnicode = codec.defaultCharUnicode;
    this.gb18030 = codec.gb18030;
}

DBCSDecoder.prototype.write = function(buf) {
    var newBuf = Buffer.alloc(buf.length*2),
        nodeIdx = this.nodeIdx, 
        prevBuf = this.prevBuf, prevBufOffset = this.prevBuf.length,
        seqStart = -this.prevBuf.length, // idx of the start of current parsed sequence.
        uCode;

    if (prevBufOffset > 0) // Make prev buf overlap a little to make it easier to slice later.
        prevBuf = Buffer.concat([prevBuf, buf.slice(0, 10)]);
    
    for (var i = 0, j = 0; i < buf.length; i++) {
        var curByte = (i >= 0) ? buf[i] : prevBuf[i + prevBufOffset];

        // Lookup in current trie node.
        var uCode = this.decodeTables[nodeIdx][curByte];

        if (uCode >= 0) { 
            // Normal character, just use it.
        }
        else if (uCode === UNASSIGNED) { // Unknown char.
            // TODO: Callback with seq.
            //var curSeq = (seqStart >= 0) ? buf.slice(seqStart, i+1) : prevBuf.slice(seqStart + prevBufOffset, i+1 + prevBufOffset);
            i = seqStart; // Try to parse again, after skipping first byte of the sequence ('i' will be incremented by 'for' cycle).
            uCode = this.defaultCharUnicode.charCodeAt(0);
        }
        else if (uCode === GB18030_CODE) {
            var curSeq = (seqStart >= 0) ? buf.slice(seqStart, i+1) : prevBuf.slice(seqStart + prevBufOffset, i+1 + prevBufOffset);
            var ptr = (curSeq[0]-0x81)*12600 + (curSeq[1]-0x30)*1260 + (curSeq[2]-0x81)*10 + (curSeq[3]-0x30);
            var idx = findIdx(this.gb18030.gbChars, ptr);
            uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
        }
        else if (uCode <= NODE_START) { // Go to next trie node.
            nodeIdx = NODE_START - uCode;
            continue;
        }
        else if (uCode <= SEQ_START) { // Output a sequence of chars.
            var seq = this.decodeTableSeq[SEQ_START - uCode];
            for (var k = 0; k < seq.length - 1; k++) {
                uCode = seq[k];
                newBuf[j++] = uCode & 0xFF;
                newBuf[j++] = uCode >> 8;
            }
            uCode = seq[seq.length-1];
        }
        else
            throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);

        // Write the character to buffer, handling higher planes using surrogate pair.
        if (uCode > 0xFFFF) { 
            uCode -= 0x10000;
            var uCodeLead = 0xD800 + Math.floor(uCode / 0x400);
            newBuf[j++] = uCodeLead & 0xFF;
            newBuf[j++] = uCodeLead >> 8;

            uCode = 0xDC00 + uCode % 0x400;
        }
        newBuf[j++] = uCode & 0xFF;
        newBuf[j++] = uCode >> 8;

        // Reset trie node.
        nodeIdx = 0; seqStart = i+1;
    }

    this.nodeIdx = nodeIdx;
    this.prevBuf = (seqStart >= 0) ? buf.slice(seqStart) : prevBuf.slice(seqStart + prevBufOffset);
    return newBuf.slice(0, j).toString('ucs2');
}

DBCSDecoder.prototype.end = function() {
    var ret = '';

    // Try to parse all remaining chars.
    while (this.prevBuf.length > 0) {
        // Skip 1 character in the buffer.
        ret += this.defaultCharUnicode;
        var buf = this.prevBuf.slice(1);

        // Parse remaining as usual.
        this.prevBuf = Buffer.alloc(0);
        this.nodeIdx = 0;
        if (buf.length > 0)
            ret += this.write(buf);
    }

    this.nodeIdx = 0;
    return ret;
}

// Binary search for GB18030. Returns largest i such that table[i] <= val.
function findIdx(table, val) {
    if (table[0] > val)
        return -1;

    var l = 0, r = table.length;
    while (l < r-1) { // always table[l] <= val < table[r]
        var mid = l + Math.floor((r-l+1)/2);
        if (table[mid] <= val)
            l = mid;
        else
            r = mid;
    }
    return l;
}



/***/ }),

/***/ "./node_modules/iconv-lite/encodings/dbcs-data.js":
/*!********************************************************!*\
  !*** ./node_modules/iconv-lite/encodings/dbcs-data.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// Description of supported double byte encodings and aliases.
// Tables are not require()-d until they are needed to speed up library load.
// require()-s are direct to support Browserify.

module.exports = {
    
    // == Japanese/ShiftJIS ====================================================
    // All japanese encodings are based on JIS X set of standards:
    // JIS X 0201 - Single-byte encoding of ASCII +  + Kana chars at 0xA1-0xDF.
    // JIS X 0208 - Main set of 6879 characters, placed in 94x94 plane, to be encoded by 2 bytes. 
    //              Has several variations in 1978, 1983, 1990 and 1997.
    // JIS X 0212 - Supplementary plane of 6067 chars in 94x94 plane. 1990. Effectively dead.
    // JIS X 0213 - Extension and modern replacement of 0208 and 0212. Total chars: 11233.
    //              2 planes, first is superset of 0208, second - revised 0212.
    //              Introduced in 2000, revised 2004. Some characters are in Unicode Plane 2 (0x2xxxx)

    // Byte encodings are:
    //  * Shift_JIS: Compatible with 0201, uses not defined chars in top half as lead bytes for double-byte
    //               encoding of 0208. Lead byte ranges: 0x81-0x9F, 0xE0-0xEF; Trail byte ranges: 0x40-0x7E, 0x80-0x9E, 0x9F-0xFC.
    //               Windows CP932 is a superset of Shift_JIS. Some companies added more chars, notably KDDI.
    //  * EUC-JP:    Up to 3 bytes per character. Used mostly on *nixes.
    //               0x00-0x7F       - lower part of 0201
    //               0x8E, 0xA1-0xDF - upper part of 0201
    //               (0xA1-0xFE)x2   - 0208 plane (94x94).
    //               0x8F, (0xA1-0xFE)x2 - 0212 plane (94x94).
    //  * JIS X 208: 7-bit, direct encoding of 0208. Byte ranges: 0x21-0x7E (94 values). Uncommon.
    //               Used as-is in ISO2022 family.
    //  * ISO2022-JP: Stateful encoding, with escape sequences to switch between ASCII, 
    //                0201-1976 Roman, 0208-1978, 0208-1983.
    //  * ISO2022-JP-1: Adds esc seq for 0212-1990.
    //  * ISO2022-JP-2: Adds esc seq for GB2313-1980, KSX1001-1992, ISO8859-1, ISO8859-7.
    //  * ISO2022-JP-3: Adds esc seq for 0201-1976 Kana set, 0213-2000 Planes 1, 2.
    //  * ISO2022-JP-2004: Adds 0213-2004 Plane 1.
    //
    // After JIS X 0213 appeared, Shift_JIS-2004, EUC-JISX0213 and ISO2022-JP-2004 followed, with just changing the planes.
    //
    // Overall, it seems that it's a mess :( http://www8.plala.or.jp/tkubota1/unicode-symbols-map2.html

    'shiftjis': {
        type: '_dbcs',
        table: function() { return __webpack_require__(/*! ./tables/shiftjis.json */ "./node_modules/iconv-lite/encodings/tables/shiftjis.json") },
        encodeAdd: {'\u00a5': 0x5C, '\u203E': 0x7E},
        encodeSkipVals: [{from: 0xED40, to: 0xF940}],
    },
    'csshiftjis': 'shiftjis',
    'mskanji': 'shiftjis',
    'sjis': 'shiftjis',
    'windows31j': 'shiftjis',
    'ms31j': 'shiftjis',
    'xsjis': 'shiftjis',
    'windows932': 'shiftjis',
    'ms932': 'shiftjis',
    '932': 'shiftjis',
    'cp932': 'shiftjis',

    'eucjp': {
        type: '_dbcs',
        table: function() { return __webpack_require__(/*! ./tables/eucjp.json */ "./node_modules/iconv-lite/encodings/tables/eucjp.json") },
        encodeAdd: {'\u00a5': 0x5C, '\u203E': 0x7E},
    },

    // TODO: KDDI extension to Shift_JIS
    // TODO: IBM CCSID 942 = CP932, but F0-F9 custom chars and other char changes.
    // TODO: IBM CCSID 943 = Shift_JIS = CP932 with original Shift_JIS lower 128 chars.


    // == Chinese/GBK ==========================================================
    // http://en.wikipedia.org/wiki/GBK
    // We mostly implement W3C recommendation: https://www.w3.org/TR/encoding/#gbk-encoder

    // Oldest GB2312 (1981, ~7600 chars) is a subset of CP936
    'gb2312': 'cp936',
    'gb231280': 'cp936',
    'gb23121980': 'cp936',
    'csgb2312': 'cp936',
    'csiso58gb231280': 'cp936',
    'euccn': 'cp936',

    // Microsoft's CP936 is a subset and approximation of GBK.
    'windows936': 'cp936',
    'ms936': 'cp936',
    '936': 'cp936',
    'cp936': {
        type: '_dbcs',
        table: function() { return __webpack_require__(/*! ./tables/cp936.json */ "./node_modules/iconv-lite/encodings/tables/cp936.json") },
    },

    // GBK (~22000 chars) is an extension of CP936 that added user-mapped chars and some other.
    'gbk': {
        type: '_dbcs',
        table: function() { return __webpack_require__(/*! ./tables/cp936.json */ "./node_modules/iconv-lite/encodings/tables/cp936.json").concat(__webpack_require__(/*! ./tables/gbk-added.json */ "./node_modules/iconv-lite/encodings/tables/gbk-added.json")) },
    },
    'xgbk': 'gbk',
    'isoir58': 'gbk',

    // GB18030 is an algorithmic extension of GBK.
    // Main source: https://www.w3.org/TR/encoding/#gbk-encoder
    // http://icu-project.org/docs/papers/gb18030.html
    // http://source.icu-project.org/repos/icu/data/trunk/charset/data/xml/gb-18030-2000.xml
    // http://www.khngai.com/chinese/charmap/tblgbk.php?page=0
    'gb18030': {
        type: '_dbcs',
        table: function() { return __webpack_require__(/*! ./tables/cp936.json */ "./node_modules/iconv-lite/encodings/tables/cp936.json").concat(__webpack_require__(/*! ./tables/gbk-added.json */ "./node_modules/iconv-lite/encodings/tables/gbk-added.json")) },
        gb18030: function() { return __webpack_require__(/*! ./tables/gb18030-ranges.json */ "./node_modules/iconv-lite/encodings/tables/gb18030-ranges.json") },
        encodeSkipVals: [0x80],
        encodeAdd: {'': 0xA2E3},
    },

    'chinese': 'gb18030',


    // == Korean ===============================================================
    // EUC-KR, KS_C_5601 and KS X 1001 are exactly the same.
    'windows949': 'cp949',
    'ms949': 'cp949',
    '949': 'cp949',
    'cp949': {
        type: '_dbcs',
        table: function() { return __webpack_require__(/*! ./tables/cp949.json */ "./node_modules/iconv-lite/encodings/tables/cp949.json") },
    },

    'cseuckr': 'cp949',
    'csksc56011987': 'cp949',
    'euckr': 'cp949',
    'isoir149': 'cp949',
    'korean': 'cp949',
    'ksc56011987': 'cp949',
    'ksc56011989': 'cp949',
    'ksc5601': 'cp949',


    // == Big5/Taiwan/Hong Kong ================================================
    // There are lots of tables for Big5 and cp950. Please see the following links for history:
    // http://moztw.org/docs/big5/  http://www.haible.de/bruno/charsets/conversion-tables/Big5.html
    // Variations, in roughly number of defined chars:
    //  * Windows CP 950: Microsoft variant of Big5. Canonical: http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP950.TXT
    //  * Windows CP 951: Microsoft variant of Big5-HKSCS-2001. Seems to be never public. http://me.abelcheung.org/articles/research/what-is-cp951/
    //  * Big5-2003 (Taiwan standard) almost superset of cp950.
    //  * Unicode-at-on (UAO) / Mozilla 1.8. Falling out of use on the Web. Not supported by other browsers.
    //  * Big5-HKSCS (-2001, -2004, -2008). Hong Kong standard. 
    //    many unicode code points moved from PUA to Supplementary plane (U+2XXXX) over the years.
    //    Plus, it has 4 combining sequences.
    //    Seems that Mozilla refused to support it for 10 yrs. https://bugzilla.mozilla.org/show_bug.cgi?id=162431 https://bugzilla.mozilla.org/show_bug.cgi?id=310299
    //    because big5-hkscs is the only encoding to include astral characters in non-algorithmic way.
    //    Implementations are not consistent within browsers; sometimes labeled as just big5.
    //    MS Internet Explorer switches from big5 to big5-hkscs when a patch applied.
    //    Great discussion & recap of what's going on https://bugzilla.mozilla.org/show_bug.cgi?id=912470#c31
    //    In the encoder, it might make sense to support encoding old PUA mappings to Big5 bytes seq-s.
    //    Official spec: http://www.ogcio.gov.hk/en/business/tech_promotion/ccli/terms/doc/2003cmp_2008.txt
    //                   http://www.ogcio.gov.hk/tc/business/tech_promotion/ccli/terms/doc/hkscs-2008-big5-iso.txt
    // 
    // Current understanding of how to deal with Big5(-HKSCS) is in the Encoding Standard, http://encoding.spec.whatwg.org/#big5-encoder
    // Unicode mapping (http://www.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/OTHER/BIG5.TXT) is said to be wrong.

    'windows950': 'cp950',
    'ms950': 'cp950',
    '950': 'cp950',
    'cp950': {
        type: '_dbcs',
        table: function() { return __webpack_require__(/*! ./tables/cp950.json */ "./node_modules/iconv-lite/encodings/tables/cp950.json") },
    },

    // Big5 has many variations and is an extension of cp950. We use Encoding Standard's as a consensus.
    'big5': 'big5hkscs',
    'big5hkscs': {
        type: '_dbcs',
        table: function() { return __webpack_require__(/*! ./tables/cp950.json */ "./node_modules/iconv-lite/encodings/tables/cp950.json").concat(__webpack_require__(/*! ./tables/big5-added.json */ "./node_modules/iconv-lite/encodings/tables/big5-added.json")) },
        encodeSkipVals: [0xa2cc],
    },

    'cnbig5': 'big5hkscs',
    'csbig5': 'big5hkscs',
    'xxbig5': 'big5hkscs',
};


/***/ }),

/***/ "./node_modules/iconv-lite/encodings/index.js":
/*!****************************************************!*\
  !*** ./node_modules/iconv-lite/encodings/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// Update this array if you add/rename/remove files in this directory.
// We support Browserify by skipping automatic module discovery and requiring modules directly.
var modules = [
    __webpack_require__(/*! ./internal */ "./node_modules/iconv-lite/encodings/internal.js"),
    __webpack_require__(/*! ./utf16 */ "./node_modules/iconv-lite/encodings/utf16.js"),
    __webpack_require__(/*! ./utf7 */ "./node_modules/iconv-lite/encodings/utf7.js"),
    __webpack_require__(/*! ./sbcs-codec */ "./node_modules/iconv-lite/encodings/sbcs-codec.js"),
    __webpack_require__(/*! ./sbcs-data */ "./node_modules/iconv-lite/encodings/sbcs-data.js"),
    __webpack_require__(/*! ./sbcs-data-generated */ "./node_modules/iconv-lite/encodings/sbcs-data-generated.js"),
    __webpack_require__(/*! ./dbcs-codec */ "./node_modules/iconv-lite/encodings/dbcs-codec.js"),
    __webpack_require__(/*! ./dbcs-data */ "./node_modules/iconv-lite/encodings/dbcs-data.js"),
];

// Put all encoding/alias/codec definitions to single object and export it. 
for (var i = 0; i < modules.length; i++) {
    var module = modules[i];
    for (var enc in module)
        if (Object.prototype.hasOwnProperty.call(module, enc))
            exports[enc] = module[enc];
}


/***/ }),

/***/ "./node_modules/iconv-lite/encodings/internal.js":
/*!*******************************************************!*\
  !*** ./node_modules/iconv-lite/encodings/internal.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Buffer = __webpack_require__(/*! safer-buffer */ "./node_modules/safer-buffer/safer.js").Buffer;

// Export Node.js internal encodings.

module.exports = {
    // Encodings
    utf8:   { type: "_internal", bomAware: true},
    cesu8:  { type: "_internal", bomAware: true},
    unicode11utf8: "utf8",

    ucs2:   { type: "_internal", bomAware: true},
    utf16le: "ucs2",

    binary: { type: "_internal" },
    base64: { type: "_internal" },
    hex:    { type: "_internal" },

    // Codec.
    _internal: InternalCodec,
};

//------------------------------------------------------------------------------

function InternalCodec(codecOptions, iconv) {
    this.enc = codecOptions.encodingName;
    this.bomAware = codecOptions.bomAware;

    if (this.enc === "base64")
        this.encoder = InternalEncoderBase64;
    else if (this.enc === "cesu8") {
        this.enc = "utf8"; // Use utf8 for decoding.
        this.encoder = InternalEncoderCesu8;

        // Add decoder for versions of Node not supporting CESU-8
        if (Buffer.from('eda0bdedb2a9', 'hex').toString() !== '') {
            this.decoder = InternalDecoderCesu8;
            this.defaultCharUnicode = iconv.defaultCharUnicode;
        }
    }
}

InternalCodec.prototype.encoder = InternalEncoder;
InternalCodec.prototype.decoder = InternalDecoder;

//------------------------------------------------------------------------------

// We use node.js internal decoder. Its signature is the same as ours.
var StringDecoder = __webpack_require__(/*! string_decoder */ "string_decoder").StringDecoder;

if (!StringDecoder.prototype.end) // Node v0.8 doesn't have this method.
    StringDecoder.prototype.end = function() {};


function InternalDecoder(options, codec) {
    StringDecoder.call(this, codec.enc);
}

InternalDecoder.prototype = StringDecoder.prototype;


//------------------------------------------------------------------------------
// Encoder is mostly trivial

function InternalEncoder(options, codec) {
    this.enc = codec.enc;
}

InternalEncoder.prototype.write = function(str) {
    return Buffer.from(str, this.enc);
}

InternalEncoder.prototype.end = function() {
}


//------------------------------------------------------------------------------
// Except base64 encoder, which must keep its state.

function InternalEncoderBase64(options, codec) {
    this.prevStr = '';
}

InternalEncoderBase64.prototype.write = function(str) {
    str = this.prevStr + str;
    var completeQuads = str.length - (str.length % 4);
    this.prevStr = str.slice(completeQuads);
    str = str.slice(0, completeQuads);

    return Buffer.from(str, "base64");
}

InternalEncoderBase64.prototype.end = function() {
    return Buffer.from(this.prevStr, "base64");
}


//------------------------------------------------------------------------------
// CESU-8 encoder is also special.

function InternalEncoderCesu8(options, codec) {
}

InternalEncoderCesu8.prototype.write = function(str) {
    var buf = Buffer.alloc(str.length * 3), bufIdx = 0;
    for (var i = 0; i < str.length; i++) {
        var charCode = str.charCodeAt(i);
        // Naive implementation, but it works because CESU-8 is especially easy
        // to convert from UTF-16 (which all JS strings are encoded in).
        if (charCode < 0x80)
            buf[bufIdx++] = charCode;
        else if (charCode < 0x800) {
            buf[bufIdx++] = 0xC0 + (charCode >>> 6);
            buf[bufIdx++] = 0x80 + (charCode & 0x3f);
        }
        else { // charCode will always be < 0x10000 in javascript.
            buf[bufIdx++] = 0xE0 + (charCode >>> 12);
            buf[bufIdx++] = 0x80 + ((charCode >>> 6) & 0x3f);
            buf[bufIdx++] = 0x80 + (charCode & 0x3f);
        }
    }
    return buf.slice(0, bufIdx);
}

InternalEncoderCesu8.prototype.end = function() {
}

//------------------------------------------------------------------------------
// CESU-8 decoder is not implemented in Node v4.0+

function InternalDecoderCesu8(options, codec) {
    this.acc = 0;
    this.contBytes = 0;
    this.accBytes = 0;
    this.defaultCharUnicode = codec.defaultCharUnicode;
}

InternalDecoderCesu8.prototype.write = function(buf) {
    var acc = this.acc, contBytes = this.contBytes, accBytes = this.accBytes, 
        res = '';
    for (var i = 0; i < buf.length; i++) {
        var curByte = buf[i];
        if ((curByte & 0xC0) !== 0x80) { // Leading byte
            if (contBytes > 0) { // Previous code is invalid
                res += this.defaultCharUnicode;
                contBytes = 0;
            }

            if (curByte < 0x80) { // Single-byte code
                res += String.fromCharCode(curByte);
            } else if (curByte < 0xE0) { // Two-byte code
                acc = curByte & 0x1F;
                contBytes = 1; accBytes = 1;
            } else if (curByte < 0xF0) { // Three-byte code
                acc = curByte & 0x0F;
                contBytes = 2; accBytes = 1;
            } else { // Four or more are not supported for CESU-8.
                res += this.defaultCharUnicode;
            }
        } else { // Continuation byte
            if (contBytes > 0) { // We're waiting for it.
                acc = (acc << 6) | (curByte & 0x3f);
                contBytes--; accBytes++;
                if (contBytes === 0) {
                    // Check for overlong encoding, but support Modified UTF-8 (encoding NULL as C0 80)
                    if (accBytes === 2 && acc < 0x80 && acc > 0)
                        res += this.defaultCharUnicode;
                    else if (accBytes === 3 && acc < 0x800)
                        res += this.defaultCharUnicode;
                    else
                        // Actually add character.
                        res += String.fromCharCode(acc);
                }
            } else { // Unexpected continuation byte
                res += this.defaultCharUnicode;
            }
        }
    }
    this.acc = acc; this.contBytes = contBytes; this.accBytes = accBytes;
    return res;
}

InternalDecoderCesu8.prototype.end = function() {
    var res = 0;
    if (this.contBytes > 0)
        res += this.defaultCharUnicode;
    return res;
}


/***/ }),

/***/ "./node_modules/iconv-lite/encodings/sbcs-codec.js":
/*!*********************************************************!*\
  !*** ./node_modules/iconv-lite/encodings/sbcs-codec.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Buffer = __webpack_require__(/*! safer-buffer */ "./node_modules/safer-buffer/safer.js").Buffer;

// Single-byte codec. Needs a 'chars' string parameter that contains 256 or 128 chars that
// correspond to encoded bytes (if 128 - then lower half is ASCII). 

exports._sbcs = SBCSCodec;
function SBCSCodec(codecOptions, iconv) {
    if (!codecOptions)
        throw new Error("SBCS codec is called without the data.")
    
    // Prepare char buffer for decoding.
    if (!codecOptions.chars || (codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256))
        throw new Error("Encoding '"+codecOptions.type+"' has incorrect 'chars' (must be of len 128 or 256)");
    
    if (codecOptions.chars.length === 128) {
        var asciiString = "";
        for (var i = 0; i < 128; i++)
            asciiString += String.fromCharCode(i);
        codecOptions.chars = asciiString + codecOptions.chars;
    }

    this.decodeBuf = Buffer.from(codecOptions.chars, 'ucs2');
    
    // Encoding buffer.
    var encodeBuf = Buffer.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));

    for (var i = 0; i < codecOptions.chars.length; i++)
        encodeBuf[codecOptions.chars.charCodeAt(i)] = i;

    this.encodeBuf = encodeBuf;
}

SBCSCodec.prototype.encoder = SBCSEncoder;
SBCSCodec.prototype.decoder = SBCSDecoder;


function SBCSEncoder(options, codec) {
    this.encodeBuf = codec.encodeBuf;
}

SBCSEncoder.prototype.write = function(str) {
    var buf = Buffer.alloc(str.length);
    for (var i = 0; i < str.length; i++)
        buf[i] = this.encodeBuf[str.charCodeAt(i)];
    
    return buf;
}

SBCSEncoder.prototype.end = function() {
}


function SBCSDecoder(options, codec) {
    this.decodeBuf = codec.decodeBuf;
}

SBCSDecoder.prototype.write = function(buf) {
    // Strings are immutable in JS -> we use ucs2 buffer to speed up computations.
    var decodeBuf = this.decodeBuf;
    var newBuf = Buffer.alloc(buf.length*2);
    var idx1 = 0, idx2 = 0;
    for (var i = 0; i < buf.length; i++) {
        idx1 = buf[i]*2; idx2 = i*2;
        newBuf[idx2] = decodeBuf[idx1];
        newBuf[idx2+1] = decodeBuf[idx1+1];
    }
    return newBuf.toString('ucs2');
}

SBCSDecoder.prototype.end = function() {
}


/***/ }),

/***/ "./node_modules/iconv-lite/encodings/sbcs-data-generated.js":
/*!******************************************************************!*\
  !*** ./node_modules/iconv-lite/encodings/sbcs-data-generated.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// Generated data for sbcs codec. Don't edit manually. Regenerate using generation/gen-sbcs.js script.
module.exports = {
  "437": "cp437",
  "737": "cp737",
  "775": "cp775",
  "850": "cp850",
  "852": "cp852",
  "855": "cp855",
  "856": "cp856",
  "857": "cp857",
  "858": "cp858",
  "860": "cp860",
  "861": "cp861",
  "862": "cp862",
  "863": "cp863",
  "864": "cp864",
  "865": "cp865",
  "866": "cp866",
  "869": "cp869",
  "874": "windows874",
  "922": "cp922",
  "1046": "cp1046",
  "1124": "cp1124",
  "1125": "cp1125",
  "1129": "cp1129",
  "1133": "cp1133",
  "1161": "cp1161",
  "1162": "cp1162",
  "1163": "cp1163",
  "1250": "windows1250",
  "1251": "windows1251",
  "1252": "windows1252",
  "1253": "windows1253",
  "1254": "windows1254",
  "1255": "windows1255",
  "1256": "windows1256",
  "1257": "windows1257",
  "1258": "windows1258",
  "28591": "iso88591",
  "28592": "iso88592",
  "28593": "iso88593",
  "28594": "iso88594",
  "28595": "iso88595",
  "28596": "iso88596",
  "28597": "iso88597",
  "28598": "iso88598",
  "28599": "iso88599",
  "28600": "iso885910",
  "28601": "iso885911",
  "28603": "iso885913",
  "28604": "iso885914",
  "28605": "iso885915",
  "28606": "iso885916",
  "windows874": {
    "type": "_sbcs",
    "chars": ""
  },
  "win874": "windows874",
  "cp874": "windows874",
  "windows1250": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1250": "windows1250",
  "cp1250": "windows1250",
  "windows1251": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1251": "windows1251",
  "cp1251": "windows1251",
  "windows1252": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1252": "windows1252",
  "cp1252": "windows1252",
  "windows1253": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1253": "windows1253",
  "cp1253": "windows1253",
  "windows1254": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1254": "windows1254",
  "cp1254": "windows1254",
  "windows1255": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1255": "windows1255",
  "cp1255": "windows1255",
  "windows1256": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1256": "windows1256",
  "cp1256": "windows1256",
  "windows1257": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1257": "windows1257",
  "cp1257": "windows1257",
  "windows1258": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1258": "windows1258",
  "cp1258": "windows1258",
  "iso88591": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28591": "iso88591",
  "iso88592": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28592": "iso88592",
  "iso88593": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28593": "iso88593",
  "iso88594": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28594": "iso88594",
  "iso88595": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28595": "iso88595",
  "iso88596": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28596": "iso88596",
  "iso88597": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28597": "iso88597",
  "iso88598": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28598": "iso88598",
  "iso88599": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28599": "iso88599",
  "iso885910": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28600": "iso885910",
  "iso885911": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28601": "iso885911",
  "iso885913": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28603": "iso885913",
  "iso885914": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28604": "iso885914",
  "iso885915": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28605": "iso885915",
  "iso885916": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28606": "iso885916",
  "cp437": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm437": "cp437",
  "csibm437": "cp437",
  "cp737": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm737": "cp737",
  "csibm737": "cp737",
  "cp775": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm775": "cp775",
  "csibm775": "cp775",
  "cp850": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm850": "cp850",
  "csibm850": "cp850",
  "cp852": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm852": "cp852",
  "csibm852": "cp852",
  "cp855": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm855": "cp855",
  "csibm855": "cp855",
  "cp856": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm856": "cp856",
  "csibm856": "cp856",
  "cp857": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm857": "cp857",
  "csibm857": "cp857",
  "cp858": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm858": "cp858",
  "csibm858": "cp858",
  "cp860": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm860": "cp860",
  "csibm860": "cp860",
  "cp861": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm861": "cp861",
  "csibm861": "cp861",
  "cp862": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm862": "cp862",
  "csibm862": "cp862",
  "cp863": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm863": "cp863",
  "csibm863": "cp863",
  "cp864": {
    "type": "_sbcs",
    "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
  },
  "ibm864": "cp864",
  "csibm864": "cp864",
  "cp865": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm865": "cp865",
  "csibm865": "cp865",
  "cp866": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm866": "cp866",
  "csibm866": "cp866",
  "cp869": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm869": "cp869",
  "csibm869": "cp869",
  "cp922": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm922": "cp922",
  "csibm922": "cp922",
  "cp1046": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1046": "cp1046",
  "csibm1046": "cp1046",
  "cp1124": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1124": "cp1124",
  "csibm1124": "cp1124",
  "cp1125": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1125": "cp1125",
  "csibm1125": "cp1125",
  "cp1129": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1129": "cp1129",
  "csibm1129": "cp1129",
  "cp1133": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1133": "cp1133",
  "csibm1133": "cp1133",
  "cp1161": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1161": "cp1161",
  "csibm1161": "cp1161",
  "cp1162": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1162": "cp1162",
  "csibm1162": "cp1162",
  "cp1163": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1163": "cp1163",
  "csibm1163": "cp1163",
  "maccroatian": {
    "type": "_sbcs",
    "chars": ""
  },
  "maccyrillic": {
    "type": "_sbcs",
    "chars": ""
  },
  "macgreek": {
    "type": "_sbcs",
    "chars": ""
  },
  "maciceland": {
    "type": "_sbcs",
    "chars": ""
  },
  "macroman": {
    "type": "_sbcs",
    "chars": ""
  },
  "macromania": {
    "type": "_sbcs",
    "chars": ""
  },
  "macthai": {
    "type": "_sbcs",
    "chars": ""
  },
  "macturkish": {
    "type": "_sbcs",
    "chars": ""
  },
  "macukraine": {
    "type": "_sbcs",
    "chars": ""
  },
  "koi8r": {
    "type": "_sbcs",
    "chars": ""
  },
  "koi8u": {
    "type": "_sbcs",
    "chars": ""
  },
  "koi8ru": {
    "type": "_sbcs",
    "chars": ""
  },
  "koi8t": {
    "type": "_sbcs",
    "chars": ""
  },
  "armscii8": {
    "type": "_sbcs",
    "chars": ")(.,-"
  },
  "rk1048": {
    "type": "_sbcs",
    "chars": ""
  },
  "tcvn": {
    "type": "_sbcs",
    "chars": "\u0000\u0003\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
  },
  "georgianacademy": {
    "type": "_sbcs",
    "chars": ""
  },
  "georgianps": {
    "type": "_sbcs",
    "chars": ""
  },
  "pt154": {
    "type": "_sbcs",
    "chars": ""
  },
  "viscii": {
    "type": "_sbcs",
    "chars": "\u0000\u0001\u0003\u0004\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0015\u0016\u0017\u0018\u001a\u001b\u001c\u001d\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
  },
  "iso646cn": {
    "type": "_sbcs",
    "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}"
  },
  "iso646jp": {
    "type": "_sbcs",
    "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}"
  },
  "hproman8": {
    "type": "_sbcs",
    "chars": ""
  },
  "macintosh": {
    "type": "_sbcs",
    "chars": ""
  },
  "ascii": {
    "type": "_sbcs",
    "chars": ""
  },
  "tis620": {
    "type": "_sbcs",
    "chars": ""
  }
}

/***/ }),

/***/ "./node_modules/iconv-lite/encodings/sbcs-data.js":
/*!********************************************************!*\
  !*** ./node_modules/iconv-lite/encodings/sbcs-data.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// Manually added data to be used by sbcs codec in addition to generated one.

module.exports = {
    // Not supported by iconv, not sure why.
    "10029": "maccenteuro",
    "maccenteuro": {
        "type": "_sbcs",
        "chars": ""
    },

    "808": "cp808",
    "ibm808": "cp808",
    "cp808": {
        "type": "_sbcs",
        "chars": ""
    },

    "mik": {
        "type": "_sbcs",
        "chars": ""
    },

    // Aliases of generated encodings.
    "ascii8bit": "ascii",
    "usascii": "ascii",
    "ansix34": "ascii",
    "ansix341968": "ascii",
    "ansix341986": "ascii",
    "csascii": "ascii",
    "cp367": "ascii",
    "ibm367": "ascii",
    "isoir6": "ascii",
    "iso646us": "ascii",
    "iso646irv": "ascii",
    "us": "ascii",

    "latin1": "iso88591",
    "latin2": "iso88592",
    "latin3": "iso88593",
    "latin4": "iso88594",
    "latin5": "iso88599",
    "latin6": "iso885910",
    "latin7": "iso885913",
    "latin8": "iso885914",
    "latin9": "iso885915",
    "latin10": "iso885916",

    "csisolatin1": "iso88591",
    "csisolatin2": "iso88592",
    "csisolatin3": "iso88593",
    "csisolatin4": "iso88594",
    "csisolatincyrillic": "iso88595",
    "csisolatinarabic": "iso88596",
    "csisolatingreek" : "iso88597",
    "csisolatinhebrew": "iso88598",
    "csisolatin5": "iso88599",
    "csisolatin6": "iso885910",

    "l1": "iso88591",
    "l2": "iso88592",
    "l3": "iso88593",
    "l4": "iso88594",
    "l5": "iso88599",
    "l6": "iso885910",
    "l7": "iso885913",
    "l8": "iso885914",
    "l9": "iso885915",
    "l10": "iso885916",

    "isoir14": "iso646jp",
    "isoir57": "iso646cn",
    "isoir100": "iso88591",
    "isoir101": "iso88592",
    "isoir109": "iso88593",
    "isoir110": "iso88594",
    "isoir144": "iso88595",
    "isoir127": "iso88596",
    "isoir126": "iso88597",
    "isoir138": "iso88598",
    "isoir148": "iso88599",
    "isoir157": "iso885910",
    "isoir166": "tis620",
    "isoir179": "iso885913",
    "isoir199": "iso885914",
    "isoir203": "iso885915",
    "isoir226": "iso885916",

    "cp819": "iso88591",
    "ibm819": "iso88591",

    "cyrillic": "iso88595",

    "arabic": "iso88596",
    "arabic8": "iso88596",
    "ecma114": "iso88596",
    "asmo708": "iso88596",

    "greek" : "iso88597",
    "greek8" : "iso88597",
    "ecma118" : "iso88597",
    "elot928" : "iso88597",

    "hebrew": "iso88598",
    "hebrew8": "iso88598",

    "turkish": "iso88599",
    "turkish8": "iso88599",

    "thai": "iso885911",
    "thai8": "iso885911",

    "celtic": "iso885914",
    "celtic8": "iso885914",
    "isoceltic": "iso885914",

    "tis6200": "tis620",
    "tis62025291": "tis620",
    "tis62025330": "tis620",

    "10000": "macroman",
    "10006": "macgreek",
    "10007": "maccyrillic",
    "10079": "maciceland",
    "10081": "macturkish",

    "cspc8codepage437": "cp437",
    "cspc775baltic": "cp775",
    "cspc850multilingual": "cp850",
    "cspcp852": "cp852",
    "cspc862latinhebrew": "cp862",
    "cpgr": "cp869",

    "msee": "cp1250",
    "mscyrl": "cp1251",
    "msansi": "cp1252",
    "msgreek": "cp1253",
    "msturk": "cp1254",
    "mshebr": "cp1255",
    "msarab": "cp1256",
    "winbaltrim": "cp1257",

    "cp20866": "koi8r",
    "20866": "koi8r",
    "ibm878": "koi8r",
    "cskoi8r": "koi8r",

    "cp21866": "koi8u",
    "21866": "koi8u",
    "ibm1168": "koi8u",

    "strk10482002": "rk1048",

    "tcvn5712": "tcvn",
    "tcvn57121": "tcvn",

    "gb198880": "iso646cn",
    "cn": "iso646cn",

    "csiso14jisc6220ro": "iso646jp",
    "jisc62201969ro": "iso646jp",
    "jp": "iso646jp",

    "cshproman8": "hproman8",
    "r8": "hproman8",
    "roman8": "hproman8",
    "xroman8": "hproman8",
    "ibm1051": "hproman8",

    "mac": "macintosh",
    "csmacintosh": "macintosh",
};



/***/ }),

/***/ "./node_modules/iconv-lite/encodings/tables/big5-added.json":
/*!******************************************************************!*\
  !*** ./node_modules/iconv-lite/encodings/tables/big5-added.json ***!
  \******************************************************************/
/*! exports provided: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, default */
/***/ (function(module) {

module.exports = JSON.parse("[[\"8740\",\"\"],[\"8767\",\"\"],[\"87a1\",\"\"],[\"8840\",\"\",4,\"\"],[\"88a1\",\"\"],[\"8940\",\"\"],[\"8943\",\"\"],[\"8946\",\"\"],[\"894c\",\"\"],[\"89a1\",\"\"],[\"89ab\",\"\"],[\"89b0\",\"\"],[\"89b5\",\"\"],[\"89c1\",\"\"],[\"89c5\",\"\"],[\"8a40\",\"\"],[\"8a43\",\"\"],[\"8a64\",\"\"],[\"8a76\",\"\"],[\"8aa1\",\"\"],[\"8aac\",\"\"],[\"8ab2\",\"\"],[\"8abb\",\"\"],[\"8ac9\",\"\"],[\"8ace\",\"\"],[\"8adf\",\"\"],[\"8af6\",\"\"],[\"8b40\",\"\"],[\"8b55\",\"\"],[\"8ba1\",\"\"],[\"8bde\",\"\"],[\"8c40\",\"\"],[\"8ca1\",\"\"],[\"8ca7\",\"\"],[\"8cc9\",\"\"],[\"8cce\",\"\"],[\"8ce6\",\"\"],[\"8d40\",\"\"],[\"8d42\",\"\"],[\"8da1\",\"\"],[\"8e40\",\"\"],[\"8ea1\",\"\"],[\"8f40\",\"\"],[\"8fa1\",\"\"],[\"9040\",\"\"],[\"90a1\",\"\"],[\"9140\",\"\"],[\"91a1\",\"\"],[\"9240\",\"\"],[\"92a1\",\"\"],[\"9340\",\"\"],[\"93a1\",\"\"],[\"9440\",\"\"],[\"94a1\",\"\"],[\"9540\",\"\"],[\"95a1\",\"\"],[\"9640\",\"\"],[\"96a1\",\"\"],[\"9740\",\"\"],[\"97a1\",\"\"],[\"9840\",\"\"],[\"98a1\",\"\"],[\"9940\",\"\"],[\"99a1\",\"\"],[\"9a40\",\"\"],[\"9aa1\",\"\"],[\"9b40\",\"\"],[\"9b62\",\"\"],[\"9ba1\",\"\"],[\"9c40\",\"\"],[\"9ca1\",\"\"],[\"9d40\",\"\"],[\"9da1\",\"\"],[\"9e40\",\"\"],[\"9ea1\",\"\"],[\"9ead\",\"\"],[\"9ec5\",\"\"],[\"9ef5\",\"\"],[\"9f40\",\"\"],[\"9f4f\",\"\"],[\"9fa1\",\"\"],[\"9fae\",\"\"],[\"9fb2\",\"\"],[\"9fc1\",\"\"],[\"9fc9\",\"\"],[\"9fdb\",\"\"],[\"9fe7\",\"\"],[\"9feb\",\"\"],[\"9ff0\",\"\"],[\"a040\",\"\"],[\"a055\",\"\"],[\"a058\",\"\"],[\"a05b\",\"\"],[\"a063\",\"\"],[\"a073\",\"\"],[\"a0a1\",\"\"],[\"a0a6\",\"\"],[\"a0ae\",\"\"],[\"a0b0\",\"\"],[\"a0d4\",\"\"],[\"a0e2\",\"\"],[\"a3c0\",\"\",31,\"\"],[\"c6a1\",\"\",9,\"\",9,\"\",9,\"\",23],[\"c740\",\"\",58,\"\"],[\"c7a1\",\"\",81,\"\",5,\"\",4],[\"c840\",\"\",26,\"\",25,\"\"],[\"c8a1\",\"\"],[\"c8cd\",\"\"],[\"c8f5\",\"\"],[\"f9fe\",\"\"],[\"fa40\",\"\"],[\"faa1\",\"\"],[\"fb40\",\"\"],[\"fba1\",\"\"],[\"fc40\",\"\"],[\"fca1\",\"\"],[\"fd40\",\"\"],[\"fda1\",\"\"],[\"fe40\",\"\"],[\"fea1\",\"\"]]");

/***/ }),

/***/ "./node_modules/iconv-lite/encodings/tables/cp936.json":
/*!*************************************************************!*\
  !*** ./node_modules/iconv-lite/encodings/tables/cp936.json ***!
  \*************************************************************/
/*! exports provided: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, default */
/***/ (function(module) {

module.exports = JSON.parse("[[\"0\",\"\\u0000\",127,\"\"],[\"8140\",\"\",5,\"\",9,\"\",6,\"\"],[\"8180\",\"\",6,\"\",4,\"\",4,\"\",5,\"\"],[\"8240\",\"\",4,\"\",8,\"\",4,\"\",11],[\"8280\",\"\",10,\"\",4,\"\",7,\"\",5,\"\",8,\"\",20,\"\",4,\"\",6,\"\"],[\"8340\",\"\",17,\"\",5,\"\",10,\"\",4,\"\",9,\"\"],[\"8380\",\"\",5,\"\",13,\"\",28,\"\",4,\"\",4,\"\",5],[\"8440\",\"\",5,\"\",5,\"\"],[\"8480\",\"\",9,\"\",4,\"\",6,\"\",6,\"\",9,\"\",5,\"\",10,\"\",7,\"\"],[\"8540\",\"\",9,\"\"],[\"8580\",\"\",4,\"\",6,\"\",4,\"\",4,\"\",7,\"\"],[\"8640\",\"\",4,\"\",5,\"\",4,\"\",5,\"\"],[\"8680\",\"\",4,\"\",4,\"\",5,\"\",6,\"\",8,\"\",4,\"\",4,\"\",4,\"\"],[\"8740\",\"\",7,\"\",11,\"\",4,\"\",4],[\"8780\",\"\",7,\"\",6,\"\",14,\"\",10,\"\",6,\"\",12,\"\",8,\"\",5,\"\",6],[\"8840\",\"\",9,\"\",4,\"\",4,\"\"],[\"8880\",\"\",4,\"\",6,\"\",8,\"\",6,\"\",7,\"\",4,\"\",4,\"\",7],[\"8940\",\"\",5,\"\",6,\"\",4,\"\",5,\"\",4,\"\",16,\"\"],[\"8980\",\"\",4,\"\",4,\"\",7,\"\",17,\"\",10,\"\",13,\"\",5,\"\",7,\"\",4,\"\"],[\"8a40\",\"\",4,\"\",12,\"\"],[\"8a80\",\"\",5,\"\",6,\"\",4,\"\",11,\"\",6,\"\",4,\"\",4,\"\",9,\"\",5],[\"8b40\",\"\",8,\"\",17,\"\",6,\"\",13,\"\"],[\"8b80\",\"\",4,\"\",4,\"\",5,\"\",4,\"\",4,\"\",22,\"\",11,\"\",25,\"\",7,\"\",6],[\"8c40\",\"\",7,\"\"],[\"8c80\",\"\",8,\"\",4,\"\",6,\"\",6,\"\",6,\"\",4,\"\",4,\"\",4],[\"8d40\",\"\",5,\"\",5,\"\",5,\"\",6,\"\",9,\"\",4],[\"8d80\",\"\",5,\"\",4,\"\",4,\"\",4,\"\",7,\"\",7,\"\",10,\"\",10,\"\",12,\"\",21,\"\"],[\"8e40\",\"\",21,\"\",12,\"\",6,\"\",12,\"\"],[\"8e80\",\"\",4,\"\",7,\"\",4,\"\",4,\"\",5,\"\",6,\"\",4,\"\",14,\"\",4,\"\",4,\"\",6],[\"8f40\",\"\",5,\"\",11,\"\",8,\"\"],[\"8f80\",\"\",6,\"\",14,\"\",5,\"\",5,\"\",4,\"\"],[\"9040\",\"\",4,\"\",4,\"\",6,\"\"],[\"9080\",\"\",7,\"\",4,\"\",4,\"\",4,\"\",4,\"\",18,\"\",6],[\"9140\",\"\",6,\"\",6,\"\",18,\"\",4,\"\"],[\"9180\",\"\",6,\"\",8,\"\",9,\"\",5,\"\",4,\"\",4,\"\",16,\"\",13,\"\",8,\"\",5,\"\",4,\"\"],[\"9240\",\"\",6,\"\",5,\"\"],[\"9280\",\"\",5,\"\",7,\"\",6,\"\"],[\"9340\",\"\",6,\"\",4,\"\",4,\"\",5,\"\"],[\"9380\",\"\",5,\"\",4,\"\",6,\"\",4,\"\",7,\"\",9,\"\",6,\"\",8,\"\",4,\"\",6,\"\"],[\"9440\",\"\",24,\"\",7,\"\",7,\"\",4,\"\",8],[\"9480\",\"\",4,\"\",4,\"\",14,\"\",7,\"\",7,\"\"],[\"9540\",\"\",4,\"\",4,\"\",6,\"\"],[\"9580\",\"\",4,\"\",4,\"\",8,\"\",4,\"\",4,\"\",25,\"\",7,\"\",5,\"\"],[\"9640\",\"\",5,\"\",4,\"\"],[\"9680\",\"\",7,\"\",9,\"\",7,\"\",4,\"\",6,\"\",6,\"\",5],[\"9740\",\"\",7,\"\",8,\"\",7,\"\",9,\"\"],[\"9780\",\"\",6,\"\",5,\"\",4,\"\",9,\"\",4,\"\",11,\"\",7,\"\",16,\"\"],[\"9840\",\"\",4,\"\",5,\"\",9,\"\"],[\"9880\",\"\",7,\"\",5,\"\",11,\"\",9,\"\",9,\"\",11,\"\",5,\"\",5,\"\",6,\"\",4,\"\",7,\"\",6,\"\"],[\"9940\",\"\",4,\"\",10,\"\",6,\"\",8,\"\",4,\"\",7,\"\",5],[\"9980\",\"\",114,\"\",6],[\"9a40\",\"\",11,\"\",7,\"\",13,\"\"],[\"9a80\",\"\",4,\"\",7,\"\",7,\"\",6,\"\",4,\"\",4,\"\",7,\"\",6,\"\",4,\"\",4,\"\"],[\"9b40\",\"\",4,\"\"],[\"9b80\",\"\",5,\"\",4,\"\",4,\"\",5,\"\"],[\"9c40\",\"\",7,\"\"],[\"9c80\",\"\",7,\"\",7,\"\",10,\"\",14,\"\",4,\"\",6,\"\",5],[\"9d40\",\"\",7,\"\",4,\"\",9,\"\",6,\"\"],[\"9d80\",\"\",9,\"\",5,\"\",6,\"\",12,\"\",4,\"\",10,\"\",5,\"\",5,\"\",6,\"\",10,\"\"],[\"9e40\",\"\",7,\"\",32,\"\",7,\"\",6,\"\",6],[\"9e80\",\"\",9,\"\",17,\"\",13,\"\",11,\"\",12,\"\",12,\"\"],[\"9f40\",\"\",6,\"\",10,\"\",4,\"\",10,\"\",7,\"\"],[\"9f80\",\"\",13,\"\",12,\"\",4,\"\",4,\"\",5,\"\",4,\"\",4,\"\",6,\"\",5,\"\",8,\"\",9,\"\",4],[\"a040\",\"\",9,\"\",5,\"\",9,\"\",11,\"\",19],[\"a080\",\"\",9,\"\",6,\"\",4,\"\",11,\"\",11,\"\",6,\"\"],[\"a1a1\",\"\",7,\"\"],[\"a2a1\",\"\",9],[\"a2b1\",\"\",19,\"\",19,\"\",9],[\"a2e5\",\"\",9],[\"a2f1\",\"\",11],[\"a3a1\",\"\",88,\"\"],[\"a4a1\",\"\",82],[\"a5a1\",\"\",85],[\"a6a1\",\"\",16,\"\",6],[\"a6c1\",\"\",16,\"\",6],[\"a6e0\",\"\"],[\"a6ee\",\"\"],[\"a6f4\",\"\"],[\"a7a1\",\"\",5,\"\",25],[\"a7d1\",\"\",5,\"\",25],[\"a840\",\"\",35,\"\",6],[\"a880\",\"\",7,\"\"],[\"a8a1\",\"\"],[\"a8bd\",\"\"],[\"a8c0\",\"\"],[\"a8c5\",\"\",36],[\"a940\",\"\",8,\"\"],[\"a959\",\"\"],[\"a95c\",\"\"],[\"a960\",\"\",9,\"\",8],[\"a980\",\"\",4,\"\"],[\"a996\",\"\"],[\"a9a4\",\"\",75],[\"aa40\",\"\",5,\"\",5,\"\",8],[\"aa80\",\"\",7,\"\",10,\"\"],[\"ab40\",\"\",11,\"\",4,\"\",5,\"\",4],[\"ab80\",\"\",6,\"\",4],[\"ac40\",\"\",10,\"\",8,\"\",5,\"\",4,\"\",11],[\"ac80\",\"\",6,\"\",12,\"\",4,\"\"],[\"ad40\",\"\",10,\"\",7,\"\",15,\"\",12],[\"ad80\",\"\",9,\"\",8,\"\",6,\"\"],[\"ae40\",\"\",6,\"\",7,\"\",4,\"\"],[\"ae80\",\"\",7,\"\",6,\"\",4,\"\"],[\"af40\",\"\",4,\"\"],[\"af80\",\"\"],[\"b040\",\"\",6,\"\",5,\"\",4,\"\",6,\"\",7,\"\"],[\"b080\",\"\",7,\"\",8,\"\",9,\"\"],[\"b140\",\"\",4,\"\",7,\"\",10,\"\"],[\"b180\",\"\",4,\"\",7,\"\",7,\"\"],[\"b240\",\"\",11,\"\",5,\"\",11,\"\",4],[\"b280\",\"\",12,\"\",8,\"\",4,\"\"],[\"b340\",\"\",5,\"\"],[\"b380\",\"\",11,\"\",7,\"\",6,\"\"],[\"b440\",\"\",7,\"\",9],[\"b480\",\"\",4,\"\",5,\"\",6,\"\"],[\"b540\",\"\",5,\"\",9,\"\",4,\"\",14,\"\",4,\"\",8,\"\"],[\"b580\",\"\",6,\"\",4,\"\"],[\"b640\",\"\",6,\"\",11,\"\",10,\"\",4,\"\",5,\"\"],[\"b680\",\"\",6,\"\",4,\"\"],[\"b740\",\"\",14,\"\",5,\"\",9,\"\",4,\"\",16],[\"b780\",\"\",6,\"\"],[\"b840\",\"\",4,\"\",10,\"\",10,\"\",9,\"\",5,\"\"],[\"b880\",\"\",4,\"\"],[\"b940\",\"\",5,\"\",10,\"\",6,\"\"],[\"b980\",\"\",7,\"\"],[\"ba40\",\"\",4,\"\",4,\"\",7,\"\",5,\"\"],[\"ba80\",\"\",4,\"\",5,\"\",12,\"\",5,\"\"],[\"bb40\",\"\",9,\"\",36,\"\",5,\"\",9],[\"bb80\",\"\",6,\"\",4,\"\"],[\"bc40\",\"\",6,\"\",6,\"\",5,\"\",7,\"\",13,\"\",5],[\"bc80\",\"\",14,\"\",6,\"\"],[\"bd40\",\"\",54,\"\",7],[\"bd80\",\"\",32,\"\"],[\"be40\",\"\",12,\"\",6,\"\",42],[\"be80\",\"\",32,\"\"],[\"bf40\",\"\",62],[\"bf80\",\"\",4,\"\",4,\"\",21,\"\"],[\"c040\",\"\",35,\"\",23,\"\"],[\"c080\",\"\",6,\"\",9,\"\"],[\"c140\",\"\",4,\"\",7,\"\",4,\"\",4,\"\",6,\"\"],[\"c180\",\"\",4,\"\",4,\"\",5,\"\"],[\"c240\",\"\",6,\"\",5,\"\"],[\"c280\",\"\",13,\"\",5,\"\",11,\"\"],[\"c340\",\"\",5,\"\",4,\"\",6,\"\"],[\"c380\",\"\",12,\"\",4,\"\"],[\"c440\",\"\",5,\"\",4,\"\",4,\"\",5,\"\",4,\"\"],[\"c480\",\"\",7,\"\",5,\"\",6,\"\"],[\"c540\",\"\",14,\"\",4,\"\",5,\"\",4,\"\",5,\"\"],[\"c580\",\"\",7,\"\",7,\"\"],[\"c640\",\"\"],[\"c680\",\"\",4,\"\",9,\"\"],[\"c740\",\"\",4,\"\",4,\"\",6,\"\",6,\"\",6,\"\"],[\"c780\",\"\"],[\"c840\",\"\",4,\"\",5,\"\",5,\"\",7,\"\",5,\"\",7,\"\"],[\"c880\",\"\",6,\"\",4,\"\",4,\"\"],[\"c940\",\"\",4,\"\",7,\"\",12,\"\"],[\"c980\",\"\",4,\"\",4,\"\",10,\"\"],[\"ca40\",\"\",8,\"\",8,\"\",9,\"\",4,\"\",10],[\"ca80\",\"\",4,\"\",8,\"\"],[\"cb40\",\"\",6,\"\",10,\"\",6,\"\",5,\"\",6,\"\",6,\"\",4,\"\"],[\"cb80\",\"\",5,\"\",6,\"\",14,\"\"],[\"cc40\",\"\",4,\"\",10,\"\",15,\"\",13,\"\"],[\"cc80\",\"\",11,\"\",4,\"\",7,\"\"],[\"cd40\",\"\",6,\"\",6,\"\",4,\"\",5,\"\",4,\"\",4,\"\"],[\"cd80\",\"\"],[\"ce40\",\"\",6,\"\",5,\"\",7,\"\"],[\"ce80\",\"\",4,\"\",6,\"\",4,\"\"],[\"cf40\",\"\",4,\"\",4,\"\",6,\"\",9],[\"cf80\",\"\",5,\"\",7,\"\",4,\"\"],[\"d040\",\"\",13,\"\",5,\"\",5,\"\",5,\"\",6,\"\"],[\"d080\",\"\",4,\"\",4,\"\",5,\"\"],[\"d140\",\"\",4,\"\",4,\"\",6,\"\",5],[\"d180\",\"\",4,\"\",4,\"\",4,\"\"],[\"d240\",\"\",8,\"\",24,\"\",5,\"\",19,\"\"],[\"d280\",\"\",26,\"\"],[\"d340\",\"\",30,\"\",6],[\"d380\",\"\",4,\"\",5,\"\",21,\"\"],[\"d440\",\"\",31,\"\",8,\"\",21],[\"d480\",\"\",25,\"\",6,\"\"],[\"d540\",\"\",7,\"\",7,\"\",46],[\"d580\",\"\",32,\"\"],[\"d640\",\"\",34,\"\",27],[\"d680\",\"\",30,\"\"],[\"d740\",\"\",31,\"\",4,\"\",25],[\"d780\",\"\",24,\"\"],[\"d840\",\"\",8,\"\",7,\"\",5,\"\",6,\"\",6,\"\",6,\"\"],[\"d880\",\"\",6,\"\",20,\"\"],[\"d940\",\"\",62],[\"d980\",\"\",32,\"\"],[\"da40\",\"\",14,\"\",8,\"\",4,\"\",9,\"\"],[\"da80\",\"\",12,\"\"],[\"db40\",\"\",6,\"\",7,\"\",4,\"\"],[\"db80\",\"\",4,\"\",5,\"\",11,\"\"],[\"dc40\",\"\",4,\"\",6,\"\",6,\"\",11,\"\",6,\"\",7],[\"dc80\",\"\",10,\"\",21,\"\"],[\"dd40\",\"\",62],[\"dd80\",\"\",32,\"\"],[\"de40\",\"\",32,\"\"],[\"de80\",\"\",4,\"\"],[\"df40\",\"\",5,\"\",4,\"\",4,\"\",5,\"\",4,\"\",6,\"\"],[\"df80\",\"\",4,\"\"],[\"e040\",\"\",19,\"\"],[\"e080\",\"\",10,\"\",6,\"\",8,\"\"],[\"e140\",\"\",4,\"\",6,\"\",5,\"\",5,\"\"],[\"e180\",\"\",10,\"\",9,\"\",8,\"\"],[\"e240\",\"\",62],[\"e280\",\"\",32,\"\",5,\"\"],[\"e340\",\"\",45,\"\",16],[\"e380\",\"\",7,\"\",24,\"\"],[\"e440\",\"\",5,\"\",24,\"\",31],[\"e480\",\"\",32,\"\"],[\"e540\",\"\",51,\"\",10],[\"e580\",\"\",31,\"\"],[\"e640\",\"\",34,\"\",27],[\"e680\",\"\",29,\"\"],[\"e740\",\"\",7,\"\",54],[\"e780\",\"\",32,\"\",6,\"\",4,\"\"],[\"e840\",\"\",14,\"\",43,\"\"],[\"e880\",\"\",20,\"\"],[\"e940\",\"\",7,\"\",42],[\"e980\",\"\",32,\"\"],[\"ea40\",\"\",27,\"\",6,\"\"],[\"ea80\",\"\",4,\"\",12,\"\"],[\"eb40\",\"\",9,\"\",7,\"\",9,\"\",6,\"\"],[\"eb80\",\"\",4,\"\"],[\"ec40\",\"\",8,\"\",4,\"\",18,\"\",7],[\"ec80\",\"\",4,\"\",7,\"\",4,\"\",4,\"\"],[\"ed40\",\"\",6,\"\",46],[\"ed80\",\"\",4,\"\",23,\"\"],[\"ee40\",\"\",62],[\"ee80\",\"\",32,\"\",4,\"\",6,\"\"],[\"ef40\",\"\",5,\"\",37,\"\",4],[\"ef80\",\"\",30,\"\",4,\"\",8,\"\"],[\"f040\",\"\",4,\"\",28,\"\",26],[\"f080\",\"\",9,\"\",12,\"\",4,\"\",6,\"\"],[\"f140\",\"\",10,\"\",47],[\"f180\",\"\",32,\"\"],[\"f240\",\"\",62],[\"f280\",\"\",32,\"\"],[\"f340\",\"\",17,\"\",6,\"\",4,\"\"],[\"f380\",\"\",8,\"\",6,\"\"],[\"f440\",\"\",5,\"\",10,\"\",10,\"\",7,\"\",5],[\"f480\",\"\",32,\"\"],[\"f540\",\"\",62],[\"f580\",\"\",32,\"\"],[\"f640\",\"\",62],[\"f680\",\"\",32,\"\",5,\"\",5,\"\",4,\"\",7,\"\"],[\"f740\",\"\",62],[\"f780\",\"\",4,\"\",4,\"\"],[\"f840\",\"\",62],[\"f880\",\"\",32],[\"f940\",\"\",62],[\"f980\",\"\",32],[\"fa40\",\"\",62],[\"fa80\",\"\",32],[\"fb40\",\"\",27,\"\",9,\"\"],[\"fb80\",\"\",5,\"\",8,\"\",5,\"\"],[\"fc40\",\"\",8,\"\",4,\"\",8,\"\",6],[\"fc80\",\"\",4,\"\",5,\"\",8,\"\"],[\"fd40\",\"\",4,\"\",4,\"\",10,\"\",38],[\"fd80\",\"\",5,\"\",11,\"\",4,\"\"],[\"fe40\",\"\"]]");

/***/ }),

/***/ "./node_modules/iconv-lite/encodings/tables/cp949.json":
/*!*************************************************************!*\
  !*** ./node_modules/iconv-lite/encodings/tables/cp949.json ***!
  \*************************************************************/
/*! exports provided: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, default */
/***/ (function(module) {

module.exports = JSON.parse("[[\"0\",\"\\u0000\",127],[\"8141\",\"\",4,\"\",6,\"\"],[\"8161\",\"\",9,\"\",5,\"\"],[\"8181\",\"\",18,\"\",4,\"\",6,\"\",5,\"\",6,\"\",7,\"\",7,\"\",4,\"\",4,\"\"],[\"8241\",\"\",7,\"\",5],[\"8261\",\"\",6,\"\",5,\"\"],[\"8281\",\"\",7,\"\",7,\"\",4,\"\",10,\"\",5,\"\",17,\"\",7,\"\",6,\"\",7,\"\",18],[\"8341\",\"\",5,\"\",5,\"\",7],[\"8361\",\"\",18,\"\"],[\"8381\",\"\",4,\"\",6,\"\",5,\"\",5,\"\",46,\"\",6,\"\",5,\"\",8],[\"8441\",\"\",5,\"\",8],[\"8461\",\"\",18],[\"8481\",\"\",7,\"\",6,\"\",5,\"\",10,\"\",5,\"\",18,\"\",5,\"\",6,\"\",5,\"\",26,\"\"],[\"8541\",\"\",5,\"\",4,\"\",6,\"\",4],[\"8561\",\"\",5,\"\",5,\"\",6,\"\"],[\"8581\",\"\",6,\"\",6,\"\",9,\"\",26,\"\",29,\"\",6,\"\",5,\"\"],[\"8641\",\"\",6,\"\",5,\"\"],[\"8661\",\"\",6,\"\",10],[\"8681\",\"\",22,\"\",4,\"\",6,\"\",5,\"\",6,\"\",22,\"\",4,\"\"],[\"8741\",\"\",9,\"\",15],[\"8761\",\"\",18,\"\"],[\"8781\",\"\",5,\"\",7,\"\",7,\"\",5,\"\",6,\"\",5,\"\",18,\"\",6,\"\",26,\"\",6,\"\",4],[\"8841\",\"\",4,\"\",5,\"\",6,\"\",4],[\"8861\",\"\",4,\"\"],[\"8881\",\"\",15,\"\",4,\"\",6,\"\",5,\"\",54,\"\"],[\"8941\",\"\",6,\"\",5,\"\"],[\"8961\",\"\",10,\"\",5,\"\"],[\"8981\",\"\",21,\"\",18,\"\",18,\"\",6,\"\",6,\"\",7,\"\",15],[\"8a41\",\"\",10,\"\",6,\"\"],[\"8a61\",\"\",4,\"\",18,\"\"],[\"8a81\",\"\",4,\"\",19,\"\",5,\"\",7,\"\",5,\"\",6,\"\",5,\"\",4,\"\",5,\"\",26,\"\"],[\"8b41\",\"\",5,\"\",4,\"\",6,\"\"],[\"8b61\",\"\",6,\"\",8],[\"8b81\",\"\",52,\"\",4,\"\",6,\"\",5,\"\",18,\"\",18],[\"8c41\",\"\",15,\"\",4],[\"8c61\",\"\",6,\"\",5,\"\",6,\"\",5],[\"8c81\",\"\",12,\"\",26,\"\",50,\"\",5,\"\",16],[\"8d41\",\"\",16,\"\",8],[\"8d61\",\"\",17,\"\"],[\"8d81\",\"\",4,\"\",33,\"\",6,\"\",7,\"\",6,\"\",9,\"\",6,\"\",5,\"\",6,\"\"],[\"8e41\",\"\",6,\"\",5,\"\",8],[\"8e61\",\"\",4,\"\",19],[\"8e81\",\"\",13,\"\",6,\"\",4,\"\",6,\"\",5,\"\",6,\"\",5,\"\",11,\"\",7,\"\",6,\"\",5,\"\",7],[\"8f41\",\"\",7,\"\",17],[\"8f61\",\"\",7,\"\",6,\"\",4],[\"8f81\",\"\",5,\"\",7,\"\",5,\"\",6,\"\",5,\"\",18,\"\",6,\"\",26,\"\",6,\"\",5],[\"9041\",\"\",6,\"\",5,\"\"],[\"9061\",\"\",5,\"\",15],[\"9081\",\"\",12,\"\",6,\"\",5,\"\",4,\"\",6,\"\",4,\"\",5,\"\",11,\"\",33,\"\"],[\"9141\",\"\",6,\"\",5],[\"9161\",\"\",9,\"\",5],[\"9181\",\"\",20,\"\",4,\"\",5,\"\",14,\"\",33,\"\",7,\"\",5,\"\",6],[\"9241\",\"\",7,\"\",4,\"\"],[\"9261\",\"\",7,\"\",7,\"\",4],[\"9281\",\"\",21,\"\",18,\"\",6,\"\",7,\"\",6,\"\",35,\"\"],[\"9341\",\"\",4,\"\"],[\"9361\",\"\",6,\"\",8],[\"9381\",\"\",37,\"\",4,\"\",4,\"\",6,\"\",5,\"\",7,\"\",22,\"\"],[\"9441\",\"\",5,\"\",5,\"\",8],[\"9461\",\"\",5,\"\",6,\"\",12],[\"9481\",\"\",5,\"\",6,\"\",6,\"\",9,\"\",22,\"\",4,\"\",6,\"\",10,\"\",6,\"\",24],[\"9541\",\"\",11,\"\",5,\"\"],[\"9561\",\"\",6,\"\",5,\"\"],[\"9581\",\"\",6,\"\",35,\"\",4,\"\",4,\"\",4,\"\",6,\"\",5,\"\",13,\"\",14],[\"9641\",\"\",23,\"\"],[\"9661\",\"\",6,\"\",5,\"\",8],[\"9681\",\"\",10,\"\",5,\"\",13,\"\",33,\"\",6,\"\",44],[\"9741\",\"\",16,\"\",8],[\"9761\",\"\",17,\"\",7],[\"9781\",\"\",11,\"\",5,\"\",6,\"\",89,\"\"],[\"9841\",\"\",16,\"\",5,\"\"],[\"9861\",\"\",6,\"\",15],[\"9881\",\"\",21,\"\",6,\"\",5,\"\",4,\"\",6,\"\",5,\"\",6,\"\",5,\"\",6,\"\",5,\"\"],[\"9941\",\"\",6,\"\",5,\"\"],[\"9961\",\"\",6,\"\",5,\"\"],[\"9981\",\"\",8,\"\",5,\"\",4,\"\",11,\"\",5,\"\",6,\"\",6,\"\",6,\"\",7,\"\",6,\"\",5,\"\"],[\"9a41\",\"\",16],[\"9a61\",\"\",6,\"\",6,\"\"],[\"9a81\",\"\",4,\"\",6,\"\",5,\"\",5,\"\",6,\"\",5,\"\",5,\"\",33,\"\",5,\"\",6,\"\"],[\"9b41\",\"\",6,\"\",8],[\"9b61\",\"\",17,\"\",7],[\"9b81\",\"\",25,\"\",4,\"\",5,\"\",50,\"\",22,\"\"],[\"9c41\",\"\",4,\"\",5,\"\",5],[\"9c61\",\"\",8,\"\",6,\"\",9],[\"9c81\",\"\",8,\"\",6,\"\",6,\"\",9,\"\",26,\"\",6,\"\",5,\"\",18,\"\",6,\"\",12],[\"9d41\",\"\",13,\"\",8],[\"9d61\",\"\",25],[\"9d81\",\"\",8,\"\",5,\"\",9,\"\",6,\"\",10,\"\",6,\"\",5,\"\",6,\"\",5,\"\"],[\"9e41\",\"\",7,\"\",9,\"\"],[\"9e61\",\"\",4,\"\",6,\"\"],[\"9e81\",\"\",6,\"\",6,\"\",6,\"\",5,\"\",10,\"\",5,\"\",6,\"\",5,\"\",6,\"\"],[\"9f41\",\"\",5,\"\",4,\"\",5,\"\"],[\"9f61\",\"\",6,\"\",5,\"\"],[\"9f81\",\"\",4,\"\",5,\"\",6,\"\",5,\"\",6,\"\",4,\"\",6,\"\",7,\"\",4,\"\",4,\"\"],[\"a041\",\"\",5,\"\",6,\"\"],[\"a061\",\"\",5,\"\",13],[\"a081\",\"\",4,\"\",4,\"\",4,\"\",6,\"\",5,\"\",6,\"\",5,\"\",26,\"\",4,\"\",5,\"\",7,\"\"],[\"a141\",\"\",18,\"\"],[\"a161\",\"\",6,\"\",5,\"\"],[\"a181\",\"\",14,\"\",5,\"\",4,\"\",9,\"\"],[\"a241\",\"\",5,\"\",18],[\"a261\",\"\",6,\"\",18],[\"a281\",\"\",7,\"\",6,\"\",7,\"\"],[\"a341\",\"\",6,\"\",10,\"\"],[\"a361\",\"\",6,\"\",16],[\"a381\",\"\",16,\"\",4,\"\",58,\"\",32,\"\"],[\"a441\",\"\",5,\"\"],[\"a461\",\"\",5,\"\",12],[\"a481\",\"\",28,\"\",93],[\"a541\",\"\",4,\"\",6,\"\",5,\"\"],[\"a561\",\"\",17,\"\",5,\"\"],[\"a581\",\"\",16,\"\",14,\"\",9],[\"a5b0\",\"\",9],[\"a5c1\",\"\",16,\"\",6],[\"a5e1\",\"\",16,\"\",6],[\"a641\",\"\",19,\"\"],[\"a661\",\"\",5,\"\",5,\"\",6],[\"a681\",\"\",6,\"\",18,\"\",7],[\"a741\",\"\",4,\"\",6,\"\",7],[\"a761\",\"\",22,\"\"],[\"a781\",\"\",6,\"\",5,\"\",7,\"\",9,\"\",9,\"\",4,\"\",5,\"\",4,\"\"],[\"a841\",\"\",10,\"\",14],[\"a861\",\"\",18,\"\",6],[\"a881\",\"\",19,\"\",11,\"\"],[\"a8a6\",\"\"],[\"a8a8\",\"\"],[\"a8b1\",\"\",27,\"\",25,\"\",14,\"\"],[\"a941\",\"\",14,\"\",10],[\"a961\",\"\",18],[\"a981\",\"\",14,\"\",6,\"\",27,\"\",25,\"\",14,\"\"],[\"aa41\",\"\",6,\"\",4,\"\"],[\"aa61\",\"\",4,\"\",5,\"\",6,\"\"],[\"aa81\",\"\",29,\"\",82],[\"ab41\",\"\",6,\"\",5,\"\"],[\"ab61\",\"\",6,\"\",5,\"\",5],[\"ab81\",\"\",8,\"\",6,\"\",12,\"\",85],[\"ac41\",\"\",5,\"\",6,\"\"],[\"ac61\",\"\",11,\"\",4],[\"ac81\",\"\",28,\"\",5,\"\",25],[\"acd1\",\"\",5,\"\",25],[\"ad41\",\"\",6,\"\",5,\"\",7],[\"ad61\",\"\",6,\"\",10,\"\"],[\"ad81\",\"\",5,\"\",18,\"\"],[\"ae41\",\"\",5,\"\",16],[\"ae61\",\"\",5,\"\",6,\"\",4],[\"ae81\",\"\",6,\"\",5,\"\"],[\"af41\",\"\",19],[\"af61\",\"\",13,\"\",5,\"\"],[\"af81\",\"\",5,\"\",6,\"\",5,\"\"],[\"b041\",\"\",5,\"\",5,\"\",12],[\"b061\",\"\",5,\"\",19],[\"b081\",\"\",13,\"\",6,\"\",5,\"\",7,\"\",4,\"\"],[\"b141\",\"\",6,\"\",5,\"\"],[\"b161\",\"\",6,\"\",5,\"\",11],[\"b181\",\"\",14,\"\",6,\"\"],[\"b241\",\"\",6,\"\",5,\"\"],[\"b261\",\"\",18,\"\",5,\"\"],[\"b281\",\"\",5,\"\",18,\"\",6,\"\"],[\"b341\",\"\",19,\"\"],[\"b361\",\"\",5,\"\",5,\"\",5],[\"b381\",\"\",5,\"\",5,\"\",19,\"\",4,\"\"],[\"b441\",\"\",5,\"\",6,\"\",5],[\"b461\",\"\",6,\"\",10,\"\"],[\"b481\",\"\",6,\"\",18,\"\",4,\"\",4,\"\"],[\"b541\",\"\",14,\"\",5],[\"b561\",\"\",5,\"\",5,\"\",4],[\"b581\",\"\",6,\"\",5,\"\",11,\"\"],[\"b641\",\"\",7,\"\",17],[\"b661\",\"\",15,\"\"],[\"b681\",\"\",5,\"\",6,\"\",5,\"\"],[\"b741\",\"\",13,\"\",6,\"\"],[\"b761\",\"\",20,\"\"],[\"b781\",\"\",6,\"\",14,\"\"],[\"b841\",\"\",7,\"\",17],[\"b861\",\"\",8,\"\",13],[\"b881\",\"\",5,\"\",24,\"\",4,\"\"],[\"b941\",\"\",6,\"\",5,\"\"],[\"b961\",\"\",14,\"\",6,\"\"],[\"b981\",\"\",22,\"\",4,\"\",4,\"\"],[\"ba41\",\"\",5,\"\",6,\"\"],[\"ba61\",\"\",5,\"\",4,\"\",5],[\"ba81\",\"\",6,\"\",9,\"\"],[\"bb41\",\"\",4,\"\",5,\"\",4,\"\"],[\"bb61\",\"\",6,\"\",5,\"\"],[\"bb81\",\"\",31,\"\"],[\"bc41\",\"\",17,\"\"],[\"bc61\",\"\",5,\"\",6,\"\"],[\"bc81\",\"\",4,\"\",6,\"\",5,\"\",5,\"\",4,\"\"],[\"bd41\",\"\",7,\"\",7,\"\"],[\"bd61\",\"\",5,\"\",13],[\"bd81\",\"\",5,\"\",25,\"\"],[\"be41\",\"\",7,\"\",14],[\"be61\",\"\",7,\"\",7,\"\"],[\"be81\",\"\",4,\"\",4,\"\",5,\"\",8,\"\",6,\"\"],[\"bf41\",\"\",10,\"\",14],[\"bf61\",\"\",18,\"\"],[\"bf81\",\"\",5,\"\",7,\"\",6,\"\",5,\"\"],[\"c041\",\"\",5,\"\",6,\"\",5],[\"c061\",\"\",25],[\"c081\",\"\",6,\"\",5,\"\",7,\"\"],[\"c141\",\"\",5,\"\",6,\"\"],[\"c161\",\"\",19,\"\"],[\"c181\",\"\",31,\"\"],[\"c241\",\"\",4,\"\",5,\"\"],[\"c261\",\"\",4,\"\",5,\"\",6,\"\"],[\"c281\",\"\",5,\"\",7,\"\",9,\"\"],[\"c341\",\"\",4],[\"c361\",\"\",4,\"\",5,\"\",11],[\"c381\",\"\",5,\"\",7,\"\",5,\"\"],[\"c441\",\"\",7,\"\",7,\"\"],[\"c461\",\"\",5,\"\",4],[\"c481\",\"\",5,\"\",11,\"\"],[\"c541\",\"\",6,\"\",5,\"\"],[\"c561\",\"\",6,\"\",5,\"\",4],[\"c581\",\"\",6,\"\",5,\"\"],[\"c641\",\"\",6,\"\",5],[\"c6a1\",\"\"],[\"c7a1\",\"\"],[\"c8a1\",\"\"],[\"caa1\",\"\"],[\"cba1\",\"\"],[\"cca1\",\"\"],[\"cda1\",\"\"],[\"cea1\",\"\"],[\"cfa1\",\"\"],[\"d0a1\",\"\"],[\"d1a1\",\"\",5,\"\",4,\"\"],[\"d2a1\",\"\",4,\"\",5,\"\",10,\"\",7,\"\",5,\"\"],[\"d3a1\",\"\"],[\"d4a1\",\"\"],[\"d5a1\",\"\"],[\"d6a1\",\"\"],[\"d7a1\",\"\"],[\"d8a1\",\"\"],[\"d9a1\",\"\"],[\"daa1\",\"\"],[\"dba1\",\"\"],[\"dca1\",\"\"],[\"dda1\",\"\"],[\"dea1\",\"\"],[\"dfa1\",\"\"],[\"e0a1\",\"\"],[\"e1a1\",\"\"],[\"e2a1\",\"\"],[\"e3a1\",\"\"],[\"e4a1\",\"\"],[\"e5a1\",\"\"],[\"e6a1\",\"\"],[\"e7a1\",\"\"],[\"e8a1\",\"\"],[\"e9a1\",\"\"],[\"eaa1\",\"\"],[\"eba1\",\"\"],[\"eca1\",\"\"],[\"eda1\",\"\"],[\"eea1\",\"\"],[\"efa1\",\"\"],[\"f0a1\",\"\"],[\"f1a1\",\"\"],[\"f2a1\",\"\"],[\"f3a1\",\"\"],[\"f4a1\",\"\"],[\"f5a1\",\"\"],[\"f6a1\",\"\"],[\"f7a1\",\"\"],[\"f8a1\",\"\"],[\"f9a1\",\"\"],[\"faa1\",\"\"],[\"fba1\",\"\"],[\"fca1\",\"\"],[\"fda1\",\"\"]]");

/***/ }),

/***/ "./node_modules/iconv-lite/encodings/tables/cp950.json":
/*!*************************************************************!*\
  !*** ./node_modules/iconv-lite/encodings/tables/cp950.json ***!
  \*************************************************************/
/*! exports provided: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, default */
/***/ (function(module) {

module.exports = JSON.parse("[[\"0\",\"\\u0000\",127],[\"a140\",\"\"],[\"a1a1\",\"\",4,\"\"],[\"a240\",\"\",7,\"\"],[\"a2a1\",\"\",9,\"\",9,\"\",8,\"\",25,\"\",21],[\"a340\",\"\",16,\"\",6,\"\",16,\"\",6,\"\",10],[\"a3a1\",\"\",25,\"\"],[\"a3e1\",\"\"],[\"a440\",\"\"],[\"a4a1\",\"\"],[\"a540\",\"\"],[\"a5a1\",\"\"],[\"a640\",\"\"],[\"a6a1\",\"\"],[\"a740\",\"\"],[\"a7a1\",\"\"],[\"a840\",\"\"],[\"a8a1\",\"\"],[\"a940\",\"\"],[\"a9a1\",\"\"],[\"aa40\",\"\"],[\"aaa1\",\"\"],[\"ab40\",\"\"],[\"aba1\",\"\"],[\"ac40\",\"\"],[\"aca1\",\"\"],[\"ad40\",\"\"],[\"ada1\",\"\"],[\"ae40\",\"\"],[\"aea1\",\"\"],[\"af40\",\"\"],[\"afa1\",\"\"],[\"b040\",\"\"],[\"b0a1\",\"\"],[\"b140\",\"\"],[\"b1a1\",\"\"],[\"b240\",\"\"],[\"b2a1\",\"\"],[\"b340\",\"\"],[\"b3a1\",\"\"],[\"b440\",\"\"],[\"b4a1\",\"\"],[\"b540\",\"\"],[\"b5a1\",\"\"],[\"b640\",\"\"],[\"b6a1\",\"\"],[\"b740\",\"\"],[\"b7a1\",\"\"],[\"b840\",\"\"],[\"b8a1\",\"\"],[\"b940\",\"\"],[\"b9a1\",\"\"],[\"ba40\",\"\"],[\"baa1\",\"\"],[\"bb40\",\"\"],[\"bba1\",\"\"],[\"bc40\",\"\"],[\"bca1\",\"\"],[\"bd40\",\"\"],[\"bda1\",\"\"],[\"be40\",\"\"],[\"bea1\",\"\"],[\"bf40\",\"\"],[\"bfa1\",\"\"],[\"c040\",\"\"],[\"c0a1\",\"\"],[\"c140\",\"\"],[\"c1a1\",\"\"],[\"c240\",\"\"],[\"c2a1\",\"\"],[\"c340\",\"\"],[\"c3a1\",\"\"],[\"c440\",\"\"],[\"c4a1\",\"\"],[\"c540\",\"\"],[\"c5a1\",\"\"],[\"c640\",\"\"],[\"c940\",\"\"],[\"c9a1\",\"\"],[\"ca40\",\"\"],[\"caa1\",\"\"],[\"cb40\",\"\"],[\"cba1\",\"\"],[\"cc40\",\"\"],[\"cca1\",\"\"],[\"cd40\",\"\"],[\"cda1\",\"\"],[\"ce40\",\"\"],[\"cea1\",\"\"],[\"cf40\",\"\"],[\"cfa1\",\"\"],[\"d040\",\"\"],[\"d0a1\",\"\"],[\"d140\",\"\"],[\"d1a1\",\"\"],[\"d240\",\"\"],[\"d2a1\",\"\"],[\"d340\",\"\"],[\"d3a1\",\"\"],[\"d440\",\"\"],[\"d4a1\",\"\"],[\"d540\",\"\"],[\"d5a1\",\"\"],[\"d640\",\"\"],[\"d6a1\",\"\"],[\"d740\",\"\"],[\"d7a1\",\"\"],[\"d840\",\"\"],[\"d8a1\",\"\"],[\"d940\",\"\"],[\"d9a1\",\"\"],[\"da40\",\"\"],[\"daa1\",\"\"],[\"db40\",\"\"],[\"dba1\",\"\"],[\"dc40\",\"\"],[\"dca1\",\"\"],[\"dd40\",\"\"],[\"dda1\",\"\"],[\"de40\",\"\"],[\"dea1\",\"\"],[\"df40\",\"\"],[\"dfa1\",\"\"],[\"e040\",\"\"],[\"e0a1\",\"\"],[\"e140\",\"\"],[\"e1a1\",\"\"],[\"e240\",\"\"],[\"e2a1\",\"\"],[\"e340\",\"\"],[\"e3a1\",\"\"],[\"e440\",\"\"],[\"e4a1\",\"\"],[\"e540\",\"\"],[\"e5a1\",\"\"],[\"e640\",\"\"],[\"e6a1\",\"\"],[\"e740\",\"\"],[\"e7a1\",\"\"],[\"e840\",\"\"],[\"e8a1\",\"\"],[\"e940\",\"\"],[\"e9a1\",\"\"],[\"ea40\",\"\"],[\"eaa1\",\"\"],[\"eb40\",\"\"],[\"eba1\",\"\"],[\"ec40\",\"\"],[\"eca1\",\"\"],[\"ed40\",\"\"],[\"eda1\",\"\"],[\"ee40\",\"\"],[\"eea1\",\"\"],[\"ef40\",\"\"],[\"efa1\",\"\"],[\"f040\",\"\"],[\"f0a1\",\"\"],[\"f140\",\"\"],[\"f1a1\",\"\"],[\"f240\",\"\"],[\"f2a1\",\"\"],[\"f340\",\"\"],[\"f3a1\",\"\"],[\"f440\",\"\"],[\"f4a1\",\"\"],[\"f540\",\"\"],[\"f5a1\",\"\"],[\"f640\",\"\"],[\"f6a1\",\"\"],[\"f740\",\"\"],[\"f7a1\",\"\"],[\"f840\",\"\"],[\"f8a1\",\"\"],[\"f940\",\"\"],[\"f9a1\",\"\"]]");

/***/ }),

/***/ "./node_modules/iconv-lite/encodings/tables/eucjp.json":
/*!*************************************************************!*\
  !*** ./node_modules/iconv-lite/encodings/tables/eucjp.json ***!
  \*************************************************************/
/*! exports provided: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, default */
/***/ (function(module) {

module.exports = JSON.parse("[[\"0\",\"\\u0000\",127],[\"8ea1\",\"\",62],[\"a1a1\",\"\",9,\"\"],[\"a2a1\",\"\"],[\"a2ba\",\"\"],[\"a2ca\",\"\"],[\"a2dc\",\"\"],[\"a2f2\",\"\"],[\"a2fe\",\"\"],[\"a3b0\",\"\",9],[\"a3c1\",\"\",25],[\"a3e1\",\"\",25],[\"a4a1\",\"\",82],[\"a5a1\",\"\",85],[\"a6a1\",\"\",16,\"\",6],[\"a6c1\",\"\",16,\"\",6],[\"a7a1\",\"\",5,\"\",25],[\"a7d1\",\"\",5,\"\",25],[\"a8a1\",\"\"],[\"ada1\",\"\",19,\"\",9],[\"adc0\",\"\"],[\"addf\",\"\",4,\"\"],[\"b0a1\",\"\"],[\"b1a1\",\"\"],[\"b2a1\",\"\"],[\"b3a1\",\"\"],[\"b4a1\",\"\"],[\"b5a1\",\"\"],[\"b6a1\",\"\"],[\"b7a1\",\"\"],[\"b8a1\",\"\"],[\"b9a1\",\"\"],[\"baa1\",\"\"],[\"bba1\",\"\"],[\"bca1\",\"\"],[\"bda1\",\"\"],[\"bea1\",\"\"],[\"bfa1\",\"\"],[\"c0a1\",\"\"],[\"c1a1\",\"\"],[\"c2a1\",\"\"],[\"c3a1\",\"\"],[\"c4a1\",\"\"],[\"c5a1\",\"\"],[\"c6a1\",\"\"],[\"c7a1\",\"\"],[\"c8a1\",\"\"],[\"c9a1\",\"\"],[\"caa1\",\"\"],[\"cba1\",\"\"],[\"cca1\",\"\"],[\"cda1\",\"\"],[\"cea1\",\"\"],[\"cfa1\",\"\"],[\"d0a1\",\"\"],[\"d1a1\",\"\"],[\"d2a1\",\"\"],[\"d3a1\",\"\"],[\"d4a1\",\"\"],[\"d5a1\",\"\"],[\"d6a1\",\"\"],[\"d7a1\",\"\"],[\"d8a1\",\"\"],[\"d9a1\",\"\"],[\"daa1\",\"\"],[\"dba1\",\"\"],[\"dca1\",\"\"],[\"dda1\",\"\"],[\"dea1\",\"\"],[\"dfa1\",\"\"],[\"e0a1\",\"\"],[\"e1a1\",\"\"],[\"e2a1\",\"\"],[\"e3a1\",\"\"],[\"e4a1\",\"\"],[\"e5a1\",\"\"],[\"e6a1\",\"\"],[\"e7a1\",\"\"],[\"e8a1\",\"\"],[\"e9a1\",\"\"],[\"eaa1\",\"\"],[\"eba1\",\"\"],[\"eca1\",\"\"],[\"eda1\",\"\"],[\"eea1\",\"\"],[\"efa1\",\"\"],[\"f0a1\",\"\"],[\"f1a1\",\"\"],[\"f2a1\",\"\"],[\"f3a1\",\"\"],[\"f4a1\",\"\"],[\"f9a1\",\"\"],[\"faa1\",\"\"],[\"fba1\",\"\"],[\"fca1\",\"\"],[\"fcf1\",\"\",9,\"\"],[\"8fa2af\",\"\"],[\"8fa2c2\",\"\"],[\"8fa2eb\",\"\"],[\"8fa6e1\",\"\"],[\"8fa6e7\",\"\"],[\"8fa6e9\",\"\"],[\"8fa6ec\",\"\"],[\"8fa6f1\",\"\"],[\"8fa7c2\",\"\",10,\"\"],[\"8fa7f2\",\"\",10,\"\"],[\"8fa9a1\",\"\"],[\"8fa9a4\",\"\"],[\"8fa9a6\",\"\"],[\"8fa9a8\",\"\"],[\"8fa9ab\",\"\"],[\"8fa9af\",\"\"],[\"8fa9c1\",\"\"],[\"8faaa1\",\"\"],[\"8faaba\",\"\"],[\"8faba1\",\"\"],[\"8fabbd\",\"\"],[\"8fabc5\",\"\"],[\"8fb0a1\",\"\"],[\"8fb1a1\",\"\"],[\"8fb2a1\",\"\",4,\"\"],[\"8fb3a1\",\"\"],[\"8fb4a1\",\"\"],[\"8fb5a1\",\"\"],[\"8fb6a1\",\"\",5,\"\",4,\"\"],[\"8fb7a1\",\"\",4,\"\"],[\"8fb8a1\",\"\"],[\"8fb9a1\",\"\"],[\"8fbaa1\",\"\",4,\"\"],[\"8fbba1\",\"\"],[\"8fbca1\",\"\",4,\"\"],[\"8fbda1\",\"\",4,\"\"],[\"8fbea1\",\"\",4,\"\"],[\"8fbfa1\",\"\"],[\"8fc0a1\",\"\"],[\"8fc1a1\",\"\"],[\"8fc2a1\",\"\"],[\"8fc3a1\",\"\",4,\"\"],[\"8fc4a1\",\"\"],[\"8fc5a1\",\"\"],[\"8fc6a1\",\"\"],[\"8fc7a1\",\"\"],[\"8fc8a1\",\"\"],[\"8fc9a1\",\"\",4,\"\",4,\"\"],[\"8fcaa1\",\"\"],[\"8fcba1\",\"\"],[\"8fcca1\",\"\",9,\"\"],[\"8fcda1\",\"\",5,\"\"],[\"8fcea1\",\"\",6,\"\"],[\"8fcfa1\",\"\"],[\"8fd0a1\",\"\"],[\"8fd1a1\",\"\"],[\"8fd2a1\",\"\",5],[\"8fd3a1\",\"\"],[\"8fd4a1\",\"\",4,\"\"],[\"8fd5a1\",\"\"],[\"8fd6a1\",\"\"],[\"8fd7a1\",\"\"],[\"8fd8a1\",\"\"],[\"8fd9a1\",\"\",4,\"\",6,\"\"],[\"8fdaa1\",\"\",4,\"\"],[\"8fdba1\",\"\",6,\"\"],[\"8fdca1\",\"\",4,\"\"],[\"8fdda1\",\"\",4,\"\"],[\"8fdea1\",\"\",4,\"\"],[\"8fdfa1\",\"\"],[\"8fe0a1\",\"\"],[\"8fe1a1\",\"\",4,\"\"],[\"8fe2a1\",\"\"],[\"8fe3a1\",\"\",5,\"\",4,\"\"],[\"8fe4a1\",\"\",4,\"\"],[\"8fe5a1\",\"\",4,\"\"],[\"8fe6a1\",\"\"],[\"8fe7a1\",\"\"],[\"8fe8a1\",\"\",4,\"\"],[\"8fe9a1\",\"\",4],[\"8feaa1\",\"\",4,\"\"],[\"8feba1\",\"\",4,\"\"],[\"8feca1\",\"\"],[\"8feda1\",\"\",4,\"\",4,\"\"]]");

/***/ }),

/***/ "./node_modules/iconv-lite/encodings/tables/gb18030-ranges.json":
/*!**********************************************************************!*\
  !*** ./node_modules/iconv-lite/encodings/tables/gb18030-ranges.json ***!
  \**********************************************************************/
/*! exports provided: uChars, gbChars, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"uChars\":[128,165,169,178,184,216,226,235,238,244,248,251,253,258,276,284,300,325,329,334,364,463,465,467,469,471,473,475,477,506,594,610,712,716,730,930,938,962,970,1026,1104,1106,8209,8215,8218,8222,8231,8241,8244,8246,8252,8365,8452,8454,8458,8471,8482,8556,8570,8596,8602,8713,8720,8722,8726,8731,8737,8740,8742,8748,8751,8760,8766,8777,8781,8787,8802,8808,8816,8854,8858,8870,8896,8979,9322,9372,9548,9588,9616,9622,9634,9652,9662,9672,9676,9680,9702,9735,9738,9793,9795,11906,11909,11913,11917,11928,11944,11947,11951,11956,11960,11964,11979,12284,12292,12312,12319,12330,12351,12436,12447,12535,12543,12586,12842,12850,12964,13200,13215,13218,13253,13263,13267,13270,13384,13428,13727,13839,13851,14617,14703,14801,14816,14964,15183,15471,15585,16471,16736,17208,17325,17330,17374,17623,17997,18018,18212,18218,18301,18318,18760,18811,18814,18820,18823,18844,18848,18872,19576,19620,19738,19887,40870,59244,59336,59367,59413,59417,59423,59431,59437,59443,59452,59460,59478,59493,63789,63866,63894,63976,63986,64016,64018,64021,64025,64034,64037,64042,65074,65093,65107,65112,65127,65132,65375,65510,65536],\"gbChars\":[0,36,38,45,50,81,89,95,96,100,103,104,105,109,126,133,148,172,175,179,208,306,307,308,309,310,311,312,313,341,428,443,544,545,558,741,742,749,750,805,819,820,7922,7924,7925,7927,7934,7943,7944,7945,7950,8062,8148,8149,8152,8164,8174,8236,8240,8262,8264,8374,8380,8381,8384,8388,8390,8392,8393,8394,8396,8401,8406,8416,8419,8424,8437,8439,8445,8482,8485,8496,8521,8603,8936,8946,9046,9050,9063,9066,9076,9092,9100,9108,9111,9113,9131,9162,9164,9218,9219,11329,11331,11334,11336,11346,11361,11363,11366,11370,11372,11375,11389,11682,11686,11687,11692,11694,11714,11716,11723,11725,11730,11736,11982,11989,12102,12336,12348,12350,12384,12393,12395,12397,12510,12553,12851,12962,12973,13738,13823,13919,13933,14080,14298,14585,14698,15583,15847,16318,16434,16438,16481,16729,17102,17122,17315,17320,17402,17418,17859,17909,17911,17915,17916,17936,17939,17961,18664,18703,18814,18962,19043,33469,33470,33471,33484,33485,33490,33497,33501,33505,33513,33520,33536,33550,37845,37921,37948,38029,38038,38064,38065,38066,38069,38075,38076,38078,39108,39109,39113,39114,39115,39116,39265,39394,189000]}");

/***/ }),

/***/ "./node_modules/iconv-lite/encodings/tables/gbk-added.json":
/*!*****************************************************************!*\
  !*** ./node_modules/iconv-lite/encodings/tables/gbk-added.json ***!
  \*****************************************************************/
/*! exports provided: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, default */
/***/ (function(module) {

module.exports = JSON.parse("[[\"a140\",\"\",62],[\"a180\",\"\",32],[\"a240\",\"\",62],[\"a280\",\"\",32],[\"a2ab\",\"\",5],[\"a2e3\",\"\"],[\"a2ef\",\"\"],[\"a2fd\",\"\"],[\"a340\",\"\",62],[\"a380\",\"\",31,\"\"],[\"a440\",\"\",62],[\"a480\",\"\",32],[\"a4f4\",\"\",10],[\"a540\",\"\",62],[\"a580\",\"\",32],[\"a5f7\",\"\",7],[\"a640\",\"\",62],[\"a680\",\"\",32],[\"a6b9\",\"\",7],[\"a6d9\",\"\",6],[\"a6ec\",\"\"],[\"a6f3\",\"\"],[\"a6f6\",\"\",8],[\"a740\",\"\",62],[\"a780\",\"\",32],[\"a7c2\",\"\",14],[\"a7f2\",\"\",12],[\"a896\",\"\",10],[\"a8bc\",\"\"],[\"a8bf\",\"\"],[\"a8c1\",\"\"],[\"a8ea\",\"\",20],[\"a958\",\"\"],[\"a95b\",\"\"],[\"a95d\",\"\"],[\"a989\",\"\",11],[\"a997\",\"\",12],[\"a9f0\",\"\",14],[\"aaa1\",\"\",93],[\"aba1\",\"\",93],[\"aca1\",\"\",93],[\"ada1\",\"\",93],[\"aea1\",\"\",93],[\"afa1\",\"\",93],[\"d7fa\",\"\",4],[\"f8a1\",\"\",93],[\"f9a1\",\"\",93],[\"faa1\",\"\",93],[\"fba1\",\"\",93],[\"fca1\",\"\",93],[\"fda1\",\"\",93],[\"fe50\",\"\"],[\"fe80\",\"\",6,\"\",93]]");

/***/ }),

/***/ "./node_modules/iconv-lite/encodings/tables/shiftjis.json":
/*!****************************************************************!*\
  !*** ./node_modules/iconv-lite/encodings/tables/shiftjis.json ***!
  \****************************************************************/
/*! exports provided: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, default */
/***/ (function(module) {

module.exports = JSON.parse("[[\"0\",\"\\u0000\",128],[\"a1\",\"\",62],[\"8140\",\"\",9,\"\"],[\"8180\",\"\"],[\"81b8\",\"\"],[\"81c8\",\"\"],[\"81da\",\"\"],[\"81f0\",\"\"],[\"81fc\",\"\"],[\"824f\",\"\",9],[\"8260\",\"\",25],[\"8281\",\"\",25],[\"829f\",\"\",82],[\"8340\",\"\",62],[\"8380\",\"\",22],[\"839f\",\"\",16,\"\",6],[\"83bf\",\"\",16,\"\",6],[\"8440\",\"\",5,\"\",25],[\"8470\",\"\",5,\"\",7],[\"8480\",\"\",17],[\"849f\",\"\"],[\"8740\",\"\",19,\"\",9],[\"875f\",\"\"],[\"877e\",\"\"],[\"8780\",\"\",4,\"\"],[\"889f\",\"\"],[\"8940\",\"\"],[\"8980\",\"\"],[\"8a40\",\"\"],[\"8a80\",\"\"],[\"8b40\",\"\"],[\"8b80\",\"\"],[\"8c40\",\"\"],[\"8c80\",\"\"],[\"8d40\",\"\"],[\"8d80\",\"\"],[\"8e40\",\"\"],[\"8e80\",\"\"],[\"8f40\",\"\"],[\"8f80\",\"\"],[\"9040\",\"\"],[\"9080\",\"\"],[\"9140\",\"\"],[\"9180\",\"\"],[\"9240\",\"\"],[\"9280\",\"\"],[\"9340\",\"\"],[\"9380\",\"\"],[\"9440\",\"\"],[\"9480\",\"\"],[\"9540\",\"\"],[\"9580\",\"\"],[\"9640\",\"\"],[\"9680\",\"\"],[\"9740\",\"\"],[\"9780\",\"\"],[\"9840\",\"\"],[\"989f\",\"\"],[\"9940\",\"\"],[\"9980\",\"\"],[\"9a40\",\"\"],[\"9a80\",\"\"],[\"9b40\",\"\"],[\"9b80\",\"\"],[\"9c40\",\"\"],[\"9c80\",\"\"],[\"9d40\",\"\"],[\"9d80\",\"\"],[\"9e40\",\"\"],[\"9e80\",\"\"],[\"9f40\",\"\"],[\"9f80\",\"\"],[\"e040\",\"\"],[\"e080\",\"\"],[\"e140\",\"\"],[\"e180\",\"\"],[\"e240\",\"\"],[\"e280\",\"\"],[\"e340\",\"\"],[\"e380\",\"\"],[\"e440\",\"\"],[\"e480\",\"\"],[\"e540\",\"\"],[\"e580\",\"\"],[\"e640\",\"\"],[\"e680\",\"\"],[\"e740\",\"\"],[\"e780\",\"\"],[\"e840\",\"\"],[\"e880\",\"\"],[\"e940\",\"\"],[\"e980\",\"\"],[\"ea40\",\"\"],[\"ea80\",\"\"],[\"ed40\",\"\"],[\"ed80\",\"\"],[\"ee40\",\"\"],[\"ee80\",\"\"],[\"eeef\",\"\",9,\"\"],[\"f040\",\"\",62],[\"f080\",\"\",124],[\"f140\",\"\",62],[\"f180\",\"\",124],[\"f240\",\"\",62],[\"f280\",\"\",124],[\"f340\",\"\",62],[\"f380\",\"\",124],[\"f440\",\"\",62],[\"f480\",\"\",124],[\"f540\",\"\",62],[\"f580\",\"\",124],[\"f640\",\"\",62],[\"f680\",\"\",124],[\"f740\",\"\",62],[\"f780\",\"\",124],[\"f840\",\"\",62],[\"f880\",\"\",124],[\"f940\",\"\"],[\"fa40\",\"\",9,\"\",9,\"\"],[\"fa80\",\"\"],[\"fb40\",\"\"],[\"fb80\",\"\"],[\"fc40\",\"\"]]");

/***/ }),

/***/ "./node_modules/iconv-lite/encodings/utf16.js":
/*!****************************************************!*\
  !*** ./node_modules/iconv-lite/encodings/utf16.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Buffer = __webpack_require__(/*! safer-buffer */ "./node_modules/safer-buffer/safer.js").Buffer;

// Note: UTF16-LE (or UCS2) codec is Node.js native. See encodings/internal.js

// == UTF16-BE codec. ==========================================================

exports.utf16be = Utf16BECodec;
function Utf16BECodec() {
}

Utf16BECodec.prototype.encoder = Utf16BEEncoder;
Utf16BECodec.prototype.decoder = Utf16BEDecoder;
Utf16BECodec.prototype.bomAware = true;


// -- Encoding

function Utf16BEEncoder() {
}

Utf16BEEncoder.prototype.write = function(str) {
    var buf = Buffer.from(str, 'ucs2');
    for (var i = 0; i < buf.length; i += 2) {
        var tmp = buf[i]; buf[i] = buf[i+1]; buf[i+1] = tmp;
    }
    return buf;
}

Utf16BEEncoder.prototype.end = function() {
}


// -- Decoding

function Utf16BEDecoder() {
    this.overflowByte = -1;
}

Utf16BEDecoder.prototype.write = function(buf) {
    if (buf.length == 0)
        return '';

    var buf2 = Buffer.alloc(buf.length + 1),
        i = 0, j = 0;

    if (this.overflowByte !== -1) {
        buf2[0] = buf[0];
        buf2[1] = this.overflowByte;
        i = 1; j = 2;
    }

    for (; i < buf.length-1; i += 2, j+= 2) {
        buf2[j] = buf[i+1];
        buf2[j+1] = buf[i];
    }

    this.overflowByte = (i == buf.length-1) ? buf[buf.length-1] : -1;

    return buf2.slice(0, j).toString('ucs2');
}

Utf16BEDecoder.prototype.end = function() {
}


// == UTF-16 codec =============================================================
// Decoder chooses automatically from UTF-16LE and UTF-16BE using BOM and space-based heuristic.
// Defaults to UTF-16LE, as it's prevalent and default in Node.
// http://en.wikipedia.org/wiki/UTF-16 and http://encoding.spec.whatwg.org/#utf-16le
// Decoder default can be changed: iconv.decode(buf, 'utf16', {defaultEncoding: 'utf-16be'});

// Encoder uses UTF-16LE and prepends BOM (which can be overridden with addBOM: false).

exports.utf16 = Utf16Codec;
function Utf16Codec(codecOptions, iconv) {
    this.iconv = iconv;
}

Utf16Codec.prototype.encoder = Utf16Encoder;
Utf16Codec.prototype.decoder = Utf16Decoder;


// -- Encoding (pass-through)

function Utf16Encoder(options, codec) {
    options = options || {};
    if (options.addBOM === undefined)
        options.addBOM = true;
    this.encoder = codec.iconv.getEncoder('utf-16le', options);
}

Utf16Encoder.prototype.write = function(str) {
    return this.encoder.write(str);
}

Utf16Encoder.prototype.end = function() {
    return this.encoder.end();
}


// -- Decoding

function Utf16Decoder(options, codec) {
    this.decoder = null;
    this.initialBytes = [];
    this.initialBytesLen = 0;

    this.options = options || {};
    this.iconv = codec.iconv;
}

Utf16Decoder.prototype.write = function(buf) {
    if (!this.decoder) {
        // Codec is not chosen yet. Accumulate initial bytes.
        this.initialBytes.push(buf);
        this.initialBytesLen += buf.length;
        
        if (this.initialBytesLen < 16) // We need more bytes to use space heuristic (see below)
            return '';

        // We have enough bytes -> detect endianness.
        var buf = Buffer.concat(this.initialBytes),
            encoding = detectEncoding(buf, this.options.defaultEncoding);
        this.decoder = this.iconv.getDecoder(encoding, this.options);
        this.initialBytes.length = this.initialBytesLen = 0;
    }

    return this.decoder.write(buf);
}

Utf16Decoder.prototype.end = function() {
    if (!this.decoder) {
        var buf = Buffer.concat(this.initialBytes),
            encoding = detectEncoding(buf, this.options.defaultEncoding);
        this.decoder = this.iconv.getDecoder(encoding, this.options);

        var res = this.decoder.write(buf),
            trail = this.decoder.end();

        return trail ? (res + trail) : res;
    }
    return this.decoder.end();
}

function detectEncoding(buf, defaultEncoding) {
    var enc = defaultEncoding || 'utf-16le';

    if (buf.length >= 2) {
        // Check BOM.
        if (buf[0] == 0xFE && buf[1] == 0xFF) // UTF-16BE BOM
            enc = 'utf-16be';
        else if (buf[0] == 0xFF && buf[1] == 0xFE) // UTF-16LE BOM
            enc = 'utf-16le';
        else {
            // No BOM found. Try to deduce encoding from initial content.
            // Most of the time, the content has ASCII chars (U+00**), but the opposite (U+**00) is uncommon.
            // So, we count ASCII as if it was LE or BE, and decide from that.
            var asciiCharsLE = 0, asciiCharsBE = 0, // Counts of chars in both positions
                _len = Math.min(buf.length - (buf.length % 2), 64); // Len is always even.

            for (var i = 0; i < _len; i += 2) {
                if (buf[i] === 0 && buf[i+1] !== 0) asciiCharsBE++;
                if (buf[i] !== 0 && buf[i+1] === 0) asciiCharsLE++;
            }

            if (asciiCharsBE > asciiCharsLE)
                enc = 'utf-16be';
            else if (asciiCharsBE < asciiCharsLE)
                enc = 'utf-16le';
        }
    }

    return enc;
}




/***/ }),

/***/ "./node_modules/iconv-lite/encodings/utf7.js":
/*!***************************************************!*\
  !*** ./node_modules/iconv-lite/encodings/utf7.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Buffer = __webpack_require__(/*! safer-buffer */ "./node_modules/safer-buffer/safer.js").Buffer;

// UTF-7 codec, according to https://tools.ietf.org/html/rfc2152
// See also below a UTF-7-IMAP codec, according to http://tools.ietf.org/html/rfc3501#section-5.1.3

exports.utf7 = Utf7Codec;
exports.unicode11utf7 = 'utf7'; // Alias UNICODE-1-1-UTF-7
function Utf7Codec(codecOptions, iconv) {
    this.iconv = iconv;
};

Utf7Codec.prototype.encoder = Utf7Encoder;
Utf7Codec.prototype.decoder = Utf7Decoder;
Utf7Codec.prototype.bomAware = true;


// -- Encoding

var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;

function Utf7Encoder(options, codec) {
    this.iconv = codec.iconv;
}

Utf7Encoder.prototype.write = function(str) {
    // Naive implementation.
    // Non-direct chars are encoded as "+<base64>-"; single "+" char is encoded as "+-".
    return Buffer.from(str.replace(nonDirectChars, function(chunk) {
        return "+" + (chunk === '+' ? '' : 
            this.iconv.encode(chunk, 'utf16-be').toString('base64').replace(/=+$/, '')) 
            + "-";
    }.bind(this)));
}

Utf7Encoder.prototype.end = function() {
}


// -- Decoding

function Utf7Decoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = '';
}

var base64Regex = /[A-Za-z0-9\/+]/;
var base64Chars = [];
for (var i = 0; i < 256; i++)
    base64Chars[i] = base64Regex.test(String.fromCharCode(i));

var plusChar = '+'.charCodeAt(0), 
    minusChar = '-'.charCodeAt(0),
    andChar = '&'.charCodeAt(0);

Utf7Decoder.prototype.write = function(buf) {
    var res = "", lastI = 0,
        inBase64 = this.inBase64,
        base64Accum = this.base64Accum;

    // The decoder is more involved as we must handle chunks in stream.

    for (var i = 0; i < buf.length; i++) {
        if (!inBase64) { // We're in direct mode.
            // Write direct chars until '+'
            if (buf[i] == plusChar) {
                res += this.iconv.decode(buf.slice(lastI, i), "ascii"); // Write direct chars.
                lastI = i+1;
                inBase64 = true;
            }
        } else { // We decode base64.
            if (!base64Chars[buf[i]]) { // Base64 ended.
                if (i == lastI && buf[i] == minusChar) {// "+-" -> "+"
                    res += "+";
                } else {
                    var b64str = base64Accum + buf.slice(lastI, i).toString();
                    res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
                }

                if (buf[i] != minusChar) // Minus is absorbed after base64.
                    i--;

                lastI = i+1;
                inBase64 = false;
                base64Accum = '';
            }
        }
    }

    if (!inBase64) {
        res += this.iconv.decode(buf.slice(lastI), "ascii"); // Write direct chars.
    } else {
        var b64str = base64Accum + buf.slice(lastI).toString();

        var canBeDecoded = b64str.length - (b64str.length % 8); // Minimal chunk: 2 quads -> 2x3 bytes -> 3 chars.
        base64Accum = b64str.slice(canBeDecoded); // The rest will be decoded in future.
        b64str = b64str.slice(0, canBeDecoded);

        res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
    }

    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;

    return res;
}

Utf7Decoder.prototype.end = function() {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0)
        res = this.iconv.decode(Buffer.from(this.base64Accum, 'base64'), "utf16-be");

    this.inBase64 = false;
    this.base64Accum = '';
    return res;
}


// UTF-7-IMAP codec.
// RFC3501 Sec. 5.1.3 Modified UTF-7 (http://tools.ietf.org/html/rfc3501#section-5.1.3)
// Differences:
//  * Base64 part is started by "&" instead of "+"
//  * Direct characters are 0x20-0x7E, except "&" (0x26)
//  * In Base64, "," is used instead of "/"
//  * Base64 must not be used to represent direct characters.
//  * No implicit shift back from Base64 (should always end with '-')
//  * String must end in non-shifted position.
//  * "-&" while in base64 is not allowed.


exports.utf7imap = Utf7IMAPCodec;
function Utf7IMAPCodec(codecOptions, iconv) {
    this.iconv = iconv;
};

Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
Utf7IMAPCodec.prototype.bomAware = true;


// -- Encoding

function Utf7IMAPEncoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = Buffer.alloc(6);
    this.base64AccumIdx = 0;
}

Utf7IMAPEncoder.prototype.write = function(str) {
    var inBase64 = this.inBase64,
        base64Accum = this.base64Accum,
        base64AccumIdx = this.base64AccumIdx,
        buf = Buffer.alloc(str.length*5 + 10), bufIdx = 0;

    for (var i = 0; i < str.length; i++) {
        var uChar = str.charCodeAt(i);
        if (0x20 <= uChar && uChar <= 0x7E) { // Direct character or '&'.
            if (inBase64) {
                if (base64AccumIdx > 0) {
                    bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString('base64').replace(/\//g, ',').replace(/=+$/, ''), bufIdx);
                    base64AccumIdx = 0;
                }

                buf[bufIdx++] = minusChar; // Write '-', then go to direct mode.
                inBase64 = false;
            }

            if (!inBase64) {
                buf[bufIdx++] = uChar; // Write direct character

                if (uChar === andChar)  // Ampersand -> '&-'
                    buf[bufIdx++] = minusChar;
            }

        } else { // Non-direct character
            if (!inBase64) {
                buf[bufIdx++] = andChar; // Write '&', then go to base64 mode.
                inBase64 = true;
            }
            if (inBase64) {
                base64Accum[base64AccumIdx++] = uChar >> 8;
                base64Accum[base64AccumIdx++] = uChar & 0xFF;

                if (base64AccumIdx == base64Accum.length) {
                    bufIdx += buf.write(base64Accum.toString('base64').replace(/\//g, ','), bufIdx);
                    base64AccumIdx = 0;
                }
            }
        }
    }

    this.inBase64 = inBase64;
    this.base64AccumIdx = base64AccumIdx;

    return buf.slice(0, bufIdx);
}

Utf7IMAPEncoder.prototype.end = function() {
    var buf = Buffer.alloc(10), bufIdx = 0;
    if (this.inBase64) {
        if (this.base64AccumIdx > 0) {
            bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString('base64').replace(/\//g, ',').replace(/=+$/, ''), bufIdx);
            this.base64AccumIdx = 0;
        }

        buf[bufIdx++] = minusChar; // Write '-', then go to direct mode.
        this.inBase64 = false;
    }

    return buf.slice(0, bufIdx);
}


// -- Decoding

function Utf7IMAPDecoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = '';
}

var base64IMAPChars = base64Chars.slice();
base64IMAPChars[','.charCodeAt(0)] = true;

Utf7IMAPDecoder.prototype.write = function(buf) {
    var res = "", lastI = 0,
        inBase64 = this.inBase64,
        base64Accum = this.base64Accum;

    // The decoder is more involved as we must handle chunks in stream.
    // It is forgiving, closer to standard UTF-7 (for example, '-' is optional at the end).

    for (var i = 0; i < buf.length; i++) {
        if (!inBase64) { // We're in direct mode.
            // Write direct chars until '&'
            if (buf[i] == andChar) {
                res += this.iconv.decode(buf.slice(lastI, i), "ascii"); // Write direct chars.
                lastI = i+1;
                inBase64 = true;
            }
        } else { // We decode base64.
            if (!base64IMAPChars[buf[i]]) { // Base64 ended.
                if (i == lastI && buf[i] == minusChar) { // "&-" -> "&"
                    res += "&";
                } else {
                    var b64str = base64Accum + buf.slice(lastI, i).toString().replace(/,/g, '/');
                    res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
                }

                if (buf[i] != minusChar) // Minus may be absorbed after base64.
                    i--;

                lastI = i+1;
                inBase64 = false;
                base64Accum = '';
            }
        }
    }

    if (!inBase64) {
        res += this.iconv.decode(buf.slice(lastI), "ascii"); // Write direct chars.
    } else {
        var b64str = base64Accum + buf.slice(lastI).toString().replace(/,/g, '/');

        var canBeDecoded = b64str.length - (b64str.length % 8); // Minimal chunk: 2 quads -> 2x3 bytes -> 3 chars.
        base64Accum = b64str.slice(canBeDecoded); // The rest will be decoded in future.
        b64str = b64str.slice(0, canBeDecoded);

        res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
    }

    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;

    return res;
}

Utf7IMAPDecoder.prototype.end = function() {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0)
        res = this.iconv.decode(Buffer.from(this.base64Accum, 'base64'), "utf16-be");

    this.inBase64 = false;
    this.base64Accum = '';
    return res;
}




/***/ }),

/***/ "./node_modules/iconv-lite/lib/bom-handling.js":
/*!*****************************************************!*\
  !*** ./node_modules/iconv-lite/lib/bom-handling.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BOMChar = '\uFEFF';

exports.PrependBOM = PrependBOMWrapper
function PrependBOMWrapper(encoder, options) {
    this.encoder = encoder;
    this.addBOM = true;
}

PrependBOMWrapper.prototype.write = function(str) {
    if (this.addBOM) {
        str = BOMChar + str;
        this.addBOM = false;
    }

    return this.encoder.write(str);
}

PrependBOMWrapper.prototype.end = function() {
    return this.encoder.end();
}


//------------------------------------------------------------------------------

exports.StripBOM = StripBOMWrapper;
function StripBOMWrapper(decoder, options) {
    this.decoder = decoder;
    this.pass = false;
    this.options = options || {};
}

StripBOMWrapper.prototype.write = function(buf) {
    var res = this.decoder.write(buf);
    if (this.pass || !res)
        return res;

    if (res[0] === BOMChar) {
        res = res.slice(1);
        if (typeof this.options.stripBOM === 'function')
            this.options.stripBOM();
    }

    this.pass = true;
    return res;
}

StripBOMWrapper.prototype.end = function() {
    return this.decoder.end();
}



/***/ }),

/***/ "./node_modules/iconv-lite/lib/extend-node.js":
/*!****************************************************!*\
  !*** ./node_modules/iconv-lite/lib/extend-node.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Buffer = __webpack_require__(/*! buffer */ "buffer").Buffer;
// Note: not polyfilled with safer-buffer on a purpose, as overrides Buffer

// == Extend Node primitives to use iconv-lite =================================

module.exports = function (iconv) {
    var original = undefined; // Place to keep original methods.

    // Node authors rewrote Buffer internals to make it compatible with
    // Uint8Array and we cannot patch key functions since then.
    // Note: this does use older Buffer API on a purpose
    iconv.supportsNodeEncodingsExtension = !(Buffer.from || new Buffer(0) instanceof Uint8Array);

    iconv.extendNodeEncodings = function extendNodeEncodings() {
        if (original) return;
        original = {};

        if (!iconv.supportsNodeEncodingsExtension) {
            console.error("ACTION NEEDED: require('iconv-lite').extendNodeEncodings() is not supported in your version of Node");
            console.error("See more info at https://github.com/ashtuchkin/iconv-lite/wiki/Node-v4-compatibility");
            return;
        }

        var nodeNativeEncodings = {
            'hex': true, 'utf8': true, 'utf-8': true, 'ascii': true, 'binary': true, 
            'base64': true, 'ucs2': true, 'ucs-2': true, 'utf16le': true, 'utf-16le': true,
        };

        Buffer.isNativeEncoding = function(enc) {
            return enc && nodeNativeEncodings[enc.toLowerCase()];
        }

        // -- SlowBuffer -----------------------------------------------------------
        var SlowBuffer = __webpack_require__(/*! buffer */ "buffer").SlowBuffer;

        original.SlowBufferToString = SlowBuffer.prototype.toString;
        SlowBuffer.prototype.toString = function(encoding, start, end) {
            encoding = String(encoding || 'utf8').toLowerCase();

            // Use native conversion when possible
            if (Buffer.isNativeEncoding(encoding))
                return original.SlowBufferToString.call(this, encoding, start, end);

            // Otherwise, use our decoding method.
            if (typeof start == 'undefined') start = 0;
            if (typeof end == 'undefined') end = this.length;
            return iconv.decode(this.slice(start, end), encoding);
        }

        original.SlowBufferWrite = SlowBuffer.prototype.write;
        SlowBuffer.prototype.write = function(string, offset, length, encoding) {
            // Support both (string, offset, length, encoding)
            // and the legacy (string, encoding, offset, length)
            if (isFinite(offset)) {
                if (!isFinite(length)) {
                    encoding = length;
                    length = undefined;
                }
            } else {  // legacy
                var swap = encoding;
                encoding = offset;
                offset = length;
                length = swap;
            }

            offset = +offset || 0;
            var remaining = this.length - offset;
            if (!length) {
                length = remaining;
            } else {
                length = +length;
                if (length > remaining) {
                    length = remaining;
                }
            }
            encoding = String(encoding || 'utf8').toLowerCase();

            // Use native conversion when possible
            if (Buffer.isNativeEncoding(encoding))
                return original.SlowBufferWrite.call(this, string, offset, length, encoding);

            if (string.length > 0 && (length < 0 || offset < 0))
                throw new RangeError('attempt to write beyond buffer bounds');

            // Otherwise, use our encoding method.
            var buf = iconv.encode(string, encoding);
            if (buf.length < length) length = buf.length;
            buf.copy(this, offset, 0, length);
            return length;
        }

        // -- Buffer ---------------------------------------------------------------

        original.BufferIsEncoding = Buffer.isEncoding;
        Buffer.isEncoding = function(encoding) {
            return Buffer.isNativeEncoding(encoding) || iconv.encodingExists(encoding);
        }

        original.BufferByteLength = Buffer.byteLength;
        Buffer.byteLength = SlowBuffer.byteLength = function(str, encoding) {
            encoding = String(encoding || 'utf8').toLowerCase();

            // Use native conversion when possible
            if (Buffer.isNativeEncoding(encoding))
                return original.BufferByteLength.call(this, str, encoding);

            // Slow, I know, but we don't have a better way yet.
            return iconv.encode(str, encoding).length;
        }

        original.BufferToString = Buffer.prototype.toString;
        Buffer.prototype.toString = function(encoding, start, end) {
            encoding = String(encoding || 'utf8').toLowerCase();

            // Use native conversion when possible
            if (Buffer.isNativeEncoding(encoding))
                return original.BufferToString.call(this, encoding, start, end);

            // Otherwise, use our decoding method.
            if (typeof start == 'undefined') start = 0;
            if (typeof end == 'undefined') end = this.length;
            return iconv.decode(this.slice(start, end), encoding);
        }

        original.BufferWrite = Buffer.prototype.write;
        Buffer.prototype.write = function(string, offset, length, encoding) {
            var _offset = offset, _length = length, _encoding = encoding;
            // Support both (string, offset, length, encoding)
            // and the legacy (string, encoding, offset, length)
            if (isFinite(offset)) {
                if (!isFinite(length)) {
                    encoding = length;
                    length = undefined;
                }
            } else {  // legacy
                var swap = encoding;
                encoding = offset;
                offset = length;
                length = swap;
            }

            encoding = String(encoding || 'utf8').toLowerCase();

            // Use native conversion when possible
            if (Buffer.isNativeEncoding(encoding))
                return original.BufferWrite.call(this, string, _offset, _length, _encoding);

            offset = +offset || 0;
            var remaining = this.length - offset;
            if (!length) {
                length = remaining;
            } else {
                length = +length;
                if (length > remaining) {
                    length = remaining;
                }
            }

            if (string.length > 0 && (length < 0 || offset < 0))
                throw new RangeError('attempt to write beyond buffer bounds');

            // Otherwise, use our encoding method.
            var buf = iconv.encode(string, encoding);
            if (buf.length < length) length = buf.length;
            buf.copy(this, offset, 0, length);
            return length;

            // TODO: Set _charsWritten.
        }


        // -- Readable -------------------------------------------------------------
        if (iconv.supportsStreams) {
            var Readable = __webpack_require__(/*! stream */ "stream").Readable;

            original.ReadableSetEncoding = Readable.prototype.setEncoding;
            Readable.prototype.setEncoding = function setEncoding(enc, options) {
                // Use our own decoder, it has the same interface.
                // We cannot use original function as it doesn't handle BOM-s.
                this._readableState.decoder = iconv.getDecoder(enc, options);
                this._readableState.encoding = enc;
            }

            Readable.prototype.collect = iconv._collect;
        }
    }

    // Remove iconv-lite Node primitive extensions.
    iconv.undoExtendNodeEncodings = function undoExtendNodeEncodings() {
        if (!iconv.supportsNodeEncodingsExtension)
            return;
        if (!original)
            throw new Error("require('iconv-lite').undoExtendNodeEncodings(): Nothing to undo; extendNodeEncodings() is not called.")

        delete Buffer.isNativeEncoding;

        var SlowBuffer = __webpack_require__(/*! buffer */ "buffer").SlowBuffer;

        SlowBuffer.prototype.toString = original.SlowBufferToString;
        SlowBuffer.prototype.write = original.SlowBufferWrite;

        Buffer.isEncoding = original.BufferIsEncoding;
        Buffer.byteLength = original.BufferByteLength;
        Buffer.prototype.toString = original.BufferToString;
        Buffer.prototype.write = original.BufferWrite;

        if (iconv.supportsStreams) {
            var Readable = __webpack_require__(/*! stream */ "stream").Readable;

            Readable.prototype.setEncoding = original.ReadableSetEncoding;
            delete Readable.prototype.collect;
        }

        original = undefined;
    }
}


/***/ }),

/***/ "./node_modules/iconv-lite/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/iconv-lite/lib/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// Some environments don't have global Buffer (e.g. React Native).
// Solution would be installing npm modules "buffer" and "stream" explicitly.
var Buffer = __webpack_require__(/*! safer-buffer */ "./node_modules/safer-buffer/safer.js").Buffer;

var bomHandling = __webpack_require__(/*! ./bom-handling */ "./node_modules/iconv-lite/lib/bom-handling.js"),
    iconv = module.exports;

// All codecs and aliases are kept here, keyed by encoding name/alias.
// They are lazy loaded in `iconv.getCodec` from `encodings/index.js`.
iconv.encodings = null;

// Characters emitted in case of error.
iconv.defaultCharUnicode = '';
iconv.defaultCharSingleByte = '?';

// Public API.
iconv.encode = function encode(str, encoding, options) {
    str = "" + (str || ""); // Ensure string.

    var encoder = iconv.getEncoder(encoding, options);

    var res = encoder.write(str);
    var trail = encoder.end();
    
    return (trail && trail.length > 0) ? Buffer.concat([res, trail]) : res;
}

iconv.decode = function decode(buf, encoding, options) {
    if (typeof buf === 'string') {
        if (!iconv.skipDecodeWarning) {
            console.error('Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding');
            iconv.skipDecodeWarning = true;
        }

        buf = Buffer.from("" + (buf || ""), "binary"); // Ensure buffer.
    }

    var decoder = iconv.getDecoder(encoding, options);

    var res = decoder.write(buf);
    var trail = decoder.end();

    return trail ? (res + trail) : res;
}

iconv.encodingExists = function encodingExists(enc) {
    try {
        iconv.getCodec(enc);
        return true;
    } catch (e) {
        return false;
    }
}

// Legacy aliases to convert functions
iconv.toEncoding = iconv.encode;
iconv.fromEncoding = iconv.decode;

// Search for a codec in iconv.encodings. Cache codec data in iconv._codecDataCache.
iconv._codecDataCache = {};
iconv.getCodec = function getCodec(encoding) {
    if (!iconv.encodings)
        iconv.encodings = __webpack_require__(/*! ../encodings */ "./node_modules/iconv-lite/encodings/index.js"); // Lazy load all encoding definitions.
    
    // Canonicalize encoding name: strip all non-alphanumeric chars and appended year.
    var enc = iconv._canonicalizeEncoding(encoding);

    // Traverse iconv.encodings to find actual codec.
    var codecOptions = {};
    while (true) {
        var codec = iconv._codecDataCache[enc];
        if (codec)
            return codec;

        var codecDef = iconv.encodings[enc];

        switch (typeof codecDef) {
            case "string": // Direct alias to other encoding.
                enc = codecDef;
                break;

            case "object": // Alias with options. Can be layered.
                for (var key in codecDef)
                    codecOptions[key] = codecDef[key];

                if (!codecOptions.encodingName)
                    codecOptions.encodingName = enc;
                
                enc = codecDef.type;
                break;

            case "function": // Codec itself.
                if (!codecOptions.encodingName)
                    codecOptions.encodingName = enc;

                // The codec function must load all tables and return object with .encoder and .decoder methods.
                // It'll be called only once (for each different options object).
                codec = new codecDef(codecOptions, iconv);

                iconv._codecDataCache[codecOptions.encodingName] = codec; // Save it to be reused later.
                return codec;

            default:
                throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '"+enc+"')");
        }
    }
}

iconv._canonicalizeEncoding = function(encoding) {
    // Canonicalize encoding name: strip all non-alphanumeric chars and appended year.
    return (''+encoding).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
}

iconv.getEncoder = function getEncoder(encoding, options) {
    var codec = iconv.getCodec(encoding),
        encoder = new codec.encoder(options, codec);

    if (codec.bomAware && options && options.addBOM)
        encoder = new bomHandling.PrependBOM(encoder, options);

    return encoder;
}

iconv.getDecoder = function getDecoder(encoding, options) {
    var codec = iconv.getCodec(encoding),
        decoder = new codec.decoder(options, codec);

    if (codec.bomAware && !(options && options.stripBOM === false))
        decoder = new bomHandling.StripBOM(decoder, options);

    return decoder;
}


// Load extensions in Node. All of them are omitted in Browserify build via 'browser' field in package.json.
var nodeVer = typeof process !== 'undefined' && process.versions && process.versions.node;
if (nodeVer) {

    // Load streaming support in Node v0.10+
    var nodeVerArr = nodeVer.split(".").map(Number);
    if (nodeVerArr[0] > 0 || nodeVerArr[1] >= 10) {
        __webpack_require__(/*! ./streams */ "./node_modules/iconv-lite/lib/streams.js")(iconv);
    }

    // Load Node primitive extensions.
    __webpack_require__(/*! ./extend-node */ "./node_modules/iconv-lite/lib/extend-node.js")(iconv);
}

if (false) {}


/***/ }),

/***/ "./node_modules/iconv-lite/lib/streams.js":
/*!************************************************!*\
  !*** ./node_modules/iconv-lite/lib/streams.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Buffer = __webpack_require__(/*! buffer */ "buffer").Buffer,
    Transform = __webpack_require__(/*! stream */ "stream").Transform;


// == Exports ==================================================================
module.exports = function(iconv) {
    
    // Additional Public API.
    iconv.encodeStream = function encodeStream(encoding, options) {
        return new IconvLiteEncoderStream(iconv.getEncoder(encoding, options), options);
    }

    iconv.decodeStream = function decodeStream(encoding, options) {
        return new IconvLiteDecoderStream(iconv.getDecoder(encoding, options), options);
    }

    iconv.supportsStreams = true;


    // Not published yet.
    iconv.IconvLiteEncoderStream = IconvLiteEncoderStream;
    iconv.IconvLiteDecoderStream = IconvLiteDecoderStream;
    iconv._collect = IconvLiteDecoderStream.prototype.collect;
};


// == Encoder stream =======================================================
function IconvLiteEncoderStream(conv, options) {
    this.conv = conv;
    options = options || {};
    options.decodeStrings = false; // We accept only strings, so we don't need to decode them.
    Transform.call(this, options);
}

IconvLiteEncoderStream.prototype = Object.create(Transform.prototype, {
    constructor: { value: IconvLiteEncoderStream }
});

IconvLiteEncoderStream.prototype._transform = function(chunk, encoding, done) {
    if (typeof chunk != 'string')
        return done(new Error("Iconv encoding stream needs strings as its input."));
    try {
        var res = this.conv.write(chunk);
        if (res && res.length) this.push(res);
        done();
    }
    catch (e) {
        done(e);
    }
}

IconvLiteEncoderStream.prototype._flush = function(done) {
    try {
        var res = this.conv.end();
        if (res && res.length) this.push(res);
        done();
    }
    catch (e) {
        done(e);
    }
}

IconvLiteEncoderStream.prototype.collect = function(cb) {
    var chunks = [];
    this.on('error', cb);
    this.on('data', function(chunk) { chunks.push(chunk); });
    this.on('end', function() {
        cb(null, Buffer.concat(chunks));
    });
    return this;
}


// == Decoder stream =======================================================
function IconvLiteDecoderStream(conv, options) {
    this.conv = conv;
    options = options || {};
    options.encoding = this.encoding = 'utf8'; // We output strings.
    Transform.call(this, options);
}

IconvLiteDecoderStream.prototype = Object.create(Transform.prototype, {
    constructor: { value: IconvLiteDecoderStream }
});

IconvLiteDecoderStream.prototype._transform = function(chunk, encoding, done) {
    if (!Buffer.isBuffer(chunk))
        return done(new Error("Iconv decoding stream needs buffers as its input."));
    try {
        var res = this.conv.write(chunk);
        if (res && res.length) this.push(res, this.encoding);
        done();
    }
    catch (e) {
        done(e);
    }
}

IconvLiteDecoderStream.prototype._flush = function(done) {
    try {
        var res = this.conv.end();
        if (res && res.length) this.push(res, this.encoding);                
        done();
    }
    catch (e) {
        done(e);
    }
}

IconvLiteDecoderStream.prototype.collect = function(cb) {
    var res = '';
    this.on('error', cb);
    this.on('data', function(chunk) { res += chunk; });
    this.on('end', function() {
        cb(null, res);
    });
    return this;
}



/***/ }),

/***/ "./node_modules/inherits/inherits.js":
/*!*******************************************!*\
  !*** ./node_modules/inherits/inherits.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

try {
  var util = __webpack_require__(/*! util */ "util");
  if (typeof util.inherits !== 'function') throw '';
  module.exports = util.inherits;
} catch (e) {
  module.exports = __webpack_require__(/*! ./inherits_browser.js */ "./node_modules/inherits/inherits_browser.js");
}


/***/ }),

/***/ "./node_modules/inherits/inherits_browser.js":
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}


/***/ }),

/***/ "./node_modules/ipaddr.js/lib/ipaddr.js":
/*!**********************************************!*\
  !*** ./node_modules/ipaddr.js/lib/ipaddr.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {(function() {
  var expandIPv6, ipaddr, ipv4Part, ipv4Regexes, ipv6Part, ipv6Regexes, matchCIDR, root, zoneIndex;

  ipaddr = {};

  root = this;

  if (( true && module !== null) && module.exports) {
    module.exports = ipaddr;
  } else {
    root['ipaddr'] = ipaddr;
  }

  matchCIDR = function(first, second, partSize, cidrBits) {
    var part, shift;
    if (first.length !== second.length) {
      throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
    }
    part = 0;
    while (cidrBits > 0) {
      shift = partSize - cidrBits;
      if (shift < 0) {
        shift = 0;
      }
      if (first[part] >> shift !== second[part] >> shift) {
        return false;
      }
      cidrBits -= partSize;
      part += 1;
    }
    return true;
  };

  ipaddr.subnetMatch = function(address, rangeList, defaultName) {
    var k, len, rangeName, rangeSubnets, subnet;
    if (defaultName == null) {
      defaultName = 'unicast';
    }
    for (rangeName in rangeList) {
      rangeSubnets = rangeList[rangeName];
      if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {
        rangeSubnets = [rangeSubnets];
      }
      for (k = 0, len = rangeSubnets.length; k < len; k++) {
        subnet = rangeSubnets[k];
        if (address.kind() === subnet[0].kind()) {
          if (address.match.apply(address, subnet)) {
            return rangeName;
          }
        }
      }
    }
    return defaultName;
  };

  ipaddr.IPv4 = (function() {
    function IPv4(octets) {
      var k, len, octet;
      if (octets.length !== 4) {
        throw new Error("ipaddr: ipv4 octet count should be 4");
      }
      for (k = 0, len = octets.length; k < len; k++) {
        octet = octets[k];
        if (!((0 <= octet && octet <= 255))) {
          throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
        }
      }
      this.octets = octets;
    }

    IPv4.prototype.kind = function() {
      return 'ipv4';
    };

    IPv4.prototype.toString = function() {
      return this.octets.join(".");
    };

    IPv4.prototype.toNormalizedString = function() {
      return this.toString();
    };

    IPv4.prototype.toByteArray = function() {
      return this.octets.slice(0);
    };

    IPv4.prototype.match = function(other, cidrRange) {
      var ref;
      if (cidrRange === void 0) {
        ref = other, other = ref[0], cidrRange = ref[1];
      }
      if (other.kind() !== 'ipv4') {
        throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
      }
      return matchCIDR(this.octets, other.octets, 8, cidrRange);
    };

    IPv4.prototype.SpecialRanges = {
      unspecified: [[new IPv4([0, 0, 0, 0]), 8]],
      broadcast: [[new IPv4([255, 255, 255, 255]), 32]],
      multicast: [[new IPv4([224, 0, 0, 0]), 4]],
      linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],
      loopback: [[new IPv4([127, 0, 0, 0]), 8]],
      carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],
      "private": [[new IPv4([10, 0, 0, 0]), 8], [new IPv4([172, 16, 0, 0]), 12], [new IPv4([192, 168, 0, 0]), 16]],
      reserved: [[new IPv4([192, 0, 0, 0]), 24], [new IPv4([192, 0, 2, 0]), 24], [new IPv4([192, 88, 99, 0]), 24], [new IPv4([198, 51, 100, 0]), 24], [new IPv4([203, 0, 113, 0]), 24], [new IPv4([240, 0, 0, 0]), 4]]
    };

    IPv4.prototype.range = function() {
      return ipaddr.subnetMatch(this, this.SpecialRanges);
    };

    IPv4.prototype.toIPv4MappedAddress = function() {
      return ipaddr.IPv6.parse("::ffff:" + (this.toString()));
    };

    IPv4.prototype.prefixLengthFromSubnetMask = function() {
      var cidr, i, k, octet, stop, zeros, zerotable;
      zerotable = {
        0: 8,
        128: 7,
        192: 6,
        224: 5,
        240: 4,
        248: 3,
        252: 2,
        254: 1,
        255: 0
      };
      cidr = 0;
      stop = false;
      for (i = k = 3; k >= 0; i = k += -1) {
        octet = this.octets[i];
        if (octet in zerotable) {
          zeros = zerotable[octet];
          if (stop && zeros !== 0) {
            return null;
          }
          if (zeros !== 8) {
            stop = true;
          }
          cidr += zeros;
        } else {
          return null;
        }
      }
      return 32 - cidr;
    };

    return IPv4;

  })();

  ipv4Part = "(0?\\d+|0x[a-f0-9]+)";

  ipv4Regexes = {
    fourOctet: new RegExp("^" + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "$", 'i'),
    longValue: new RegExp("^" + ipv4Part + "$", 'i')
  };

  ipaddr.IPv4.parser = function(string) {
    var match, parseIntAuto, part, shift, value;
    parseIntAuto = function(string) {
      if (string[0] === "0" && string[1] !== "x") {
        return parseInt(string, 8);
      } else {
        return parseInt(string);
      }
    };
    if (match = string.match(ipv4Regexes.fourOctet)) {
      return (function() {
        var k, len, ref, results;
        ref = match.slice(1, 6);
        results = [];
        for (k = 0, len = ref.length; k < len; k++) {
          part = ref[k];
          results.push(parseIntAuto(part));
        }
        return results;
      })();
    } else if (match = string.match(ipv4Regexes.longValue)) {
      value = parseIntAuto(match[1]);
      if (value > 0xffffffff || value < 0) {
        throw new Error("ipaddr: address outside defined range");
      }
      return ((function() {
        var k, results;
        results = [];
        for (shift = k = 0; k <= 24; shift = k += 8) {
          results.push((value >> shift) & 0xff);
        }
        return results;
      })()).reverse();
    } else {
      return null;
    }
  };

  ipaddr.IPv6 = (function() {
    function IPv6(parts, zoneId) {
      var i, k, l, len, part, ref;
      if (parts.length === 16) {
        this.parts = [];
        for (i = k = 0; k <= 14; i = k += 2) {
          this.parts.push((parts[i] << 8) | parts[i + 1]);
        }
      } else if (parts.length === 8) {
        this.parts = parts;
      } else {
        throw new Error("ipaddr: ipv6 part count should be 8 or 16");
      }
      ref = this.parts;
      for (l = 0, len = ref.length; l < len; l++) {
        part = ref[l];
        if (!((0 <= part && part <= 0xffff))) {
          throw new Error("ipaddr: ipv6 part should fit in 16 bits");
        }
      }
      if (zoneId) {
        this.zoneId = zoneId;
      }
    }

    IPv6.prototype.kind = function() {
      return 'ipv6';
    };

    IPv6.prototype.toString = function() {
      return this.toNormalizedString().replace(/((^|:)(0(:|$))+)/, '::');
    };

    IPv6.prototype.toRFC5952String = function() {
      var bestMatchIndex, bestMatchLength, match, regex, string;
      regex = /((^|:)(0(:|$)){2,})/g;
      string = this.toNormalizedString();
      bestMatchIndex = 0;
      bestMatchLength = -1;
      while ((match = regex.exec(string))) {
        if (match[0].length > bestMatchLength) {
          bestMatchIndex = match.index;
          bestMatchLength = match[0].length;
        }
      }
      if (bestMatchLength < 0) {
        return string;
      }
      return string.substring(0, bestMatchIndex) + '::' + string.substring(bestMatchIndex + bestMatchLength);
    };

    IPv6.prototype.toByteArray = function() {
      var bytes, k, len, part, ref;
      bytes = [];
      ref = this.parts;
      for (k = 0, len = ref.length; k < len; k++) {
        part = ref[k];
        bytes.push(part >> 8);
        bytes.push(part & 0xff);
      }
      return bytes;
    };

    IPv6.prototype.toNormalizedString = function() {
      var addr, part, suffix;
      addr = ((function() {
        var k, len, ref, results;
        ref = this.parts;
        results = [];
        for (k = 0, len = ref.length; k < len; k++) {
          part = ref[k];
          results.push(part.toString(16));
        }
        return results;
      }).call(this)).join(":");
      suffix = '';
      if (this.zoneId) {
        suffix = '%' + this.zoneId;
      }
      return addr + suffix;
    };

    IPv6.prototype.toFixedLengthString = function() {
      var addr, part, suffix;
      addr = ((function() {
        var k, len, ref, results;
        ref = this.parts;
        results = [];
        for (k = 0, len = ref.length; k < len; k++) {
          part = ref[k];
          results.push(part.toString(16).padStart(4, '0'));
        }
        return results;
      }).call(this)).join(":");
      suffix = '';
      if (this.zoneId) {
        suffix = '%' + this.zoneId;
      }
      return addr + suffix;
    };

    IPv6.prototype.match = function(other, cidrRange) {
      var ref;
      if (cidrRange === void 0) {
        ref = other, other = ref[0], cidrRange = ref[1];
      }
      if (other.kind() !== 'ipv6') {
        throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
      }
      return matchCIDR(this.parts, other.parts, 16, cidrRange);
    };

    IPv6.prototype.SpecialRanges = {
      unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],
      linkLocal: [new IPv6([0xfe80, 0, 0, 0, 0, 0, 0, 0]), 10],
      multicast: [new IPv6([0xff00, 0, 0, 0, 0, 0, 0, 0]), 8],
      loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],
      uniqueLocal: [new IPv6([0xfc00, 0, 0, 0, 0, 0, 0, 0]), 7],
      ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 0xffff, 0, 0]), 96],
      rfc6145: [new IPv6([0, 0, 0, 0, 0xffff, 0, 0, 0]), 96],
      rfc6052: [new IPv6([0x64, 0xff9b, 0, 0, 0, 0, 0, 0]), 96],
      '6to4': [new IPv6([0x2002, 0, 0, 0, 0, 0, 0, 0]), 16],
      teredo: [new IPv6([0x2001, 0, 0, 0, 0, 0, 0, 0]), 32],
      reserved: [[new IPv6([0x2001, 0xdb8, 0, 0, 0, 0, 0, 0]), 32]]
    };

    IPv6.prototype.range = function() {
      return ipaddr.subnetMatch(this, this.SpecialRanges);
    };

    IPv6.prototype.isIPv4MappedAddress = function() {
      return this.range() === 'ipv4Mapped';
    };

    IPv6.prototype.toIPv4Address = function() {
      var high, low, ref;
      if (!this.isIPv4MappedAddress()) {
        throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
      }
      ref = this.parts.slice(-2), high = ref[0], low = ref[1];
      return new ipaddr.IPv4([high >> 8, high & 0xff, low >> 8, low & 0xff]);
    };

    IPv6.prototype.prefixLengthFromSubnetMask = function() {
      var cidr, i, k, part, stop, zeros, zerotable;
      zerotable = {
        0: 16,
        32768: 15,
        49152: 14,
        57344: 13,
        61440: 12,
        63488: 11,
        64512: 10,
        65024: 9,
        65280: 8,
        65408: 7,
        65472: 6,
        65504: 5,
        65520: 4,
        65528: 3,
        65532: 2,
        65534: 1,
        65535: 0
      };
      cidr = 0;
      stop = false;
      for (i = k = 7; k >= 0; i = k += -1) {
        part = this.parts[i];
        if (part in zerotable) {
          zeros = zerotable[part];
          if (stop && zeros !== 0) {
            return null;
          }
          if (zeros !== 16) {
            stop = true;
          }
          cidr += zeros;
        } else {
          return null;
        }
      }
      return 128 - cidr;
    };

    return IPv6;

  })();

  ipv6Part = "(?:[0-9a-f]+::?)+";

  zoneIndex = "%[0-9a-z]{1,}";

  ipv6Regexes = {
    zoneIndex: new RegExp(zoneIndex, 'i'),
    "native": new RegExp("^(::)?(" + ipv6Part + ")?([0-9a-f]+)?(::)?(" + zoneIndex + ")?$", 'i'),
    transitional: new RegExp(("^((?:" + ipv6Part + ")|(?:::)(?:" + ipv6Part + ")?)") + (ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part) + ("(" + zoneIndex + ")?$"), 'i')
  };

  expandIPv6 = function(string, parts) {
    var colonCount, lastColon, part, replacement, replacementCount, zoneId;
    if (string.indexOf('::') !== string.lastIndexOf('::')) {
      return null;
    }
    zoneId = (string.match(ipv6Regexes['zoneIndex']) || [])[0];
    if (zoneId) {
      zoneId = zoneId.substring(1);
      string = string.replace(/%.+$/, '');
    }
    colonCount = 0;
    lastColon = -1;
    while ((lastColon = string.indexOf(':', lastColon + 1)) >= 0) {
      colonCount++;
    }
    if (string.substr(0, 2) === '::') {
      colonCount--;
    }
    if (string.substr(-2, 2) === '::') {
      colonCount--;
    }
    if (colonCount > parts) {
      return null;
    }
    replacementCount = parts - colonCount;
    replacement = ':';
    while (replacementCount--) {
      replacement += '0:';
    }
    string = string.replace('::', replacement);
    if (string[0] === ':') {
      string = string.slice(1);
    }
    if (string[string.length - 1] === ':') {
      string = string.slice(0, -1);
    }
    parts = (function() {
      var k, len, ref, results;
      ref = string.split(":");
      results = [];
      for (k = 0, len = ref.length; k < len; k++) {
        part = ref[k];
        results.push(parseInt(part, 16));
      }
      return results;
    })();
    return {
      parts: parts,
      zoneId: zoneId
    };
  };

  ipaddr.IPv6.parser = function(string) {
    var addr, k, len, match, octet, octets, zoneId;
    if (ipv6Regexes['native'].test(string)) {
      return expandIPv6(string, 8);
    } else if (match = string.match(ipv6Regexes['transitional'])) {
      zoneId = match[6] || '';
      addr = expandIPv6(match[1].slice(0, -1) + zoneId, 6);
      if (addr.parts) {
        octets = [parseInt(match[2]), parseInt(match[3]), parseInt(match[4]), parseInt(match[5])];
        for (k = 0, len = octets.length; k < len; k++) {
          octet = octets[k];
          if (!((0 <= octet && octet <= 255))) {
            return null;
          }
        }
        addr.parts.push(octets[0] << 8 | octets[1]);
        addr.parts.push(octets[2] << 8 | octets[3]);
        return {
          parts: addr.parts,
          zoneId: addr.zoneId
        };
      }
    }
    return null;
  };

  ipaddr.IPv4.isIPv4 = ipaddr.IPv6.isIPv6 = function(string) {
    return this.parser(string) !== null;
  };

  ipaddr.IPv4.isValid = function(string) {
    var e;
    try {
      new this(this.parser(string));
      return true;
    } catch (error1) {
      e = error1;
      return false;
    }
  };

  ipaddr.IPv4.isValidFourPartDecimal = function(string) {
    if (ipaddr.IPv4.isValid(string) && string.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/)) {
      return true;
    } else {
      return false;
    }
  };

  ipaddr.IPv6.isValid = function(string) {
    var addr, e;
    if (typeof string === "string" && string.indexOf(":") === -1) {
      return false;
    }
    try {
      addr = this.parser(string);
      new this(addr.parts, addr.zoneId);
      return true;
    } catch (error1) {
      e = error1;
      return false;
    }
  };

  ipaddr.IPv4.parse = function(string) {
    var parts;
    parts = this.parser(string);
    if (parts === null) {
      throw new Error("ipaddr: string is not formatted like ip address");
    }
    return new this(parts);
  };

  ipaddr.IPv6.parse = function(string) {
    var addr;
    addr = this.parser(string);
    if (addr.parts === null) {
      throw new Error("ipaddr: string is not formatted like ip address");
    }
    return new this(addr.parts, addr.zoneId);
  };

  ipaddr.IPv4.parseCIDR = function(string) {
    var maskLength, match, parsed;
    if (match = string.match(/^(.+)\/(\d+)$/)) {
      maskLength = parseInt(match[2]);
      if (maskLength >= 0 && maskLength <= 32) {
        parsed = [this.parse(match[1]), maskLength];
        Object.defineProperty(parsed, 'toString', {
          value: function() {
            return this.join('/');
          }
        });
        return parsed;
      }
    }
    throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
  };

  ipaddr.IPv4.subnetMaskFromPrefixLength = function(prefix) {
    var filledOctetCount, j, octets;
    prefix = parseInt(prefix);
    if (prefix < 0 || prefix > 32) {
      throw new Error('ipaddr: invalid IPv4 prefix length');
    }
    octets = [0, 0, 0, 0];
    j = 0;
    filledOctetCount = Math.floor(prefix / 8);
    while (j < filledOctetCount) {
      octets[j] = 255;
      j++;
    }
    if (filledOctetCount < 4) {
      octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - (prefix % 8);
    }
    return new this(octets);
  };

  ipaddr.IPv4.broadcastAddressFromCIDR = function(string) {
    var cidr, error, i, ipInterfaceOctets, octets, subnetMaskOctets;
    try {
      cidr = this.parseCIDR(string);
      ipInterfaceOctets = cidr[0].toByteArray();
      subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
      octets = [];
      i = 0;
      while (i < 4) {
        octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
        i++;
      }
      return new this(octets);
    } catch (error1) {
      error = error1;
      throw new Error('ipaddr: the address does not have IPv4 CIDR format');
    }
  };

  ipaddr.IPv4.networkAddressFromCIDR = function(string) {
    var cidr, error, i, ipInterfaceOctets, octets, subnetMaskOctets;
    try {
      cidr = this.parseCIDR(string);
      ipInterfaceOctets = cidr[0].toByteArray();
      subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
      octets = [];
      i = 0;
      while (i < 4) {
        octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
        i++;
      }
      return new this(octets);
    } catch (error1) {
      error = error1;
      throw new Error('ipaddr: the address does not have IPv4 CIDR format');
    }
  };

  ipaddr.IPv6.parseCIDR = function(string) {
    var maskLength, match, parsed;
    if (match = string.match(/^(.+)\/(\d+)$/)) {
      maskLength = parseInt(match[2]);
      if (maskLength >= 0 && maskLength <= 128) {
        parsed = [this.parse(match[1]), maskLength];
        Object.defineProperty(parsed, 'toString', {
          value: function() {
            return this.join('/');
          }
        });
        return parsed;
      }
    }
    throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
  };

  ipaddr.isValid = function(string) {
    return ipaddr.IPv6.isValid(string) || ipaddr.IPv4.isValid(string);
  };

  ipaddr.parse = function(string) {
    if (ipaddr.IPv6.isValid(string)) {
      return ipaddr.IPv6.parse(string);
    } else if (ipaddr.IPv4.isValid(string)) {
      return ipaddr.IPv4.parse(string);
    } else {
      throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
    }
  };

  ipaddr.parseCIDR = function(string) {
    var e;
    try {
      return ipaddr.IPv6.parseCIDR(string);
    } catch (error1) {
      e = error1;
      try {
        return ipaddr.IPv4.parseCIDR(string);
      } catch (error1) {
        e = error1;
        throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
      }
    }
  };

  ipaddr.fromByteArray = function(bytes) {
    var length;
    length = bytes.length;
    if (length === 4) {
      return new ipaddr.IPv4(bytes);
    } else if (length === 16) {
      return new ipaddr.IPv6(bytes);
    } else {
      throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
    }
  };

  ipaddr.process = function(string) {
    var addr;
    addr = this.parse(string);
    if (addr.kind() === 'ipv6' && addr.isIPv4MappedAddress()) {
      return addr.toIPv4Address();
    } else {
      return addr;
    }
  };

}).call(this);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/is-binary-path/index.js":
/*!**********************************************!*\
  !*** ./node_modules/is-binary-path/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const path = __webpack_require__(/*! path */ "path");
const binaryExtensions = __webpack_require__(/*! binary-extensions */ "./node_modules/binary-extensions/index.js");

const extensions = new Set(binaryExtensions);

module.exports = filePath => extensions.has(path.extname(filePath).slice(1).toLowerCase());


/***/ }),

/***/ "./node_modules/is-extglob/index.js":
/*!******************************************!*\
  !*** ./node_modules/is-extglob/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*!
 * is-extglob <https://github.com/jonschlinkert/is-extglob>
 *
 * Copyright (c) 2014-2016, Jon Schlinkert.
 * Licensed under the MIT License.
 */

module.exports = function isExtglob(str) {
  if (typeof str !== 'string' || str === '') {
    return false;
  }

  var match;
  while ((match = /(\\).|([@?!+*]\(.*\))/g.exec(str))) {
    if (match[2]) return true;
    str = str.slice(match.index + match[0].length);
  }

  return false;
};


/***/ }),

/***/ "./node_modules/is-glob/index.js":
/*!***************************************!*\
  !*** ./node_modules/is-glob/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*!
 * is-glob <https://github.com/jonschlinkert/is-glob>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

var isExtglob = __webpack_require__(/*! is-extglob */ "./node_modules/is-extglob/index.js");
var chars = { '{': '}', '(': ')', '[': ']'};
var strictRegex = /\\(.)|(^!|\*|[\].+)]\?|\[[^\\\]]+\]|\{[^\\}]+\}|\(\?[:!=][^\\)]+\)|\([^|]+\|[^\\)]+\))/;
var relaxedRegex = /\\(.)|(^!|[*?{}()[\]]|\(\?)/;

module.exports = function isGlob(str, options) {
  if (typeof str !== 'string' || str === '') {
    return false;
  }

  if (isExtglob(str)) {
    return true;
  }

  var regex = strictRegex;
  var match;

  // optionally relax regex
  if (options && options.strict === false) {
    regex = relaxedRegex;
  }

  while ((match = regex.exec(str))) {
    if (match[2]) return true;
    var idx = match.index + match[0].length;

    // if an open bracket/brace/paren is escaped,
    // set the index to the next closing character
    var open = match[1];
    var close = open ? chars[open] : null;
    if (open && close) {
      var n = str.indexOf(close, idx);
      if (n !== -1) {
        idx = n + 1;
      }
    }

    str = str.slice(idx);
  }
  return false;
};


/***/ }),

/***/ "./node_modules/is-number/index.js":
/*!*****************************************!*\
  !*** ./node_modules/is-number/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * is-number <https://github.com/jonschlinkert/is-number>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Released under the MIT License.
 */



module.exports = function(num) {
  if (typeof num === 'number') {
    return num - num === 0;
  }
  if (typeof num === 'string' && num.trim() !== '') {
    return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
  }
  return false;
};


/***/ }),

/***/ "./node_modules/media-typer/index.js":
/*!*******************************************!*\
  !*** ./node_modules/media-typer/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*!
 * media-typer
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * RegExp to match *( ";" parameter ) in RFC 2616 sec 3.7
 *
 * parameter     = token "=" ( token | quoted-string )
 * token         = 1*<any CHAR except CTLs or separators>
 * separators    = "(" | ")" | "<" | ">" | "@"
 *               | "," | ";" | ":" | "\" | <">
 *               | "/" | "[" | "]" | "?" | "="
 *               | "{" | "}" | SP | HT
 * quoted-string = ( <"> *(qdtext | quoted-pair ) <"> )
 * qdtext        = <any TEXT except <">>
 * quoted-pair   = "\" CHAR
 * CHAR          = <any US-ASCII character (octets 0 - 127)>
 * TEXT          = <any OCTET except CTLs, but including LWS>
 * LWS           = [CRLF] 1*( SP | HT )
 * CRLF          = CR LF
 * CR            = <US-ASCII CR, carriage return (13)>
 * LF            = <US-ASCII LF, linefeed (10)>
 * SP            = <US-ASCII SP, space (32)>
 * SHT           = <US-ASCII HT, horizontal-tab (9)>
 * CTL           = <any US-ASCII control character (octets 0 - 31) and DEL (127)>
 * OCTET         = <any 8-bit sequence of data>
 */
var paramRegExp = /; *([!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) *= *("(?:[ !\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u0020-\u007e])*"|[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) */g;
var textRegExp = /^[\u0020-\u007e\u0080-\u00ff]+$/
var tokenRegExp = /^[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+$/

/**
 * RegExp to match quoted-pair in RFC 2616
 *
 * quoted-pair = "\" CHAR
 * CHAR        = <any US-ASCII character (octets 0 - 127)>
 */
var qescRegExp = /\\([\u0000-\u007f])/g;

/**
 * RegExp to match chars that must be quoted-pair in RFC 2616
 */
var quoteRegExp = /([\\"])/g;

/**
 * RegExp to match type in RFC 6838
 *
 * type-name = restricted-name
 * subtype-name = restricted-name
 * restricted-name = restricted-name-first *126restricted-name-chars
 * restricted-name-first  = ALPHA / DIGIT
 * restricted-name-chars  = ALPHA / DIGIT / "!" / "#" /
 *                          "$" / "&" / "-" / "^" / "_"
 * restricted-name-chars =/ "." ; Characters before first dot always
 *                              ; specify a facet name
 * restricted-name-chars =/ "+" ; Characters after last plus always
 *                              ; specify a structured syntax suffix
 * ALPHA =  %x41-5A / %x61-7A   ; A-Z / a-z
 * DIGIT =  %x30-39             ; 0-9
 */
var subtypeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/
var typeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/
var typeRegExp = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;

/**
 * Module exports.
 */

exports.format = format
exports.parse = parse

/**
 * Format object to media type.
 *
 * @param {object} obj
 * @return {string}
 * @api public
 */

function format(obj) {
  if (!obj || typeof obj !== 'object') {
    throw new TypeError('argument obj is required')
  }

  var parameters = obj.parameters
  var subtype = obj.subtype
  var suffix = obj.suffix
  var type = obj.type

  if (!type || !typeNameRegExp.test(type)) {
    throw new TypeError('invalid type')
  }

  if (!subtype || !subtypeNameRegExp.test(subtype)) {
    throw new TypeError('invalid subtype')
  }

  // format as type/subtype
  var string = type + '/' + subtype

  // append +suffix
  if (suffix) {
    if (!typeNameRegExp.test(suffix)) {
      throw new TypeError('invalid suffix')
    }

    string += '+' + suffix
  }

  // append parameters
  if (parameters && typeof parameters === 'object') {
    var param
    var params = Object.keys(parameters).sort()

    for (var i = 0; i < params.length; i++) {
      param = params[i]

      if (!tokenRegExp.test(param)) {
        throw new TypeError('invalid parameter name')
      }

      string += '; ' + param + '=' + qstring(parameters[param])
    }
  }

  return string
}

/**
 * Parse media type to object.
 *
 * @param {string|object} string
 * @return {Object}
 * @api public
 */

function parse(string) {
  if (!string) {
    throw new TypeError('argument string is required')
  }

  // support req/res-like objects as argument
  if (typeof string === 'object') {
    string = getcontenttype(string)
  }

  if (typeof string !== 'string') {
    throw new TypeError('argument string is required to be a string')
  }

  var index = string.indexOf(';')
  var type = index !== -1
    ? string.substr(0, index)
    : string

  var key
  var match
  var obj = splitType(type)
  var params = {}
  var value

  paramRegExp.lastIndex = index

  while (match = paramRegExp.exec(string)) {
    if (match.index !== index) {
      throw new TypeError('invalid parameter format')
    }

    index += match[0].length
    key = match[1].toLowerCase()
    value = match[2]

    if (value[0] === '"') {
      // remove quotes and escapes
      value = value
        .substr(1, value.length - 2)
        .replace(qescRegExp, '$1')
    }

    params[key] = value
  }

  if (index !== -1 && index !== string.length) {
    throw new TypeError('invalid parameter format')
  }

  obj.parameters = params

  return obj
}

/**
 * Get content-type from req/res objects.
 *
 * @param {object}
 * @return {Object}
 * @api private
 */

function getcontenttype(obj) {
  if (typeof obj.getHeader === 'function') {
    // res-like
    return obj.getHeader('content-type')
  }

  if (typeof obj.headers === 'object') {
    // req-like
    return obj.headers && obj.headers['content-type']
  }
}

/**
 * Quote a string if necessary.
 *
 * @param {string} val
 * @return {string}
 * @api private
 */

function qstring(val) {
  var str = String(val)

  // no need to quote tokens
  if (tokenRegExp.test(str)) {
    return str
  }

  if (str.length > 0 && !textRegExp.test(str)) {
    throw new TypeError('invalid parameter value')
  }

  return '"' + str.replace(quoteRegExp, '\\$1') + '"'
}

/**
 * Simply "type/subtype+siffx" into parts.
 *
 * @param {string} string
 * @return {Object}
 * @api private
 */

function splitType(string) {
  var match = typeRegExp.exec(string.toLowerCase())

  if (!match) {
    throw new TypeError('invalid media type')
  }

  var type = match[1]
  var subtype = match[2]
  var suffix

  // suffix after last +
  var index = subtype.lastIndexOf('+')
  if (index !== -1) {
    suffix = subtype.substr(index + 1)
    subtype = subtype.substr(0, index)
  }

  var obj = {
    type: type,
    subtype: subtype,
    suffix: suffix
  }

  return obj
}


/***/ }),

/***/ "./node_modules/merge-descriptors/index.js":
/*!*************************************************!*\
  !*** ./node_modules/merge-descriptors/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * merge-descriptors
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = merge

/**
 * Module variables.
 * @private
 */

var hasOwnProperty = Object.prototype.hasOwnProperty

/**
 * Merge the property descriptors of `src` into `dest`
 *
 * @param {object} dest Object to add descriptors to
 * @param {object} src Object to clone descriptors from
 * @param {boolean} [redefine=true] Redefine `dest` properties with `src` properties
 * @returns {object} Reference to dest
 * @public
 */

function merge(dest, src, redefine) {
  if (!dest) {
    throw new TypeError('argument dest is required')
  }

  if (!src) {
    throw new TypeError('argument src is required')
  }

  if (redefine === undefined) {
    // Default to true
    redefine = true
  }

  Object.getOwnPropertyNames(src).forEach(function forEachOwnPropertyName(name) {
    if (!redefine && hasOwnProperty.call(dest, name)) {
      // Skip desriptor
      return
    }

    // Copy descriptor
    var descriptor = Object.getOwnPropertyDescriptor(src, name)
    Object.defineProperty(dest, name, descriptor)
  })

  return dest
}


/***/ }),

/***/ "./node_modules/methods/index.js":
/*!***************************************!*\
  !*** ./node_modules/methods/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * methods
 * Copyright(c) 2013-2014 TJ Holowaychuk
 * Copyright(c) 2015-2016 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var http = __webpack_require__(/*! http */ "http");

/**
 * Module exports.
 * @public
 */

module.exports = getCurrentNodeMethods() || getBasicNodeMethods();

/**
 * Get the current Node.js methods.
 * @private
 */

function getCurrentNodeMethods() {
  return http.METHODS && http.METHODS.map(function lowerCaseMethod(method) {
    return method.toLowerCase();
  });
}

/**
 * Get the "basic" Node.js methods, a snapshot from Node.js 0.10.
 * @private
 */

function getBasicNodeMethods() {
  return [
    'get',
    'post',
    'put',
    'head',
    'delete',
    'options',
    'trace',
    'copy',
    'lock',
    'mkcol',
    'move',
    'purge',
    'propfind',
    'proppatch',
    'unlock',
    'report',
    'mkactivity',
    'checkout',
    'merge',
    'm-search',
    'notify',
    'subscribe',
    'unsubscribe',
    'patch',
    'search',
    'connect'
  ];
}


/***/ }),

/***/ "./node_modules/mime-db/db.json":
/*!**************************************!*\
  !*** ./node_modules/mime-db/db.json ***!
  \**************************************/
/*! exports provided: application/1d-interleaved-parityfec, application/3gpdash-qoe-report+xml, application/3gpp-ims+xml, application/a2l, application/activemessage, application/activity+json, application/alto-costmap+json, application/alto-costmapfilter+json, application/alto-directory+json, application/alto-endpointcost+json, application/alto-endpointcostparams+json, application/alto-endpointprop+json, application/alto-endpointpropparams+json, application/alto-error+json, application/alto-networkmap+json, application/alto-networkmapfilter+json, application/aml, application/andrew-inset, application/applefile, application/applixware, application/atf, application/atfx, application/atom+xml, application/atomcat+xml, application/atomdeleted+xml, application/atomicmail, application/atomsvc+xml, application/atsc-dwd+xml, application/atsc-held+xml, application/atsc-rsat+xml, application/atxml, application/auth-policy+xml, application/bacnet-xdd+zip, application/batch-smtp, application/bdoc, application/beep+xml, application/calendar+json, application/calendar+xml, application/call-completion, application/cals-1840, application/cbor, application/cccex, application/ccmp+xml, application/ccxml+xml, application/cdfx+xml, application/cdmi-capability, application/cdmi-container, application/cdmi-domain, application/cdmi-object, application/cdmi-queue, application/cdni, application/cea, application/cea-2018+xml, application/cellml+xml, application/cfw, application/clue_info+xml, application/cms, application/cnrp+xml, application/coap-group+json, application/coap-payload, application/commonground, application/conference-info+xml, application/cose, application/cose-key, application/cose-key-set, application/cpl+xml, application/csrattrs, application/csta+xml, application/cstadata+xml, application/csvm+json, application/cu-seeme, application/cwt, application/cybercash, application/dart, application/dash+xml, application/dashdelta, application/davmount+xml, application/dca-rft, application/dcd, application/dec-dx, application/dialog-info+xml, application/dicom, application/dicom+json, application/dicom+xml, application/dii, application/dit, application/dns, application/dns+json, application/dns-message, application/docbook+xml, application/dskpp+xml, application/dssc+der, application/dssc+xml, application/dvcs, application/ecmascript, application/edi-consent, application/edi-x12, application/edifact, application/efi, application/emergencycalldata.comment+xml, application/emergencycalldata.control+xml, application/emergencycalldata.deviceinfo+xml, application/emergencycalldata.ecall.msd, application/emergencycalldata.providerinfo+xml, application/emergencycalldata.serviceinfo+xml, application/emergencycalldata.subscriberinfo+xml, application/emergencycalldata.veds+xml, application/emma+xml, application/emotionml+xml, application/encaprtp, application/epp+xml, application/epub+zip, application/eshop, application/exi, application/expect-ct-report+json, application/fastinfoset, application/fastsoap, application/fdt+xml, application/fhir+json, application/fhir+xml, application/fido.trusted-apps+json, application/fits, application/font-sfnt, application/font-tdpfr, application/font-woff, application/framework-attributes+xml, application/geo+json, application/geo+json-seq, application/geopackage+sqlite3, application/geoxacml+xml, application/gltf-buffer, application/gml+xml, application/gpx+xml, application/gxf, application/gzip, application/h224, application/held+xml, application/hjson, application/http, application/hyperstudio, application/ibe-key-request+xml, application/ibe-pkg-reply+xml, application/ibe-pp-data, application/iges, application/im-iscomposing+xml, application/index, application/index.cmd, application/index.obj, application/index.response, application/index.vnd, application/inkml+xml, application/iotp, application/ipfix, application/ipp, application/isup, application/its+xml, application/java-archive, application/java-serialized-object, application/java-vm, application/javascript, application/jf2feed+json, application/jose, application/jose+json, application/jrd+json, application/json, application/json-patch+json, application/json-seq, application/json5, application/jsonml+json, application/jwk+json, application/jwk-set+json, application/jwt, application/kpml-request+xml, application/kpml-response+xml, application/ld+json, application/lgr+xml, application/link-format, application/load-control+xml, application/lost+xml, application/lostsync+xml, application/lxf, application/mac-binhex40, application/mac-compactpro, application/macwriteii, application/mads+xml, application/manifest+json, application/marc, application/marcxml+xml, application/mathematica, application/mathml+xml, application/mathml-content+xml, application/mathml-presentation+xml, application/mbms-associated-procedure-description+xml, application/mbms-deregister+xml, application/mbms-envelope+xml, application/mbms-msk+xml, application/mbms-msk-response+xml, application/mbms-protection-description+xml, application/mbms-reception-report+xml, application/mbms-register+xml, application/mbms-register-response+xml, application/mbms-schedule+xml, application/mbms-user-service-description+xml, application/mbox, application/media-policy-dataset+xml, application/media_control+xml, application/mediaservercontrol+xml, application/merge-patch+json, application/metalink+xml, application/metalink4+xml, application/mets+xml, application/mf4, application/mikey, application/mmt-aei+xml, application/mmt-usd+xml, application/mods+xml, application/moss-keys, application/moss-signature, application/mosskey-data, application/mosskey-request, application/mp21, application/mp4, application/mpeg4-generic, application/mpeg4-iod, application/mpeg4-iod-xmt, application/mrb-consumer+xml, application/mrb-publish+xml, application/msc-ivr+xml, application/msc-mixer+xml, application/msword, application/mud+json, application/mxf, application/n-quads, application/n-triples, application/nasdata, application/news-checkgroups, application/news-groupinfo, application/news-transmission, application/nlsml+xml, application/node, application/nss, application/ocsp-request, application/ocsp-response, application/octet-stream, application/oda, application/odm+xml, application/odx, application/oebps-package+xml, application/ogg, application/omdoc+xml, application/onenote, application/oscore, application/oxps, application/p2p-overlay+xml, application/parityfec, application/passport, application/patch-ops-error+xml, application/pdf, application/pdx, application/pem-certificate-chain, application/pgp-encrypted, application/pgp-keys, application/pgp-signature, application/pics-rules, application/pidf+xml, application/pidf-diff+xml, application/pkcs10, application/pkcs12, application/pkcs7-mime, application/pkcs7-signature, application/pkcs8, application/pkcs8-encrypted, application/pkix-attr-cert, application/pkix-cert, application/pkix-crl, application/pkix-pkipath, application/pkixcmp, application/pls+xml, application/poc-settings+xml, application/postscript, application/ppsp-tracker+json, application/problem+json, application/problem+xml, application/provenance+xml, application/prs.alvestrand.titrax-sheet, application/prs.cww, application/prs.hpub+zip, application/prs.nprend, application/prs.plucker, application/prs.rdf-xml-crypt, application/prs.xsf+xml, application/pskc+xml, application/qsig, application/raml+yaml, application/raptorfec, application/rdap+json, application/rdf+xml, application/reginfo+xml, application/relax-ng-compact-syntax, application/remote-printing, application/reputon+json, application/resource-lists+xml, application/resource-lists-diff+xml, application/rfc+xml, application/riscos, application/rlmi+xml, application/rls-services+xml, application/route-apd+xml, application/route-s-tsid+xml, application/route-usd+xml, application/rpki-ghostbusters, application/rpki-manifest, application/rpki-publication, application/rpki-roa, application/rpki-updown, application/rsd+xml, application/rss+xml, application/rtf, application/rtploopback, application/rtx, application/samlassertion+xml, application/samlmetadata+xml, application/sbml+xml, application/scaip+xml, application/scim+json, application/scvp-cv-request, application/scvp-cv-response, application/scvp-vp-request, application/scvp-vp-response, application/sdp, application/secevent+jwt, application/senml+cbor, application/senml+json, application/senml+xml, application/senml-exi, application/sensml+cbor, application/sensml+json, application/sensml+xml, application/sensml-exi, application/sep+xml, application/sep-exi, application/session-info, application/set-payment, application/set-payment-initiation, application/set-registration, application/set-registration-initiation, application/sgml, application/sgml-open-catalog, application/shf+xml, application/sieve, application/simple-filter+xml, application/simple-message-summary, application/simplesymbolcontainer, application/slate, application/smil, application/smil+xml, application/smpte336m, application/soap+fastinfoset, application/soap+xml, application/sparql-query, application/sparql-results+xml, application/spirits-event+xml, application/sql, application/srgs, application/srgs+xml, application/sru+xml, application/ssdl+xml, application/ssml+xml, application/stix+json, application/tamp-apex-update, application/tamp-apex-update-confirm, application/tamp-community-update, application/tamp-community-update-confirm, application/tamp-error, application/tamp-sequence-adjust, application/tamp-sequence-adjust-confirm, application/tamp-status-query, application/tamp-status-response, application/tamp-update, application/tamp-update-confirm, application/tar, application/taxii+json, application/tei+xml, application/tetra_isi, application/thraud+xml, application/timestamp-query, application/timestamp-reply, application/timestamped-data, application/tlsrpt+gzip, application/tlsrpt+json, application/tnauthlist, application/trickle-ice-sdpfrag, application/trig, application/ttml+xml, application/tve-trigger, application/tzif, application/tzif-leap, application/ulpfec, application/urc-grpsheet+xml, application/urc-ressheet+xml, application/urc-targetdesc+xml, application/urc-uisocketdesc+xml, application/vcard+json, application/vcard+xml, application/vemmi, application/vividence.scriptfile, application/vnd.1000minds.decision-model+xml, application/vnd.3gpp-prose+xml, application/vnd.3gpp-prose-pc3ch+xml, application/vnd.3gpp-v2x-local-service-information, application/vnd.3gpp.access-transfer-events+xml, application/vnd.3gpp.bsf+xml, application/vnd.3gpp.gmop+xml, application/vnd.3gpp.mc-signalling-ear, application/vnd.3gpp.mcdata-affiliation-command+xml, application/vnd.3gpp.mcdata-info+xml, application/vnd.3gpp.mcdata-payload, application/vnd.3gpp.mcdata-service-config+xml, application/vnd.3gpp.mcdata-signalling, application/vnd.3gpp.mcdata-ue-config+xml, application/vnd.3gpp.mcdata-user-profile+xml, application/vnd.3gpp.mcptt-affiliation-command+xml, application/vnd.3gpp.mcptt-floor-request+xml, application/vnd.3gpp.mcptt-info+xml, application/vnd.3gpp.mcptt-location-info+xml, application/vnd.3gpp.mcptt-mbms-usage-info+xml, application/vnd.3gpp.mcptt-service-config+xml, application/vnd.3gpp.mcptt-signed+xml, application/vnd.3gpp.mcptt-ue-config+xml, application/vnd.3gpp.mcptt-ue-init-config+xml, application/vnd.3gpp.mcptt-user-profile+xml, application/vnd.3gpp.mcvideo-affiliation-command+xml, application/vnd.3gpp.mcvideo-affiliation-info+xml, application/vnd.3gpp.mcvideo-location-info+xml, application/vnd.3gpp.mcvideo-mbms-usage-info+xml, application/vnd.3gpp.mcvideo-service-config+xml, application/vnd.3gpp.mcvideo-transmission-request+xml, application/vnd.3gpp.mcvideo-ue-config+xml, application/vnd.3gpp.mcvideo-user-profile+xml, application/vnd.3gpp.mid-call+xml, application/vnd.3gpp.pic-bw-large, application/vnd.3gpp.pic-bw-small, application/vnd.3gpp.pic-bw-var, application/vnd.3gpp.sms, application/vnd.3gpp.sms+xml, application/vnd.3gpp.srvcc-ext+xml, application/vnd.3gpp.srvcc-info+xml, application/vnd.3gpp.state-and-event-info+xml, application/vnd.3gpp.ussd+xml, application/vnd.3gpp2.bcmcsinfo+xml, application/vnd.3gpp2.sms, application/vnd.3gpp2.tcap, application/vnd.3lightssoftware.imagescal, application/vnd.3m.post-it-notes, application/vnd.accpac.simply.aso, application/vnd.accpac.simply.imp, application/vnd.acucobol, application/vnd.acucorp, application/vnd.adobe.air-application-installer-package+zip, application/vnd.adobe.flash.movie, application/vnd.adobe.formscentral.fcdt, application/vnd.adobe.fxp, application/vnd.adobe.partial-upload, application/vnd.adobe.xdp+xml, application/vnd.adobe.xfdf, application/vnd.aether.imp, application/vnd.afpc.afplinedata, application/vnd.afpc.modca, application/vnd.ah-barcode, application/vnd.ahead.space, application/vnd.airzip.filesecure.azf, application/vnd.airzip.filesecure.azs, application/vnd.amadeus+json, application/vnd.amazon.ebook, application/vnd.amazon.mobi8-ebook, application/vnd.americandynamics.acc, application/vnd.amiga.ami, application/vnd.amundsen.maze+xml, application/vnd.android.package-archive, application/vnd.anki, application/vnd.anser-web-certificate-issue-initiation, application/vnd.anser-web-funds-transfer-initiation, application/vnd.antix.game-component, application/vnd.apache.thrift.binary, application/vnd.apache.thrift.compact, application/vnd.apache.thrift.json, application/vnd.api+json, application/vnd.apothekende.reservation+json, application/vnd.apple.installer+xml, application/vnd.apple.keynote, application/vnd.apple.mpegurl, application/vnd.apple.numbers, application/vnd.apple.pages, application/vnd.apple.pkpass, application/vnd.arastra.swi, application/vnd.aristanetworks.swi, application/vnd.artisan+json, application/vnd.artsquare, application/vnd.astraea-software.iota, application/vnd.audiograph, application/vnd.autopackage, application/vnd.avalon+json, application/vnd.avistar+xml, application/vnd.balsamiq.bmml+xml, application/vnd.balsamiq.bmpr, application/vnd.banana-accounting, application/vnd.bbf.usp.msg, application/vnd.bbf.usp.msg+json, application/vnd.bekitzur-stech+json, application/vnd.bint.med-content, application/vnd.biopax.rdf+xml, application/vnd.blink-idb-value-wrapper, application/vnd.blueice.multipass, application/vnd.bluetooth.ep.oob, application/vnd.bluetooth.le.oob, application/vnd.bmi, application/vnd.businessobjects, application/vnd.byu.uapi+json, application/vnd.cab-jscript, application/vnd.canon-cpdl, application/vnd.canon-lips, application/vnd.capasystems-pg+json, application/vnd.cendio.thinlinc.clientconf, application/vnd.century-systems.tcp_stream, application/vnd.chemdraw+xml, application/vnd.chess-pgn, application/vnd.chipnuts.karaoke-mmd, application/vnd.cinderella, application/vnd.cirpack.isdn-ext, application/vnd.citationstyles.style+xml, application/vnd.claymore, application/vnd.cloanto.rp9, application/vnd.clonk.c4group, application/vnd.cluetrust.cartomobile-config, application/vnd.cluetrust.cartomobile-config-pkg, application/vnd.coffeescript, application/vnd.collabio.xodocuments.document, application/vnd.collabio.xodocuments.document-template, application/vnd.collabio.xodocuments.presentation, application/vnd.collabio.xodocuments.presentation-template, application/vnd.collabio.xodocuments.spreadsheet, application/vnd.collabio.xodocuments.spreadsheet-template, application/vnd.collection+json, application/vnd.collection.doc+json, application/vnd.collection.next+json, application/vnd.comicbook+zip, application/vnd.comicbook-rar, application/vnd.commerce-battelle, application/vnd.commonspace, application/vnd.contact.cmsg, application/vnd.coreos.ignition+json, application/vnd.cosmocaller, application/vnd.crick.clicker, application/vnd.crick.clicker.keyboard, application/vnd.crick.clicker.palette, application/vnd.crick.clicker.template, application/vnd.crick.clicker.wordbank, application/vnd.criticaltools.wbs+xml, application/vnd.ctc-posml, application/vnd.ctct.ws+xml, application/vnd.cups-pdf, application/vnd.cups-postscript, application/vnd.cups-ppd, application/vnd.cups-raster, application/vnd.cups-raw, application/vnd.curl, application/vnd.curl.car, application/vnd.curl.pcurl, application/vnd.cyan.dean.root+xml, application/vnd.cybank, application/vnd.d2l.coursepackage1p0+zip, application/vnd.dart, application/vnd.data-vision.rdz, application/vnd.datapackage+json, application/vnd.dataresource+json, application/vnd.debian.binary-package, application/vnd.dece.data, application/vnd.dece.ttml+xml, application/vnd.dece.unspecified, application/vnd.dece.zip, application/vnd.denovo.fcselayout-link, application/vnd.desmume.movie, application/vnd.dir-bi.plate-dl-nosuffix, application/vnd.dm.delegation+xml, application/vnd.dna, application/vnd.document+json, application/vnd.dolby.mlp, application/vnd.dolby.mobile.1, application/vnd.dolby.mobile.2, application/vnd.doremir.scorecloud-binary-document, application/vnd.dpgraph, application/vnd.dreamfactory, application/vnd.drive+json, application/vnd.ds-keypoint, application/vnd.dtg.local, application/vnd.dtg.local.flash, application/vnd.dtg.local.html, application/vnd.dvb.ait, application/vnd.dvb.dvbj, application/vnd.dvb.esgcontainer, application/vnd.dvb.ipdcdftnotifaccess, application/vnd.dvb.ipdcesgaccess, application/vnd.dvb.ipdcesgaccess2, application/vnd.dvb.ipdcesgpdd, application/vnd.dvb.ipdcroaming, application/vnd.dvb.iptv.alfec-base, application/vnd.dvb.iptv.alfec-enhancement, application/vnd.dvb.notif-aggregate-root+xml, application/vnd.dvb.notif-container+xml, application/vnd.dvb.notif-generic+xml, application/vnd.dvb.notif-ia-msglist+xml, application/vnd.dvb.notif-ia-registration-request+xml, application/vnd.dvb.notif-ia-registration-response+xml, application/vnd.dvb.notif-init+xml, application/vnd.dvb.pfr, application/vnd.dvb.service, application/vnd.dxr, application/vnd.dynageo, application/vnd.dzr, application/vnd.easykaraoke.cdgdownload, application/vnd.ecdis-update, application/vnd.ecip.rlp, application/vnd.ecowin.chart, application/vnd.ecowin.filerequest, application/vnd.ecowin.fileupdate, application/vnd.ecowin.series, application/vnd.ecowin.seriesrequest, application/vnd.ecowin.seriesupdate, application/vnd.efi.img, application/vnd.efi.iso, application/vnd.emclient.accessrequest+xml, application/vnd.enliven, application/vnd.enphase.envoy, application/vnd.eprints.data+xml, application/vnd.epson.esf, application/vnd.epson.msf, application/vnd.epson.quickanime, application/vnd.epson.salt, application/vnd.epson.ssf, application/vnd.ericsson.quickcall, application/vnd.espass-espass+zip, application/vnd.eszigno3+xml, application/vnd.etsi.aoc+xml, application/vnd.etsi.asic-e+zip, application/vnd.etsi.asic-s+zip, application/vnd.etsi.cug+xml, application/vnd.etsi.iptvcommand+xml, application/vnd.etsi.iptvdiscovery+xml, application/vnd.etsi.iptvprofile+xml, application/vnd.etsi.iptvsad-bc+xml, application/vnd.etsi.iptvsad-cod+xml, application/vnd.etsi.iptvsad-npvr+xml, application/vnd.etsi.iptvservice+xml, application/vnd.etsi.iptvsync+xml, application/vnd.etsi.iptvueprofile+xml, application/vnd.etsi.mcid+xml, application/vnd.etsi.mheg5, application/vnd.etsi.overload-control-policy-dataset+xml, application/vnd.etsi.pstn+xml, application/vnd.etsi.sci+xml, application/vnd.etsi.simservs+xml, application/vnd.etsi.timestamp-token, application/vnd.etsi.tsl+xml, application/vnd.etsi.tsl.der, application/vnd.eudora.data, application/vnd.evolv.ecig.profile, application/vnd.evolv.ecig.settings, application/vnd.evolv.ecig.theme, application/vnd.exstream-empower+zip, application/vnd.exstream-package, application/vnd.ezpix-album, application/vnd.ezpix-package, application/vnd.f-secure.mobile, application/vnd.fastcopy-disk-image, application/vnd.fdf, application/vnd.fdsn.mseed, application/vnd.fdsn.seed, application/vnd.ffsns, application/vnd.filmit.zfc, application/vnd.fints, application/vnd.firemonkeys.cloudcell, application/vnd.flographit, application/vnd.fluxtime.clip, application/vnd.font-fontforge-sfd, application/vnd.framemaker, application/vnd.frogans.fnc, application/vnd.frogans.ltf, application/vnd.fsc.weblaunch, application/vnd.fujitsu.oasys, application/vnd.fujitsu.oasys2, application/vnd.fujitsu.oasys3, application/vnd.fujitsu.oasysgp, application/vnd.fujitsu.oasysprs, application/vnd.fujixerox.art-ex, application/vnd.fujixerox.art4, application/vnd.fujixerox.ddd, application/vnd.fujixerox.docuworks, application/vnd.fujixerox.docuworks.binder, application/vnd.fujixerox.docuworks.container, application/vnd.fujixerox.hbpl, application/vnd.fut-misnet, application/vnd.futoin+cbor, application/vnd.futoin+json, application/vnd.fuzzysheet, application/vnd.genomatix.tuxedo, application/vnd.geo+json, application/vnd.geocube+xml, application/vnd.geogebra.file, application/vnd.geogebra.tool, application/vnd.geometry-explorer, application/vnd.geonext, application/vnd.geoplan, application/vnd.geospace, application/vnd.gerber, application/vnd.globalplatform.card-content-mgt, application/vnd.globalplatform.card-content-mgt-response, application/vnd.gmx, application/vnd.google-apps.document, application/vnd.google-apps.presentation, application/vnd.google-apps.spreadsheet, application/vnd.google-earth.kml+xml, application/vnd.google-earth.kmz, application/vnd.gov.sk.e-form+xml, application/vnd.gov.sk.e-form+zip, application/vnd.gov.sk.xmldatacontainer+xml, application/vnd.grafeq, application/vnd.gridmp, application/vnd.groove-account, application/vnd.groove-help, application/vnd.groove-identity-message, application/vnd.groove-injector, application/vnd.groove-tool-message, application/vnd.groove-tool-template, application/vnd.groove-vcard, application/vnd.hal+json, application/vnd.hal+xml, application/vnd.handheld-entertainment+xml, application/vnd.hbci, application/vnd.hc+json, application/vnd.hcl-bireports, application/vnd.hdt, application/vnd.heroku+json, application/vnd.hhe.lesson-player, application/vnd.hp-hpgl, application/vnd.hp-hpid, application/vnd.hp-hps, application/vnd.hp-jlyt, application/vnd.hp-pcl, application/vnd.hp-pclxl, application/vnd.httphone, application/vnd.hydrostatix.sof-data, application/vnd.hyper+json, application/vnd.hyper-item+json, application/vnd.hyperdrive+json, application/vnd.hzn-3d-crossword, application/vnd.ibm.afplinedata, application/vnd.ibm.electronic-media, application/vnd.ibm.minipay, application/vnd.ibm.modcap, application/vnd.ibm.rights-management, application/vnd.ibm.secure-container, application/vnd.iccprofile, application/vnd.ieee.1905, application/vnd.igloader, application/vnd.imagemeter.folder+zip, application/vnd.imagemeter.image+zip, application/vnd.immervision-ivp, application/vnd.immervision-ivu, application/vnd.ims.imsccv1p1, application/vnd.ims.imsccv1p2, application/vnd.ims.imsccv1p3, application/vnd.ims.lis.v2.result+json, application/vnd.ims.lti.v2.toolconsumerprofile+json, application/vnd.ims.lti.v2.toolproxy+json, application/vnd.ims.lti.v2.toolproxy.id+json, application/vnd.ims.lti.v2.toolsettings+json, application/vnd.ims.lti.v2.toolsettings.simple+json, application/vnd.informedcontrol.rms+xml, application/vnd.informix-visionary, application/vnd.infotech.project, application/vnd.infotech.project+xml, application/vnd.innopath.wamp.notification, application/vnd.insors.igm, application/vnd.intercon.formnet, application/vnd.intergeo, application/vnd.intertrust.digibox, application/vnd.intertrust.nncp, application/vnd.intu.qbo, application/vnd.intu.qfx, application/vnd.iptc.g2.catalogitem+xml, application/vnd.iptc.g2.conceptitem+xml, application/vnd.iptc.g2.knowledgeitem+xml, application/vnd.iptc.g2.newsitem+xml, application/vnd.iptc.g2.newsmessage+xml, application/vnd.iptc.g2.packageitem+xml, application/vnd.iptc.g2.planningitem+xml, application/vnd.ipunplugged.rcprofile, application/vnd.irepository.package+xml, application/vnd.is-xpr, application/vnd.isac.fcs, application/vnd.jam, application/vnd.japannet-directory-service, application/vnd.japannet-jpnstore-wakeup, application/vnd.japannet-payment-wakeup, application/vnd.japannet-registration, application/vnd.japannet-registration-wakeup, application/vnd.japannet-setstore-wakeup, application/vnd.japannet-verification, application/vnd.japannet-verification-wakeup, application/vnd.jcp.javame.midlet-rms, application/vnd.jisp, application/vnd.joost.joda-archive, application/vnd.jsk.isdn-ngn, application/vnd.kahootz, application/vnd.kde.karbon, application/vnd.kde.kchart, application/vnd.kde.kformula, application/vnd.kde.kivio, application/vnd.kde.kontour, application/vnd.kde.kpresenter, application/vnd.kde.kspread, application/vnd.kde.kword, application/vnd.kenameaapp, application/vnd.kidspiration, application/vnd.kinar, application/vnd.koan, application/vnd.kodak-descriptor, application/vnd.las.las+json, application/vnd.las.las+xml, application/vnd.leap+json, application/vnd.liberty-request+xml, application/vnd.llamagraphics.life-balance.desktop, application/vnd.llamagraphics.life-balance.exchange+xml, application/vnd.lotus-1-2-3, application/vnd.lotus-approach, application/vnd.lotus-freelance, application/vnd.lotus-notes, application/vnd.lotus-organizer, application/vnd.lotus-screencam, application/vnd.lotus-wordpro, application/vnd.macports.portpkg, application/vnd.mapbox-vector-tile, application/vnd.marlin.drm.actiontoken+xml, application/vnd.marlin.drm.conftoken+xml, application/vnd.marlin.drm.license+xml, application/vnd.marlin.drm.mdcf, application/vnd.mason+json, application/vnd.maxmind.maxmind-db, application/vnd.mcd, application/vnd.medcalcdata, application/vnd.mediastation.cdkey, application/vnd.meridian-slingshot, application/vnd.mfer, application/vnd.mfmp, application/vnd.micro+json, application/vnd.micrografx.flo, application/vnd.micrografx.igx, application/vnd.microsoft.portable-executable, application/vnd.microsoft.windows.thumbnail-cache, application/vnd.miele+json, application/vnd.mif, application/vnd.minisoft-hp3000-save, application/vnd.mitsubishi.misty-guard.trustweb, application/vnd.mobius.daf, application/vnd.mobius.dis, application/vnd.mobius.mbk, application/vnd.mobius.mqy, application/vnd.mobius.msl, application/vnd.mobius.plc, application/vnd.mobius.txf, application/vnd.mophun.application, application/vnd.mophun.certificate, application/vnd.motorola.flexsuite, application/vnd.motorola.flexsuite.adsi, application/vnd.motorola.flexsuite.fis, application/vnd.motorola.flexsuite.gotap, application/vnd.motorola.flexsuite.kmr, application/vnd.motorola.flexsuite.ttc, application/vnd.motorola.flexsuite.wem, application/vnd.motorola.iprm, application/vnd.mozilla.xul+xml, application/vnd.ms-3mfdocument, application/vnd.ms-artgalry, application/vnd.ms-asf, application/vnd.ms-cab-compressed, application/vnd.ms-color.iccprofile, application/vnd.ms-excel, application/vnd.ms-excel.addin.macroenabled.12, application/vnd.ms-excel.sheet.binary.macroenabled.12, application/vnd.ms-excel.sheet.macroenabled.12, application/vnd.ms-excel.template.macroenabled.12, application/vnd.ms-fontobject, application/vnd.ms-htmlhelp, application/vnd.ms-ims, application/vnd.ms-lrm, application/vnd.ms-office.activex+xml, application/vnd.ms-officetheme, application/vnd.ms-opentype, application/vnd.ms-outlook, application/vnd.ms-package.obfuscated-opentype, application/vnd.ms-pki.seccat, application/vnd.ms-pki.stl, application/vnd.ms-playready.initiator+xml, application/vnd.ms-powerpoint, application/vnd.ms-powerpoint.addin.macroenabled.12, application/vnd.ms-powerpoint.presentation.macroenabled.12, application/vnd.ms-powerpoint.slide.macroenabled.12, application/vnd.ms-powerpoint.slideshow.macroenabled.12, application/vnd.ms-powerpoint.template.macroenabled.12, application/vnd.ms-printdevicecapabilities+xml, application/vnd.ms-printing.printticket+xml, application/vnd.ms-printschematicket+xml, application/vnd.ms-project, application/vnd.ms-tnef, application/vnd.ms-windows.devicepairing, application/vnd.ms-windows.nwprinting.oob, application/vnd.ms-windows.printerpairing, application/vnd.ms-windows.wsd.oob, application/vnd.ms-wmdrm.lic-chlg-req, application/vnd.ms-wmdrm.lic-resp, application/vnd.ms-wmdrm.meter-chlg-req, application/vnd.ms-wmdrm.meter-resp, application/vnd.ms-word.document.macroenabled.12, application/vnd.ms-word.template.macroenabled.12, application/vnd.ms-works, application/vnd.ms-wpl, application/vnd.ms-xpsdocument, application/vnd.msa-disk-image, application/vnd.mseq, application/vnd.msign, application/vnd.multiad.creator, application/vnd.multiad.creator.cif, application/vnd.music-niff, application/vnd.musician, application/vnd.muvee.style, application/vnd.mynfc, application/vnd.ncd.control, application/vnd.ncd.reference, application/vnd.nearst.inv+json, application/vnd.nervana, application/vnd.netfpx, application/vnd.neurolanguage.nlu, application/vnd.nimn, application/vnd.nintendo.nitro.rom, application/vnd.nintendo.snes.rom, application/vnd.nitf, application/vnd.noblenet-directory, application/vnd.noblenet-sealer, application/vnd.noblenet-web, application/vnd.nokia.catalogs, application/vnd.nokia.conml+wbxml, application/vnd.nokia.conml+xml, application/vnd.nokia.iptv.config+xml, application/vnd.nokia.isds-radio-presets, application/vnd.nokia.landmark+wbxml, application/vnd.nokia.landmark+xml, application/vnd.nokia.landmarkcollection+xml, application/vnd.nokia.n-gage.ac+xml, application/vnd.nokia.n-gage.data, application/vnd.nokia.n-gage.symbian.install, application/vnd.nokia.ncd, application/vnd.nokia.pcd+wbxml, application/vnd.nokia.pcd+xml, application/vnd.nokia.radio-preset, application/vnd.nokia.radio-presets, application/vnd.novadigm.edm, application/vnd.novadigm.edx, application/vnd.novadigm.ext, application/vnd.ntt-local.content-share, application/vnd.ntt-local.file-transfer, application/vnd.ntt-local.ogw_remote-access, application/vnd.ntt-local.sip-ta_remote, application/vnd.ntt-local.sip-ta_tcp_stream, application/vnd.oasis.opendocument.chart, application/vnd.oasis.opendocument.chart-template, application/vnd.oasis.opendocument.database, application/vnd.oasis.opendocument.formula, application/vnd.oasis.opendocument.formula-template, application/vnd.oasis.opendocument.graphics, application/vnd.oasis.opendocument.graphics-template, application/vnd.oasis.opendocument.image, application/vnd.oasis.opendocument.image-template, application/vnd.oasis.opendocument.presentation, application/vnd.oasis.opendocument.presentation-template, application/vnd.oasis.opendocument.spreadsheet, application/vnd.oasis.opendocument.spreadsheet-template, application/vnd.oasis.opendocument.text, application/vnd.oasis.opendocument.text-master, application/vnd.oasis.opendocument.text-template, application/vnd.oasis.opendocument.text-web, application/vnd.obn, application/vnd.ocf+cbor, application/vnd.oftn.l10n+json, application/vnd.oipf.contentaccessdownload+xml, application/vnd.oipf.contentaccessstreaming+xml, application/vnd.oipf.cspg-hexbinary, application/vnd.oipf.dae.svg+xml, application/vnd.oipf.dae.xhtml+xml, application/vnd.oipf.mippvcontrolmessage+xml, application/vnd.oipf.pae.gem, application/vnd.oipf.spdiscovery+xml, application/vnd.oipf.spdlist+xml, application/vnd.oipf.ueprofile+xml, application/vnd.oipf.userprofile+xml, application/vnd.olpc-sugar, application/vnd.oma-scws-config, application/vnd.oma-scws-http-request, application/vnd.oma-scws-http-response, application/vnd.oma.bcast.associated-procedure-parameter+xml, application/vnd.oma.bcast.drm-trigger+xml, application/vnd.oma.bcast.imd+xml, application/vnd.oma.bcast.ltkm, application/vnd.oma.bcast.notification+xml, application/vnd.oma.bcast.provisioningtrigger, application/vnd.oma.bcast.sgboot, application/vnd.oma.bcast.sgdd+xml, application/vnd.oma.bcast.sgdu, application/vnd.oma.bcast.simple-symbol-container, application/vnd.oma.bcast.smartcard-trigger+xml, application/vnd.oma.bcast.sprov+xml, application/vnd.oma.bcast.stkm, application/vnd.oma.cab-address-book+xml, application/vnd.oma.cab-feature-handler+xml, application/vnd.oma.cab-pcc+xml, application/vnd.oma.cab-subs-invite+xml, application/vnd.oma.cab-user-prefs+xml, application/vnd.oma.dcd, application/vnd.oma.dcdc, application/vnd.oma.dd2+xml, application/vnd.oma.drm.risd+xml, application/vnd.oma.group-usage-list+xml, application/vnd.oma.lwm2m+json, application/vnd.oma.lwm2m+tlv, application/vnd.oma.pal+xml, application/vnd.oma.poc.detailed-progress-report+xml, application/vnd.oma.poc.final-report+xml, application/vnd.oma.poc.groups+xml, application/vnd.oma.poc.invocation-descriptor+xml, application/vnd.oma.poc.optimized-progress-report+xml, application/vnd.oma.push, application/vnd.oma.scidm.messages+xml, application/vnd.oma.xcap-directory+xml, application/vnd.omads-email+xml, application/vnd.omads-file+xml, application/vnd.omads-folder+xml, application/vnd.omaloc-supl-init, application/vnd.onepager, application/vnd.onepagertamp, application/vnd.onepagertamx, application/vnd.onepagertat, application/vnd.onepagertatp, application/vnd.onepagertatx, application/vnd.openblox.game+xml, application/vnd.openblox.game-binary, application/vnd.openeye.oeb, application/vnd.openofficeorg.extension, application/vnd.openstreetmap.data+xml, application/vnd.openxmlformats-officedocument.custom-properties+xml, application/vnd.openxmlformats-officedocument.customxmlproperties+xml, application/vnd.openxmlformats-officedocument.drawing+xml, application/vnd.openxmlformats-officedocument.drawingml.chart+xml, application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml, application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml, application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml, application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml, application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml, application/vnd.openxmlformats-officedocument.extended-properties+xml, application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml, application/vnd.openxmlformats-officedocument.presentationml.comments+xml, application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml, application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml, application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml, application/vnd.openxmlformats-officedocument.presentationml.presentation, application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml, application/vnd.openxmlformats-officedocument.presentationml.presprops+xml, application/vnd.openxmlformats-officedocument.presentationml.slide, application/vnd.openxmlformats-officedocument.presentationml.slide+xml, application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml, application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml, application/vnd.openxmlformats-officedocument.presentationml.slideshow, application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml, application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml, application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml, application/vnd.openxmlformats-officedocument.presentationml.tags+xml, application/vnd.openxmlformats-officedocument.presentationml.template, application/vnd.openxmlformats-officedocument.presentationml.template.main+xml, application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.template, application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml, application/vnd.openxmlformats-officedocument.theme+xml, application/vnd.openxmlformats-officedocument.themeoverride+xml, application/vnd.openxmlformats-officedocument.vmldrawing, application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml, application/vnd.openxmlformats-officedocument.wordprocessingml.document, application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml, application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml, application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml, application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml, application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml, application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml, application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml, application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml, application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml, application/vnd.openxmlformats-officedocument.wordprocessingml.template, application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml, application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml, application/vnd.openxmlformats-package.core-properties+xml, application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml, application/vnd.openxmlformats-package.relationships+xml, application/vnd.oracle.resource+json, application/vnd.orange.indata, application/vnd.osa.netdeploy, application/vnd.osgeo.mapguide.package, application/vnd.osgi.bundle, application/vnd.osgi.dp, application/vnd.osgi.subsystem, application/vnd.otps.ct-kip+xml, application/vnd.oxli.countgraph, application/vnd.pagerduty+json, application/vnd.palm, application/vnd.panoply, application/vnd.paos.xml, application/vnd.patentdive, application/vnd.patientecommsdoc, application/vnd.pawaafile, application/vnd.pcos, application/vnd.pg.format, application/vnd.pg.osasli, application/vnd.piaccess.application-licence, application/vnd.picsel, application/vnd.pmi.widget, application/vnd.poc.group-advertisement+xml, application/vnd.pocketlearn, application/vnd.powerbuilder6, application/vnd.powerbuilder6-s, application/vnd.powerbuilder7, application/vnd.powerbuilder7-s, application/vnd.powerbuilder75, application/vnd.powerbuilder75-s, application/vnd.preminet, application/vnd.previewsystems.box, application/vnd.proteus.magazine, application/vnd.psfs, application/vnd.publishare-delta-tree, application/vnd.pvi.ptid1, application/vnd.pwg-multiplexed, application/vnd.pwg-xhtml-print+xml, application/vnd.qualcomm.brew-app-res, application/vnd.quarantainenet, application/vnd.quark.quarkxpress, application/vnd.quobject-quoxdocument, application/vnd.radisys.moml+xml, application/vnd.radisys.msml+xml, application/vnd.radisys.msml-audit+xml, application/vnd.radisys.msml-audit-conf+xml, application/vnd.radisys.msml-audit-conn+xml, application/vnd.radisys.msml-audit-dialog+xml, application/vnd.radisys.msml-audit-stream+xml, application/vnd.radisys.msml-conf+xml, application/vnd.radisys.msml-dialog+xml, application/vnd.radisys.msml-dialog-base+xml, application/vnd.radisys.msml-dialog-fax-detect+xml, application/vnd.radisys.msml-dialog-fax-sendrecv+xml, application/vnd.radisys.msml-dialog-group+xml, application/vnd.radisys.msml-dialog-speech+xml, application/vnd.radisys.msml-dialog-transform+xml, application/vnd.rainstor.data, application/vnd.rapid, application/vnd.rar, application/vnd.realvnc.bed, application/vnd.recordare.musicxml, application/vnd.recordare.musicxml+xml, application/vnd.renlearn.rlprint, application/vnd.restful+json, application/vnd.rig.cryptonote, application/vnd.rim.cod, application/vnd.rn-realmedia, application/vnd.rn-realmedia-vbr, application/vnd.route66.link66+xml, application/vnd.rs-274x, application/vnd.ruckus.download, application/vnd.s3sms, application/vnd.sailingtracker.track, application/vnd.sbm.cid, application/vnd.sbm.mid2, application/vnd.scribus, application/vnd.sealed.3df, application/vnd.sealed.csf, application/vnd.sealed.doc, application/vnd.sealed.eml, application/vnd.sealed.mht, application/vnd.sealed.net, application/vnd.sealed.ppt, application/vnd.sealed.tiff, application/vnd.sealed.xls, application/vnd.sealedmedia.softseal.html, application/vnd.sealedmedia.softseal.pdf, application/vnd.seemail, application/vnd.sema, application/vnd.semd, application/vnd.semf, application/vnd.shana.informed.formdata, application/vnd.shana.informed.formtemplate, application/vnd.shana.informed.interchange, application/vnd.shana.informed.package, application/vnd.shootproof+json, application/vnd.sigrok.session, application/vnd.simtech-mindmapper, application/vnd.siren+json, application/vnd.smaf, application/vnd.smart.notebook, application/vnd.smart.teacher, application/vnd.software602.filler.form+xml, application/vnd.software602.filler.form-xml-zip, application/vnd.solent.sdkm+xml, application/vnd.spotfire.dxp, application/vnd.spotfire.sfs, application/vnd.sqlite3, application/vnd.sss-cod, application/vnd.sss-dtf, application/vnd.sss-ntf, application/vnd.stardivision.calc, application/vnd.stardivision.draw, application/vnd.stardivision.impress, application/vnd.stardivision.math, application/vnd.stardivision.writer, application/vnd.stardivision.writer-global, application/vnd.stepmania.package, application/vnd.stepmania.stepchart, application/vnd.street-stream, application/vnd.sun.wadl+xml, application/vnd.sun.xml.calc, application/vnd.sun.xml.calc.template, application/vnd.sun.xml.draw, application/vnd.sun.xml.draw.template, application/vnd.sun.xml.impress, application/vnd.sun.xml.impress.template, application/vnd.sun.xml.math, application/vnd.sun.xml.writer, application/vnd.sun.xml.writer.global, application/vnd.sun.xml.writer.template, application/vnd.sus-calendar, application/vnd.svd, application/vnd.swiftview-ics, application/vnd.symbian.install, application/vnd.syncml+xml, application/vnd.syncml.dm+wbxml, application/vnd.syncml.dm+xml, application/vnd.syncml.dm.notification, application/vnd.syncml.dmddf+wbxml, application/vnd.syncml.dmddf+xml, application/vnd.syncml.dmtnds+wbxml, application/vnd.syncml.dmtnds+xml, application/vnd.syncml.ds.notification, application/vnd.tableschema+json, application/vnd.tao.intent-module-archive, application/vnd.tcpdump.pcap, application/vnd.think-cell.ppttc+json, application/vnd.tmd.mediaflex.api+xml, application/vnd.tml, application/vnd.tmobile-livetv, application/vnd.tri.onesource, application/vnd.trid.tpt, application/vnd.triscape.mxs, application/vnd.trueapp, application/vnd.truedoc, application/vnd.ubisoft.webplayer, application/vnd.ufdl, application/vnd.uiq.theme, application/vnd.umajin, application/vnd.unity, application/vnd.uoml+xml, application/vnd.uplanet.alert, application/vnd.uplanet.alert-wbxml, application/vnd.uplanet.bearer-choice, application/vnd.uplanet.bearer-choice-wbxml, application/vnd.uplanet.cacheop, application/vnd.uplanet.cacheop-wbxml, application/vnd.uplanet.channel, application/vnd.uplanet.channel-wbxml, application/vnd.uplanet.list, application/vnd.uplanet.list-wbxml, application/vnd.uplanet.listcmd, application/vnd.uplanet.listcmd-wbxml, application/vnd.uplanet.signal, application/vnd.uri-map, application/vnd.valve.source.material, application/vnd.vcx, application/vnd.vd-study, application/vnd.vectorworks, application/vnd.vel+json, application/vnd.verimatrix.vcas, application/vnd.veryant.thin, application/vnd.vidsoft.vidconference, application/vnd.visio, application/vnd.visionary, application/vnd.vividence.scriptfile, application/vnd.vsf, application/vnd.wap.sic, application/vnd.wap.slc, application/vnd.wap.wbxml, application/vnd.wap.wmlc, application/vnd.wap.wmlscriptc, application/vnd.webturbo, application/vnd.wfa.p2p, application/vnd.wfa.wsc, application/vnd.windows.devicepairing, application/vnd.wmc, application/vnd.wmf.bootstrap, application/vnd.wolfram.mathematica, application/vnd.wolfram.mathematica.package, application/vnd.wolfram.player, application/vnd.wordperfect, application/vnd.wqd, application/vnd.wrq-hp3000-labelled, application/vnd.wt.stf, application/vnd.wv.csp+wbxml, application/vnd.wv.csp+xml, application/vnd.wv.ssp+xml, application/vnd.xacml+json, application/vnd.xara, application/vnd.xfdl, application/vnd.xfdl.webform, application/vnd.xmi+xml, application/vnd.xmpie.cpkg, application/vnd.xmpie.dpkg, application/vnd.xmpie.plan, application/vnd.xmpie.ppkg, application/vnd.xmpie.xlim, application/vnd.yamaha.hv-dic, application/vnd.yamaha.hv-script, application/vnd.yamaha.hv-voice, application/vnd.yamaha.openscoreformat, application/vnd.yamaha.openscoreformat.osfpvg+xml, application/vnd.yamaha.remote-setup, application/vnd.yamaha.smaf-audio, application/vnd.yamaha.smaf-phrase, application/vnd.yamaha.through-ngn, application/vnd.yamaha.tunnel-udpencap, application/vnd.yaoweme, application/vnd.yellowriver-custom-menu, application/vnd.youtube.yt, application/vnd.zul, application/vnd.zzazz.deck+xml, application/voicexml+xml, application/voucher-cms+json, application/vq-rtcpxr, application/wasm, application/watcherinfo+xml, application/webpush-options+json, application/whoispp-query, application/whoispp-response, application/widget, application/winhlp, application/wita, application/wordperfect5.1, application/wsdl+xml, application/wspolicy+xml, application/x-7z-compressed, application/x-abiword, application/x-ace-compressed, application/x-amf, application/x-apple-diskimage, application/x-arj, application/x-authorware-bin, application/x-authorware-map, application/x-authorware-seg, application/x-bcpio, application/x-bdoc, application/x-bittorrent, application/x-blorb, application/x-bzip, application/x-bzip2, application/x-cbr, application/x-cdlink, application/x-cfs-compressed, application/x-chat, application/x-chess-pgn, application/x-chrome-extension, application/x-cocoa, application/x-compress, application/x-conference, application/x-cpio, application/x-csh, application/x-deb, application/x-debian-package, application/x-dgc-compressed, application/x-director, application/x-doom, application/x-dtbncx+xml, application/x-dtbook+xml, application/x-dtbresource+xml, application/x-dvi, application/x-envoy, application/x-eva, application/x-font-bdf, application/x-font-dos, application/x-font-framemaker, application/x-font-ghostscript, application/x-font-libgrx, application/x-font-linux-psf, application/x-font-pcf, application/x-font-snf, application/x-font-speedo, application/x-font-sunos-news, application/x-font-type1, application/x-font-vfont, application/x-freearc, application/x-futuresplash, application/x-gca-compressed, application/x-glulx, application/x-gnumeric, application/x-gramps-xml, application/x-gtar, application/x-gzip, application/x-hdf, application/x-httpd-php, application/x-install-instructions, application/x-iso9660-image, application/x-java-archive-diff, application/x-java-jnlp-file, application/x-javascript, application/x-latex, application/x-lua-bytecode, application/x-lzh-compressed, application/x-makeself, application/x-mie, application/x-mobipocket-ebook, application/x-mpegurl, application/x-ms-application, application/x-ms-shortcut, application/x-ms-wmd, application/x-ms-wmz, application/x-ms-xbap, application/x-msaccess, application/x-msbinder, application/x-mscardfile, application/x-msclip, application/x-msdos-program, application/x-msdownload, application/x-msmediaview, application/x-msmetafile, application/x-msmoney, application/x-mspublisher, application/x-msschedule, application/x-msterminal, application/x-mswrite, application/x-netcdf, application/x-ns-proxy-autoconfig, application/x-nzb, application/x-perl, application/x-pilot, application/x-pkcs12, application/x-pkcs7-certificates, application/x-pkcs7-certreqresp, application/x-rar-compressed, application/x-redhat-package-manager, application/x-research-info-systems, application/x-sea, application/x-sh, application/x-shar, application/x-shockwave-flash, application/x-silverlight-app, application/x-sql, application/x-stuffit, application/x-stuffitx, application/x-subrip, application/x-sv4cpio, application/x-sv4crc, application/x-t3vm-image, application/x-tads, application/x-tar, application/x-tcl, application/x-tex, application/x-tex-tfm, application/x-texinfo, application/x-tgif, application/x-ustar, application/x-virtualbox-hdd, application/x-virtualbox-ova, application/x-virtualbox-ovf, application/x-virtualbox-vbox, application/x-virtualbox-vbox-extpack, application/x-virtualbox-vdi, application/x-virtualbox-vhd, application/x-virtualbox-vmdk, application/x-wais-source, application/x-web-app-manifest+json, application/x-www-form-urlencoded, application/x-x509-ca-cert, application/x-xfig, application/x-xliff+xml, application/x-xpinstall, application/x-xz, application/x-zmachine, application/x400-bp, application/xacml+xml, application/xaml+xml, application/xcap-att+xml, application/xcap-caps+xml, application/xcap-diff+xml, application/xcap-el+xml, application/xcap-error+xml, application/xcap-ns+xml, application/xcon-conference-info+xml, application/xcon-conference-info-diff+xml, application/xenc+xml, application/xhtml+xml, application/xhtml-voice+xml, application/xliff+xml, application/xml, application/xml-dtd, application/xml-external-parsed-entity, application/xml-patch+xml, application/xmpp+xml, application/xop+xml, application/xproc+xml, application/xslt+xml, application/xspf+xml, application/xv+xml, application/yang, application/yang-data+json, application/yang-data+xml, application/yang-patch+json, application/yang-patch+xml, application/yin+xml, application/zip, application/zlib, application/zstd, audio/1d-interleaved-parityfec, audio/32kadpcm, audio/3gpp, audio/3gpp2, audio/aac, audio/ac3, audio/adpcm, audio/amr, audio/amr-wb, audio/amr-wb+, audio/aptx, audio/asc, audio/atrac-advanced-lossless, audio/atrac-x, audio/atrac3, audio/basic, audio/bv16, audio/bv32, audio/clearmode, audio/cn, audio/dat12, audio/dls, audio/dsr-es201108, audio/dsr-es202050, audio/dsr-es202211, audio/dsr-es202212, audio/dv, audio/dvi4, audio/eac3, audio/encaprtp, audio/evrc, audio/evrc-qcp, audio/evrc0, audio/evrc1, audio/evrcb, audio/evrcb0, audio/evrcb1, audio/evrcnw, audio/evrcnw0, audio/evrcnw1, audio/evrcwb, audio/evrcwb0, audio/evrcwb1, audio/evs, audio/fwdred, audio/g711-0, audio/g719, audio/g722, audio/g7221, audio/g723, audio/g726-16, audio/g726-24, audio/g726-32, audio/g726-40, audio/g728, audio/g729, audio/g7291, audio/g729d, audio/g729e, audio/gsm, audio/gsm-efr, audio/gsm-hr-08, audio/ilbc, audio/ip-mr_v2.5, audio/isac, audio/l16, audio/l20, audio/l24, audio/l8, audio/lpc, audio/melp, audio/melp1200, audio/melp2400, audio/melp600, audio/midi, audio/mobile-xmf, audio/mp3, audio/mp4, audio/mp4a-latm, audio/mpa, audio/mpa-robust, audio/mpeg, audio/mpeg4-generic, audio/musepack, audio/ogg, audio/opus, audio/parityfec, audio/pcma, audio/pcma-wb, audio/pcmu, audio/pcmu-wb, audio/prs.sid, audio/qcelp, audio/raptorfec, audio/red, audio/rtp-enc-aescm128, audio/rtp-midi, audio/rtploopback, audio/rtx, audio/s3m, audio/silk, audio/smv, audio/smv-qcp, audio/smv0, audio/sp-midi, audio/speex, audio/t140c, audio/t38, audio/telephone-event, audio/tetra_acelp, audio/tone, audio/uemclip, audio/ulpfec, audio/usac, audio/vdvi, audio/vmr-wb, audio/vnd.3gpp.iufp, audio/vnd.4sb, audio/vnd.audiokoz, audio/vnd.celp, audio/vnd.cisco.nse, audio/vnd.cmles.radio-events, audio/vnd.cns.anp1, audio/vnd.cns.inf1, audio/vnd.dece.audio, audio/vnd.digital-winds, audio/vnd.dlna.adts, audio/vnd.dolby.heaac.1, audio/vnd.dolby.heaac.2, audio/vnd.dolby.mlp, audio/vnd.dolby.mps, audio/vnd.dolby.pl2, audio/vnd.dolby.pl2x, audio/vnd.dolby.pl2z, audio/vnd.dolby.pulse.1, audio/vnd.dra, audio/vnd.dts, audio/vnd.dts.hd, audio/vnd.dts.uhd, audio/vnd.dvb.file, audio/vnd.everad.plj, audio/vnd.hns.audio, audio/vnd.lucent.voice, audio/vnd.ms-playready.media.pya, audio/vnd.nokia.mobile-xmf, audio/vnd.nortel.vbk, audio/vnd.nuera.ecelp4800, audio/vnd.nuera.ecelp7470, audio/vnd.nuera.ecelp9600, audio/vnd.octel.sbc, audio/vnd.presonus.multitrack, audio/vnd.qcelp, audio/vnd.rhetorex.32kadpcm, audio/vnd.rip, audio/vnd.rn-realaudio, audio/vnd.sealedmedia.softseal.mpeg, audio/vnd.vmx.cvsd, audio/vnd.wave, audio/vorbis, audio/vorbis-config, audio/wav, audio/wave, audio/webm, audio/x-aac, audio/x-aiff, audio/x-caf, audio/x-flac, audio/x-m4a, audio/x-matroska, audio/x-mpegurl, audio/x-ms-wax, audio/x-ms-wma, audio/x-pn-realaudio, audio/x-pn-realaudio-plugin, audio/x-realaudio, audio/x-tta, audio/x-wav, audio/xm, chemical/x-cdx, chemical/x-cif, chemical/x-cmdf, chemical/x-cml, chemical/x-csml, chemical/x-pdb, chemical/x-xyz, font/collection, font/otf, font/sfnt, font/ttf, font/woff, font/woff2, image/aces, image/apng, image/avci, image/avcs, image/bmp, image/cgm, image/dicom-rle, image/emf, image/fits, image/g3fax, image/gif, image/heic, image/heic-sequence, image/heif, image/heif-sequence, image/ief, image/jls, image/jp2, image/jpeg, image/jpm, image/jpx, image/jxr, image/ktx, image/naplps, image/pjpeg, image/png, image/prs.btif, image/prs.pti, image/pwg-raster, image/sgi, image/svg+xml, image/t38, image/tiff, image/tiff-fx, image/vnd.adobe.photoshop, image/vnd.airzip.accelerator.azv, image/vnd.cns.inf2, image/vnd.dece.graphic, image/vnd.djvu, image/vnd.dvb.subtitle, image/vnd.dwg, image/vnd.dxf, image/vnd.fastbidsheet, image/vnd.fpx, image/vnd.fst, image/vnd.fujixerox.edmics-mmr, image/vnd.fujixerox.edmics-rlc, image/vnd.globalgraphics.pgb, image/vnd.microsoft.icon, image/vnd.mix, image/vnd.mozilla.apng, image/vnd.ms-modi, image/vnd.ms-photo, image/vnd.net-fpx, image/vnd.radiance, image/vnd.sealed.png, image/vnd.sealedmedia.softseal.gif, image/vnd.sealedmedia.softseal.jpg, image/vnd.svf, image/vnd.tencent.tap, image/vnd.valve.source.texture, image/vnd.wap.wbmp, image/vnd.xiff, image/vnd.zbrush.pcx, image/webp, image/wmf, image/x-3ds, image/x-cmu-raster, image/x-cmx, image/x-freehand, image/x-icon, image/x-jng, image/x-mrsid-image, image/x-ms-bmp, image/x-pcx, image/x-pict, image/x-portable-anymap, image/x-portable-bitmap, image/x-portable-graymap, image/x-portable-pixmap, image/x-rgb, image/x-tga, image/x-xbitmap, image/x-xcf, image/x-xpixmap, image/x-xwindowdump, message/cpim, message/delivery-status, message/disposition-notification, message/external-body, message/feedback-report, message/global, message/global-delivery-status, message/global-disposition-notification, message/global-headers, message/http, message/imdn+xml, message/news, message/partial, message/rfc822, message/s-http, message/sip, message/sipfrag, message/tracking-status, message/vnd.si.simp, message/vnd.wfa.wsc, model/3mf, model/gltf+json, model/gltf-binary, model/iges, model/mesh, model/stl, model/vnd.collada+xml, model/vnd.dwf, model/vnd.flatland.3dml, model/vnd.gdl, model/vnd.gs-gdl, model/vnd.gs.gdl, model/vnd.gtw, model/vnd.moml+xml, model/vnd.mts, model/vnd.opengex, model/vnd.parasolid.transmit.binary, model/vnd.parasolid.transmit.text, model/vnd.rosette.annotated-data-model, model/vnd.usdz+zip, model/vnd.valve.source.compiled-map, model/vnd.vtu, model/vrml, model/x3d+binary, model/x3d+fastinfoset, model/x3d+vrml, model/x3d+xml, model/x3d-vrml, multipart/alternative, multipart/appledouble, multipart/byteranges, multipart/digest, multipart/encrypted, multipart/form-data, multipart/header-set, multipart/mixed, multipart/multilingual, multipart/parallel, multipart/related, multipart/report, multipart/signed, multipart/vnd.bint.med-plus, multipart/voice-message, multipart/x-mixed-replace, text/1d-interleaved-parityfec, text/cache-manifest, text/calendar, text/calender, text/cmd, text/coffeescript, text/css, text/csv, text/csv-schema, text/directory, text/dns, text/ecmascript, text/encaprtp, text/enriched, text/fwdred, text/grammar-ref-list, text/html, text/jade, text/javascript, text/jcr-cnd, text/jsx, text/less, text/markdown, text/mathml, text/mdx, text/mizar, text/n3, text/parameters, text/parityfec, text/plain, text/provenance-notation, text/prs.fallenstein.rst, text/prs.lines.tag, text/prs.prop.logic, text/raptorfec, text/red, text/rfc822-headers, text/richtext, text/rtf, text/rtp-enc-aescm128, text/rtploopback, text/rtx, text/sgml, text/shex, text/slim, text/strings, text/stylus, text/t140, text/tab-separated-values, text/troff, text/turtle, text/ulpfec, text/uri-list, text/vcard, text/vnd.a, text/vnd.abc, text/vnd.ascii-art, text/vnd.curl, text/vnd.curl.dcurl, text/vnd.curl.mcurl, text/vnd.curl.scurl, text/vnd.debian.copyright, text/vnd.dmclientscript, text/vnd.dvb.subtitle, text/vnd.esmertec.theme-descriptor, text/vnd.fly, text/vnd.fmi.flexstor, text/vnd.gml, text/vnd.graphviz, text/vnd.hgl, text/vnd.in3d.3dml, text/vnd.in3d.spot, text/vnd.iptc.newsml, text/vnd.iptc.nitf, text/vnd.latex-z, text/vnd.motorola.reflex, text/vnd.ms-mediapackage, text/vnd.net2phone.commcenter.command, text/vnd.radisys.msml-basic-layout, text/vnd.senx.warpscript, text/vnd.si.uricatalogue, text/vnd.sun.j2me.app-descriptor, text/vnd.trolltech.linguist, text/vnd.wap.si, text/vnd.wap.sl, text/vnd.wap.wml, text/vnd.wap.wmlscript, text/vtt, text/x-asm, text/x-c, text/x-component, text/x-fortran, text/x-gwt-rpc, text/x-handlebars-template, text/x-java-source, text/x-jquery-tmpl, text/x-lua, text/x-markdown, text/x-nfo, text/x-opml, text/x-org, text/x-pascal, text/x-processing, text/x-sass, text/x-scss, text/x-setext, text/x-sfv, text/x-suse-ymp, text/x-uuencode, text/x-vcalendar, text/x-vcard, text/xml, text/xml-external-parsed-entity, text/yaml, video/1d-interleaved-parityfec, video/3gpp, video/3gpp-tt, video/3gpp2, video/bmpeg, video/bt656, video/celb, video/dv, video/encaprtp, video/h261, video/h263, video/h263-1998, video/h263-2000, video/h264, video/h264-rcdo, video/h264-svc, video/h265, video/iso.segment, video/jpeg, video/jpeg2000, video/jpm, video/mj2, video/mp1s, video/mp2p, video/mp2t, video/mp4, video/mp4v-es, video/mpeg, video/mpeg4-generic, video/mpv, video/nv, video/ogg, video/parityfec, video/pointer, video/quicktime, video/raptorfec, video/raw, video/rtp-enc-aescm128, video/rtploopback, video/rtx, video/smpte291, video/smpte292m, video/ulpfec, video/vc1, video/vc2, video/vnd.cctv, video/vnd.dece.hd, video/vnd.dece.mobile, video/vnd.dece.mp4, video/vnd.dece.pd, video/vnd.dece.sd, video/vnd.dece.video, video/vnd.directv.mpeg, video/vnd.directv.mpeg-tts, video/vnd.dlna.mpeg-tts, video/vnd.dvb.file, video/vnd.fvt, video/vnd.hns.video, video/vnd.iptvforum.1dparityfec-1010, video/vnd.iptvforum.1dparityfec-2005, video/vnd.iptvforum.2dparityfec-1010, video/vnd.iptvforum.2dparityfec-2005, video/vnd.iptvforum.ttsavc, video/vnd.iptvforum.ttsmpeg2, video/vnd.motorola.video, video/vnd.motorola.videop, video/vnd.mpegurl, video/vnd.ms-playready.media.pyv, video/vnd.nokia.interleaved-multimedia, video/vnd.nokia.mp4vr, video/vnd.nokia.videovoip, video/vnd.objectvideo, video/vnd.radgamettools.bink, video/vnd.radgamettools.smacker, video/vnd.sealed.mpeg1, video/vnd.sealed.mpeg4, video/vnd.sealed.swf, video/vnd.sealedmedia.softseal.mov, video/vnd.uvvu.mp4, video/vnd.vivo, video/vp8, video/webm, video/x-f4v, video/x-fli, video/x-flv, video/x-m4v, video/x-matroska, video/x-mng, video/x-ms-asf, video/x-ms-vob, video/x-ms-wm, video/x-ms-wmv, video/x-ms-wmx, video/x-ms-wvx, video/x-msvideo, video/x-sgi-movie, video/x-smv, x-conference/x-cooltalk, x-shader/x-fragment, x-shader/x-vertex, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"application/1d-interleaved-parityfec\":{\"source\":\"iana\"},\"application/3gpdash-qoe-report+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/3gpp-ims+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/a2l\":{\"source\":\"iana\"},\"application/activemessage\":{\"source\":\"iana\"},\"application/activity+json\":{\"source\":\"iana\",\"compressible\":true},\"application/alto-costmap+json\":{\"source\":\"iana\",\"compressible\":true},\"application/alto-costmapfilter+json\":{\"source\":\"iana\",\"compressible\":true},\"application/alto-directory+json\":{\"source\":\"iana\",\"compressible\":true},\"application/alto-endpointcost+json\":{\"source\":\"iana\",\"compressible\":true},\"application/alto-endpointcostparams+json\":{\"source\":\"iana\",\"compressible\":true},\"application/alto-endpointprop+json\":{\"source\":\"iana\",\"compressible\":true},\"application/alto-endpointpropparams+json\":{\"source\":\"iana\",\"compressible\":true},\"application/alto-error+json\":{\"source\":\"iana\",\"compressible\":true},\"application/alto-networkmap+json\":{\"source\":\"iana\",\"compressible\":true},\"application/alto-networkmapfilter+json\":{\"source\":\"iana\",\"compressible\":true},\"application/aml\":{\"source\":\"iana\"},\"application/andrew-inset\":{\"source\":\"iana\",\"extensions\":[\"ez\"]},\"application/applefile\":{\"source\":\"iana\"},\"application/applixware\":{\"source\":\"apache\",\"extensions\":[\"aw\"]},\"application/atf\":{\"source\":\"iana\"},\"application/atfx\":{\"source\":\"iana\"},\"application/atom+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"atom\"]},\"application/atomcat+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"atomcat\"]},\"application/atomdeleted+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/atomicmail\":{\"source\":\"iana\"},\"application/atomsvc+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"atomsvc\"]},\"application/atsc-dwd+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/atsc-held+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/atsc-rsat+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/atxml\":{\"source\":\"iana\"},\"application/auth-policy+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/bacnet-xdd+zip\":{\"source\":\"iana\",\"compressible\":false},\"application/batch-smtp\":{\"source\":\"iana\"},\"application/bdoc\":{\"compressible\":false,\"extensions\":[\"bdoc\"]},\"application/beep+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/calendar+json\":{\"source\":\"iana\",\"compressible\":true},\"application/calendar+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/call-completion\":{\"source\":\"iana\"},\"application/cals-1840\":{\"source\":\"iana\"},\"application/cbor\":{\"source\":\"iana\"},\"application/cccex\":{\"source\":\"iana\"},\"application/ccmp+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/ccxml+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"ccxml\"]},\"application/cdfx+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/cdmi-capability\":{\"source\":\"iana\",\"extensions\":[\"cdmia\"]},\"application/cdmi-container\":{\"source\":\"iana\",\"extensions\":[\"cdmic\"]},\"application/cdmi-domain\":{\"source\":\"iana\",\"extensions\":[\"cdmid\"]},\"application/cdmi-object\":{\"source\":\"iana\",\"extensions\":[\"cdmio\"]},\"application/cdmi-queue\":{\"source\":\"iana\",\"extensions\":[\"cdmiq\"]},\"application/cdni\":{\"source\":\"iana\"},\"application/cea\":{\"source\":\"iana\"},\"application/cea-2018+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/cellml+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/cfw\":{\"source\":\"iana\"},\"application/clue_info+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/cms\":{\"source\":\"iana\"},\"application/cnrp+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/coap-group+json\":{\"source\":\"iana\",\"compressible\":true},\"application/coap-payload\":{\"source\":\"iana\"},\"application/commonground\":{\"source\":\"iana\"},\"application/conference-info+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/cose\":{\"source\":\"iana\"},\"application/cose-key\":{\"source\":\"iana\"},\"application/cose-key-set\":{\"source\":\"iana\"},\"application/cpl+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/csrattrs\":{\"source\":\"iana\"},\"application/csta+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/cstadata+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/csvm+json\":{\"source\":\"iana\",\"compressible\":true},\"application/cu-seeme\":{\"source\":\"apache\",\"extensions\":[\"cu\"]},\"application/cwt\":{\"source\":\"iana\"},\"application/cybercash\":{\"source\":\"iana\"},\"application/dart\":{\"compressible\":true},\"application/dash+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"mpd\"]},\"application/dashdelta\":{\"source\":\"iana\"},\"application/davmount+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"davmount\"]},\"application/dca-rft\":{\"source\":\"iana\"},\"application/dcd\":{\"source\":\"iana\"},\"application/dec-dx\":{\"source\":\"iana\"},\"application/dialog-info+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/dicom\":{\"source\":\"iana\"},\"application/dicom+json\":{\"source\":\"iana\",\"compressible\":true},\"application/dicom+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/dii\":{\"source\":\"iana\"},\"application/dit\":{\"source\":\"iana\"},\"application/dns\":{\"source\":\"iana\"},\"application/dns+json\":{\"source\":\"iana\",\"compressible\":true},\"application/dns-message\":{\"source\":\"iana\"},\"application/docbook+xml\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"dbk\"]},\"application/dskpp+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/dssc+der\":{\"source\":\"iana\",\"extensions\":[\"dssc\"]},\"application/dssc+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"xdssc\"]},\"application/dvcs\":{\"source\":\"iana\"},\"application/ecmascript\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"ecma\",\"es\"]},\"application/edi-consent\":{\"source\":\"iana\"},\"application/edi-x12\":{\"source\":\"iana\",\"compressible\":false},\"application/edifact\":{\"source\":\"iana\",\"compressible\":false},\"application/efi\":{\"source\":\"iana\"},\"application/emergencycalldata.comment+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/emergencycalldata.control+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/emergencycalldata.deviceinfo+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/emergencycalldata.ecall.msd\":{\"source\":\"iana\"},\"application/emergencycalldata.providerinfo+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/emergencycalldata.serviceinfo+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/emergencycalldata.subscriberinfo+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/emergencycalldata.veds+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/emma+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"emma\"]},\"application/emotionml+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/encaprtp\":{\"source\":\"iana\"},\"application/epp+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/epub+zip\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"epub\"]},\"application/eshop\":{\"source\":\"iana\"},\"application/exi\":{\"source\":\"iana\",\"extensions\":[\"exi\"]},\"application/expect-ct-report+json\":{\"source\":\"iana\",\"compressible\":true},\"application/fastinfoset\":{\"source\":\"iana\"},\"application/fastsoap\":{\"source\":\"iana\"},\"application/fdt+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/fhir+json\":{\"source\":\"iana\",\"compressible\":true},\"application/fhir+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/fido.trusted-apps+json\":{\"compressible\":true},\"application/fits\":{\"source\":\"iana\"},\"application/font-sfnt\":{\"source\":\"iana\"},\"application/font-tdpfr\":{\"source\":\"iana\",\"extensions\":[\"pfr\"]},\"application/font-woff\":{\"source\":\"iana\",\"compressible\":false},\"application/framework-attributes+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/geo+json\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"geojson\"]},\"application/geo+json-seq\":{\"source\":\"iana\"},\"application/geopackage+sqlite3\":{\"source\":\"iana\"},\"application/geoxacml+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/gltf-buffer\":{\"source\":\"iana\"},\"application/gml+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"gml\"]},\"application/gpx+xml\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"gpx\"]},\"application/gxf\":{\"source\":\"apache\",\"extensions\":[\"gxf\"]},\"application/gzip\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"gz\"]},\"application/h224\":{\"source\":\"iana\"},\"application/held+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/hjson\":{\"extensions\":[\"hjson\"]},\"application/http\":{\"source\":\"iana\"},\"application/hyperstudio\":{\"source\":\"iana\",\"extensions\":[\"stk\"]},\"application/ibe-key-request+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/ibe-pkg-reply+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/ibe-pp-data\":{\"source\":\"iana\"},\"application/iges\":{\"source\":\"iana\"},\"application/im-iscomposing+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/index\":{\"source\":\"iana\"},\"application/index.cmd\":{\"source\":\"iana\"},\"application/index.obj\":{\"source\":\"iana\"},\"application/index.response\":{\"source\":\"iana\"},\"application/index.vnd\":{\"source\":\"iana\"},\"application/inkml+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"ink\",\"inkml\"]},\"application/iotp\":{\"source\":\"iana\"},\"application/ipfix\":{\"source\":\"iana\",\"extensions\":[\"ipfix\"]},\"application/ipp\":{\"source\":\"iana\"},\"application/isup\":{\"source\":\"iana\"},\"application/its+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/java-archive\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"jar\",\"war\",\"ear\"]},\"application/java-serialized-object\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"ser\"]},\"application/java-vm\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"class\"]},\"application/javascript\":{\"source\":\"iana\",\"charset\":\"UTF-8\",\"compressible\":true,\"extensions\":[\"js\",\"mjs\"]},\"application/jf2feed+json\":{\"source\":\"iana\",\"compressible\":true},\"application/jose\":{\"source\":\"iana\"},\"application/jose+json\":{\"source\":\"iana\",\"compressible\":true},\"application/jrd+json\":{\"source\":\"iana\",\"compressible\":true},\"application/json\":{\"source\":\"iana\",\"charset\":\"UTF-8\",\"compressible\":true,\"extensions\":[\"json\",\"map\"]},\"application/json-patch+json\":{\"source\":\"iana\",\"compressible\":true},\"application/json-seq\":{\"source\":\"iana\"},\"application/json5\":{\"extensions\":[\"json5\"]},\"application/jsonml+json\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"jsonml\"]},\"application/jwk+json\":{\"source\":\"iana\",\"compressible\":true},\"application/jwk-set+json\":{\"source\":\"iana\",\"compressible\":true},\"application/jwt\":{\"source\":\"iana\"},\"application/kpml-request+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/kpml-response+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/ld+json\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"jsonld\"]},\"application/lgr+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/link-format\":{\"source\":\"iana\"},\"application/load-control+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/lost+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"lostxml\"]},\"application/lostsync+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/lxf\":{\"source\":\"iana\"},\"application/mac-binhex40\":{\"source\":\"iana\",\"extensions\":[\"hqx\"]},\"application/mac-compactpro\":{\"source\":\"apache\",\"extensions\":[\"cpt\"]},\"application/macwriteii\":{\"source\":\"iana\"},\"application/mads+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"mads\"]},\"application/manifest+json\":{\"charset\":\"UTF-8\",\"compressible\":true,\"extensions\":[\"webmanifest\"]},\"application/marc\":{\"source\":\"iana\",\"extensions\":[\"mrc\"]},\"application/marcxml+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"mrcx\"]},\"application/mathematica\":{\"source\":\"iana\",\"extensions\":[\"ma\",\"nb\",\"mb\"]},\"application/mathml+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"mathml\"]},\"application/mathml-content+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/mathml-presentation+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/mbms-associated-procedure-description+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/mbms-deregister+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/mbms-envelope+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/mbms-msk+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/mbms-msk-response+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/mbms-protection-description+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/mbms-reception-report+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/mbms-register+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/mbms-register-response+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/mbms-schedule+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/mbms-user-service-description+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/mbox\":{\"source\":\"iana\",\"extensions\":[\"mbox\"]},\"application/media-policy-dataset+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/media_control+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/mediaservercontrol+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"mscml\"]},\"application/merge-patch+json\":{\"source\":\"iana\",\"compressible\":true},\"application/metalink+xml\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"metalink\"]},\"application/metalink4+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"meta4\"]},\"application/mets+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"mets\"]},\"application/mf4\":{\"source\":\"iana\"},\"application/mikey\":{\"source\":\"iana\"},\"application/mmt-aei+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/mmt-usd+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/mods+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"mods\"]},\"application/moss-keys\":{\"source\":\"iana\"},\"application/moss-signature\":{\"source\":\"iana\"},\"application/mosskey-data\":{\"source\":\"iana\"},\"application/mosskey-request\":{\"source\":\"iana\"},\"application/mp21\":{\"source\":\"iana\",\"extensions\":[\"m21\",\"mp21\"]},\"application/mp4\":{\"source\":\"iana\",\"extensions\":[\"mp4s\",\"m4p\"]},\"application/mpeg4-generic\":{\"source\":\"iana\"},\"application/mpeg4-iod\":{\"source\":\"iana\"},\"application/mpeg4-iod-xmt\":{\"source\":\"iana\"},\"application/mrb-consumer+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/mrb-publish+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/msc-ivr+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/msc-mixer+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/msword\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"doc\",\"dot\"]},\"application/mud+json\":{\"source\":\"iana\",\"compressible\":true},\"application/mxf\":{\"source\":\"iana\",\"extensions\":[\"mxf\"]},\"application/n-quads\":{\"source\":\"iana\",\"extensions\":[\"nq\"]},\"application/n-triples\":{\"source\":\"iana\",\"extensions\":[\"nt\"]},\"application/nasdata\":{\"source\":\"iana\"},\"application/news-checkgroups\":{\"source\":\"iana\"},\"application/news-groupinfo\":{\"source\":\"iana\"},\"application/news-transmission\":{\"source\":\"iana\"},\"application/nlsml+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/node\":{\"source\":\"iana\"},\"application/nss\":{\"source\":\"iana\"},\"application/ocsp-request\":{\"source\":\"iana\"},\"application/ocsp-response\":{\"source\":\"iana\"},\"application/octet-stream\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"bin\",\"dms\",\"lrf\",\"mar\",\"so\",\"dist\",\"distz\",\"pkg\",\"bpk\",\"dump\",\"elc\",\"deploy\",\"exe\",\"dll\",\"deb\",\"dmg\",\"iso\",\"img\",\"msi\",\"msp\",\"msm\",\"buffer\"]},\"application/oda\":{\"source\":\"iana\",\"extensions\":[\"oda\"]},\"application/odm+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/odx\":{\"source\":\"iana\"},\"application/oebps-package+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"opf\"]},\"application/ogg\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"ogx\"]},\"application/omdoc+xml\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"omdoc\"]},\"application/onenote\":{\"source\":\"apache\",\"extensions\":[\"onetoc\",\"onetoc2\",\"onetmp\",\"onepkg\"]},\"application/oscore\":{\"source\":\"iana\"},\"application/oxps\":{\"source\":\"iana\",\"extensions\":[\"oxps\"]},\"application/p2p-overlay+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/parityfec\":{\"source\":\"iana\"},\"application/passport\":{\"source\":\"iana\"},\"application/patch-ops-error+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"xer\"]},\"application/pdf\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"pdf\"]},\"application/pdx\":{\"source\":\"iana\"},\"application/pem-certificate-chain\":{\"source\":\"iana\"},\"application/pgp-encrypted\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"pgp\"]},\"application/pgp-keys\":{\"source\":\"iana\"},\"application/pgp-signature\":{\"source\":\"iana\",\"extensions\":[\"asc\",\"sig\"]},\"application/pics-rules\":{\"source\":\"apache\",\"extensions\":[\"prf\"]},\"application/pidf+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/pidf-diff+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/pkcs10\":{\"source\":\"iana\",\"extensions\":[\"p10\"]},\"application/pkcs12\":{\"source\":\"iana\"},\"application/pkcs7-mime\":{\"source\":\"iana\",\"extensions\":[\"p7m\",\"p7c\"]},\"application/pkcs7-signature\":{\"source\":\"iana\",\"extensions\":[\"p7s\"]},\"application/pkcs8\":{\"source\":\"iana\",\"extensions\":[\"p8\"]},\"application/pkcs8-encrypted\":{\"source\":\"iana\"},\"application/pkix-attr-cert\":{\"source\":\"iana\",\"extensions\":[\"ac\"]},\"application/pkix-cert\":{\"source\":\"iana\",\"extensions\":[\"cer\"]},\"application/pkix-crl\":{\"source\":\"iana\",\"extensions\":[\"crl\"]},\"application/pkix-pkipath\":{\"source\":\"iana\",\"extensions\":[\"pkipath\"]},\"application/pkixcmp\":{\"source\":\"iana\",\"extensions\":[\"pki\"]},\"application/pls+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"pls\"]},\"application/poc-settings+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/postscript\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"ai\",\"eps\",\"ps\"]},\"application/ppsp-tracker+json\":{\"source\":\"iana\",\"compressible\":true},\"application/problem+json\":{\"source\":\"iana\",\"compressible\":true},\"application/problem+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/provenance+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/prs.alvestrand.titrax-sheet\":{\"source\":\"iana\"},\"application/prs.cww\":{\"source\":\"iana\",\"extensions\":[\"cww\"]},\"application/prs.hpub+zip\":{\"source\":\"iana\",\"compressible\":false},\"application/prs.nprend\":{\"source\":\"iana\"},\"application/prs.plucker\":{\"source\":\"iana\"},\"application/prs.rdf-xml-crypt\":{\"source\":\"iana\"},\"application/prs.xsf+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/pskc+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"pskcxml\"]},\"application/qsig\":{\"source\":\"iana\"},\"application/raml+yaml\":{\"compressible\":true,\"extensions\":[\"raml\"]},\"application/raptorfec\":{\"source\":\"iana\"},\"application/rdap+json\":{\"source\":\"iana\",\"compressible\":true},\"application/rdf+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"rdf\",\"owl\"]},\"application/reginfo+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"rif\"]},\"application/relax-ng-compact-syntax\":{\"source\":\"iana\",\"extensions\":[\"rnc\"]},\"application/remote-printing\":{\"source\":\"iana\"},\"application/reputon+json\":{\"source\":\"iana\",\"compressible\":true},\"application/resource-lists+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"rl\"]},\"application/resource-lists-diff+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"rld\"]},\"application/rfc+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/riscos\":{\"source\":\"iana\"},\"application/rlmi+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/rls-services+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"rs\"]},\"application/route-apd+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/route-s-tsid+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/route-usd+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/rpki-ghostbusters\":{\"source\":\"iana\",\"extensions\":[\"gbr\"]},\"application/rpki-manifest\":{\"source\":\"iana\",\"extensions\":[\"mft\"]},\"application/rpki-publication\":{\"source\":\"iana\"},\"application/rpki-roa\":{\"source\":\"iana\",\"extensions\":[\"roa\"]},\"application/rpki-updown\":{\"source\":\"iana\"},\"application/rsd+xml\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"rsd\"]},\"application/rss+xml\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"rss\"]},\"application/rtf\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"rtf\"]},\"application/rtploopback\":{\"source\":\"iana\"},\"application/rtx\":{\"source\":\"iana\"},\"application/samlassertion+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/samlmetadata+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/sbml+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"sbml\"]},\"application/scaip+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/scim+json\":{\"source\":\"iana\",\"compressible\":true},\"application/scvp-cv-request\":{\"source\":\"iana\",\"extensions\":[\"scq\"]},\"application/scvp-cv-response\":{\"source\":\"iana\",\"extensions\":[\"scs\"]},\"application/scvp-vp-request\":{\"source\":\"iana\",\"extensions\":[\"spq\"]},\"application/scvp-vp-response\":{\"source\":\"iana\",\"extensions\":[\"spp\"]},\"application/sdp\":{\"source\":\"iana\",\"extensions\":[\"sdp\"]},\"application/secevent+jwt\":{\"source\":\"iana\"},\"application/senml+cbor\":{\"source\":\"iana\"},\"application/senml+json\":{\"source\":\"iana\",\"compressible\":true},\"application/senml+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/senml-exi\":{\"source\":\"iana\"},\"application/sensml+cbor\":{\"source\":\"iana\"},\"application/sensml+json\":{\"source\":\"iana\",\"compressible\":true},\"application/sensml+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/sensml-exi\":{\"source\":\"iana\"},\"application/sep+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/sep-exi\":{\"source\":\"iana\"},\"application/session-info\":{\"source\":\"iana\"},\"application/set-payment\":{\"source\":\"iana\"},\"application/set-payment-initiation\":{\"source\":\"iana\",\"extensions\":[\"setpay\"]},\"application/set-registration\":{\"source\":\"iana\"},\"application/set-registration-initiation\":{\"source\":\"iana\",\"extensions\":[\"setreg\"]},\"application/sgml\":{\"source\":\"iana\"},\"application/sgml-open-catalog\":{\"source\":\"iana\"},\"application/shf+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"shf\"]},\"application/sieve\":{\"source\":\"iana\",\"extensions\":[\"siv\",\"sieve\"]},\"application/simple-filter+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/simple-message-summary\":{\"source\":\"iana\"},\"application/simplesymbolcontainer\":{\"source\":\"iana\"},\"application/slate\":{\"source\":\"iana\"},\"application/smil\":{\"source\":\"iana\"},\"application/smil+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"smi\",\"smil\"]},\"application/smpte336m\":{\"source\":\"iana\"},\"application/soap+fastinfoset\":{\"source\":\"iana\"},\"application/soap+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/sparql-query\":{\"source\":\"iana\",\"extensions\":[\"rq\"]},\"application/sparql-results+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"srx\"]},\"application/spirits-event+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/sql\":{\"source\":\"iana\"},\"application/srgs\":{\"source\":\"iana\",\"extensions\":[\"gram\"]},\"application/srgs+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"grxml\"]},\"application/sru+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"sru\"]},\"application/ssdl+xml\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"ssdl\"]},\"application/ssml+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"ssml\"]},\"application/stix+json\":{\"source\":\"iana\",\"compressible\":true},\"application/tamp-apex-update\":{\"source\":\"iana\"},\"application/tamp-apex-update-confirm\":{\"source\":\"iana\"},\"application/tamp-community-update\":{\"source\":\"iana\"},\"application/tamp-community-update-confirm\":{\"source\":\"iana\"},\"application/tamp-error\":{\"source\":\"iana\"},\"application/tamp-sequence-adjust\":{\"source\":\"iana\"},\"application/tamp-sequence-adjust-confirm\":{\"source\":\"iana\"},\"application/tamp-status-query\":{\"source\":\"iana\"},\"application/tamp-status-response\":{\"source\":\"iana\"},\"application/tamp-update\":{\"source\":\"iana\"},\"application/tamp-update-confirm\":{\"source\":\"iana\"},\"application/tar\":{\"compressible\":true},\"application/taxii+json\":{\"source\":\"iana\",\"compressible\":true},\"application/tei+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"tei\",\"teicorpus\"]},\"application/tetra_isi\":{\"source\":\"iana\"},\"application/thraud+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"tfi\"]},\"application/timestamp-query\":{\"source\":\"iana\"},\"application/timestamp-reply\":{\"source\":\"iana\"},\"application/timestamped-data\":{\"source\":\"iana\",\"extensions\":[\"tsd\"]},\"application/tlsrpt+gzip\":{\"source\":\"iana\"},\"application/tlsrpt+json\":{\"source\":\"iana\",\"compressible\":true},\"application/tnauthlist\":{\"source\":\"iana\"},\"application/trickle-ice-sdpfrag\":{\"source\":\"iana\"},\"application/trig\":{\"source\":\"iana\"},\"application/ttml+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/tve-trigger\":{\"source\":\"iana\"},\"application/tzif\":{\"source\":\"iana\"},\"application/tzif-leap\":{\"source\":\"iana\"},\"application/ulpfec\":{\"source\":\"iana\"},\"application/urc-grpsheet+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/urc-ressheet+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/urc-targetdesc+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/urc-uisocketdesc+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vcard+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vcard+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vemmi\":{\"source\":\"iana\"},\"application/vividence.scriptfile\":{\"source\":\"apache\"},\"application/vnd.1000minds.decision-model+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp-prose+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp-prose-pc3ch+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp-v2x-local-service-information\":{\"source\":\"iana\"},\"application/vnd.3gpp.access-transfer-events+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.bsf+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.gmop+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mc-signalling-ear\":{\"source\":\"iana\"},\"application/vnd.3gpp.mcdata-affiliation-command+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcdata-info+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcdata-payload\":{\"source\":\"iana\"},\"application/vnd.3gpp.mcdata-service-config+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcdata-signalling\":{\"source\":\"iana\"},\"application/vnd.3gpp.mcdata-ue-config+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcdata-user-profile+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcptt-affiliation-command+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcptt-floor-request+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcptt-info+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcptt-location-info+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcptt-mbms-usage-info+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcptt-service-config+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcptt-signed+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcptt-ue-config+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcptt-ue-init-config+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcptt-user-profile+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcvideo-affiliation-command+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcvideo-affiliation-info+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcvideo-location-info+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcvideo-mbms-usage-info+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcvideo-service-config+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcvideo-transmission-request+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcvideo-ue-config+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcvideo-user-profile+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mid-call+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.pic-bw-large\":{\"source\":\"iana\",\"extensions\":[\"plb\"]},\"application/vnd.3gpp.pic-bw-small\":{\"source\":\"iana\",\"extensions\":[\"psb\"]},\"application/vnd.3gpp.pic-bw-var\":{\"source\":\"iana\",\"extensions\":[\"pvb\"]},\"application/vnd.3gpp.sms\":{\"source\":\"iana\"},\"application/vnd.3gpp.sms+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.srvcc-ext+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.srvcc-info+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.state-and-event-info+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.ussd+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp2.bcmcsinfo+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp2.sms\":{\"source\":\"iana\"},\"application/vnd.3gpp2.tcap\":{\"source\":\"iana\",\"extensions\":[\"tcap\"]},\"application/vnd.3lightssoftware.imagescal\":{\"source\":\"iana\"},\"application/vnd.3m.post-it-notes\":{\"source\":\"iana\",\"extensions\":[\"pwn\"]},\"application/vnd.accpac.simply.aso\":{\"source\":\"iana\",\"extensions\":[\"aso\"]},\"application/vnd.accpac.simply.imp\":{\"source\":\"iana\",\"extensions\":[\"imp\"]},\"application/vnd.acucobol\":{\"source\":\"iana\",\"extensions\":[\"acu\"]},\"application/vnd.acucorp\":{\"source\":\"iana\",\"extensions\":[\"atc\",\"acutc\"]},\"application/vnd.adobe.air-application-installer-package+zip\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"air\"]},\"application/vnd.adobe.flash.movie\":{\"source\":\"iana\"},\"application/vnd.adobe.formscentral.fcdt\":{\"source\":\"iana\",\"extensions\":[\"fcdt\"]},\"application/vnd.adobe.fxp\":{\"source\":\"iana\",\"extensions\":[\"fxp\",\"fxpl\"]},\"application/vnd.adobe.partial-upload\":{\"source\":\"iana\"},\"application/vnd.adobe.xdp+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"xdp\"]},\"application/vnd.adobe.xfdf\":{\"source\":\"iana\",\"extensions\":[\"xfdf\"]},\"application/vnd.aether.imp\":{\"source\":\"iana\"},\"application/vnd.afpc.afplinedata\":{\"source\":\"iana\"},\"application/vnd.afpc.modca\":{\"source\":\"iana\"},\"application/vnd.ah-barcode\":{\"source\":\"iana\"},\"application/vnd.ahead.space\":{\"source\":\"iana\",\"extensions\":[\"ahead\"]},\"application/vnd.airzip.filesecure.azf\":{\"source\":\"iana\",\"extensions\":[\"azf\"]},\"application/vnd.airzip.filesecure.azs\":{\"source\":\"iana\",\"extensions\":[\"azs\"]},\"application/vnd.amadeus+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.amazon.ebook\":{\"source\":\"apache\",\"extensions\":[\"azw\"]},\"application/vnd.amazon.mobi8-ebook\":{\"source\":\"iana\"},\"application/vnd.americandynamics.acc\":{\"source\":\"iana\",\"extensions\":[\"acc\"]},\"application/vnd.amiga.ami\":{\"source\":\"iana\",\"extensions\":[\"ami\"]},\"application/vnd.amundsen.maze+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.android.package-archive\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"apk\"]},\"application/vnd.anki\":{\"source\":\"iana\"},\"application/vnd.anser-web-certificate-issue-initiation\":{\"source\":\"iana\",\"extensions\":[\"cii\"]},\"application/vnd.anser-web-funds-transfer-initiation\":{\"source\":\"apache\",\"extensions\":[\"fti\"]},\"application/vnd.antix.game-component\":{\"source\":\"iana\",\"extensions\":[\"atx\"]},\"application/vnd.apache.thrift.binary\":{\"source\":\"iana\"},\"application/vnd.apache.thrift.compact\":{\"source\":\"iana\"},\"application/vnd.apache.thrift.json\":{\"source\":\"iana\"},\"application/vnd.api+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.apothekende.reservation+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.apple.installer+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"mpkg\"]},\"application/vnd.apple.keynote\":{\"source\":\"iana\",\"extensions\":[\"keynote\"]},\"application/vnd.apple.mpegurl\":{\"source\":\"iana\",\"extensions\":[\"m3u8\"]},\"application/vnd.apple.numbers\":{\"source\":\"iana\",\"extensions\":[\"numbers\"]},\"application/vnd.apple.pages\":{\"source\":\"iana\",\"extensions\":[\"pages\"]},\"application/vnd.apple.pkpass\":{\"compressible\":false,\"extensions\":[\"pkpass\"]},\"application/vnd.arastra.swi\":{\"source\":\"iana\"},\"application/vnd.aristanetworks.swi\":{\"source\":\"iana\",\"extensions\":[\"swi\"]},\"application/vnd.artisan+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.artsquare\":{\"source\":\"iana\"},\"application/vnd.astraea-software.iota\":{\"source\":\"iana\",\"extensions\":[\"iota\"]},\"application/vnd.audiograph\":{\"source\":\"iana\",\"extensions\":[\"aep\"]},\"application/vnd.autopackage\":{\"source\":\"iana\"},\"application/vnd.avalon+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.avistar+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.balsamiq.bmml+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.balsamiq.bmpr\":{\"source\":\"iana\"},\"application/vnd.banana-accounting\":{\"source\":\"iana\"},\"application/vnd.bbf.usp.msg\":{\"source\":\"iana\"},\"application/vnd.bbf.usp.msg+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.bekitzur-stech+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.bint.med-content\":{\"source\":\"iana\"},\"application/vnd.biopax.rdf+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.blink-idb-value-wrapper\":{\"source\":\"iana\"},\"application/vnd.blueice.multipass\":{\"source\":\"iana\",\"extensions\":[\"mpm\"]},\"application/vnd.bluetooth.ep.oob\":{\"source\":\"iana\"},\"application/vnd.bluetooth.le.oob\":{\"source\":\"iana\"},\"application/vnd.bmi\":{\"source\":\"iana\",\"extensions\":[\"bmi\"]},\"application/vnd.businessobjects\":{\"source\":\"iana\",\"extensions\":[\"rep\"]},\"application/vnd.byu.uapi+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.cab-jscript\":{\"source\":\"iana\"},\"application/vnd.canon-cpdl\":{\"source\":\"iana\"},\"application/vnd.canon-lips\":{\"source\":\"iana\"},\"application/vnd.capasystems-pg+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.cendio.thinlinc.clientconf\":{\"source\":\"iana\"},\"application/vnd.century-systems.tcp_stream\":{\"source\":\"iana\"},\"application/vnd.chemdraw+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"cdxml\"]},\"application/vnd.chess-pgn\":{\"source\":\"iana\"},\"application/vnd.chipnuts.karaoke-mmd\":{\"source\":\"iana\",\"extensions\":[\"mmd\"]},\"application/vnd.cinderella\":{\"source\":\"iana\",\"extensions\":[\"cdy\"]},\"application/vnd.cirpack.isdn-ext\":{\"source\":\"iana\"},\"application/vnd.citationstyles.style+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"csl\"]},\"application/vnd.claymore\":{\"source\":\"iana\",\"extensions\":[\"cla\"]},\"application/vnd.cloanto.rp9\":{\"source\":\"iana\",\"extensions\":[\"rp9\"]},\"application/vnd.clonk.c4group\":{\"source\":\"iana\",\"extensions\":[\"c4g\",\"c4d\",\"c4f\",\"c4p\",\"c4u\"]},\"application/vnd.cluetrust.cartomobile-config\":{\"source\":\"iana\",\"extensions\":[\"c11amc\"]},\"application/vnd.cluetrust.cartomobile-config-pkg\":{\"source\":\"iana\",\"extensions\":[\"c11amz\"]},\"application/vnd.coffeescript\":{\"source\":\"iana\"},\"application/vnd.collabio.xodocuments.document\":{\"source\":\"iana\"},\"application/vnd.collabio.xodocuments.document-template\":{\"source\":\"iana\"},\"application/vnd.collabio.xodocuments.presentation\":{\"source\":\"iana\"},\"application/vnd.collabio.xodocuments.presentation-template\":{\"source\":\"iana\"},\"application/vnd.collabio.xodocuments.spreadsheet\":{\"source\":\"iana\"},\"application/vnd.collabio.xodocuments.spreadsheet-template\":{\"source\":\"iana\"},\"application/vnd.collection+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.collection.doc+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.collection.next+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.comicbook+zip\":{\"source\":\"iana\",\"compressible\":false},\"application/vnd.comicbook-rar\":{\"source\":\"iana\"},\"application/vnd.commerce-battelle\":{\"source\":\"iana\"},\"application/vnd.commonspace\":{\"source\":\"iana\",\"extensions\":[\"csp\"]},\"application/vnd.contact.cmsg\":{\"source\":\"iana\",\"extensions\":[\"cdbcmsg\"]},\"application/vnd.coreos.ignition+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.cosmocaller\":{\"source\":\"iana\",\"extensions\":[\"cmc\"]},\"application/vnd.crick.clicker\":{\"source\":\"iana\",\"extensions\":[\"clkx\"]},\"application/vnd.crick.clicker.keyboard\":{\"source\":\"iana\",\"extensions\":[\"clkk\"]},\"application/vnd.crick.clicker.palette\":{\"source\":\"iana\",\"extensions\":[\"clkp\"]},\"application/vnd.crick.clicker.template\":{\"source\":\"iana\",\"extensions\":[\"clkt\"]},\"application/vnd.crick.clicker.wordbank\":{\"source\":\"iana\",\"extensions\":[\"clkw\"]},\"application/vnd.criticaltools.wbs+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"wbs\"]},\"application/vnd.ctc-posml\":{\"source\":\"iana\",\"extensions\":[\"pml\"]},\"application/vnd.ctct.ws+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.cups-pdf\":{\"source\":\"iana\"},\"application/vnd.cups-postscript\":{\"source\":\"iana\"},\"application/vnd.cups-ppd\":{\"source\":\"iana\",\"extensions\":[\"ppd\"]},\"application/vnd.cups-raster\":{\"source\":\"iana\"},\"application/vnd.cups-raw\":{\"source\":\"iana\"},\"application/vnd.curl\":{\"source\":\"iana\"},\"application/vnd.curl.car\":{\"source\":\"apache\",\"extensions\":[\"car\"]},\"application/vnd.curl.pcurl\":{\"source\":\"apache\",\"extensions\":[\"pcurl\"]},\"application/vnd.cyan.dean.root+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.cybank\":{\"source\":\"iana\"},\"application/vnd.d2l.coursepackage1p0+zip\":{\"source\":\"iana\",\"compressible\":false},\"application/vnd.dart\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"dart\"]},\"application/vnd.data-vision.rdz\":{\"source\":\"iana\",\"extensions\":[\"rdz\"]},\"application/vnd.datapackage+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.dataresource+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.debian.binary-package\":{\"source\":\"iana\"},\"application/vnd.dece.data\":{\"source\":\"iana\",\"extensions\":[\"uvf\",\"uvvf\",\"uvd\",\"uvvd\"]},\"application/vnd.dece.ttml+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"uvt\",\"uvvt\"]},\"application/vnd.dece.unspecified\":{\"source\":\"iana\",\"extensions\":[\"uvx\",\"uvvx\"]},\"application/vnd.dece.zip\":{\"source\":\"iana\",\"extensions\":[\"uvz\",\"uvvz\"]},\"application/vnd.denovo.fcselayout-link\":{\"source\":\"iana\",\"extensions\":[\"fe_launch\"]},\"application/vnd.desmume.movie\":{\"source\":\"iana\"},\"application/vnd.dir-bi.plate-dl-nosuffix\":{\"source\":\"iana\"},\"application/vnd.dm.delegation+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.dna\":{\"source\":\"iana\",\"extensions\":[\"dna\"]},\"application/vnd.document+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.dolby.mlp\":{\"source\":\"apache\",\"extensions\":[\"mlp\"]},\"application/vnd.dolby.mobile.1\":{\"source\":\"iana\"},\"application/vnd.dolby.mobile.2\":{\"source\":\"iana\"},\"application/vnd.doremir.scorecloud-binary-document\":{\"source\":\"iana\"},\"application/vnd.dpgraph\":{\"source\":\"iana\",\"extensions\":[\"dpg\"]},\"application/vnd.dreamfactory\":{\"source\":\"iana\",\"extensions\":[\"dfac\"]},\"application/vnd.drive+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.ds-keypoint\":{\"source\":\"apache\",\"extensions\":[\"kpxx\"]},\"application/vnd.dtg.local\":{\"source\":\"iana\"},\"application/vnd.dtg.local.flash\":{\"source\":\"iana\"},\"application/vnd.dtg.local.html\":{\"source\":\"iana\"},\"application/vnd.dvb.ait\":{\"source\":\"iana\",\"extensions\":[\"ait\"]},\"application/vnd.dvb.dvbj\":{\"source\":\"iana\"},\"application/vnd.dvb.esgcontainer\":{\"source\":\"iana\"},\"application/vnd.dvb.ipdcdftnotifaccess\":{\"source\":\"iana\"},\"application/vnd.dvb.ipdcesgaccess\":{\"source\":\"iana\"},\"application/vnd.dvb.ipdcesgaccess2\":{\"source\":\"iana\"},\"application/vnd.dvb.ipdcesgpdd\":{\"source\":\"iana\"},\"application/vnd.dvb.ipdcroaming\":{\"source\":\"iana\"},\"application/vnd.dvb.iptv.alfec-base\":{\"source\":\"iana\"},\"application/vnd.dvb.iptv.alfec-enhancement\":{\"source\":\"iana\"},\"application/vnd.dvb.notif-aggregate-root+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.dvb.notif-container+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.dvb.notif-generic+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.dvb.notif-ia-msglist+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.dvb.notif-ia-registration-request+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.dvb.notif-ia-registration-response+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.dvb.notif-init+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.dvb.pfr\":{\"source\":\"iana\"},\"application/vnd.dvb.service\":{\"source\":\"iana\",\"extensions\":[\"svc\"]},\"application/vnd.dxr\":{\"source\":\"iana\"},\"application/vnd.dynageo\":{\"source\":\"iana\",\"extensions\":[\"geo\"]},\"application/vnd.dzr\":{\"source\":\"iana\"},\"application/vnd.easykaraoke.cdgdownload\":{\"source\":\"iana\"},\"application/vnd.ecdis-update\":{\"source\":\"iana\"},\"application/vnd.ecip.rlp\":{\"source\":\"iana\"},\"application/vnd.ecowin.chart\":{\"source\":\"iana\",\"extensions\":[\"mag\"]},\"application/vnd.ecowin.filerequest\":{\"source\":\"iana\"},\"application/vnd.ecowin.fileupdate\":{\"source\":\"iana\"},\"application/vnd.ecowin.series\":{\"source\":\"iana\"},\"application/vnd.ecowin.seriesrequest\":{\"source\":\"iana\"},\"application/vnd.ecowin.seriesupdate\":{\"source\":\"iana\"},\"application/vnd.efi.img\":{\"source\":\"iana\"},\"application/vnd.efi.iso\":{\"source\":\"iana\"},\"application/vnd.emclient.accessrequest+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.enliven\":{\"source\":\"iana\",\"extensions\":[\"nml\"]},\"application/vnd.enphase.envoy\":{\"source\":\"iana\"},\"application/vnd.eprints.data+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.epson.esf\":{\"source\":\"iana\",\"extensions\":[\"esf\"]},\"application/vnd.epson.msf\":{\"source\":\"iana\",\"extensions\":[\"msf\"]},\"application/vnd.epson.quickanime\":{\"source\":\"iana\",\"extensions\":[\"qam\"]},\"application/vnd.epson.salt\":{\"source\":\"iana\",\"extensions\":[\"slt\"]},\"application/vnd.epson.ssf\":{\"source\":\"iana\",\"extensions\":[\"ssf\"]},\"application/vnd.ericsson.quickcall\":{\"source\":\"iana\"},\"application/vnd.espass-espass+zip\":{\"source\":\"iana\",\"compressible\":false},\"application/vnd.eszigno3+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"es3\",\"et3\"]},\"application/vnd.etsi.aoc+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.etsi.asic-e+zip\":{\"source\":\"iana\",\"compressible\":false},\"application/vnd.etsi.asic-s+zip\":{\"source\":\"iana\",\"compressible\":false},\"application/vnd.etsi.cug+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.etsi.iptvcommand+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.etsi.iptvdiscovery+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.etsi.iptvprofile+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.etsi.iptvsad-bc+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.etsi.iptvsad-cod+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.etsi.iptvsad-npvr+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.etsi.iptvservice+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.etsi.iptvsync+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.etsi.iptvueprofile+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.etsi.mcid+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.etsi.mheg5\":{\"source\":\"iana\"},\"application/vnd.etsi.overload-control-policy-dataset+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.etsi.pstn+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.etsi.sci+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.etsi.simservs+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.etsi.timestamp-token\":{\"source\":\"iana\"},\"application/vnd.etsi.tsl+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.etsi.tsl.der\":{\"source\":\"iana\"},\"application/vnd.eudora.data\":{\"source\":\"iana\"},\"application/vnd.evolv.ecig.profile\":{\"source\":\"iana\"},\"application/vnd.evolv.ecig.settings\":{\"source\":\"iana\"},\"application/vnd.evolv.ecig.theme\":{\"source\":\"iana\"},\"application/vnd.exstream-empower+zip\":{\"source\":\"iana\",\"compressible\":false},\"application/vnd.exstream-package\":{\"source\":\"iana\"},\"application/vnd.ezpix-album\":{\"source\":\"iana\",\"extensions\":[\"ez2\"]},\"application/vnd.ezpix-package\":{\"source\":\"iana\",\"extensions\":[\"ez3\"]},\"application/vnd.f-secure.mobile\":{\"source\":\"iana\"},\"application/vnd.fastcopy-disk-image\":{\"source\":\"iana\"},\"application/vnd.fdf\":{\"source\":\"iana\",\"extensions\":[\"fdf\"]},\"application/vnd.fdsn.mseed\":{\"source\":\"iana\",\"extensions\":[\"mseed\"]},\"application/vnd.fdsn.seed\":{\"source\":\"iana\",\"extensions\":[\"seed\",\"dataless\"]},\"application/vnd.ffsns\":{\"source\":\"iana\"},\"application/vnd.filmit.zfc\":{\"source\":\"iana\"},\"application/vnd.fints\":{\"source\":\"iana\"},\"application/vnd.firemonkeys.cloudcell\":{\"source\":\"iana\"},\"application/vnd.flographit\":{\"source\":\"iana\",\"extensions\":[\"gph\"]},\"application/vnd.fluxtime.clip\":{\"source\":\"iana\",\"extensions\":[\"ftc\"]},\"application/vnd.font-fontforge-sfd\":{\"source\":\"iana\"},\"application/vnd.framemaker\":{\"source\":\"iana\",\"extensions\":[\"fm\",\"frame\",\"maker\",\"book\"]},\"application/vnd.frogans.fnc\":{\"source\":\"iana\",\"extensions\":[\"fnc\"]},\"application/vnd.frogans.ltf\":{\"source\":\"iana\",\"extensions\":[\"ltf\"]},\"application/vnd.fsc.weblaunch\":{\"source\":\"iana\",\"extensions\":[\"fsc\"]},\"application/vnd.fujitsu.oasys\":{\"source\":\"iana\",\"extensions\":[\"oas\"]},\"application/vnd.fujitsu.oasys2\":{\"source\":\"iana\",\"extensions\":[\"oa2\"]},\"application/vnd.fujitsu.oasys3\":{\"source\":\"iana\",\"extensions\":[\"oa3\"]},\"application/vnd.fujitsu.oasysgp\":{\"source\":\"iana\",\"extensions\":[\"fg5\"]},\"application/vnd.fujitsu.oasysprs\":{\"source\":\"iana\",\"extensions\":[\"bh2\"]},\"application/vnd.fujixerox.art-ex\":{\"source\":\"iana\"},\"application/vnd.fujixerox.art4\":{\"source\":\"iana\"},\"application/vnd.fujixerox.ddd\":{\"source\":\"iana\",\"extensions\":[\"ddd\"]},\"application/vnd.fujixerox.docuworks\":{\"source\":\"iana\",\"extensions\":[\"xdw\"]},\"application/vnd.fujixerox.docuworks.binder\":{\"source\":\"iana\",\"extensions\":[\"xbd\"]},\"application/vnd.fujixerox.docuworks.container\":{\"source\":\"iana\"},\"application/vnd.fujixerox.hbpl\":{\"source\":\"iana\"},\"application/vnd.fut-misnet\":{\"source\":\"iana\"},\"application/vnd.futoin+cbor\":{\"source\":\"iana\"},\"application/vnd.futoin+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.fuzzysheet\":{\"source\":\"iana\",\"extensions\":[\"fzs\"]},\"application/vnd.genomatix.tuxedo\":{\"source\":\"iana\",\"extensions\":[\"txd\"]},\"application/vnd.geo+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.geocube+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.geogebra.file\":{\"source\":\"iana\",\"extensions\":[\"ggb\"]},\"application/vnd.geogebra.tool\":{\"source\":\"iana\",\"extensions\":[\"ggt\"]},\"application/vnd.geometry-explorer\":{\"source\":\"iana\",\"extensions\":[\"gex\",\"gre\"]},\"application/vnd.geonext\":{\"source\":\"iana\",\"extensions\":[\"gxt\"]},\"application/vnd.geoplan\":{\"source\":\"iana\",\"extensions\":[\"g2w\"]},\"application/vnd.geospace\":{\"source\":\"iana\",\"extensions\":[\"g3w\"]},\"application/vnd.gerber\":{\"source\":\"iana\"},\"application/vnd.globalplatform.card-content-mgt\":{\"source\":\"iana\"},\"application/vnd.globalplatform.card-content-mgt-response\":{\"source\":\"iana\"},\"application/vnd.gmx\":{\"source\":\"iana\",\"extensions\":[\"gmx\"]},\"application/vnd.google-apps.document\":{\"compressible\":false,\"extensions\":[\"gdoc\"]},\"application/vnd.google-apps.presentation\":{\"compressible\":false,\"extensions\":[\"gslides\"]},\"application/vnd.google-apps.spreadsheet\":{\"compressible\":false,\"extensions\":[\"gsheet\"]},\"application/vnd.google-earth.kml+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"kml\"]},\"application/vnd.google-earth.kmz\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"kmz\"]},\"application/vnd.gov.sk.e-form+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.gov.sk.e-form+zip\":{\"source\":\"iana\",\"compressible\":false},\"application/vnd.gov.sk.xmldatacontainer+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.grafeq\":{\"source\":\"iana\",\"extensions\":[\"gqf\",\"gqs\"]},\"application/vnd.gridmp\":{\"source\":\"iana\"},\"application/vnd.groove-account\":{\"source\":\"iana\",\"extensions\":[\"gac\"]},\"application/vnd.groove-help\":{\"source\":\"iana\",\"extensions\":[\"ghf\"]},\"application/vnd.groove-identity-message\":{\"source\":\"iana\",\"extensions\":[\"gim\"]},\"application/vnd.groove-injector\":{\"source\":\"iana\",\"extensions\":[\"grv\"]},\"application/vnd.groove-tool-message\":{\"source\":\"iana\",\"extensions\":[\"gtm\"]},\"application/vnd.groove-tool-template\":{\"source\":\"iana\",\"extensions\":[\"tpl\"]},\"application/vnd.groove-vcard\":{\"source\":\"iana\",\"extensions\":[\"vcg\"]},\"application/vnd.hal+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.hal+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"hal\"]},\"application/vnd.handheld-entertainment+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"zmm\"]},\"application/vnd.hbci\":{\"source\":\"iana\",\"extensions\":[\"hbci\"]},\"application/vnd.hc+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.hcl-bireports\":{\"source\":\"iana\"},\"application/vnd.hdt\":{\"source\":\"iana\"},\"application/vnd.heroku+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.hhe.lesson-player\":{\"source\":\"iana\",\"extensions\":[\"les\"]},\"application/vnd.hp-hpgl\":{\"source\":\"iana\",\"extensions\":[\"hpgl\"]},\"application/vnd.hp-hpid\":{\"source\":\"iana\",\"extensions\":[\"hpid\"]},\"application/vnd.hp-hps\":{\"source\":\"iana\",\"extensions\":[\"hps\"]},\"application/vnd.hp-jlyt\":{\"source\":\"iana\",\"extensions\":[\"jlt\"]},\"application/vnd.hp-pcl\":{\"source\":\"iana\",\"extensions\":[\"pcl\"]},\"application/vnd.hp-pclxl\":{\"source\":\"iana\",\"extensions\":[\"pclxl\"]},\"application/vnd.httphone\":{\"source\":\"iana\"},\"application/vnd.hydrostatix.sof-data\":{\"source\":\"iana\",\"extensions\":[\"sfd-hdstx\"]},\"application/vnd.hyper+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.hyper-item+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.hyperdrive+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.hzn-3d-crossword\":{\"source\":\"iana\"},\"application/vnd.ibm.afplinedata\":{\"source\":\"iana\"},\"application/vnd.ibm.electronic-media\":{\"source\":\"iana\"},\"application/vnd.ibm.minipay\":{\"source\":\"iana\",\"extensions\":[\"mpy\"]},\"application/vnd.ibm.modcap\":{\"source\":\"iana\",\"extensions\":[\"afp\",\"listafp\",\"list3820\"]},\"application/vnd.ibm.rights-management\":{\"source\":\"iana\",\"extensions\":[\"irm\"]},\"application/vnd.ibm.secure-container\":{\"source\":\"iana\",\"extensions\":[\"sc\"]},\"application/vnd.iccprofile\":{\"source\":\"iana\",\"extensions\":[\"icc\",\"icm\"]},\"application/vnd.ieee.1905\":{\"source\":\"iana\"},\"application/vnd.igloader\":{\"source\":\"iana\",\"extensions\":[\"igl\"]},\"application/vnd.imagemeter.folder+zip\":{\"source\":\"iana\",\"compressible\":false},\"application/vnd.imagemeter.image+zip\":{\"source\":\"iana\",\"compressible\":false},\"application/vnd.immervision-ivp\":{\"source\":\"iana\",\"extensions\":[\"ivp\"]},\"application/vnd.immervision-ivu\":{\"source\":\"iana\",\"extensions\":[\"ivu\"]},\"application/vnd.ims.imsccv1p1\":{\"source\":\"iana\"},\"application/vnd.ims.imsccv1p2\":{\"source\":\"iana\"},\"application/vnd.ims.imsccv1p3\":{\"source\":\"iana\"},\"application/vnd.ims.lis.v2.result+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.ims.lti.v2.toolconsumerprofile+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.ims.lti.v2.toolproxy+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.ims.lti.v2.toolproxy.id+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.ims.lti.v2.toolsettings+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.ims.lti.v2.toolsettings.simple+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.informedcontrol.rms+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.informix-visionary\":{\"source\":\"iana\"},\"application/vnd.infotech.project\":{\"source\":\"iana\"},\"application/vnd.infotech.project+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.innopath.wamp.notification\":{\"source\":\"iana\"},\"application/vnd.insors.igm\":{\"source\":\"iana\",\"extensions\":[\"igm\"]},\"application/vnd.intercon.formnet\":{\"source\":\"iana\",\"extensions\":[\"xpw\",\"xpx\"]},\"application/vnd.intergeo\":{\"source\":\"iana\",\"extensions\":[\"i2g\"]},\"application/vnd.intertrust.digibox\":{\"source\":\"iana\"},\"application/vnd.intertrust.nncp\":{\"source\":\"iana\"},\"application/vnd.intu.qbo\":{\"source\":\"iana\",\"extensions\":[\"qbo\"]},\"application/vnd.intu.qfx\":{\"source\":\"iana\",\"extensions\":[\"qfx\"]},\"application/vnd.iptc.g2.catalogitem+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.iptc.g2.conceptitem+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.iptc.g2.knowledgeitem+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.iptc.g2.newsitem+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.iptc.g2.newsmessage+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.iptc.g2.packageitem+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.iptc.g2.planningitem+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.ipunplugged.rcprofile\":{\"source\":\"iana\",\"extensions\":[\"rcprofile\"]},\"application/vnd.irepository.package+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"irp\"]},\"application/vnd.is-xpr\":{\"source\":\"iana\",\"extensions\":[\"xpr\"]},\"application/vnd.isac.fcs\":{\"source\":\"iana\",\"extensions\":[\"fcs\"]},\"application/vnd.jam\":{\"source\":\"iana\",\"extensions\":[\"jam\"]},\"application/vnd.japannet-directory-service\":{\"source\":\"iana\"},\"application/vnd.japannet-jpnstore-wakeup\":{\"source\":\"iana\"},\"application/vnd.japannet-payment-wakeup\":{\"source\":\"iana\"},\"application/vnd.japannet-registration\":{\"source\":\"iana\"},\"application/vnd.japannet-registration-wakeup\":{\"source\":\"iana\"},\"application/vnd.japannet-setstore-wakeup\":{\"source\":\"iana\"},\"application/vnd.japannet-verification\":{\"source\":\"iana\"},\"application/vnd.japannet-verification-wakeup\":{\"source\":\"iana\"},\"application/vnd.jcp.javame.midlet-rms\":{\"source\":\"iana\",\"extensions\":[\"rms\"]},\"application/vnd.jisp\":{\"source\":\"iana\",\"extensions\":[\"jisp\"]},\"application/vnd.joost.joda-archive\":{\"source\":\"iana\",\"extensions\":[\"joda\"]},\"application/vnd.jsk.isdn-ngn\":{\"source\":\"iana\"},\"application/vnd.kahootz\":{\"source\":\"iana\",\"extensions\":[\"ktz\",\"ktr\"]},\"application/vnd.kde.karbon\":{\"source\":\"iana\",\"extensions\":[\"karbon\"]},\"application/vnd.kde.kchart\":{\"source\":\"iana\",\"extensions\":[\"chrt\"]},\"application/vnd.kde.kformula\":{\"source\":\"iana\",\"extensions\":[\"kfo\"]},\"application/vnd.kde.kivio\":{\"source\":\"iana\",\"extensions\":[\"flw\"]},\"application/vnd.kde.kontour\":{\"source\":\"iana\",\"extensions\":[\"kon\"]},\"application/vnd.kde.kpresenter\":{\"source\":\"iana\",\"extensions\":[\"kpr\",\"kpt\"]},\"application/vnd.kde.kspread\":{\"source\":\"iana\",\"extensions\":[\"ksp\"]},\"application/vnd.kde.kword\":{\"source\":\"iana\",\"extensions\":[\"kwd\",\"kwt\"]},\"application/vnd.kenameaapp\":{\"source\":\"iana\",\"extensions\":[\"htke\"]},\"application/vnd.kidspiration\":{\"source\":\"iana\",\"extensions\":[\"kia\"]},\"application/vnd.kinar\":{\"source\":\"iana\",\"extensions\":[\"kne\",\"knp\"]},\"application/vnd.koan\":{\"source\":\"iana\",\"extensions\":[\"skp\",\"skd\",\"skt\",\"skm\"]},\"application/vnd.kodak-descriptor\":{\"source\":\"iana\",\"extensions\":[\"sse\"]},\"application/vnd.las.las+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.las.las+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"lasxml\"]},\"application/vnd.leap+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.liberty-request+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.llamagraphics.life-balance.desktop\":{\"source\":\"iana\",\"extensions\":[\"lbd\"]},\"application/vnd.llamagraphics.life-balance.exchange+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"lbe\"]},\"application/vnd.lotus-1-2-3\":{\"source\":\"iana\",\"extensions\":[\"123\"]},\"application/vnd.lotus-approach\":{\"source\":\"iana\",\"extensions\":[\"apr\"]},\"application/vnd.lotus-freelance\":{\"source\":\"iana\",\"extensions\":[\"pre\"]},\"application/vnd.lotus-notes\":{\"source\":\"iana\",\"extensions\":[\"nsf\"]},\"application/vnd.lotus-organizer\":{\"source\":\"iana\",\"extensions\":[\"org\"]},\"application/vnd.lotus-screencam\":{\"source\":\"iana\",\"extensions\":[\"scm\"]},\"application/vnd.lotus-wordpro\":{\"source\":\"iana\",\"extensions\":[\"lwp\"]},\"application/vnd.macports.portpkg\":{\"source\":\"iana\",\"extensions\":[\"portpkg\"]},\"application/vnd.mapbox-vector-tile\":{\"source\":\"iana\"},\"application/vnd.marlin.drm.actiontoken+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.marlin.drm.conftoken+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.marlin.drm.license+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.marlin.drm.mdcf\":{\"source\":\"iana\"},\"application/vnd.mason+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.maxmind.maxmind-db\":{\"source\":\"iana\"},\"application/vnd.mcd\":{\"source\":\"iana\",\"extensions\":[\"mcd\"]},\"application/vnd.medcalcdata\":{\"source\":\"iana\",\"extensions\":[\"mc1\"]},\"application/vnd.mediastation.cdkey\":{\"source\":\"iana\",\"extensions\":[\"cdkey\"]},\"application/vnd.meridian-slingshot\":{\"source\":\"iana\"},\"application/vnd.mfer\":{\"source\":\"iana\",\"extensions\":[\"mwf\"]},\"application/vnd.mfmp\":{\"source\":\"iana\",\"extensions\":[\"mfm\"]},\"application/vnd.micro+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.micrografx.flo\":{\"source\":\"iana\",\"extensions\":[\"flo\"]},\"application/vnd.micrografx.igx\":{\"source\":\"iana\",\"extensions\":[\"igx\"]},\"application/vnd.microsoft.portable-executable\":{\"source\":\"iana\"},\"application/vnd.microsoft.windows.thumbnail-cache\":{\"source\":\"iana\"},\"application/vnd.miele+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.mif\":{\"source\":\"iana\",\"extensions\":[\"mif\"]},\"application/vnd.minisoft-hp3000-save\":{\"source\":\"iana\"},\"application/vnd.mitsubishi.misty-guard.trustweb\":{\"source\":\"iana\"},\"application/vnd.mobius.daf\":{\"source\":\"iana\",\"extensions\":[\"daf\"]},\"application/vnd.mobius.dis\":{\"source\":\"iana\",\"extensions\":[\"dis\"]},\"application/vnd.mobius.mbk\":{\"source\":\"iana\",\"extensions\":[\"mbk\"]},\"application/vnd.mobius.mqy\":{\"source\":\"iana\",\"extensions\":[\"mqy\"]},\"application/vnd.mobius.msl\":{\"source\":\"iana\",\"extensions\":[\"msl\"]},\"application/vnd.mobius.plc\":{\"source\":\"iana\",\"extensions\":[\"plc\"]},\"application/vnd.mobius.txf\":{\"source\":\"iana\",\"extensions\":[\"txf\"]},\"application/vnd.mophun.application\":{\"source\":\"iana\",\"extensions\":[\"mpn\"]},\"application/vnd.mophun.certificate\":{\"source\":\"iana\",\"extensions\":[\"mpc\"]},\"application/vnd.motorola.flexsuite\":{\"source\":\"iana\"},\"application/vnd.motorola.flexsuite.adsi\":{\"source\":\"iana\"},\"application/vnd.motorola.flexsuite.fis\":{\"source\":\"iana\"},\"application/vnd.motorola.flexsuite.gotap\":{\"source\":\"iana\"},\"application/vnd.motorola.flexsuite.kmr\":{\"source\":\"iana\"},\"application/vnd.motorola.flexsuite.ttc\":{\"source\":\"iana\"},\"application/vnd.motorola.flexsuite.wem\":{\"source\":\"iana\"},\"application/vnd.motorola.iprm\":{\"source\":\"iana\"},\"application/vnd.mozilla.xul+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"xul\"]},\"application/vnd.ms-3mfdocument\":{\"source\":\"iana\"},\"application/vnd.ms-artgalry\":{\"source\":\"iana\",\"extensions\":[\"cil\"]},\"application/vnd.ms-asf\":{\"source\":\"iana\"},\"application/vnd.ms-cab-compressed\":{\"source\":\"iana\",\"extensions\":[\"cab\"]},\"application/vnd.ms-color.iccprofile\":{\"source\":\"apache\"},\"application/vnd.ms-excel\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"xls\",\"xlm\",\"xla\",\"xlc\",\"xlt\",\"xlw\"]},\"application/vnd.ms-excel.addin.macroenabled.12\":{\"source\":\"iana\",\"extensions\":[\"xlam\"]},\"application/vnd.ms-excel.sheet.binary.macroenabled.12\":{\"source\":\"iana\",\"extensions\":[\"xlsb\"]},\"application/vnd.ms-excel.sheet.macroenabled.12\":{\"source\":\"iana\",\"extensions\":[\"xlsm\"]},\"application/vnd.ms-excel.template.macroenabled.12\":{\"source\":\"iana\",\"extensions\":[\"xltm\"]},\"application/vnd.ms-fontobject\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"eot\"]},\"application/vnd.ms-htmlhelp\":{\"source\":\"iana\",\"extensions\":[\"chm\"]},\"application/vnd.ms-ims\":{\"source\":\"iana\",\"extensions\":[\"ims\"]},\"application/vnd.ms-lrm\":{\"source\":\"iana\",\"extensions\":[\"lrm\"]},\"application/vnd.ms-office.activex+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.ms-officetheme\":{\"source\":\"iana\",\"extensions\":[\"thmx\"]},\"application/vnd.ms-opentype\":{\"source\":\"apache\",\"compressible\":true},\"application/vnd.ms-outlook\":{\"compressible\":false,\"extensions\":[\"msg\"]},\"application/vnd.ms-package.obfuscated-opentype\":{\"source\":\"apache\"},\"application/vnd.ms-pki.seccat\":{\"source\":\"apache\",\"extensions\":[\"cat\"]},\"application/vnd.ms-pki.stl\":{\"source\":\"apache\",\"extensions\":[\"stl\"]},\"application/vnd.ms-playready.initiator+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.ms-powerpoint\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"ppt\",\"pps\",\"pot\"]},\"application/vnd.ms-powerpoint.addin.macroenabled.12\":{\"source\":\"iana\",\"extensions\":[\"ppam\"]},\"application/vnd.ms-powerpoint.presentation.macroenabled.12\":{\"source\":\"iana\",\"extensions\":[\"pptm\"]},\"application/vnd.ms-powerpoint.slide.macroenabled.12\":{\"source\":\"iana\",\"extensions\":[\"sldm\"]},\"application/vnd.ms-powerpoint.slideshow.macroenabled.12\":{\"source\":\"iana\",\"extensions\":[\"ppsm\"]},\"application/vnd.ms-powerpoint.template.macroenabled.12\":{\"source\":\"iana\",\"extensions\":[\"potm\"]},\"application/vnd.ms-printdevicecapabilities+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.ms-printing.printticket+xml\":{\"source\":\"apache\",\"compressible\":true},\"application/vnd.ms-printschematicket+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.ms-project\":{\"source\":\"iana\",\"extensions\":[\"mpp\",\"mpt\"]},\"application/vnd.ms-tnef\":{\"source\":\"iana\"},\"application/vnd.ms-windows.devicepairing\":{\"source\":\"iana\"},\"application/vnd.ms-windows.nwprinting.oob\":{\"source\":\"iana\"},\"application/vnd.ms-windows.printerpairing\":{\"source\":\"iana\"},\"application/vnd.ms-windows.wsd.oob\":{\"source\":\"iana\"},\"application/vnd.ms-wmdrm.lic-chlg-req\":{\"source\":\"iana\"},\"application/vnd.ms-wmdrm.lic-resp\":{\"source\":\"iana\"},\"application/vnd.ms-wmdrm.meter-chlg-req\":{\"source\":\"iana\"},\"application/vnd.ms-wmdrm.meter-resp\":{\"source\":\"iana\"},\"application/vnd.ms-word.document.macroenabled.12\":{\"source\":\"iana\",\"extensions\":[\"docm\"]},\"application/vnd.ms-word.template.macroenabled.12\":{\"source\":\"iana\",\"extensions\":[\"dotm\"]},\"application/vnd.ms-works\":{\"source\":\"iana\",\"extensions\":[\"wps\",\"wks\",\"wcm\",\"wdb\"]},\"application/vnd.ms-wpl\":{\"source\":\"iana\",\"extensions\":[\"wpl\"]},\"application/vnd.ms-xpsdocument\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"xps\"]},\"application/vnd.msa-disk-image\":{\"source\":\"iana\"},\"application/vnd.mseq\":{\"source\":\"iana\",\"extensions\":[\"mseq\"]},\"application/vnd.msign\":{\"source\":\"iana\"},\"application/vnd.multiad.creator\":{\"source\":\"iana\"},\"application/vnd.multiad.creator.cif\":{\"source\":\"iana\"},\"application/vnd.music-niff\":{\"source\":\"iana\"},\"application/vnd.musician\":{\"source\":\"iana\",\"extensions\":[\"mus\"]},\"application/vnd.muvee.style\":{\"source\":\"iana\",\"extensions\":[\"msty\"]},\"application/vnd.mynfc\":{\"source\":\"iana\",\"extensions\":[\"taglet\"]},\"application/vnd.ncd.control\":{\"source\":\"iana\"},\"application/vnd.ncd.reference\":{\"source\":\"iana\"},\"application/vnd.nearst.inv+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.nervana\":{\"source\":\"iana\"},\"application/vnd.netfpx\":{\"source\":\"iana\"},\"application/vnd.neurolanguage.nlu\":{\"source\":\"iana\",\"extensions\":[\"nlu\"]},\"application/vnd.nimn\":{\"source\":\"iana\"},\"application/vnd.nintendo.nitro.rom\":{\"source\":\"iana\"},\"application/vnd.nintendo.snes.rom\":{\"source\":\"iana\"},\"application/vnd.nitf\":{\"source\":\"iana\",\"extensions\":[\"ntf\",\"nitf\"]},\"application/vnd.noblenet-directory\":{\"source\":\"iana\",\"extensions\":[\"nnd\"]},\"application/vnd.noblenet-sealer\":{\"source\":\"iana\",\"extensions\":[\"nns\"]},\"application/vnd.noblenet-web\":{\"source\":\"iana\",\"extensions\":[\"nnw\"]},\"application/vnd.nokia.catalogs\":{\"source\":\"iana\"},\"application/vnd.nokia.conml+wbxml\":{\"source\":\"iana\"},\"application/vnd.nokia.conml+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.nokia.iptv.config+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.nokia.isds-radio-presets\":{\"source\":\"iana\"},\"application/vnd.nokia.landmark+wbxml\":{\"source\":\"iana\"},\"application/vnd.nokia.landmark+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.nokia.landmarkcollection+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.nokia.n-gage.ac+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.nokia.n-gage.data\":{\"source\":\"iana\",\"extensions\":[\"ngdat\"]},\"application/vnd.nokia.n-gage.symbian.install\":{\"source\":\"iana\",\"extensions\":[\"n-gage\"]},\"application/vnd.nokia.ncd\":{\"source\":\"iana\"},\"application/vnd.nokia.pcd+wbxml\":{\"source\":\"iana\"},\"application/vnd.nokia.pcd+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.nokia.radio-preset\":{\"source\":\"iana\",\"extensions\":[\"rpst\"]},\"application/vnd.nokia.radio-presets\":{\"source\":\"iana\",\"extensions\":[\"rpss\"]},\"application/vnd.novadigm.edm\":{\"source\":\"iana\",\"extensions\":[\"edm\"]},\"application/vnd.novadigm.edx\":{\"source\":\"iana\",\"extensions\":[\"edx\"]},\"application/vnd.novadigm.ext\":{\"source\":\"iana\",\"extensions\":[\"ext\"]},\"application/vnd.ntt-local.content-share\":{\"source\":\"iana\"},\"application/vnd.ntt-local.file-transfer\":{\"source\":\"iana\"},\"application/vnd.ntt-local.ogw_remote-access\":{\"source\":\"iana\"},\"application/vnd.ntt-local.sip-ta_remote\":{\"source\":\"iana\"},\"application/vnd.ntt-local.sip-ta_tcp_stream\":{\"source\":\"iana\"},\"application/vnd.oasis.opendocument.chart\":{\"source\":\"iana\",\"extensions\":[\"odc\"]},\"application/vnd.oasis.opendocument.chart-template\":{\"source\":\"iana\",\"extensions\":[\"otc\"]},\"application/vnd.oasis.opendocument.database\":{\"source\":\"iana\",\"extensions\":[\"odb\"]},\"application/vnd.oasis.opendocument.formula\":{\"source\":\"iana\",\"extensions\":[\"odf\"]},\"application/vnd.oasis.opendocument.formula-template\":{\"source\":\"iana\",\"extensions\":[\"odft\"]},\"application/vnd.oasis.opendocument.graphics\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"odg\"]},\"application/vnd.oasis.opendocument.graphics-template\":{\"source\":\"iana\",\"extensions\":[\"otg\"]},\"application/vnd.oasis.opendocument.image\":{\"source\":\"iana\",\"extensions\":[\"odi\"]},\"application/vnd.oasis.opendocument.image-template\":{\"source\":\"iana\",\"extensions\":[\"oti\"]},\"application/vnd.oasis.opendocument.presentation\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"odp\"]},\"application/vnd.oasis.opendocument.presentation-template\":{\"source\":\"iana\",\"extensions\":[\"otp\"]},\"application/vnd.oasis.opendocument.spreadsheet\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"ods\"]},\"application/vnd.oasis.opendocument.spreadsheet-template\":{\"source\":\"iana\",\"extensions\":[\"ots\"]},\"application/vnd.oasis.opendocument.text\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"odt\"]},\"application/vnd.oasis.opendocument.text-master\":{\"source\":\"iana\",\"extensions\":[\"odm\"]},\"application/vnd.oasis.opendocument.text-template\":{\"source\":\"iana\",\"extensions\":[\"ott\"]},\"application/vnd.oasis.opendocument.text-web\":{\"source\":\"iana\",\"extensions\":[\"oth\"]},\"application/vnd.obn\":{\"source\":\"iana\"},\"application/vnd.ocf+cbor\":{\"source\":\"iana\"},\"application/vnd.oftn.l10n+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oipf.contentaccessdownload+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oipf.contentaccessstreaming+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oipf.cspg-hexbinary\":{\"source\":\"iana\"},\"application/vnd.oipf.dae.svg+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oipf.dae.xhtml+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oipf.mippvcontrolmessage+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oipf.pae.gem\":{\"source\":\"iana\"},\"application/vnd.oipf.spdiscovery+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oipf.spdlist+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oipf.ueprofile+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oipf.userprofile+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.olpc-sugar\":{\"source\":\"iana\",\"extensions\":[\"xo\"]},\"application/vnd.oma-scws-config\":{\"source\":\"iana\"},\"application/vnd.oma-scws-http-request\":{\"source\":\"iana\"},\"application/vnd.oma-scws-http-response\":{\"source\":\"iana\"},\"application/vnd.oma.bcast.associated-procedure-parameter+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.bcast.drm-trigger+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.bcast.imd+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.bcast.ltkm\":{\"source\":\"iana\"},\"application/vnd.oma.bcast.notification+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.bcast.provisioningtrigger\":{\"source\":\"iana\"},\"application/vnd.oma.bcast.sgboot\":{\"source\":\"iana\"},\"application/vnd.oma.bcast.sgdd+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.bcast.sgdu\":{\"source\":\"iana\"},\"application/vnd.oma.bcast.simple-symbol-container\":{\"source\":\"iana\"},\"application/vnd.oma.bcast.smartcard-trigger+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.bcast.sprov+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.bcast.stkm\":{\"source\":\"iana\"},\"application/vnd.oma.cab-address-book+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.cab-feature-handler+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.cab-pcc+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.cab-subs-invite+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.cab-user-prefs+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.dcd\":{\"source\":\"iana\"},\"application/vnd.oma.dcdc\":{\"source\":\"iana\"},\"application/vnd.oma.dd2+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"dd2\"]},\"application/vnd.oma.drm.risd+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.group-usage-list+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.lwm2m+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.lwm2m+tlv\":{\"source\":\"iana\"},\"application/vnd.oma.pal+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.poc.detailed-progress-report+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.poc.final-report+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.poc.groups+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.poc.invocation-descriptor+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.poc.optimized-progress-report+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.push\":{\"source\":\"iana\"},\"application/vnd.oma.scidm.messages+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.xcap-directory+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.omads-email+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.omads-file+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.omads-folder+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.omaloc-supl-init\":{\"source\":\"iana\"},\"application/vnd.onepager\":{\"source\":\"iana\"},\"application/vnd.onepagertamp\":{\"source\":\"iana\"},\"application/vnd.onepagertamx\":{\"source\":\"iana\"},\"application/vnd.onepagertat\":{\"source\":\"iana\"},\"application/vnd.onepagertatp\":{\"source\":\"iana\"},\"application/vnd.onepagertatx\":{\"source\":\"iana\"},\"application/vnd.openblox.game+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openblox.game-binary\":{\"source\":\"iana\"},\"application/vnd.openeye.oeb\":{\"source\":\"iana\"},\"application/vnd.openofficeorg.extension\":{\"source\":\"apache\",\"extensions\":[\"oxt\"]},\"application/vnd.openstreetmap.data+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.custom-properties+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.customxmlproperties+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.drawing+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.drawingml.chart+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.extended-properties+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.presentationml.comments+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.presentationml.presentation\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"pptx\"]},\"application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.presentationml.presprops+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.presentationml.slide\":{\"source\":\"iana\",\"extensions\":[\"sldx\"]},\"application/vnd.openxmlformats-officedocument.presentationml.slide+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.presentationml.slideshow\":{\"source\":\"iana\",\"extensions\":[\"ppsx\"]},\"application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.presentationml.tags+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.presentationml.template\":{\"source\":\"iana\",\"extensions\":[\"potx\"]},\"application/vnd.openxmlformats-officedocument.presentationml.template.main+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"xlsx\"]},\"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.template\":{\"source\":\"iana\",\"extensions\":[\"xltx\"]},\"application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.theme+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.themeoverride+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.vmldrawing\":{\"source\":\"iana\"},\"application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.wordprocessingml.document\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"docx\"]},\"application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.wordprocessingml.template\":{\"source\":\"iana\",\"extensions\":[\"dotx\"]},\"application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-package.core-properties+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-package.relationships+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oracle.resource+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.orange.indata\":{\"source\":\"iana\"},\"application/vnd.osa.netdeploy\":{\"source\":\"iana\"},\"application/vnd.osgeo.mapguide.package\":{\"source\":\"iana\",\"extensions\":[\"mgp\"]},\"application/vnd.osgi.bundle\":{\"source\":\"iana\"},\"application/vnd.osgi.dp\":{\"source\":\"iana\",\"extensions\":[\"dp\"]},\"application/vnd.osgi.subsystem\":{\"source\":\"iana\",\"extensions\":[\"esa\"]},\"application/vnd.otps.ct-kip+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oxli.countgraph\":{\"source\":\"iana\"},\"application/vnd.pagerduty+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.palm\":{\"source\":\"iana\",\"extensions\":[\"pdb\",\"pqa\",\"oprc\"]},\"application/vnd.panoply\":{\"source\":\"iana\"},\"application/vnd.paos.xml\":{\"source\":\"iana\"},\"application/vnd.patentdive\":{\"source\":\"iana\"},\"application/vnd.patientecommsdoc\":{\"source\":\"iana\"},\"application/vnd.pawaafile\":{\"source\":\"iana\",\"extensions\":[\"paw\"]},\"application/vnd.pcos\":{\"source\":\"iana\"},\"application/vnd.pg.format\":{\"source\":\"iana\",\"extensions\":[\"str\"]},\"application/vnd.pg.osasli\":{\"source\":\"iana\",\"extensions\":[\"ei6\"]},\"application/vnd.piaccess.application-licence\":{\"source\":\"iana\"},\"application/vnd.picsel\":{\"source\":\"iana\",\"extensions\":[\"efif\"]},\"application/vnd.pmi.widget\":{\"source\":\"iana\",\"extensions\":[\"wg\"]},\"application/vnd.poc.group-advertisement+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.pocketlearn\":{\"source\":\"iana\",\"extensions\":[\"plf\"]},\"application/vnd.powerbuilder6\":{\"source\":\"iana\",\"extensions\":[\"pbd\"]},\"application/vnd.powerbuilder6-s\":{\"source\":\"iana\"},\"application/vnd.powerbuilder7\":{\"source\":\"iana\"},\"application/vnd.powerbuilder7-s\":{\"source\":\"iana\"},\"application/vnd.powerbuilder75\":{\"source\":\"iana\"},\"application/vnd.powerbuilder75-s\":{\"source\":\"iana\"},\"application/vnd.preminet\":{\"source\":\"iana\"},\"application/vnd.previewsystems.box\":{\"source\":\"iana\",\"extensions\":[\"box\"]},\"application/vnd.proteus.magazine\":{\"source\":\"iana\",\"extensions\":[\"mgz\"]},\"application/vnd.psfs\":{\"source\":\"iana\"},\"application/vnd.publishare-delta-tree\":{\"source\":\"iana\",\"extensions\":[\"qps\"]},\"application/vnd.pvi.ptid1\":{\"source\":\"iana\",\"extensions\":[\"ptid\"]},\"application/vnd.pwg-multiplexed\":{\"source\":\"iana\"},\"application/vnd.pwg-xhtml-print+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.qualcomm.brew-app-res\":{\"source\":\"iana\"},\"application/vnd.quarantainenet\":{\"source\":\"iana\"},\"application/vnd.quark.quarkxpress\":{\"source\":\"iana\",\"extensions\":[\"qxd\",\"qxt\",\"qwd\",\"qwt\",\"qxl\",\"qxb\"]},\"application/vnd.quobject-quoxdocument\":{\"source\":\"iana\"},\"application/vnd.radisys.moml+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.radisys.msml+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.radisys.msml-audit+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.radisys.msml-audit-conf+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.radisys.msml-audit-conn+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.radisys.msml-audit-dialog+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.radisys.msml-audit-stream+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.radisys.msml-conf+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.radisys.msml-dialog+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.radisys.msml-dialog-base+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.radisys.msml-dialog-fax-detect+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.radisys.msml-dialog-fax-sendrecv+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.radisys.msml-dialog-group+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.radisys.msml-dialog-speech+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.radisys.msml-dialog-transform+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.rainstor.data\":{\"source\":\"iana\"},\"application/vnd.rapid\":{\"source\":\"iana\"},\"application/vnd.rar\":{\"source\":\"iana\"},\"application/vnd.realvnc.bed\":{\"source\":\"iana\",\"extensions\":[\"bed\"]},\"application/vnd.recordare.musicxml\":{\"source\":\"iana\",\"extensions\":[\"mxl\"]},\"application/vnd.recordare.musicxml+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"musicxml\"]},\"application/vnd.renlearn.rlprint\":{\"source\":\"iana\"},\"application/vnd.restful+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.rig.cryptonote\":{\"source\":\"iana\",\"extensions\":[\"cryptonote\"]},\"application/vnd.rim.cod\":{\"source\":\"apache\",\"extensions\":[\"cod\"]},\"application/vnd.rn-realmedia\":{\"source\":\"apache\",\"extensions\":[\"rm\"]},\"application/vnd.rn-realmedia-vbr\":{\"source\":\"apache\",\"extensions\":[\"rmvb\"]},\"application/vnd.route66.link66+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"link66\"]},\"application/vnd.rs-274x\":{\"source\":\"iana\"},\"application/vnd.ruckus.download\":{\"source\":\"iana\"},\"application/vnd.s3sms\":{\"source\":\"iana\"},\"application/vnd.sailingtracker.track\":{\"source\":\"iana\",\"extensions\":[\"st\"]},\"application/vnd.sbm.cid\":{\"source\":\"iana\"},\"application/vnd.sbm.mid2\":{\"source\":\"iana\"},\"application/vnd.scribus\":{\"source\":\"iana\"},\"application/vnd.sealed.3df\":{\"source\":\"iana\"},\"application/vnd.sealed.csf\":{\"source\":\"iana\"},\"application/vnd.sealed.doc\":{\"source\":\"iana\"},\"application/vnd.sealed.eml\":{\"source\":\"iana\"},\"application/vnd.sealed.mht\":{\"source\":\"iana\"},\"application/vnd.sealed.net\":{\"source\":\"iana\"},\"application/vnd.sealed.ppt\":{\"source\":\"iana\"},\"application/vnd.sealed.tiff\":{\"source\":\"iana\"},\"application/vnd.sealed.xls\":{\"source\":\"iana\"},\"application/vnd.sealedmedia.softseal.html\":{\"source\":\"iana\"},\"application/vnd.sealedmedia.softseal.pdf\":{\"source\":\"iana\"},\"application/vnd.seemail\":{\"source\":\"iana\",\"extensions\":[\"see\"]},\"application/vnd.sema\":{\"source\":\"iana\",\"extensions\":[\"sema\"]},\"application/vnd.semd\":{\"source\":\"iana\",\"extensions\":[\"semd\"]},\"application/vnd.semf\":{\"source\":\"iana\",\"extensions\":[\"semf\"]},\"application/vnd.shana.informed.formdata\":{\"source\":\"iana\",\"extensions\":[\"ifm\"]},\"application/vnd.shana.informed.formtemplate\":{\"source\":\"iana\",\"extensions\":[\"itp\"]},\"application/vnd.shana.informed.interchange\":{\"source\":\"iana\",\"extensions\":[\"iif\"]},\"application/vnd.shana.informed.package\":{\"source\":\"iana\",\"extensions\":[\"ipk\"]},\"application/vnd.shootproof+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.sigrok.session\":{\"source\":\"iana\"},\"application/vnd.simtech-mindmapper\":{\"source\":\"iana\",\"extensions\":[\"twd\",\"twds\"]},\"application/vnd.siren+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.smaf\":{\"source\":\"iana\",\"extensions\":[\"mmf\"]},\"application/vnd.smart.notebook\":{\"source\":\"iana\"},\"application/vnd.smart.teacher\":{\"source\":\"iana\",\"extensions\":[\"teacher\"]},\"application/vnd.software602.filler.form+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.software602.filler.form-xml-zip\":{\"source\":\"iana\"},\"application/vnd.solent.sdkm+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"sdkm\",\"sdkd\"]},\"application/vnd.spotfire.dxp\":{\"source\":\"iana\",\"extensions\":[\"dxp\"]},\"application/vnd.spotfire.sfs\":{\"source\":\"iana\",\"extensions\":[\"sfs\"]},\"application/vnd.sqlite3\":{\"source\":\"iana\"},\"application/vnd.sss-cod\":{\"source\":\"iana\"},\"application/vnd.sss-dtf\":{\"source\":\"iana\"},\"application/vnd.sss-ntf\":{\"source\":\"iana\"},\"application/vnd.stardivision.calc\":{\"source\":\"apache\",\"extensions\":[\"sdc\"]},\"application/vnd.stardivision.draw\":{\"source\":\"apache\",\"extensions\":[\"sda\"]},\"application/vnd.stardivision.impress\":{\"source\":\"apache\",\"extensions\":[\"sdd\"]},\"application/vnd.stardivision.math\":{\"source\":\"apache\",\"extensions\":[\"smf\"]},\"application/vnd.stardivision.writer\":{\"source\":\"apache\",\"extensions\":[\"sdw\",\"vor\"]},\"application/vnd.stardivision.writer-global\":{\"source\":\"apache\",\"extensions\":[\"sgl\"]},\"application/vnd.stepmania.package\":{\"source\":\"iana\",\"extensions\":[\"smzip\"]},\"application/vnd.stepmania.stepchart\":{\"source\":\"iana\",\"extensions\":[\"sm\"]},\"application/vnd.street-stream\":{\"source\":\"iana\"},\"application/vnd.sun.wadl+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"wadl\"]},\"application/vnd.sun.xml.calc\":{\"source\":\"apache\",\"extensions\":[\"sxc\"]},\"application/vnd.sun.xml.calc.template\":{\"source\":\"apache\",\"extensions\":[\"stc\"]},\"application/vnd.sun.xml.draw\":{\"source\":\"apache\",\"extensions\":[\"sxd\"]},\"application/vnd.sun.xml.draw.template\":{\"source\":\"apache\",\"extensions\":[\"std\"]},\"application/vnd.sun.xml.impress\":{\"source\":\"apache\",\"extensions\":[\"sxi\"]},\"application/vnd.sun.xml.impress.template\":{\"source\":\"apache\",\"extensions\":[\"sti\"]},\"application/vnd.sun.xml.math\":{\"source\":\"apache\",\"extensions\":[\"sxm\"]},\"application/vnd.sun.xml.writer\":{\"source\":\"apache\",\"extensions\":[\"sxw\"]},\"application/vnd.sun.xml.writer.global\":{\"source\":\"apache\",\"extensions\":[\"sxg\"]},\"application/vnd.sun.xml.writer.template\":{\"source\":\"apache\",\"extensions\":[\"stw\"]},\"application/vnd.sus-calendar\":{\"source\":\"iana\",\"extensions\":[\"sus\",\"susp\"]},\"application/vnd.svd\":{\"source\":\"iana\",\"extensions\":[\"svd\"]},\"application/vnd.swiftview-ics\":{\"source\":\"iana\"},\"application/vnd.symbian.install\":{\"source\":\"apache\",\"extensions\":[\"sis\",\"sisx\"]},\"application/vnd.syncml+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"xsm\"]},\"application/vnd.syncml.dm+wbxml\":{\"source\":\"iana\",\"extensions\":[\"bdm\"]},\"application/vnd.syncml.dm+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"xdm\"]},\"application/vnd.syncml.dm.notification\":{\"source\":\"iana\"},\"application/vnd.syncml.dmddf+wbxml\":{\"source\":\"iana\"},\"application/vnd.syncml.dmddf+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.syncml.dmtnds+wbxml\":{\"source\":\"iana\"},\"application/vnd.syncml.dmtnds+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.syncml.ds.notification\":{\"source\":\"iana\"},\"application/vnd.tableschema+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.tao.intent-module-archive\":{\"source\":\"iana\",\"extensions\":[\"tao\"]},\"application/vnd.tcpdump.pcap\":{\"source\":\"iana\",\"extensions\":[\"pcap\",\"cap\",\"dmp\"]},\"application/vnd.think-cell.ppttc+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.tmd.mediaflex.api+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.tml\":{\"source\":\"iana\"},\"application/vnd.tmobile-livetv\":{\"source\":\"iana\",\"extensions\":[\"tmo\"]},\"application/vnd.tri.onesource\":{\"source\":\"iana\"},\"application/vnd.trid.tpt\":{\"source\":\"iana\",\"extensions\":[\"tpt\"]},\"application/vnd.triscape.mxs\":{\"source\":\"iana\",\"extensions\":[\"mxs\"]},\"application/vnd.trueapp\":{\"source\":\"iana\",\"extensions\":[\"tra\"]},\"application/vnd.truedoc\":{\"source\":\"iana\"},\"application/vnd.ubisoft.webplayer\":{\"source\":\"iana\"},\"application/vnd.ufdl\":{\"source\":\"iana\",\"extensions\":[\"ufd\",\"ufdl\"]},\"application/vnd.uiq.theme\":{\"source\":\"iana\",\"extensions\":[\"utz\"]},\"application/vnd.umajin\":{\"source\":\"iana\",\"extensions\":[\"umj\"]},\"application/vnd.unity\":{\"source\":\"iana\",\"extensions\":[\"unityweb\"]},\"application/vnd.uoml+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"uoml\"]},\"application/vnd.uplanet.alert\":{\"source\":\"iana\"},\"application/vnd.uplanet.alert-wbxml\":{\"source\":\"iana\"},\"application/vnd.uplanet.bearer-choice\":{\"source\":\"iana\"},\"application/vnd.uplanet.bearer-choice-wbxml\":{\"source\":\"iana\"},\"application/vnd.uplanet.cacheop\":{\"source\":\"iana\"},\"application/vnd.uplanet.cacheop-wbxml\":{\"source\":\"iana\"},\"application/vnd.uplanet.channel\":{\"source\":\"iana\"},\"application/vnd.uplanet.channel-wbxml\":{\"source\":\"iana\"},\"application/vnd.uplanet.list\":{\"source\":\"iana\"},\"application/vnd.uplanet.list-wbxml\":{\"source\":\"iana\"},\"application/vnd.uplanet.listcmd\":{\"source\":\"iana\"},\"application/vnd.uplanet.listcmd-wbxml\":{\"source\":\"iana\"},\"application/vnd.uplanet.signal\":{\"source\":\"iana\"},\"application/vnd.uri-map\":{\"source\":\"iana\"},\"application/vnd.valve.source.material\":{\"source\":\"iana\"},\"application/vnd.vcx\":{\"source\":\"iana\",\"extensions\":[\"vcx\"]},\"application/vnd.vd-study\":{\"source\":\"iana\"},\"application/vnd.vectorworks\":{\"source\":\"iana\"},\"application/vnd.vel+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.verimatrix.vcas\":{\"source\":\"iana\"},\"application/vnd.veryant.thin\":{\"source\":\"iana\"},\"application/vnd.vidsoft.vidconference\":{\"source\":\"iana\"},\"application/vnd.visio\":{\"source\":\"iana\",\"extensions\":[\"vsd\",\"vst\",\"vss\",\"vsw\"]},\"application/vnd.visionary\":{\"source\":\"iana\",\"extensions\":[\"vis\"]},\"application/vnd.vividence.scriptfile\":{\"source\":\"iana\"},\"application/vnd.vsf\":{\"source\":\"iana\",\"extensions\":[\"vsf\"]},\"application/vnd.wap.sic\":{\"source\":\"iana\"},\"application/vnd.wap.slc\":{\"source\":\"iana\"},\"application/vnd.wap.wbxml\":{\"source\":\"iana\",\"extensions\":[\"wbxml\"]},\"application/vnd.wap.wmlc\":{\"source\":\"iana\",\"extensions\":[\"wmlc\"]},\"application/vnd.wap.wmlscriptc\":{\"source\":\"iana\",\"extensions\":[\"wmlsc\"]},\"application/vnd.webturbo\":{\"source\":\"iana\",\"extensions\":[\"wtb\"]},\"application/vnd.wfa.p2p\":{\"source\":\"iana\"},\"application/vnd.wfa.wsc\":{\"source\":\"iana\"},\"application/vnd.windows.devicepairing\":{\"source\":\"iana\"},\"application/vnd.wmc\":{\"source\":\"iana\"},\"application/vnd.wmf.bootstrap\":{\"source\":\"iana\"},\"application/vnd.wolfram.mathematica\":{\"source\":\"iana\"},\"application/vnd.wolfram.mathematica.package\":{\"source\":\"iana\"},\"application/vnd.wolfram.player\":{\"source\":\"iana\",\"extensions\":[\"nbp\"]},\"application/vnd.wordperfect\":{\"source\":\"iana\",\"extensions\":[\"wpd\"]},\"application/vnd.wqd\":{\"source\":\"iana\",\"extensions\":[\"wqd\"]},\"application/vnd.wrq-hp3000-labelled\":{\"source\":\"iana\"},\"application/vnd.wt.stf\":{\"source\":\"iana\",\"extensions\":[\"stf\"]},\"application/vnd.wv.csp+wbxml\":{\"source\":\"iana\"},\"application/vnd.wv.csp+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.wv.ssp+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.xacml+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.xara\":{\"source\":\"iana\",\"extensions\":[\"xar\"]},\"application/vnd.xfdl\":{\"source\":\"iana\",\"extensions\":[\"xfdl\"]},\"application/vnd.xfdl.webform\":{\"source\":\"iana\"},\"application/vnd.xmi+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.xmpie.cpkg\":{\"source\":\"iana\"},\"application/vnd.xmpie.dpkg\":{\"source\":\"iana\"},\"application/vnd.xmpie.plan\":{\"source\":\"iana\"},\"application/vnd.xmpie.ppkg\":{\"source\":\"iana\"},\"application/vnd.xmpie.xlim\":{\"source\":\"iana\"},\"application/vnd.yamaha.hv-dic\":{\"source\":\"iana\",\"extensions\":[\"hvd\"]},\"application/vnd.yamaha.hv-script\":{\"source\":\"iana\",\"extensions\":[\"hvs\"]},\"application/vnd.yamaha.hv-voice\":{\"source\":\"iana\",\"extensions\":[\"hvp\"]},\"application/vnd.yamaha.openscoreformat\":{\"source\":\"iana\",\"extensions\":[\"osf\"]},\"application/vnd.yamaha.openscoreformat.osfpvg+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"osfpvg\"]},\"application/vnd.yamaha.remote-setup\":{\"source\":\"iana\"},\"application/vnd.yamaha.smaf-audio\":{\"source\":\"iana\",\"extensions\":[\"saf\"]},\"application/vnd.yamaha.smaf-phrase\":{\"source\":\"iana\",\"extensions\":[\"spf\"]},\"application/vnd.yamaha.through-ngn\":{\"source\":\"iana\"},\"application/vnd.yamaha.tunnel-udpencap\":{\"source\":\"iana\"},\"application/vnd.yaoweme\":{\"source\":\"iana\"},\"application/vnd.yellowriver-custom-menu\":{\"source\":\"iana\",\"extensions\":[\"cmp\"]},\"application/vnd.youtube.yt\":{\"source\":\"iana\"},\"application/vnd.zul\":{\"source\":\"iana\",\"extensions\":[\"zir\",\"zirz\"]},\"application/vnd.zzazz.deck+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"zaz\"]},\"application/voicexml+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"vxml\"]},\"application/voucher-cms+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vq-rtcpxr\":{\"source\":\"iana\"},\"application/wasm\":{\"compressible\":true,\"extensions\":[\"wasm\"]},\"application/watcherinfo+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/webpush-options+json\":{\"source\":\"iana\",\"compressible\":true},\"application/whoispp-query\":{\"source\":\"iana\"},\"application/whoispp-response\":{\"source\":\"iana\"},\"application/widget\":{\"source\":\"iana\",\"extensions\":[\"wgt\"]},\"application/winhlp\":{\"source\":\"apache\",\"extensions\":[\"hlp\"]},\"application/wita\":{\"source\":\"iana\"},\"application/wordperfect5.1\":{\"source\":\"iana\"},\"application/wsdl+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"wsdl\"]},\"application/wspolicy+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"wspolicy\"]},\"application/x-7z-compressed\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"7z\"]},\"application/x-abiword\":{\"source\":\"apache\",\"extensions\":[\"abw\"]},\"application/x-ace-compressed\":{\"source\":\"apache\",\"extensions\":[\"ace\"]},\"application/x-amf\":{\"source\":\"apache\"},\"application/x-apple-diskimage\":{\"source\":\"apache\",\"extensions\":[\"dmg\"]},\"application/x-arj\":{\"compressible\":false,\"extensions\":[\"arj\"]},\"application/x-authorware-bin\":{\"source\":\"apache\",\"extensions\":[\"aab\",\"x32\",\"u32\",\"vox\"]},\"application/x-authorware-map\":{\"source\":\"apache\",\"extensions\":[\"aam\"]},\"application/x-authorware-seg\":{\"source\":\"apache\",\"extensions\":[\"aas\"]},\"application/x-bcpio\":{\"source\":\"apache\",\"extensions\":[\"bcpio\"]},\"application/x-bdoc\":{\"compressible\":false,\"extensions\":[\"bdoc\"]},\"application/x-bittorrent\":{\"source\":\"apache\",\"extensions\":[\"torrent\"]},\"application/x-blorb\":{\"source\":\"apache\",\"extensions\":[\"blb\",\"blorb\"]},\"application/x-bzip\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"bz\"]},\"application/x-bzip2\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"bz2\",\"boz\"]},\"application/x-cbr\":{\"source\":\"apache\",\"extensions\":[\"cbr\",\"cba\",\"cbt\",\"cbz\",\"cb7\"]},\"application/x-cdlink\":{\"source\":\"apache\",\"extensions\":[\"vcd\"]},\"application/x-cfs-compressed\":{\"source\":\"apache\",\"extensions\":[\"cfs\"]},\"application/x-chat\":{\"source\":\"apache\",\"extensions\":[\"chat\"]},\"application/x-chess-pgn\":{\"source\":\"apache\",\"extensions\":[\"pgn\"]},\"application/x-chrome-extension\":{\"extensions\":[\"crx\"]},\"application/x-cocoa\":{\"source\":\"nginx\",\"extensions\":[\"cco\"]},\"application/x-compress\":{\"source\":\"apache\"},\"application/x-conference\":{\"source\":\"apache\",\"extensions\":[\"nsc\"]},\"application/x-cpio\":{\"source\":\"apache\",\"extensions\":[\"cpio\"]},\"application/x-csh\":{\"source\":\"apache\",\"extensions\":[\"csh\"]},\"application/x-deb\":{\"compressible\":false},\"application/x-debian-package\":{\"source\":\"apache\",\"extensions\":[\"deb\",\"udeb\"]},\"application/x-dgc-compressed\":{\"source\":\"apache\",\"extensions\":[\"dgc\"]},\"application/x-director\":{\"source\":\"apache\",\"extensions\":[\"dir\",\"dcr\",\"dxr\",\"cst\",\"cct\",\"cxt\",\"w3d\",\"fgd\",\"swa\"]},\"application/x-doom\":{\"source\":\"apache\",\"extensions\":[\"wad\"]},\"application/x-dtbncx+xml\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"ncx\"]},\"application/x-dtbook+xml\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"dtb\"]},\"application/x-dtbresource+xml\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"res\"]},\"application/x-dvi\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"dvi\"]},\"application/x-envoy\":{\"source\":\"apache\",\"extensions\":[\"evy\"]},\"application/x-eva\":{\"source\":\"apache\",\"extensions\":[\"eva\"]},\"application/x-font-bdf\":{\"source\":\"apache\",\"extensions\":[\"bdf\"]},\"application/x-font-dos\":{\"source\":\"apache\"},\"application/x-font-framemaker\":{\"source\":\"apache\"},\"application/x-font-ghostscript\":{\"source\":\"apache\",\"extensions\":[\"gsf\"]},\"application/x-font-libgrx\":{\"source\":\"apache\"},\"application/x-font-linux-psf\":{\"source\":\"apache\",\"extensions\":[\"psf\"]},\"application/x-font-pcf\":{\"source\":\"apache\",\"extensions\":[\"pcf\"]},\"application/x-font-snf\":{\"source\":\"apache\",\"extensions\":[\"snf\"]},\"application/x-font-speedo\":{\"source\":\"apache\"},\"application/x-font-sunos-news\":{\"source\":\"apache\"},\"application/x-font-type1\":{\"source\":\"apache\",\"extensions\":[\"pfa\",\"pfb\",\"pfm\",\"afm\"]},\"application/x-font-vfont\":{\"source\":\"apache\"},\"application/x-freearc\":{\"source\":\"apache\",\"extensions\":[\"arc\"]},\"application/x-futuresplash\":{\"source\":\"apache\",\"extensions\":[\"spl\"]},\"application/x-gca-compressed\":{\"source\":\"apache\",\"extensions\":[\"gca\"]},\"application/x-glulx\":{\"source\":\"apache\",\"extensions\":[\"ulx\"]},\"application/x-gnumeric\":{\"source\":\"apache\",\"extensions\":[\"gnumeric\"]},\"application/x-gramps-xml\":{\"source\":\"apache\",\"extensions\":[\"gramps\"]},\"application/x-gtar\":{\"source\":\"apache\",\"extensions\":[\"gtar\"]},\"application/x-gzip\":{\"source\":\"apache\"},\"application/x-hdf\":{\"source\":\"apache\",\"extensions\":[\"hdf\"]},\"application/x-httpd-php\":{\"compressible\":true,\"extensions\":[\"php\"]},\"application/x-install-instructions\":{\"source\":\"apache\",\"extensions\":[\"install\"]},\"application/x-iso9660-image\":{\"source\":\"apache\",\"extensions\":[\"iso\"]},\"application/x-java-archive-diff\":{\"source\":\"nginx\",\"extensions\":[\"jardiff\"]},\"application/x-java-jnlp-file\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"jnlp\"]},\"application/x-javascript\":{\"compressible\":true},\"application/x-latex\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"latex\"]},\"application/x-lua-bytecode\":{\"extensions\":[\"luac\"]},\"application/x-lzh-compressed\":{\"source\":\"apache\",\"extensions\":[\"lzh\",\"lha\"]},\"application/x-makeself\":{\"source\":\"nginx\",\"extensions\":[\"run\"]},\"application/x-mie\":{\"source\":\"apache\",\"extensions\":[\"mie\"]},\"application/x-mobipocket-ebook\":{\"source\":\"apache\",\"extensions\":[\"prc\",\"mobi\"]},\"application/x-mpegurl\":{\"compressible\":false},\"application/x-ms-application\":{\"source\":\"apache\",\"extensions\":[\"application\"]},\"application/x-ms-shortcut\":{\"source\":\"apache\",\"extensions\":[\"lnk\"]},\"application/x-ms-wmd\":{\"source\":\"apache\",\"extensions\":[\"wmd\"]},\"application/x-ms-wmz\":{\"source\":\"apache\",\"extensions\":[\"wmz\"]},\"application/x-ms-xbap\":{\"source\":\"apache\",\"extensions\":[\"xbap\"]},\"application/x-msaccess\":{\"source\":\"apache\",\"extensions\":[\"mdb\"]},\"application/x-msbinder\":{\"source\":\"apache\",\"extensions\":[\"obd\"]},\"application/x-mscardfile\":{\"source\":\"apache\",\"extensions\":[\"crd\"]},\"application/x-msclip\":{\"source\":\"apache\",\"extensions\":[\"clp\"]},\"application/x-msdos-program\":{\"extensions\":[\"exe\"]},\"application/x-msdownload\":{\"source\":\"apache\",\"extensions\":[\"exe\",\"dll\",\"com\",\"bat\",\"msi\"]},\"application/x-msmediaview\":{\"source\":\"apache\",\"extensions\":[\"mvb\",\"m13\",\"m14\"]},\"application/x-msmetafile\":{\"source\":\"apache\",\"extensions\":[\"wmf\",\"wmz\",\"emf\",\"emz\"]},\"application/x-msmoney\":{\"source\":\"apache\",\"extensions\":[\"mny\"]},\"application/x-mspublisher\":{\"source\":\"apache\",\"extensions\":[\"pub\"]},\"application/x-msschedule\":{\"source\":\"apache\",\"extensions\":[\"scd\"]},\"application/x-msterminal\":{\"source\":\"apache\",\"extensions\":[\"trm\"]},\"application/x-mswrite\":{\"source\":\"apache\",\"extensions\":[\"wri\"]},\"application/x-netcdf\":{\"source\":\"apache\",\"extensions\":[\"nc\",\"cdf\"]},\"application/x-ns-proxy-autoconfig\":{\"compressible\":true,\"extensions\":[\"pac\"]},\"application/x-nzb\":{\"source\":\"apache\",\"extensions\":[\"nzb\"]},\"application/x-perl\":{\"source\":\"nginx\",\"extensions\":[\"pl\",\"pm\"]},\"application/x-pilot\":{\"source\":\"nginx\",\"extensions\":[\"prc\",\"pdb\"]},\"application/x-pkcs12\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"p12\",\"pfx\"]},\"application/x-pkcs7-certificates\":{\"source\":\"apache\",\"extensions\":[\"p7b\",\"spc\"]},\"application/x-pkcs7-certreqresp\":{\"source\":\"apache\",\"extensions\":[\"p7r\"]},\"application/x-rar-compressed\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"rar\"]},\"application/x-redhat-package-manager\":{\"source\":\"nginx\",\"extensions\":[\"rpm\"]},\"application/x-research-info-systems\":{\"source\":\"apache\",\"extensions\":[\"ris\"]},\"application/x-sea\":{\"source\":\"nginx\",\"extensions\":[\"sea\"]},\"application/x-sh\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"sh\"]},\"application/x-shar\":{\"source\":\"apache\",\"extensions\":[\"shar\"]},\"application/x-shockwave-flash\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"swf\"]},\"application/x-silverlight-app\":{\"source\":\"apache\",\"extensions\":[\"xap\"]},\"application/x-sql\":{\"source\":\"apache\",\"extensions\":[\"sql\"]},\"application/x-stuffit\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"sit\"]},\"application/x-stuffitx\":{\"source\":\"apache\",\"extensions\":[\"sitx\"]},\"application/x-subrip\":{\"source\":\"apache\",\"extensions\":[\"srt\"]},\"application/x-sv4cpio\":{\"source\":\"apache\",\"extensions\":[\"sv4cpio\"]},\"application/x-sv4crc\":{\"source\":\"apache\",\"extensions\":[\"sv4crc\"]},\"application/x-t3vm-image\":{\"source\":\"apache\",\"extensions\":[\"t3\"]},\"application/x-tads\":{\"source\":\"apache\",\"extensions\":[\"gam\"]},\"application/x-tar\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"tar\"]},\"application/x-tcl\":{\"source\":\"apache\",\"extensions\":[\"tcl\",\"tk\"]},\"application/x-tex\":{\"source\":\"apache\",\"extensions\":[\"tex\"]},\"application/x-tex-tfm\":{\"source\":\"apache\",\"extensions\":[\"tfm\"]},\"application/x-texinfo\":{\"source\":\"apache\",\"extensions\":[\"texinfo\",\"texi\"]},\"application/x-tgif\":{\"source\":\"apache\",\"extensions\":[\"obj\"]},\"application/x-ustar\":{\"source\":\"apache\",\"extensions\":[\"ustar\"]},\"application/x-virtualbox-hdd\":{\"compressible\":true,\"extensions\":[\"hdd\"]},\"application/x-virtualbox-ova\":{\"compressible\":true,\"extensions\":[\"ova\"]},\"application/x-virtualbox-ovf\":{\"compressible\":true,\"extensions\":[\"ovf\"]},\"application/x-virtualbox-vbox\":{\"compressible\":true,\"extensions\":[\"vbox\"]},\"application/x-virtualbox-vbox-extpack\":{\"compressible\":false,\"extensions\":[\"vbox-extpack\"]},\"application/x-virtualbox-vdi\":{\"compressible\":true,\"extensions\":[\"vdi\"]},\"application/x-virtualbox-vhd\":{\"compressible\":true,\"extensions\":[\"vhd\"]},\"application/x-virtualbox-vmdk\":{\"compressible\":true,\"extensions\":[\"vmdk\"]},\"application/x-wais-source\":{\"source\":\"apache\",\"extensions\":[\"src\"]},\"application/x-web-app-manifest+json\":{\"compressible\":true,\"extensions\":[\"webapp\"]},\"application/x-www-form-urlencoded\":{\"source\":\"iana\",\"compressible\":true},\"application/x-x509-ca-cert\":{\"source\":\"apache\",\"extensions\":[\"der\",\"crt\",\"pem\"]},\"application/x-xfig\":{\"source\":\"apache\",\"extensions\":[\"fig\"]},\"application/x-xliff+xml\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"xlf\"]},\"application/x-xpinstall\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"xpi\"]},\"application/x-xz\":{\"source\":\"apache\",\"extensions\":[\"xz\"]},\"application/x-zmachine\":{\"source\":\"apache\",\"extensions\":[\"z1\",\"z2\",\"z3\",\"z4\",\"z5\",\"z6\",\"z7\",\"z8\"]},\"application/x400-bp\":{\"source\":\"iana\"},\"application/xacml+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/xaml+xml\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"xaml\"]},\"application/xcap-att+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/xcap-caps+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/xcap-diff+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"xdf\"]},\"application/xcap-el+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/xcap-error+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/xcap-ns+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/xcon-conference-info+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/xcon-conference-info-diff+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/xenc+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"xenc\"]},\"application/xhtml+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"xhtml\",\"xht\"]},\"application/xhtml-voice+xml\":{\"source\":\"apache\",\"compressible\":true},\"application/xliff+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"xml\",\"xsl\",\"xsd\",\"rng\"]},\"application/xml-dtd\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"dtd\"]},\"application/xml-external-parsed-entity\":{\"source\":\"iana\"},\"application/xml-patch+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/xmpp+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/xop+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"xop\"]},\"application/xproc+xml\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"xpl\"]},\"application/xslt+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"xslt\"]},\"application/xspf+xml\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"xspf\"]},\"application/xv+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"mxml\",\"xhvml\",\"xvml\",\"xvm\"]},\"application/yang\":{\"source\":\"iana\",\"extensions\":[\"yang\"]},\"application/yang-data+json\":{\"source\":\"iana\",\"compressible\":true},\"application/yang-data+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/yang-patch+json\":{\"source\":\"iana\",\"compressible\":true},\"application/yang-patch+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/yin+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"yin\"]},\"application/zip\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"zip\"]},\"application/zlib\":{\"source\":\"iana\"},\"application/zstd\":{\"source\":\"iana\"},\"audio/1d-interleaved-parityfec\":{\"source\":\"iana\"},\"audio/32kadpcm\":{\"source\":\"iana\"},\"audio/3gpp\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"3gpp\"]},\"audio/3gpp2\":{\"source\":\"iana\"},\"audio/aac\":{\"source\":\"iana\"},\"audio/ac3\":{\"source\":\"iana\"},\"audio/adpcm\":{\"source\":\"apache\",\"extensions\":[\"adp\"]},\"audio/amr\":{\"source\":\"iana\"},\"audio/amr-wb\":{\"source\":\"iana\"},\"audio/amr-wb+\":{\"source\":\"iana\"},\"audio/aptx\":{\"source\":\"iana\"},\"audio/asc\":{\"source\":\"iana\"},\"audio/atrac-advanced-lossless\":{\"source\":\"iana\"},\"audio/atrac-x\":{\"source\":\"iana\"},\"audio/atrac3\":{\"source\":\"iana\"},\"audio/basic\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"au\",\"snd\"]},\"audio/bv16\":{\"source\":\"iana\"},\"audio/bv32\":{\"source\":\"iana\"},\"audio/clearmode\":{\"source\":\"iana\"},\"audio/cn\":{\"source\":\"iana\"},\"audio/dat12\":{\"source\":\"iana\"},\"audio/dls\":{\"source\":\"iana\"},\"audio/dsr-es201108\":{\"source\":\"iana\"},\"audio/dsr-es202050\":{\"source\":\"iana\"},\"audio/dsr-es202211\":{\"source\":\"iana\"},\"audio/dsr-es202212\":{\"source\":\"iana\"},\"audio/dv\":{\"source\":\"iana\"},\"audio/dvi4\":{\"source\":\"iana\"},\"audio/eac3\":{\"source\":\"iana\"},\"audio/encaprtp\":{\"source\":\"iana\"},\"audio/evrc\":{\"source\":\"iana\"},\"audio/evrc-qcp\":{\"source\":\"iana\"},\"audio/evrc0\":{\"source\":\"iana\"},\"audio/evrc1\":{\"source\":\"iana\"},\"audio/evrcb\":{\"source\":\"iana\"},\"audio/evrcb0\":{\"source\":\"iana\"},\"audio/evrcb1\":{\"source\":\"iana\"},\"audio/evrcnw\":{\"source\":\"iana\"},\"audio/evrcnw0\":{\"source\":\"iana\"},\"audio/evrcnw1\":{\"source\":\"iana\"},\"audio/evrcwb\":{\"source\":\"iana\"},\"audio/evrcwb0\":{\"source\":\"iana\"},\"audio/evrcwb1\":{\"source\":\"iana\"},\"audio/evs\":{\"source\":\"iana\"},\"audio/fwdred\":{\"source\":\"iana\"},\"audio/g711-0\":{\"source\":\"iana\"},\"audio/g719\":{\"source\":\"iana\"},\"audio/g722\":{\"source\":\"iana\"},\"audio/g7221\":{\"source\":\"iana\"},\"audio/g723\":{\"source\":\"iana\"},\"audio/g726-16\":{\"source\":\"iana\"},\"audio/g726-24\":{\"source\":\"iana\"},\"audio/g726-32\":{\"source\":\"iana\"},\"audio/g726-40\":{\"source\":\"iana\"},\"audio/g728\":{\"source\":\"iana\"},\"audio/g729\":{\"source\":\"iana\"},\"audio/g7291\":{\"source\":\"iana\"},\"audio/g729d\":{\"source\":\"iana\"},\"audio/g729e\":{\"source\":\"iana\"},\"audio/gsm\":{\"source\":\"iana\"},\"audio/gsm-efr\":{\"source\":\"iana\"},\"audio/gsm-hr-08\":{\"source\":\"iana\"},\"audio/ilbc\":{\"source\":\"iana\"},\"audio/ip-mr_v2.5\":{\"source\":\"iana\"},\"audio/isac\":{\"source\":\"apache\"},\"audio/l16\":{\"source\":\"iana\"},\"audio/l20\":{\"source\":\"iana\"},\"audio/l24\":{\"source\":\"iana\",\"compressible\":false},\"audio/l8\":{\"source\":\"iana\"},\"audio/lpc\":{\"source\":\"iana\"},\"audio/melp\":{\"source\":\"iana\"},\"audio/melp1200\":{\"source\":\"iana\"},\"audio/melp2400\":{\"source\":\"iana\"},\"audio/melp600\":{\"source\":\"iana\"},\"audio/midi\":{\"source\":\"apache\",\"extensions\":[\"mid\",\"midi\",\"kar\",\"rmi\"]},\"audio/mobile-xmf\":{\"source\":\"iana\"},\"audio/mp3\":{\"compressible\":false,\"extensions\":[\"mp3\"]},\"audio/mp4\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"m4a\",\"mp4a\"]},\"audio/mp4a-latm\":{\"source\":\"iana\"},\"audio/mpa\":{\"source\":\"iana\"},\"audio/mpa-robust\":{\"source\":\"iana\"},\"audio/mpeg\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"mpga\",\"mp2\",\"mp2a\",\"mp3\",\"m2a\",\"m3a\"]},\"audio/mpeg4-generic\":{\"source\":\"iana\"},\"audio/musepack\":{\"source\":\"apache\"},\"audio/ogg\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"oga\",\"ogg\",\"spx\"]},\"audio/opus\":{\"source\":\"iana\"},\"audio/parityfec\":{\"source\":\"iana\"},\"audio/pcma\":{\"source\":\"iana\"},\"audio/pcma-wb\":{\"source\":\"iana\"},\"audio/pcmu\":{\"source\":\"iana\"},\"audio/pcmu-wb\":{\"source\":\"iana\"},\"audio/prs.sid\":{\"source\":\"iana\"},\"audio/qcelp\":{\"source\":\"iana\"},\"audio/raptorfec\":{\"source\":\"iana\"},\"audio/red\":{\"source\":\"iana\"},\"audio/rtp-enc-aescm128\":{\"source\":\"iana\"},\"audio/rtp-midi\":{\"source\":\"iana\"},\"audio/rtploopback\":{\"source\":\"iana\"},\"audio/rtx\":{\"source\":\"iana\"},\"audio/s3m\":{\"source\":\"apache\",\"extensions\":[\"s3m\"]},\"audio/silk\":{\"source\":\"apache\",\"extensions\":[\"sil\"]},\"audio/smv\":{\"source\":\"iana\"},\"audio/smv-qcp\":{\"source\":\"iana\"},\"audio/smv0\":{\"source\":\"iana\"},\"audio/sp-midi\":{\"source\":\"iana\"},\"audio/speex\":{\"source\":\"iana\"},\"audio/t140c\":{\"source\":\"iana\"},\"audio/t38\":{\"source\":\"iana\"},\"audio/telephone-event\":{\"source\":\"iana\"},\"audio/tetra_acelp\":{\"source\":\"iana\"},\"audio/tone\":{\"source\":\"iana\"},\"audio/uemclip\":{\"source\":\"iana\"},\"audio/ulpfec\":{\"source\":\"iana\"},\"audio/usac\":{\"source\":\"iana\"},\"audio/vdvi\":{\"source\":\"iana\"},\"audio/vmr-wb\":{\"source\":\"iana\"},\"audio/vnd.3gpp.iufp\":{\"source\":\"iana\"},\"audio/vnd.4sb\":{\"source\":\"iana\"},\"audio/vnd.audiokoz\":{\"source\":\"iana\"},\"audio/vnd.celp\":{\"source\":\"iana\"},\"audio/vnd.cisco.nse\":{\"source\":\"iana\"},\"audio/vnd.cmles.radio-events\":{\"source\":\"iana\"},\"audio/vnd.cns.anp1\":{\"source\":\"iana\"},\"audio/vnd.cns.inf1\":{\"source\":\"iana\"},\"audio/vnd.dece.audio\":{\"source\":\"iana\",\"extensions\":[\"uva\",\"uvva\"]},\"audio/vnd.digital-winds\":{\"source\":\"iana\",\"extensions\":[\"eol\"]},\"audio/vnd.dlna.adts\":{\"source\":\"iana\"},\"audio/vnd.dolby.heaac.1\":{\"source\":\"iana\"},\"audio/vnd.dolby.heaac.2\":{\"source\":\"iana\"},\"audio/vnd.dolby.mlp\":{\"source\":\"iana\"},\"audio/vnd.dolby.mps\":{\"source\":\"iana\"},\"audio/vnd.dolby.pl2\":{\"source\":\"iana\"},\"audio/vnd.dolby.pl2x\":{\"source\":\"iana\"},\"audio/vnd.dolby.pl2z\":{\"source\":\"iana\"},\"audio/vnd.dolby.pulse.1\":{\"source\":\"iana\"},\"audio/vnd.dra\":{\"source\":\"iana\",\"extensions\":[\"dra\"]},\"audio/vnd.dts\":{\"source\":\"iana\",\"extensions\":[\"dts\"]},\"audio/vnd.dts.hd\":{\"source\":\"iana\",\"extensions\":[\"dtshd\"]},\"audio/vnd.dts.uhd\":{\"source\":\"iana\"},\"audio/vnd.dvb.file\":{\"source\":\"iana\"},\"audio/vnd.everad.plj\":{\"source\":\"iana\"},\"audio/vnd.hns.audio\":{\"source\":\"iana\"},\"audio/vnd.lucent.voice\":{\"source\":\"iana\",\"extensions\":[\"lvp\"]},\"audio/vnd.ms-playready.media.pya\":{\"source\":\"iana\",\"extensions\":[\"pya\"]},\"audio/vnd.nokia.mobile-xmf\":{\"source\":\"iana\"},\"audio/vnd.nortel.vbk\":{\"source\":\"iana\"},\"audio/vnd.nuera.ecelp4800\":{\"source\":\"iana\",\"extensions\":[\"ecelp4800\"]},\"audio/vnd.nuera.ecelp7470\":{\"source\":\"iana\",\"extensions\":[\"ecelp7470\"]},\"audio/vnd.nuera.ecelp9600\":{\"source\":\"iana\",\"extensions\":[\"ecelp9600\"]},\"audio/vnd.octel.sbc\":{\"source\":\"iana\"},\"audio/vnd.presonus.multitrack\":{\"source\":\"iana\"},\"audio/vnd.qcelp\":{\"source\":\"iana\"},\"audio/vnd.rhetorex.32kadpcm\":{\"source\":\"iana\"},\"audio/vnd.rip\":{\"source\":\"iana\",\"extensions\":[\"rip\"]},\"audio/vnd.rn-realaudio\":{\"compressible\":false},\"audio/vnd.sealedmedia.softseal.mpeg\":{\"source\":\"iana\"},\"audio/vnd.vmx.cvsd\":{\"source\":\"iana\"},\"audio/vnd.wave\":{\"compressible\":false},\"audio/vorbis\":{\"source\":\"iana\",\"compressible\":false},\"audio/vorbis-config\":{\"source\":\"iana\"},\"audio/wav\":{\"compressible\":false,\"extensions\":[\"wav\"]},\"audio/wave\":{\"compressible\":false,\"extensions\":[\"wav\"]},\"audio/webm\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"weba\"]},\"audio/x-aac\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"aac\"]},\"audio/x-aiff\":{\"source\":\"apache\",\"extensions\":[\"aif\",\"aiff\",\"aifc\"]},\"audio/x-caf\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"caf\"]},\"audio/x-flac\":{\"source\":\"apache\",\"extensions\":[\"flac\"]},\"audio/x-m4a\":{\"source\":\"nginx\",\"extensions\":[\"m4a\"]},\"audio/x-matroska\":{\"source\":\"apache\",\"extensions\":[\"mka\"]},\"audio/x-mpegurl\":{\"source\":\"apache\",\"extensions\":[\"m3u\"]},\"audio/x-ms-wax\":{\"source\":\"apache\",\"extensions\":[\"wax\"]},\"audio/x-ms-wma\":{\"source\":\"apache\",\"extensions\":[\"wma\"]},\"audio/x-pn-realaudio\":{\"source\":\"apache\",\"extensions\":[\"ram\",\"ra\"]},\"audio/x-pn-realaudio-plugin\":{\"source\":\"apache\",\"extensions\":[\"rmp\"]},\"audio/x-realaudio\":{\"source\":\"nginx\",\"extensions\":[\"ra\"]},\"audio/x-tta\":{\"source\":\"apache\"},\"audio/x-wav\":{\"source\":\"apache\",\"extensions\":[\"wav\"]},\"audio/xm\":{\"source\":\"apache\",\"extensions\":[\"xm\"]},\"chemical/x-cdx\":{\"source\":\"apache\",\"extensions\":[\"cdx\"]},\"chemical/x-cif\":{\"source\":\"apache\",\"extensions\":[\"cif\"]},\"chemical/x-cmdf\":{\"source\":\"apache\",\"extensions\":[\"cmdf\"]},\"chemical/x-cml\":{\"source\":\"apache\",\"extensions\":[\"cml\"]},\"chemical/x-csml\":{\"source\":\"apache\",\"extensions\":[\"csml\"]},\"chemical/x-pdb\":{\"source\":\"apache\"},\"chemical/x-xyz\":{\"source\":\"apache\",\"extensions\":[\"xyz\"]},\"font/collection\":{\"source\":\"iana\",\"extensions\":[\"ttc\"]},\"font/otf\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"otf\"]},\"font/sfnt\":{\"source\":\"iana\"},\"font/ttf\":{\"source\":\"iana\",\"extensions\":[\"ttf\"]},\"font/woff\":{\"source\":\"iana\",\"extensions\":[\"woff\"]},\"font/woff2\":{\"source\":\"iana\",\"extensions\":[\"woff2\"]},\"image/aces\":{\"source\":\"iana\",\"extensions\":[\"exr\"]},\"image/apng\":{\"compressible\":false,\"extensions\":[\"apng\"]},\"image/avci\":{\"source\":\"iana\"},\"image/avcs\":{\"source\":\"iana\"},\"image/bmp\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"bmp\"]},\"image/cgm\":{\"source\":\"iana\",\"extensions\":[\"cgm\"]},\"image/dicom-rle\":{\"source\":\"iana\",\"extensions\":[\"drle\"]},\"image/emf\":{\"source\":\"iana\",\"extensions\":[\"emf\"]},\"image/fits\":{\"source\":\"iana\",\"extensions\":[\"fits\"]},\"image/g3fax\":{\"source\":\"iana\",\"extensions\":[\"g3\"]},\"image/gif\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"gif\"]},\"image/heic\":{\"source\":\"iana\",\"extensions\":[\"heic\"]},\"image/heic-sequence\":{\"source\":\"iana\",\"extensions\":[\"heics\"]},\"image/heif\":{\"source\":\"iana\",\"extensions\":[\"heif\"]},\"image/heif-sequence\":{\"source\":\"iana\",\"extensions\":[\"heifs\"]},\"image/ief\":{\"source\":\"iana\",\"extensions\":[\"ief\"]},\"image/jls\":{\"source\":\"iana\",\"extensions\":[\"jls\"]},\"image/jp2\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"jp2\",\"jpg2\"]},\"image/jpeg\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"jpeg\",\"jpg\",\"jpe\"]},\"image/jpm\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"jpm\"]},\"image/jpx\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"jpx\",\"jpf\"]},\"image/jxr\":{\"source\":\"iana\",\"extensions\":[\"jxr\"]},\"image/ktx\":{\"source\":\"iana\",\"extensions\":[\"ktx\"]},\"image/naplps\":{\"source\":\"iana\"},\"image/pjpeg\":{\"compressible\":false},\"image/png\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"png\"]},\"image/prs.btif\":{\"source\":\"iana\",\"extensions\":[\"btif\"]},\"image/prs.pti\":{\"source\":\"iana\",\"extensions\":[\"pti\"]},\"image/pwg-raster\":{\"source\":\"iana\"},\"image/sgi\":{\"source\":\"apache\",\"extensions\":[\"sgi\"]},\"image/svg+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"svg\",\"svgz\"]},\"image/t38\":{\"source\":\"iana\",\"extensions\":[\"t38\"]},\"image/tiff\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"tif\",\"tiff\"]},\"image/tiff-fx\":{\"source\":\"iana\",\"extensions\":[\"tfx\"]},\"image/vnd.adobe.photoshop\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"psd\"]},\"image/vnd.airzip.accelerator.azv\":{\"source\":\"iana\",\"extensions\":[\"azv\"]},\"image/vnd.cns.inf2\":{\"source\":\"iana\"},\"image/vnd.dece.graphic\":{\"source\":\"iana\",\"extensions\":[\"uvi\",\"uvvi\",\"uvg\",\"uvvg\"]},\"image/vnd.djvu\":{\"source\":\"iana\",\"extensions\":[\"djvu\",\"djv\"]},\"image/vnd.dvb.subtitle\":{\"source\":\"iana\",\"extensions\":[\"sub\"]},\"image/vnd.dwg\":{\"source\":\"iana\",\"extensions\":[\"dwg\"]},\"image/vnd.dxf\":{\"source\":\"iana\",\"extensions\":[\"dxf\"]},\"image/vnd.fastbidsheet\":{\"source\":\"iana\",\"extensions\":[\"fbs\"]},\"image/vnd.fpx\":{\"source\":\"iana\",\"extensions\":[\"fpx\"]},\"image/vnd.fst\":{\"source\":\"iana\",\"extensions\":[\"fst\"]},\"image/vnd.fujixerox.edmics-mmr\":{\"source\":\"iana\",\"extensions\":[\"mmr\"]},\"image/vnd.fujixerox.edmics-rlc\":{\"source\":\"iana\",\"extensions\":[\"rlc\"]},\"image/vnd.globalgraphics.pgb\":{\"source\":\"iana\"},\"image/vnd.microsoft.icon\":{\"source\":\"iana\",\"extensions\":[\"ico\"]},\"image/vnd.mix\":{\"source\":\"iana\"},\"image/vnd.mozilla.apng\":{\"source\":\"iana\"},\"image/vnd.ms-modi\":{\"source\":\"iana\",\"extensions\":[\"mdi\"]},\"image/vnd.ms-photo\":{\"source\":\"apache\",\"extensions\":[\"wdp\"]},\"image/vnd.net-fpx\":{\"source\":\"iana\",\"extensions\":[\"npx\"]},\"image/vnd.radiance\":{\"source\":\"iana\"},\"image/vnd.sealed.png\":{\"source\":\"iana\"},\"image/vnd.sealedmedia.softseal.gif\":{\"source\":\"iana\"},\"image/vnd.sealedmedia.softseal.jpg\":{\"source\":\"iana\"},\"image/vnd.svf\":{\"source\":\"iana\"},\"image/vnd.tencent.tap\":{\"source\":\"iana\",\"extensions\":[\"tap\"]},\"image/vnd.valve.source.texture\":{\"source\":\"iana\",\"extensions\":[\"vtf\"]},\"image/vnd.wap.wbmp\":{\"source\":\"iana\",\"extensions\":[\"wbmp\"]},\"image/vnd.xiff\":{\"source\":\"iana\",\"extensions\":[\"xif\"]},\"image/vnd.zbrush.pcx\":{\"source\":\"iana\",\"extensions\":[\"pcx\"]},\"image/webp\":{\"source\":\"apache\",\"extensions\":[\"webp\"]},\"image/wmf\":{\"source\":\"iana\",\"extensions\":[\"wmf\"]},\"image/x-3ds\":{\"source\":\"apache\",\"extensions\":[\"3ds\"]},\"image/x-cmu-raster\":{\"source\":\"apache\",\"extensions\":[\"ras\"]},\"image/x-cmx\":{\"source\":\"apache\",\"extensions\":[\"cmx\"]},\"image/x-freehand\":{\"source\":\"apache\",\"extensions\":[\"fh\",\"fhc\",\"fh4\",\"fh5\",\"fh7\"]},\"image/x-icon\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"ico\"]},\"image/x-jng\":{\"source\":\"nginx\",\"extensions\":[\"jng\"]},\"image/x-mrsid-image\":{\"source\":\"apache\",\"extensions\":[\"sid\"]},\"image/x-ms-bmp\":{\"source\":\"nginx\",\"compressible\":true,\"extensions\":[\"bmp\"]},\"image/x-pcx\":{\"source\":\"apache\",\"extensions\":[\"pcx\"]},\"image/x-pict\":{\"source\":\"apache\",\"extensions\":[\"pic\",\"pct\"]},\"image/x-portable-anymap\":{\"source\":\"apache\",\"extensions\":[\"pnm\"]},\"image/x-portable-bitmap\":{\"source\":\"apache\",\"extensions\":[\"pbm\"]},\"image/x-portable-graymap\":{\"source\":\"apache\",\"extensions\":[\"pgm\"]},\"image/x-portable-pixmap\":{\"source\":\"apache\",\"extensions\":[\"ppm\"]},\"image/x-rgb\":{\"source\":\"apache\",\"extensions\":[\"rgb\"]},\"image/x-tga\":{\"source\":\"apache\",\"extensions\":[\"tga\"]},\"image/x-xbitmap\":{\"source\":\"apache\",\"extensions\":[\"xbm\"]},\"image/x-xcf\":{\"compressible\":false},\"image/x-xpixmap\":{\"source\":\"apache\",\"extensions\":[\"xpm\"]},\"image/x-xwindowdump\":{\"source\":\"apache\",\"extensions\":[\"xwd\"]},\"message/cpim\":{\"source\":\"iana\"},\"message/delivery-status\":{\"source\":\"iana\"},\"message/disposition-notification\":{\"source\":\"iana\",\"extensions\":[\"disposition-notification\"]},\"message/external-body\":{\"source\":\"iana\"},\"message/feedback-report\":{\"source\":\"iana\"},\"message/global\":{\"source\":\"iana\",\"extensions\":[\"u8msg\"]},\"message/global-delivery-status\":{\"source\":\"iana\",\"extensions\":[\"u8dsn\"]},\"message/global-disposition-notification\":{\"source\":\"iana\",\"extensions\":[\"u8mdn\"]},\"message/global-headers\":{\"source\":\"iana\",\"extensions\":[\"u8hdr\"]},\"message/http\":{\"source\":\"iana\",\"compressible\":false},\"message/imdn+xml\":{\"source\":\"iana\",\"compressible\":true},\"message/news\":{\"source\":\"iana\"},\"message/partial\":{\"source\":\"iana\",\"compressible\":false},\"message/rfc822\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"eml\",\"mime\"]},\"message/s-http\":{\"source\":\"iana\"},\"message/sip\":{\"source\":\"iana\"},\"message/sipfrag\":{\"source\":\"iana\"},\"message/tracking-status\":{\"source\":\"iana\"},\"message/vnd.si.simp\":{\"source\":\"iana\"},\"message/vnd.wfa.wsc\":{\"source\":\"iana\",\"extensions\":[\"wsc\"]},\"model/3mf\":{\"source\":\"iana\",\"extensions\":[\"3mf\"]},\"model/gltf+json\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"gltf\"]},\"model/gltf-binary\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"glb\"]},\"model/iges\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"igs\",\"iges\"]},\"model/mesh\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"msh\",\"mesh\",\"silo\"]},\"model/stl\":{\"source\":\"iana\",\"extensions\":[\"stl\"]},\"model/vnd.collada+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"dae\"]},\"model/vnd.dwf\":{\"source\":\"iana\",\"extensions\":[\"dwf\"]},\"model/vnd.flatland.3dml\":{\"source\":\"iana\"},\"model/vnd.gdl\":{\"source\":\"iana\",\"extensions\":[\"gdl\"]},\"model/vnd.gs-gdl\":{\"source\":\"apache\"},\"model/vnd.gs.gdl\":{\"source\":\"iana\"},\"model/vnd.gtw\":{\"source\":\"iana\",\"extensions\":[\"gtw\"]},\"model/vnd.moml+xml\":{\"source\":\"iana\",\"compressible\":true},\"model/vnd.mts\":{\"source\":\"iana\",\"extensions\":[\"mts\"]},\"model/vnd.opengex\":{\"source\":\"iana\",\"extensions\":[\"ogex\"]},\"model/vnd.parasolid.transmit.binary\":{\"source\":\"iana\",\"extensions\":[\"x_b\"]},\"model/vnd.parasolid.transmit.text\":{\"source\":\"iana\",\"extensions\":[\"x_t\"]},\"model/vnd.rosette.annotated-data-model\":{\"source\":\"iana\"},\"model/vnd.usdz+zip\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"usdz\"]},\"model/vnd.valve.source.compiled-map\":{\"source\":\"iana\",\"extensions\":[\"bsp\"]},\"model/vnd.vtu\":{\"source\":\"iana\",\"extensions\":[\"vtu\"]},\"model/vrml\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"wrl\",\"vrml\"]},\"model/x3d+binary\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"x3db\",\"x3dbz\"]},\"model/x3d+fastinfoset\":{\"source\":\"iana\",\"extensions\":[\"x3db\"]},\"model/x3d+vrml\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"x3dv\",\"x3dvz\"]},\"model/x3d+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"x3d\",\"x3dz\"]},\"model/x3d-vrml\":{\"source\":\"iana\",\"extensions\":[\"x3dv\"]},\"multipart/alternative\":{\"source\":\"iana\",\"compressible\":false},\"multipart/appledouble\":{\"source\":\"iana\"},\"multipart/byteranges\":{\"source\":\"iana\"},\"multipart/digest\":{\"source\":\"iana\"},\"multipart/encrypted\":{\"source\":\"iana\",\"compressible\":false},\"multipart/form-data\":{\"source\":\"iana\",\"compressible\":false},\"multipart/header-set\":{\"source\":\"iana\"},\"multipart/mixed\":{\"source\":\"iana\",\"compressible\":false},\"multipart/multilingual\":{\"source\":\"iana\"},\"multipart/parallel\":{\"source\":\"iana\"},\"multipart/related\":{\"source\":\"iana\",\"compressible\":false},\"multipart/report\":{\"source\":\"iana\"},\"multipart/signed\":{\"source\":\"iana\",\"compressible\":false},\"multipart/vnd.bint.med-plus\":{\"source\":\"iana\"},\"multipart/voice-message\":{\"source\":\"iana\"},\"multipart/x-mixed-replace\":{\"source\":\"iana\"},\"text/1d-interleaved-parityfec\":{\"source\":\"iana\"},\"text/cache-manifest\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"appcache\",\"manifest\"]},\"text/calendar\":{\"source\":\"iana\",\"extensions\":[\"ics\",\"ifb\"]},\"text/calender\":{\"compressible\":true},\"text/cmd\":{\"compressible\":true},\"text/coffeescript\":{\"extensions\":[\"coffee\",\"litcoffee\"]},\"text/css\":{\"source\":\"iana\",\"charset\":\"UTF-8\",\"compressible\":true,\"extensions\":[\"css\"]},\"text/csv\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"csv\"]},\"text/csv-schema\":{\"source\":\"iana\"},\"text/directory\":{\"source\":\"iana\"},\"text/dns\":{\"source\":\"iana\"},\"text/ecmascript\":{\"source\":\"iana\"},\"text/encaprtp\":{\"source\":\"iana\"},\"text/enriched\":{\"source\":\"iana\"},\"text/fwdred\":{\"source\":\"iana\"},\"text/grammar-ref-list\":{\"source\":\"iana\"},\"text/html\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"html\",\"htm\",\"shtml\"]},\"text/jade\":{\"extensions\":[\"jade\"]},\"text/javascript\":{\"source\":\"iana\",\"compressible\":true},\"text/jcr-cnd\":{\"source\":\"iana\"},\"text/jsx\":{\"compressible\":true,\"extensions\":[\"jsx\"]},\"text/less\":{\"compressible\":true,\"extensions\":[\"less\"]},\"text/markdown\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"markdown\",\"md\"]},\"text/mathml\":{\"source\":\"nginx\",\"extensions\":[\"mml\"]},\"text/mdx\":{\"compressible\":true,\"extensions\":[\"mdx\"]},\"text/mizar\":{\"source\":\"iana\"},\"text/n3\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"n3\"]},\"text/parameters\":{\"source\":\"iana\"},\"text/parityfec\":{\"source\":\"iana\"},\"text/plain\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"txt\",\"text\",\"conf\",\"def\",\"list\",\"log\",\"in\",\"ini\"]},\"text/provenance-notation\":{\"source\":\"iana\"},\"text/prs.fallenstein.rst\":{\"source\":\"iana\"},\"text/prs.lines.tag\":{\"source\":\"iana\",\"extensions\":[\"dsc\"]},\"text/prs.prop.logic\":{\"source\":\"iana\"},\"text/raptorfec\":{\"source\":\"iana\"},\"text/red\":{\"source\":\"iana\"},\"text/rfc822-headers\":{\"source\":\"iana\"},\"text/richtext\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"rtx\"]},\"text/rtf\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"rtf\"]},\"text/rtp-enc-aescm128\":{\"source\":\"iana\"},\"text/rtploopback\":{\"source\":\"iana\"},\"text/rtx\":{\"source\":\"iana\"},\"text/sgml\":{\"source\":\"iana\",\"extensions\":[\"sgml\",\"sgm\"]},\"text/shex\":{\"extensions\":[\"shex\"]},\"text/slim\":{\"extensions\":[\"slim\",\"slm\"]},\"text/strings\":{\"source\":\"iana\"},\"text/stylus\":{\"extensions\":[\"stylus\",\"styl\"]},\"text/t140\":{\"source\":\"iana\"},\"text/tab-separated-values\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"tsv\"]},\"text/troff\":{\"source\":\"iana\",\"extensions\":[\"t\",\"tr\",\"roff\",\"man\",\"me\",\"ms\"]},\"text/turtle\":{\"source\":\"iana\",\"charset\":\"UTF-8\",\"extensions\":[\"ttl\"]},\"text/ulpfec\":{\"source\":\"iana\"},\"text/uri-list\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"uri\",\"uris\",\"urls\"]},\"text/vcard\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"vcard\"]},\"text/vnd.a\":{\"source\":\"iana\"},\"text/vnd.abc\":{\"source\":\"iana\"},\"text/vnd.ascii-art\":{\"source\":\"iana\"},\"text/vnd.curl\":{\"source\":\"iana\",\"extensions\":[\"curl\"]},\"text/vnd.curl.dcurl\":{\"source\":\"apache\",\"extensions\":[\"dcurl\"]},\"text/vnd.curl.mcurl\":{\"source\":\"apache\",\"extensions\":[\"mcurl\"]},\"text/vnd.curl.scurl\":{\"source\":\"apache\",\"extensions\":[\"scurl\"]},\"text/vnd.debian.copyright\":{\"source\":\"iana\"},\"text/vnd.dmclientscript\":{\"source\":\"iana\"},\"text/vnd.dvb.subtitle\":{\"source\":\"iana\",\"extensions\":[\"sub\"]},\"text/vnd.esmertec.theme-descriptor\":{\"source\":\"iana\"},\"text/vnd.fly\":{\"source\":\"iana\",\"extensions\":[\"fly\"]},\"text/vnd.fmi.flexstor\":{\"source\":\"iana\",\"extensions\":[\"flx\"]},\"text/vnd.gml\":{\"source\":\"iana\"},\"text/vnd.graphviz\":{\"source\":\"iana\",\"extensions\":[\"gv\"]},\"text/vnd.hgl\":{\"source\":\"iana\"},\"text/vnd.in3d.3dml\":{\"source\":\"iana\",\"extensions\":[\"3dml\"]},\"text/vnd.in3d.spot\":{\"source\":\"iana\",\"extensions\":[\"spot\"]},\"text/vnd.iptc.newsml\":{\"source\":\"iana\"},\"text/vnd.iptc.nitf\":{\"source\":\"iana\"},\"text/vnd.latex-z\":{\"source\":\"iana\"},\"text/vnd.motorola.reflex\":{\"source\":\"iana\"},\"text/vnd.ms-mediapackage\":{\"source\":\"iana\"},\"text/vnd.net2phone.commcenter.command\":{\"source\":\"iana\"},\"text/vnd.radisys.msml-basic-layout\":{\"source\":\"iana\"},\"text/vnd.senx.warpscript\":{\"source\":\"iana\"},\"text/vnd.si.uricatalogue\":{\"source\":\"iana\"},\"text/vnd.sun.j2me.app-descriptor\":{\"source\":\"iana\",\"extensions\":[\"jad\"]},\"text/vnd.trolltech.linguist\":{\"source\":\"iana\"},\"text/vnd.wap.si\":{\"source\":\"iana\"},\"text/vnd.wap.sl\":{\"source\":\"iana\"},\"text/vnd.wap.wml\":{\"source\":\"iana\",\"extensions\":[\"wml\"]},\"text/vnd.wap.wmlscript\":{\"source\":\"iana\",\"extensions\":[\"wmls\"]},\"text/vtt\":{\"charset\":\"UTF-8\",\"compressible\":true,\"extensions\":[\"vtt\"]},\"text/x-asm\":{\"source\":\"apache\",\"extensions\":[\"s\",\"asm\"]},\"text/x-c\":{\"source\":\"apache\",\"extensions\":[\"c\",\"cc\",\"cxx\",\"cpp\",\"h\",\"hh\",\"dic\"]},\"text/x-component\":{\"source\":\"nginx\",\"extensions\":[\"htc\"]},\"text/x-fortran\":{\"source\":\"apache\",\"extensions\":[\"f\",\"for\",\"f77\",\"f90\"]},\"text/x-gwt-rpc\":{\"compressible\":true},\"text/x-handlebars-template\":{\"extensions\":[\"hbs\"]},\"text/x-java-source\":{\"source\":\"apache\",\"extensions\":[\"java\"]},\"text/x-jquery-tmpl\":{\"compressible\":true},\"text/x-lua\":{\"extensions\":[\"lua\"]},\"text/x-markdown\":{\"compressible\":true,\"extensions\":[\"mkd\"]},\"text/x-nfo\":{\"source\":\"apache\",\"extensions\":[\"nfo\"]},\"text/x-opml\":{\"source\":\"apache\",\"extensions\":[\"opml\"]},\"text/x-org\":{\"compressible\":true,\"extensions\":[\"org\"]},\"text/x-pascal\":{\"source\":\"apache\",\"extensions\":[\"p\",\"pas\"]},\"text/x-processing\":{\"compressible\":true,\"extensions\":[\"pde\"]},\"text/x-sass\":{\"extensions\":[\"sass\"]},\"text/x-scss\":{\"extensions\":[\"scss\"]},\"text/x-setext\":{\"source\":\"apache\",\"extensions\":[\"etx\"]},\"text/x-sfv\":{\"source\":\"apache\",\"extensions\":[\"sfv\"]},\"text/x-suse-ymp\":{\"compressible\":true,\"extensions\":[\"ymp\"]},\"text/x-uuencode\":{\"source\":\"apache\",\"extensions\":[\"uu\"]},\"text/x-vcalendar\":{\"source\":\"apache\",\"extensions\":[\"vcs\"]},\"text/x-vcard\":{\"source\":\"apache\",\"extensions\":[\"vcf\"]},\"text/xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"xml\"]},\"text/xml-external-parsed-entity\":{\"source\":\"iana\"},\"text/yaml\":{\"extensions\":[\"yaml\",\"yml\"]},\"video/1d-interleaved-parityfec\":{\"source\":\"iana\"},\"video/3gpp\":{\"source\":\"iana\",\"extensions\":[\"3gp\",\"3gpp\"]},\"video/3gpp-tt\":{\"source\":\"iana\"},\"video/3gpp2\":{\"source\":\"iana\",\"extensions\":[\"3g2\"]},\"video/bmpeg\":{\"source\":\"iana\"},\"video/bt656\":{\"source\":\"iana\"},\"video/celb\":{\"source\":\"iana\"},\"video/dv\":{\"source\":\"iana\"},\"video/encaprtp\":{\"source\":\"iana\"},\"video/h261\":{\"source\":\"iana\",\"extensions\":[\"h261\"]},\"video/h263\":{\"source\":\"iana\",\"extensions\":[\"h263\"]},\"video/h263-1998\":{\"source\":\"iana\"},\"video/h263-2000\":{\"source\":\"iana\"},\"video/h264\":{\"source\":\"iana\",\"extensions\":[\"h264\"]},\"video/h264-rcdo\":{\"source\":\"iana\"},\"video/h264-svc\":{\"source\":\"iana\"},\"video/h265\":{\"source\":\"iana\"},\"video/iso.segment\":{\"source\":\"iana\"},\"video/jpeg\":{\"source\":\"iana\",\"extensions\":[\"jpgv\"]},\"video/jpeg2000\":{\"source\":\"iana\"},\"video/jpm\":{\"source\":\"apache\",\"extensions\":[\"jpm\",\"jpgm\"]},\"video/mj2\":{\"source\":\"iana\",\"extensions\":[\"mj2\",\"mjp2\"]},\"video/mp1s\":{\"source\":\"iana\"},\"video/mp2p\":{\"source\":\"iana\"},\"video/mp2t\":{\"source\":\"iana\",\"extensions\":[\"ts\"]},\"video/mp4\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"mp4\",\"mp4v\",\"mpg4\"]},\"video/mp4v-es\":{\"source\":\"iana\"},\"video/mpeg\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"mpeg\",\"mpg\",\"mpe\",\"m1v\",\"m2v\"]},\"video/mpeg4-generic\":{\"source\":\"iana\"},\"video/mpv\":{\"source\":\"iana\"},\"video/nv\":{\"source\":\"iana\"},\"video/ogg\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"ogv\"]},\"video/parityfec\":{\"source\":\"iana\"},\"video/pointer\":{\"source\":\"iana\"},\"video/quicktime\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"qt\",\"mov\"]},\"video/raptorfec\":{\"source\":\"iana\"},\"video/raw\":{\"source\":\"iana\"},\"video/rtp-enc-aescm128\":{\"source\":\"iana\"},\"video/rtploopback\":{\"source\":\"iana\"},\"video/rtx\":{\"source\":\"iana\"},\"video/smpte291\":{\"source\":\"iana\"},\"video/smpte292m\":{\"source\":\"iana\"},\"video/ulpfec\":{\"source\":\"iana\"},\"video/vc1\":{\"source\":\"iana\"},\"video/vc2\":{\"source\":\"iana\"},\"video/vnd.cctv\":{\"source\":\"iana\"},\"video/vnd.dece.hd\":{\"source\":\"iana\",\"extensions\":[\"uvh\",\"uvvh\"]},\"video/vnd.dece.mobile\":{\"source\":\"iana\",\"extensions\":[\"uvm\",\"uvvm\"]},\"video/vnd.dece.mp4\":{\"source\":\"iana\"},\"video/vnd.dece.pd\":{\"source\":\"iana\",\"extensions\":[\"uvp\",\"uvvp\"]},\"video/vnd.dece.sd\":{\"source\":\"iana\",\"extensions\":[\"uvs\",\"uvvs\"]},\"video/vnd.dece.video\":{\"source\":\"iana\",\"extensions\":[\"uvv\",\"uvvv\"]},\"video/vnd.directv.mpeg\":{\"source\":\"iana\"},\"video/vnd.directv.mpeg-tts\":{\"source\":\"iana\"},\"video/vnd.dlna.mpeg-tts\":{\"source\":\"iana\"},\"video/vnd.dvb.file\":{\"source\":\"iana\",\"extensions\":[\"dvb\"]},\"video/vnd.fvt\":{\"source\":\"iana\",\"extensions\":[\"fvt\"]},\"video/vnd.hns.video\":{\"source\":\"iana\"},\"video/vnd.iptvforum.1dparityfec-1010\":{\"source\":\"iana\"},\"video/vnd.iptvforum.1dparityfec-2005\":{\"source\":\"iana\"},\"video/vnd.iptvforum.2dparityfec-1010\":{\"source\":\"iana\"},\"video/vnd.iptvforum.2dparityfec-2005\":{\"source\":\"iana\"},\"video/vnd.iptvforum.ttsavc\":{\"source\":\"iana\"},\"video/vnd.iptvforum.ttsmpeg2\":{\"source\":\"iana\"},\"video/vnd.motorola.video\":{\"source\":\"iana\"},\"video/vnd.motorola.videop\":{\"source\":\"iana\"},\"video/vnd.mpegurl\":{\"source\":\"iana\",\"extensions\":[\"mxu\",\"m4u\"]},\"video/vnd.ms-playready.media.pyv\":{\"source\":\"iana\",\"extensions\":[\"pyv\"]},\"video/vnd.nokia.interleaved-multimedia\":{\"source\":\"iana\"},\"video/vnd.nokia.mp4vr\":{\"source\":\"iana\"},\"video/vnd.nokia.videovoip\":{\"source\":\"iana\"},\"video/vnd.objectvideo\":{\"source\":\"iana\"},\"video/vnd.radgamettools.bink\":{\"source\":\"iana\"},\"video/vnd.radgamettools.smacker\":{\"source\":\"iana\"},\"video/vnd.sealed.mpeg1\":{\"source\":\"iana\"},\"video/vnd.sealed.mpeg4\":{\"source\":\"iana\"},\"video/vnd.sealed.swf\":{\"source\":\"iana\"},\"video/vnd.sealedmedia.softseal.mov\":{\"source\":\"iana\"},\"video/vnd.uvvu.mp4\":{\"source\":\"iana\",\"extensions\":[\"uvu\",\"uvvu\"]},\"video/vnd.vivo\":{\"source\":\"iana\",\"extensions\":[\"viv\"]},\"video/vp8\":{\"source\":\"iana\"},\"video/webm\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"webm\"]},\"video/x-f4v\":{\"source\":\"apache\",\"extensions\":[\"f4v\"]},\"video/x-fli\":{\"source\":\"apache\",\"extensions\":[\"fli\"]},\"video/x-flv\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"flv\"]},\"video/x-m4v\":{\"source\":\"apache\",\"extensions\":[\"m4v\"]},\"video/x-matroska\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"mkv\",\"mk3d\",\"mks\"]},\"video/x-mng\":{\"source\":\"apache\",\"extensions\":[\"mng\"]},\"video/x-ms-asf\":{\"source\":\"apache\",\"extensions\":[\"asf\",\"asx\"]},\"video/x-ms-vob\":{\"source\":\"apache\",\"extensions\":[\"vob\"]},\"video/x-ms-wm\":{\"source\":\"apache\",\"extensions\":[\"wm\"]},\"video/x-ms-wmv\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"wmv\"]},\"video/x-ms-wmx\":{\"source\":\"apache\",\"extensions\":[\"wmx\"]},\"video/x-ms-wvx\":{\"source\":\"apache\",\"extensions\":[\"wvx\"]},\"video/x-msvideo\":{\"source\":\"apache\",\"extensions\":[\"avi\"]},\"video/x-sgi-movie\":{\"source\":\"apache\",\"extensions\":[\"movie\"]},\"video/x-smv\":{\"source\":\"apache\",\"extensions\":[\"smv\"]},\"x-conference/x-cooltalk\":{\"source\":\"apache\",\"extensions\":[\"ice\"]},\"x-shader/x-fragment\":{\"compressible\":true},\"x-shader/x-vertex\":{\"compressible\":true}}");

/***/ }),

/***/ "./node_modules/mime-db/index.js":
/*!***************************************!*\
  !*** ./node_modules/mime-db/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * MIT Licensed
 */

/**
 * Module exports.
 */

module.exports = __webpack_require__(/*! ./db.json */ "./node_modules/mime-db/db.json")


/***/ }),

/***/ "./node_modules/mime-types/index.js":
/*!******************************************!*\
  !*** ./node_modules/mime-types/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var db = __webpack_require__(/*! mime-db */ "./node_modules/mime-db/index.js")
var extname = __webpack_require__(/*! path */ "path").extname

/**
 * Module variables.
 * @private
 */

var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/
var TEXT_TYPE_REGEXP = /^text\//i

/**
 * Module exports.
 * @public
 */

exports.charset = charset
exports.charsets = { lookup: charset }
exports.contentType = contentType
exports.extension = extension
exports.extensions = Object.create(null)
exports.lookup = lookup
exports.types = Object.create(null)

// Populate the extensions/types maps
populateMaps(exports.extensions, exports.types)

/**
 * Get the default charset for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */

function charset (type) {
  if (!type || typeof type !== 'string') {
    return false
  }

  // TODO: use media-typer
  var match = EXTRACT_TYPE_REGEXP.exec(type)
  var mime = match && db[match[1].toLowerCase()]

  if (mime && mime.charset) {
    return mime.charset
  }

  // default text/* to utf-8
  if (match && TEXT_TYPE_REGEXP.test(match[1])) {
    return 'UTF-8'
  }

  return false
}

/**
 * Create a full Content-Type header given a MIME type or extension.
 *
 * @param {string} str
 * @return {boolean|string}
 */

function contentType (str) {
  // TODO: should this even be in this module?
  if (!str || typeof str !== 'string') {
    return false
  }

  var mime = str.indexOf('/') === -1
    ? exports.lookup(str)
    : str

  if (!mime) {
    return false
  }

  // TODO: use content-type or other module
  if (mime.indexOf('charset') === -1) {
    var charset = exports.charset(mime)
    if (charset) mime += '; charset=' + charset.toLowerCase()
  }

  return mime
}

/**
 * Get the default extension for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */

function extension (type) {
  if (!type || typeof type !== 'string') {
    return false
  }

  // TODO: use media-typer
  var match = EXTRACT_TYPE_REGEXP.exec(type)

  // get extensions
  var exts = match && exports.extensions[match[1].toLowerCase()]

  if (!exts || !exts.length) {
    return false
  }

  return exts[0]
}

/**
 * Lookup the MIME type for a file path/extension.
 *
 * @param {string} path
 * @return {boolean|string}
 */

function lookup (path) {
  if (!path || typeof path !== 'string') {
    return false
  }

  // get the extension ("ext" or ".ext" or full path)
  var extension = extname('x.' + path)
    .toLowerCase()
    .substr(1)

  if (!extension) {
    return false
  }

  return exports.types[extension] || false
}

/**
 * Populate the extensions and types maps.
 * @private
 */

function populateMaps (extensions, types) {
  // source preference (least -> most)
  var preference = ['nginx', 'apache', undefined, 'iana']

  Object.keys(db).forEach(function forEachMimeType (type) {
    var mime = db[type]
    var exts = mime.extensions

    if (!exts || !exts.length) {
      return
    }

    // mime -> extensions
    extensions[type] = exts

    // extension -> mime
    for (var i = 0; i < exts.length; i++) {
      var extension = exts[i]

      if (types[extension]) {
        var from = preference.indexOf(db[types[extension]].source)
        var to = preference.indexOf(mime.source)

        if (types[extension] !== 'application/octet-stream' &&
          (from > to || (from === to && types[extension].substr(0, 12) === 'application/'))) {
          // skip the remapping
          continue
        }
      }

      // set the extension -> mime
      types[extension] = type
    }
  })
}


/***/ }),

/***/ "./node_modules/mime/mime.js":
/*!***********************************!*\
  !*** ./node_modules/mime/mime.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var path = __webpack_require__(/*! path */ "path");
var fs = __webpack_require__(/*! fs */ "fs");

function Mime() {
  // Map of extension -> mime type
  this.types = Object.create(null);

  // Map of mime type -> extension
  this.extensions = Object.create(null);
}

/**
 * Define mimetype -> extension mappings.  Each key is a mime-type that maps
 * to an array of extensions associated with the type.  The first extension is
 * used as the default extension for the type.
 *
 * e.g. mime.define({'audio/ogg', ['oga', 'ogg', 'spx']});
 *
 * @param map (Object) type definitions
 */
Mime.prototype.define = function (map) {
  for (var type in map) {
    var exts = map[type];
    for (var i = 0; i < exts.length; i++) {
      if (process.env.DEBUG_MIME && this.types[exts[i]]) {
        console.warn((this._loading || "define()").replace(/.*\//, ''), 'changes "' + exts[i] + '" extension type from ' +
          this.types[exts[i]] + ' to ' + type);
      }

      this.types[exts[i]] = type;
    }

    // Default extension is the first one we encounter
    if (!this.extensions[type]) {
      this.extensions[type] = exts[0];
    }
  }
};

/**
 * Load an Apache2-style ".types" file
 *
 * This may be called multiple times (it's expected).  Where files declare
 * overlapping types/extensions, the last file wins.
 *
 * @param file (String) path of file to load.
 */
Mime.prototype.load = function(file) {
  this._loading = file;
  // Read file and split into lines
  var map = {},
      content = fs.readFileSync(file, 'ascii'),
      lines = content.split(/[\r\n]+/);

  lines.forEach(function(line) {
    // Clean up whitespace/comments, and split into fields
    var fields = line.replace(/\s*#.*|^\s*|\s*$/g, '').split(/\s+/);
    map[fields.shift()] = fields;
  });

  this.define(map);

  this._loading = null;
};

/**
 * Lookup a mime type based on extension
 */
Mime.prototype.lookup = function(path, fallback) {
  var ext = path.replace(/^.*[\.\/\\]/, '').toLowerCase();

  return this.types[ext] || fallback || this.default_type;
};

/**
 * Return file extension associated with a mime type
 */
Mime.prototype.extension = function(mimeType) {
  var type = mimeType.match(/^\s*([^;\s]*)(?:;|\s|$)/)[1].toLowerCase();
  return this.extensions[type];
};

// Default instance
var mime = new Mime();

// Define built-in types
mime.define(__webpack_require__(/*! ./types.json */ "./node_modules/mime/types.json"));

// Default type
mime.default_type = mime.lookup('bin');

//
// Additional API specific to the default instance
//

mime.Mime = Mime;

/**
 * Lookup a charset based on mime type.
 */
mime.charsets = {
  lookup: function(mimeType, fallback) {
    // Assume text types are utf8
    return (/^text\/|^application\/(javascript|json)/).test(mimeType) ? 'UTF-8' : fallback;
  }
};

module.exports = mime;


/***/ }),

/***/ "./node_modules/mime/types.json":
/*!**************************************!*\
  !*** ./node_modules/mime/types.json ***!
  \**************************************/
/*! exports provided: application/andrew-inset, application/applixware, application/atom+xml, application/atomcat+xml, application/atomsvc+xml, application/bdoc, application/ccxml+xml, application/cdmi-capability, application/cdmi-container, application/cdmi-domain, application/cdmi-object, application/cdmi-queue, application/cu-seeme, application/dash+xml, application/davmount+xml, application/docbook+xml, application/dssc+der, application/dssc+xml, application/ecmascript, application/emma+xml, application/epub+zip, application/exi, application/font-tdpfr, application/font-woff, application/font-woff2, application/geo+json, application/gml+xml, application/gpx+xml, application/gxf, application/gzip, application/hyperstudio, application/inkml+xml, application/ipfix, application/java-archive, application/java-serialized-object, application/java-vm, application/javascript, application/json, application/json5, application/jsonml+json, application/ld+json, application/lost+xml, application/mac-binhex40, application/mac-compactpro, application/mads+xml, application/manifest+json, application/marc, application/marcxml+xml, application/mathematica, application/mathml+xml, application/mbox, application/mediaservercontrol+xml, application/metalink+xml, application/metalink4+xml, application/mets+xml, application/mods+xml, application/mp21, application/mp4, application/msword, application/mxf, application/octet-stream, application/oda, application/oebps-package+xml, application/ogg, application/omdoc+xml, application/onenote, application/oxps, application/patch-ops-error+xml, application/pdf, application/pgp-encrypted, application/pgp-signature, application/pics-rules, application/pkcs10, application/pkcs7-mime, application/pkcs7-signature, application/pkcs8, application/pkix-attr-cert, application/pkix-cert, application/pkix-crl, application/pkix-pkipath, application/pkixcmp, application/pls+xml, application/postscript, application/prs.cww, application/pskc+xml, application/raml+yaml, application/rdf+xml, application/reginfo+xml, application/relax-ng-compact-syntax, application/resource-lists+xml, application/resource-lists-diff+xml, application/rls-services+xml, application/rpki-ghostbusters, application/rpki-manifest, application/rpki-roa, application/rsd+xml, application/rss+xml, application/rtf, application/sbml+xml, application/scvp-cv-request, application/scvp-cv-response, application/scvp-vp-request, application/scvp-vp-response, application/sdp, application/set-payment-initiation, application/set-registration-initiation, application/shf+xml, application/smil+xml, application/sparql-query, application/sparql-results+xml, application/srgs, application/srgs+xml, application/sru+xml, application/ssdl+xml, application/ssml+xml, application/tei+xml, application/thraud+xml, application/timestamped-data, application/vnd.3gpp.pic-bw-large, application/vnd.3gpp.pic-bw-small, application/vnd.3gpp.pic-bw-var, application/vnd.3gpp2.tcap, application/vnd.3m.post-it-notes, application/vnd.accpac.simply.aso, application/vnd.accpac.simply.imp, application/vnd.acucobol, application/vnd.acucorp, application/vnd.adobe.air-application-installer-package+zip, application/vnd.adobe.formscentral.fcdt, application/vnd.adobe.fxp, application/vnd.adobe.xdp+xml, application/vnd.adobe.xfdf, application/vnd.ahead.space, application/vnd.airzip.filesecure.azf, application/vnd.airzip.filesecure.azs, application/vnd.amazon.ebook, application/vnd.americandynamics.acc, application/vnd.amiga.ami, application/vnd.android.package-archive, application/vnd.anser-web-certificate-issue-initiation, application/vnd.anser-web-funds-transfer-initiation, application/vnd.antix.game-component, application/vnd.apple.installer+xml, application/vnd.apple.mpegurl, application/vnd.apple.pkpass, application/vnd.aristanetworks.swi, application/vnd.astraea-software.iota, application/vnd.audiograph, application/vnd.blueice.multipass, application/vnd.bmi, application/vnd.businessobjects, application/vnd.chemdraw+xml, application/vnd.chipnuts.karaoke-mmd, application/vnd.cinderella, application/vnd.claymore, application/vnd.cloanto.rp9, application/vnd.clonk.c4group, application/vnd.cluetrust.cartomobile-config, application/vnd.cluetrust.cartomobile-config-pkg, application/vnd.commonspace, application/vnd.contact.cmsg, application/vnd.cosmocaller, application/vnd.crick.clicker, application/vnd.crick.clicker.keyboard, application/vnd.crick.clicker.palette, application/vnd.crick.clicker.template, application/vnd.crick.clicker.wordbank, application/vnd.criticaltools.wbs+xml, application/vnd.ctc-posml, application/vnd.cups-ppd, application/vnd.curl.car, application/vnd.curl.pcurl, application/vnd.dart, application/vnd.data-vision.rdz, application/vnd.dece.data, application/vnd.dece.ttml+xml, application/vnd.dece.unspecified, application/vnd.dece.zip, application/vnd.denovo.fcselayout-link, application/vnd.dna, application/vnd.dolby.mlp, application/vnd.dpgraph, application/vnd.dreamfactory, application/vnd.ds-keypoint, application/vnd.dvb.ait, application/vnd.dvb.service, application/vnd.dynageo, application/vnd.ecowin.chart, application/vnd.enliven, application/vnd.epson.esf, application/vnd.epson.msf, application/vnd.epson.quickanime, application/vnd.epson.salt, application/vnd.epson.ssf, application/vnd.eszigno3+xml, application/vnd.ezpix-album, application/vnd.ezpix-package, application/vnd.fdf, application/vnd.fdsn.mseed, application/vnd.fdsn.seed, application/vnd.flographit, application/vnd.fluxtime.clip, application/vnd.framemaker, application/vnd.frogans.fnc, application/vnd.frogans.ltf, application/vnd.fsc.weblaunch, application/vnd.fujitsu.oasys, application/vnd.fujitsu.oasys2, application/vnd.fujitsu.oasys3, application/vnd.fujitsu.oasysgp, application/vnd.fujitsu.oasysprs, application/vnd.fujixerox.ddd, application/vnd.fujixerox.docuworks, application/vnd.fujixerox.docuworks.binder, application/vnd.fuzzysheet, application/vnd.genomatix.tuxedo, application/vnd.geogebra.file, application/vnd.geogebra.tool, application/vnd.geometry-explorer, application/vnd.geonext, application/vnd.geoplan, application/vnd.geospace, application/vnd.gmx, application/vnd.google-apps.document, application/vnd.google-apps.presentation, application/vnd.google-apps.spreadsheet, application/vnd.google-earth.kml+xml, application/vnd.google-earth.kmz, application/vnd.grafeq, application/vnd.groove-account, application/vnd.groove-help, application/vnd.groove-identity-message, application/vnd.groove-injector, application/vnd.groove-tool-message, application/vnd.groove-tool-template, application/vnd.groove-vcard, application/vnd.hal+xml, application/vnd.handheld-entertainment+xml, application/vnd.hbci, application/vnd.hhe.lesson-player, application/vnd.hp-hpgl, application/vnd.hp-hpid, application/vnd.hp-hps, application/vnd.hp-jlyt, application/vnd.hp-pcl, application/vnd.hp-pclxl, application/vnd.hydrostatix.sof-data, application/vnd.ibm.minipay, application/vnd.ibm.modcap, application/vnd.ibm.rights-management, application/vnd.ibm.secure-container, application/vnd.iccprofile, application/vnd.igloader, application/vnd.immervision-ivp, application/vnd.immervision-ivu, application/vnd.insors.igm, application/vnd.intercon.formnet, application/vnd.intergeo, application/vnd.intu.qbo, application/vnd.intu.qfx, application/vnd.ipunplugged.rcprofile, application/vnd.irepository.package+xml, application/vnd.is-xpr, application/vnd.isac.fcs, application/vnd.jam, application/vnd.jcp.javame.midlet-rms, application/vnd.jisp, application/vnd.joost.joda-archive, application/vnd.kahootz, application/vnd.kde.karbon, application/vnd.kde.kchart, application/vnd.kde.kformula, application/vnd.kde.kivio, application/vnd.kde.kontour, application/vnd.kde.kpresenter, application/vnd.kde.kspread, application/vnd.kde.kword, application/vnd.kenameaapp, application/vnd.kidspiration, application/vnd.kinar, application/vnd.koan, application/vnd.kodak-descriptor, application/vnd.las.las+xml, application/vnd.llamagraphics.life-balance.desktop, application/vnd.llamagraphics.life-balance.exchange+xml, application/vnd.lotus-1-2-3, application/vnd.lotus-approach, application/vnd.lotus-freelance, application/vnd.lotus-notes, application/vnd.lotus-organizer, application/vnd.lotus-screencam, application/vnd.lotus-wordpro, application/vnd.macports.portpkg, application/vnd.mcd, application/vnd.medcalcdata, application/vnd.mediastation.cdkey, application/vnd.mfer, application/vnd.mfmp, application/vnd.micrografx.flo, application/vnd.micrografx.igx, application/vnd.mif, application/vnd.mobius.daf, application/vnd.mobius.dis, application/vnd.mobius.mbk, application/vnd.mobius.mqy, application/vnd.mobius.msl, application/vnd.mobius.plc, application/vnd.mobius.txf, application/vnd.mophun.application, application/vnd.mophun.certificate, application/vnd.mozilla.xul+xml, application/vnd.ms-artgalry, application/vnd.ms-cab-compressed, application/vnd.ms-excel, application/vnd.ms-excel.addin.macroenabled.12, application/vnd.ms-excel.sheet.binary.macroenabled.12, application/vnd.ms-excel.sheet.macroenabled.12, application/vnd.ms-excel.template.macroenabled.12, application/vnd.ms-fontobject, application/vnd.ms-htmlhelp, application/vnd.ms-ims, application/vnd.ms-lrm, application/vnd.ms-officetheme, application/vnd.ms-outlook, application/vnd.ms-pki.seccat, application/vnd.ms-pki.stl, application/vnd.ms-powerpoint, application/vnd.ms-powerpoint.addin.macroenabled.12, application/vnd.ms-powerpoint.presentation.macroenabled.12, application/vnd.ms-powerpoint.slide.macroenabled.12, application/vnd.ms-powerpoint.slideshow.macroenabled.12, application/vnd.ms-powerpoint.template.macroenabled.12, application/vnd.ms-project, application/vnd.ms-word.document.macroenabled.12, application/vnd.ms-word.template.macroenabled.12, application/vnd.ms-works, application/vnd.ms-wpl, application/vnd.ms-xpsdocument, application/vnd.mseq, application/vnd.musician, application/vnd.muvee.style, application/vnd.mynfc, application/vnd.neurolanguage.nlu, application/vnd.nitf, application/vnd.noblenet-directory, application/vnd.noblenet-sealer, application/vnd.noblenet-web, application/vnd.nokia.n-gage.data, application/vnd.nokia.n-gage.symbian.install, application/vnd.nokia.radio-preset, application/vnd.nokia.radio-presets, application/vnd.novadigm.edm, application/vnd.novadigm.edx, application/vnd.novadigm.ext, application/vnd.oasis.opendocument.chart, application/vnd.oasis.opendocument.chart-template, application/vnd.oasis.opendocument.database, application/vnd.oasis.opendocument.formula, application/vnd.oasis.opendocument.formula-template, application/vnd.oasis.opendocument.graphics, application/vnd.oasis.opendocument.graphics-template, application/vnd.oasis.opendocument.image, application/vnd.oasis.opendocument.image-template, application/vnd.oasis.opendocument.presentation, application/vnd.oasis.opendocument.presentation-template, application/vnd.oasis.opendocument.spreadsheet, application/vnd.oasis.opendocument.spreadsheet-template, application/vnd.oasis.opendocument.text, application/vnd.oasis.opendocument.text-master, application/vnd.oasis.opendocument.text-template, application/vnd.oasis.opendocument.text-web, application/vnd.olpc-sugar, application/vnd.oma.dd2+xml, application/vnd.openofficeorg.extension, application/vnd.openxmlformats-officedocument.presentationml.presentation, application/vnd.openxmlformats-officedocument.presentationml.slide, application/vnd.openxmlformats-officedocument.presentationml.slideshow, application/vnd.openxmlformats-officedocument.presentationml.template, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/vnd.openxmlformats-officedocument.spreadsheetml.template, application/vnd.openxmlformats-officedocument.wordprocessingml.document, application/vnd.openxmlformats-officedocument.wordprocessingml.template, application/vnd.osgeo.mapguide.package, application/vnd.osgi.dp, application/vnd.osgi.subsystem, application/vnd.palm, application/vnd.pawaafile, application/vnd.pg.format, application/vnd.pg.osasli, application/vnd.picsel, application/vnd.pmi.widget, application/vnd.pocketlearn, application/vnd.powerbuilder6, application/vnd.previewsystems.box, application/vnd.proteus.magazine, application/vnd.publishare-delta-tree, application/vnd.pvi.ptid1, application/vnd.quark.quarkxpress, application/vnd.realvnc.bed, application/vnd.recordare.musicxml, application/vnd.recordare.musicxml+xml, application/vnd.rig.cryptonote, application/vnd.rim.cod, application/vnd.rn-realmedia, application/vnd.rn-realmedia-vbr, application/vnd.route66.link66+xml, application/vnd.sailingtracker.track, application/vnd.seemail, application/vnd.sema, application/vnd.semd, application/vnd.semf, application/vnd.shana.informed.formdata, application/vnd.shana.informed.formtemplate, application/vnd.shana.informed.interchange, application/vnd.shana.informed.package, application/vnd.simtech-mindmapper, application/vnd.smaf, application/vnd.smart.teacher, application/vnd.solent.sdkm+xml, application/vnd.spotfire.dxp, application/vnd.spotfire.sfs, application/vnd.stardivision.calc, application/vnd.stardivision.draw, application/vnd.stardivision.impress, application/vnd.stardivision.math, application/vnd.stardivision.writer, application/vnd.stardivision.writer-global, application/vnd.stepmania.package, application/vnd.stepmania.stepchart, application/vnd.sun.wadl+xml, application/vnd.sun.xml.calc, application/vnd.sun.xml.calc.template, application/vnd.sun.xml.draw, application/vnd.sun.xml.draw.template, application/vnd.sun.xml.impress, application/vnd.sun.xml.impress.template, application/vnd.sun.xml.math, application/vnd.sun.xml.writer, application/vnd.sun.xml.writer.global, application/vnd.sun.xml.writer.template, application/vnd.sus-calendar, application/vnd.svd, application/vnd.symbian.install, application/vnd.syncml+xml, application/vnd.syncml.dm+wbxml, application/vnd.syncml.dm+xml, application/vnd.tao.intent-module-archive, application/vnd.tcpdump.pcap, application/vnd.tmobile-livetv, application/vnd.trid.tpt, application/vnd.triscape.mxs, application/vnd.trueapp, application/vnd.ufdl, application/vnd.uiq.theme, application/vnd.umajin, application/vnd.unity, application/vnd.uoml+xml, application/vnd.vcx, application/vnd.visio, application/vnd.visionary, application/vnd.vsf, application/vnd.wap.wbxml, application/vnd.wap.wmlc, application/vnd.wap.wmlscriptc, application/vnd.webturbo, application/vnd.wolfram.player, application/vnd.wordperfect, application/vnd.wqd, application/vnd.wt.stf, application/vnd.xara, application/vnd.xfdl, application/vnd.yamaha.hv-dic, application/vnd.yamaha.hv-script, application/vnd.yamaha.hv-voice, application/vnd.yamaha.openscoreformat, application/vnd.yamaha.openscoreformat.osfpvg+xml, application/vnd.yamaha.smaf-audio, application/vnd.yamaha.smaf-phrase, application/vnd.yellowriver-custom-menu, application/vnd.zul, application/vnd.zzazz.deck+xml, application/voicexml+xml, application/wasm, application/widget, application/winhlp, application/wsdl+xml, application/wspolicy+xml, application/x-7z-compressed, application/x-abiword, application/x-ace-compressed, application/x-apple-diskimage, application/x-arj, application/x-authorware-bin, application/x-authorware-map, application/x-authorware-seg, application/x-bcpio, application/x-bdoc, application/x-bittorrent, application/x-blorb, application/x-bzip, application/x-bzip2, application/x-cbr, application/x-cdlink, application/x-cfs-compressed, application/x-chat, application/x-chess-pgn, application/x-chrome-extension, application/x-cocoa, application/x-conference, application/x-cpio, application/x-csh, application/x-debian-package, application/x-dgc-compressed, application/x-director, application/x-doom, application/x-dtbncx+xml, application/x-dtbook+xml, application/x-dtbresource+xml, application/x-dvi, application/x-envoy, application/x-eva, application/x-font-bdf, application/x-font-ghostscript, application/x-font-linux-psf, application/x-font-pcf, application/x-font-snf, application/x-font-type1, application/x-freearc, application/x-futuresplash, application/x-gca-compressed, application/x-glulx, application/x-gnumeric, application/x-gramps-xml, application/x-gtar, application/x-hdf, application/x-httpd-php, application/x-install-instructions, application/x-iso9660-image, application/x-java-archive-diff, application/x-java-jnlp-file, application/x-latex, application/x-lua-bytecode, application/x-lzh-compressed, application/x-makeself, application/x-mie, application/x-mobipocket-ebook, application/x-ms-application, application/x-ms-shortcut, application/x-ms-wmd, application/x-ms-wmz, application/x-ms-xbap, application/x-msaccess, application/x-msbinder, application/x-mscardfile, application/x-msclip, application/x-msdos-program, application/x-msdownload, application/x-msmediaview, application/x-msmetafile, application/x-msmoney, application/x-mspublisher, application/x-msschedule, application/x-msterminal, application/x-mswrite, application/x-netcdf, application/x-ns-proxy-autoconfig, application/x-nzb, application/x-perl, application/x-pilot, application/x-pkcs12, application/x-pkcs7-certificates, application/x-pkcs7-certreqresp, application/x-rar-compressed, application/x-redhat-package-manager, application/x-research-info-systems, application/x-sea, application/x-sh, application/x-shar, application/x-shockwave-flash, application/x-silverlight-app, application/x-sql, application/x-stuffit, application/x-stuffitx, application/x-subrip, application/x-sv4cpio, application/x-sv4crc, application/x-t3vm-image, application/x-tads, application/x-tar, application/x-tcl, application/x-tex, application/x-tex-tfm, application/x-texinfo, application/x-tgif, application/x-ustar, application/x-virtualbox-hdd, application/x-virtualbox-ova, application/x-virtualbox-ovf, application/x-virtualbox-vbox, application/x-virtualbox-vbox-extpack, application/x-virtualbox-vdi, application/x-virtualbox-vhd, application/x-virtualbox-vmdk, application/x-wais-source, application/x-web-app-manifest+json, application/x-x509-ca-cert, application/x-xfig, application/x-xliff+xml, application/x-xpinstall, application/x-xz, application/x-zmachine, application/xaml+xml, application/xcap-diff+xml, application/xenc+xml, application/xhtml+xml, application/xml, application/xml-dtd, application/xop+xml, application/xproc+xml, application/xslt+xml, application/xspf+xml, application/xv+xml, application/yang, application/yin+xml, application/zip, audio/3gpp, audio/adpcm, audio/basic, audio/midi, audio/mp3, audio/mp4, audio/mpeg, audio/ogg, audio/s3m, audio/silk, audio/vnd.dece.audio, audio/vnd.digital-winds, audio/vnd.dra, audio/vnd.dts, audio/vnd.dts.hd, audio/vnd.lucent.voice, audio/vnd.ms-playready.media.pya, audio/vnd.nuera.ecelp4800, audio/vnd.nuera.ecelp7470, audio/vnd.nuera.ecelp9600, audio/vnd.rip, audio/wav, audio/wave, audio/webm, audio/x-aac, audio/x-aiff, audio/x-caf, audio/x-flac, audio/x-m4a, audio/x-matroska, audio/x-mpegurl, audio/x-ms-wax, audio/x-ms-wma, audio/x-pn-realaudio, audio/x-pn-realaudio-plugin, audio/x-realaudio, audio/x-wav, audio/xm, chemical/x-cdx, chemical/x-cif, chemical/x-cmdf, chemical/x-cml, chemical/x-csml, chemical/x-xyz, font/collection, font/otf, font/ttf, font/woff, font/woff2, image/apng, image/bmp, image/cgm, image/g3fax, image/gif, image/ief, image/jp2, image/jpeg, image/jpm, image/jpx, image/ktx, image/png, image/prs.btif, image/sgi, image/svg+xml, image/tiff, image/vnd.adobe.photoshop, image/vnd.dece.graphic, image/vnd.djvu, image/vnd.dvb.subtitle, image/vnd.dwg, image/vnd.dxf, image/vnd.fastbidsheet, image/vnd.fpx, image/vnd.fst, image/vnd.fujixerox.edmics-mmr, image/vnd.fujixerox.edmics-rlc, image/vnd.ms-modi, image/vnd.ms-photo, image/vnd.net-fpx, image/vnd.wap.wbmp, image/vnd.xiff, image/webp, image/x-3ds, image/x-cmu-raster, image/x-cmx, image/x-freehand, image/x-icon, image/x-jng, image/x-mrsid-image, image/x-ms-bmp, image/x-pcx, image/x-pict, image/x-portable-anymap, image/x-portable-bitmap, image/x-portable-graymap, image/x-portable-pixmap, image/x-rgb, image/x-tga, image/x-xbitmap, image/x-xpixmap, image/x-xwindowdump, message/rfc822, model/gltf+json, model/gltf-binary, model/iges, model/mesh, model/vnd.collada+xml, model/vnd.dwf, model/vnd.gdl, model/vnd.gtw, model/vnd.mts, model/vnd.vtu, model/vrml, model/x3d+binary, model/x3d+vrml, model/x3d+xml, text/cache-manifest, text/calendar, text/coffeescript, text/css, text/csv, text/hjson, text/html, text/jade, text/jsx, text/less, text/markdown, text/mathml, text/n3, text/plain, text/prs.lines.tag, text/richtext, text/rtf, text/sgml, text/slim, text/stylus, text/tab-separated-values, text/troff, text/turtle, text/uri-list, text/vcard, text/vnd.curl, text/vnd.curl.dcurl, text/vnd.curl.mcurl, text/vnd.curl.scurl, text/vnd.dvb.subtitle, text/vnd.fly, text/vnd.fmi.flexstor, text/vnd.graphviz, text/vnd.in3d.3dml, text/vnd.in3d.spot, text/vnd.sun.j2me.app-descriptor, text/vnd.wap.wml, text/vnd.wap.wmlscript, text/vtt, text/x-asm, text/x-c, text/x-component, text/x-fortran, text/x-handlebars-template, text/x-java-source, text/x-lua, text/x-markdown, text/x-nfo, text/x-opml, text/x-org, text/x-pascal, text/x-processing, text/x-sass, text/x-scss, text/x-setext, text/x-sfv, text/x-suse-ymp, text/x-uuencode, text/x-vcalendar, text/x-vcard, text/xml, text/yaml, video/3gpp, video/3gpp2, video/h261, video/h263, video/h264, video/jpeg, video/jpm, video/mj2, video/mp2t, video/mp4, video/mpeg, video/ogg, video/quicktime, video/vnd.dece.hd, video/vnd.dece.mobile, video/vnd.dece.pd, video/vnd.dece.sd, video/vnd.dece.video, video/vnd.dvb.file, video/vnd.fvt, video/vnd.mpegurl, video/vnd.ms-playready.media.pyv, video/vnd.uvvu.mp4, video/vnd.vivo, video/webm, video/x-f4v, video/x-fli, video/x-flv, video/x-m4v, video/x-matroska, video/x-mng, video/x-ms-asf, video/x-ms-vob, video/x-ms-wm, video/x-ms-wmv, video/x-ms-wmx, video/x-ms-wvx, video/x-msvideo, video/x-sgi-movie, video/x-smv, x-conference/x-cooltalk, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"application/andrew-inset\":[\"ez\"],\"application/applixware\":[\"aw\"],\"application/atom+xml\":[\"atom\"],\"application/atomcat+xml\":[\"atomcat\"],\"application/atomsvc+xml\":[\"atomsvc\"],\"application/bdoc\":[\"bdoc\"],\"application/ccxml+xml\":[\"ccxml\"],\"application/cdmi-capability\":[\"cdmia\"],\"application/cdmi-container\":[\"cdmic\"],\"application/cdmi-domain\":[\"cdmid\"],\"application/cdmi-object\":[\"cdmio\"],\"application/cdmi-queue\":[\"cdmiq\"],\"application/cu-seeme\":[\"cu\"],\"application/dash+xml\":[\"mpd\"],\"application/davmount+xml\":[\"davmount\"],\"application/docbook+xml\":[\"dbk\"],\"application/dssc+der\":[\"dssc\"],\"application/dssc+xml\":[\"xdssc\"],\"application/ecmascript\":[\"ecma\"],\"application/emma+xml\":[\"emma\"],\"application/epub+zip\":[\"epub\"],\"application/exi\":[\"exi\"],\"application/font-tdpfr\":[\"pfr\"],\"application/font-woff\":[],\"application/font-woff2\":[],\"application/geo+json\":[\"geojson\"],\"application/gml+xml\":[\"gml\"],\"application/gpx+xml\":[\"gpx\"],\"application/gxf\":[\"gxf\"],\"application/gzip\":[\"gz\"],\"application/hyperstudio\":[\"stk\"],\"application/inkml+xml\":[\"ink\",\"inkml\"],\"application/ipfix\":[\"ipfix\"],\"application/java-archive\":[\"jar\",\"war\",\"ear\"],\"application/java-serialized-object\":[\"ser\"],\"application/java-vm\":[\"class\"],\"application/javascript\":[\"js\",\"mjs\"],\"application/json\":[\"json\",\"map\"],\"application/json5\":[\"json5\"],\"application/jsonml+json\":[\"jsonml\"],\"application/ld+json\":[\"jsonld\"],\"application/lost+xml\":[\"lostxml\"],\"application/mac-binhex40\":[\"hqx\"],\"application/mac-compactpro\":[\"cpt\"],\"application/mads+xml\":[\"mads\"],\"application/manifest+json\":[\"webmanifest\"],\"application/marc\":[\"mrc\"],\"application/marcxml+xml\":[\"mrcx\"],\"application/mathematica\":[\"ma\",\"nb\",\"mb\"],\"application/mathml+xml\":[\"mathml\"],\"application/mbox\":[\"mbox\"],\"application/mediaservercontrol+xml\":[\"mscml\"],\"application/metalink+xml\":[\"metalink\"],\"application/metalink4+xml\":[\"meta4\"],\"application/mets+xml\":[\"mets\"],\"application/mods+xml\":[\"mods\"],\"application/mp21\":[\"m21\",\"mp21\"],\"application/mp4\":[\"mp4s\",\"m4p\"],\"application/msword\":[\"doc\",\"dot\"],\"application/mxf\":[\"mxf\"],\"application/octet-stream\":[\"bin\",\"dms\",\"lrf\",\"mar\",\"so\",\"dist\",\"distz\",\"pkg\",\"bpk\",\"dump\",\"elc\",\"deploy\",\"exe\",\"dll\",\"deb\",\"dmg\",\"iso\",\"img\",\"msi\",\"msp\",\"msm\",\"buffer\"],\"application/oda\":[\"oda\"],\"application/oebps-package+xml\":[\"opf\"],\"application/ogg\":[\"ogx\"],\"application/omdoc+xml\":[\"omdoc\"],\"application/onenote\":[\"onetoc\",\"onetoc2\",\"onetmp\",\"onepkg\"],\"application/oxps\":[\"oxps\"],\"application/patch-ops-error+xml\":[\"xer\"],\"application/pdf\":[\"pdf\"],\"application/pgp-encrypted\":[\"pgp\"],\"application/pgp-signature\":[\"asc\",\"sig\"],\"application/pics-rules\":[\"prf\"],\"application/pkcs10\":[\"p10\"],\"application/pkcs7-mime\":[\"p7m\",\"p7c\"],\"application/pkcs7-signature\":[\"p7s\"],\"application/pkcs8\":[\"p8\"],\"application/pkix-attr-cert\":[\"ac\"],\"application/pkix-cert\":[\"cer\"],\"application/pkix-crl\":[\"crl\"],\"application/pkix-pkipath\":[\"pkipath\"],\"application/pkixcmp\":[\"pki\"],\"application/pls+xml\":[\"pls\"],\"application/postscript\":[\"ai\",\"eps\",\"ps\"],\"application/prs.cww\":[\"cww\"],\"application/pskc+xml\":[\"pskcxml\"],\"application/raml+yaml\":[\"raml\"],\"application/rdf+xml\":[\"rdf\"],\"application/reginfo+xml\":[\"rif\"],\"application/relax-ng-compact-syntax\":[\"rnc\"],\"application/resource-lists+xml\":[\"rl\"],\"application/resource-lists-diff+xml\":[\"rld\"],\"application/rls-services+xml\":[\"rs\"],\"application/rpki-ghostbusters\":[\"gbr\"],\"application/rpki-manifest\":[\"mft\"],\"application/rpki-roa\":[\"roa\"],\"application/rsd+xml\":[\"rsd\"],\"application/rss+xml\":[\"rss\"],\"application/rtf\":[\"rtf\"],\"application/sbml+xml\":[\"sbml\"],\"application/scvp-cv-request\":[\"scq\"],\"application/scvp-cv-response\":[\"scs\"],\"application/scvp-vp-request\":[\"spq\"],\"application/scvp-vp-response\":[\"spp\"],\"application/sdp\":[\"sdp\"],\"application/set-payment-initiation\":[\"setpay\"],\"application/set-registration-initiation\":[\"setreg\"],\"application/shf+xml\":[\"shf\"],\"application/smil+xml\":[\"smi\",\"smil\"],\"application/sparql-query\":[\"rq\"],\"application/sparql-results+xml\":[\"srx\"],\"application/srgs\":[\"gram\"],\"application/srgs+xml\":[\"grxml\"],\"application/sru+xml\":[\"sru\"],\"application/ssdl+xml\":[\"ssdl\"],\"application/ssml+xml\":[\"ssml\"],\"application/tei+xml\":[\"tei\",\"teicorpus\"],\"application/thraud+xml\":[\"tfi\"],\"application/timestamped-data\":[\"tsd\"],\"application/vnd.3gpp.pic-bw-large\":[\"plb\"],\"application/vnd.3gpp.pic-bw-small\":[\"psb\"],\"application/vnd.3gpp.pic-bw-var\":[\"pvb\"],\"application/vnd.3gpp2.tcap\":[\"tcap\"],\"application/vnd.3m.post-it-notes\":[\"pwn\"],\"application/vnd.accpac.simply.aso\":[\"aso\"],\"application/vnd.accpac.simply.imp\":[\"imp\"],\"application/vnd.acucobol\":[\"acu\"],\"application/vnd.acucorp\":[\"atc\",\"acutc\"],\"application/vnd.adobe.air-application-installer-package+zip\":[\"air\"],\"application/vnd.adobe.formscentral.fcdt\":[\"fcdt\"],\"application/vnd.adobe.fxp\":[\"fxp\",\"fxpl\"],\"application/vnd.adobe.xdp+xml\":[\"xdp\"],\"application/vnd.adobe.xfdf\":[\"xfdf\"],\"application/vnd.ahead.space\":[\"ahead\"],\"application/vnd.airzip.filesecure.azf\":[\"azf\"],\"application/vnd.airzip.filesecure.azs\":[\"azs\"],\"application/vnd.amazon.ebook\":[\"azw\"],\"application/vnd.americandynamics.acc\":[\"acc\"],\"application/vnd.amiga.ami\":[\"ami\"],\"application/vnd.android.package-archive\":[\"apk\"],\"application/vnd.anser-web-certificate-issue-initiation\":[\"cii\"],\"application/vnd.anser-web-funds-transfer-initiation\":[\"fti\"],\"application/vnd.antix.game-component\":[\"atx\"],\"application/vnd.apple.installer+xml\":[\"mpkg\"],\"application/vnd.apple.mpegurl\":[\"m3u8\"],\"application/vnd.apple.pkpass\":[\"pkpass\"],\"application/vnd.aristanetworks.swi\":[\"swi\"],\"application/vnd.astraea-software.iota\":[\"iota\"],\"application/vnd.audiograph\":[\"aep\"],\"application/vnd.blueice.multipass\":[\"mpm\"],\"application/vnd.bmi\":[\"bmi\"],\"application/vnd.businessobjects\":[\"rep\"],\"application/vnd.chemdraw+xml\":[\"cdxml\"],\"application/vnd.chipnuts.karaoke-mmd\":[\"mmd\"],\"application/vnd.cinderella\":[\"cdy\"],\"application/vnd.claymore\":[\"cla\"],\"application/vnd.cloanto.rp9\":[\"rp9\"],\"application/vnd.clonk.c4group\":[\"c4g\",\"c4d\",\"c4f\",\"c4p\",\"c4u\"],\"application/vnd.cluetrust.cartomobile-config\":[\"c11amc\"],\"application/vnd.cluetrust.cartomobile-config-pkg\":[\"c11amz\"],\"application/vnd.commonspace\":[\"csp\"],\"application/vnd.contact.cmsg\":[\"cdbcmsg\"],\"application/vnd.cosmocaller\":[\"cmc\"],\"application/vnd.crick.clicker\":[\"clkx\"],\"application/vnd.crick.clicker.keyboard\":[\"clkk\"],\"application/vnd.crick.clicker.palette\":[\"clkp\"],\"application/vnd.crick.clicker.template\":[\"clkt\"],\"application/vnd.crick.clicker.wordbank\":[\"clkw\"],\"application/vnd.criticaltools.wbs+xml\":[\"wbs\"],\"application/vnd.ctc-posml\":[\"pml\"],\"application/vnd.cups-ppd\":[\"ppd\"],\"application/vnd.curl.car\":[\"car\"],\"application/vnd.curl.pcurl\":[\"pcurl\"],\"application/vnd.dart\":[\"dart\"],\"application/vnd.data-vision.rdz\":[\"rdz\"],\"application/vnd.dece.data\":[\"uvf\",\"uvvf\",\"uvd\",\"uvvd\"],\"application/vnd.dece.ttml+xml\":[\"uvt\",\"uvvt\"],\"application/vnd.dece.unspecified\":[\"uvx\",\"uvvx\"],\"application/vnd.dece.zip\":[\"uvz\",\"uvvz\"],\"application/vnd.denovo.fcselayout-link\":[\"fe_launch\"],\"application/vnd.dna\":[\"dna\"],\"application/vnd.dolby.mlp\":[\"mlp\"],\"application/vnd.dpgraph\":[\"dpg\"],\"application/vnd.dreamfactory\":[\"dfac\"],\"application/vnd.ds-keypoint\":[\"kpxx\"],\"application/vnd.dvb.ait\":[\"ait\"],\"application/vnd.dvb.service\":[\"svc\"],\"application/vnd.dynageo\":[\"geo\"],\"application/vnd.ecowin.chart\":[\"mag\"],\"application/vnd.enliven\":[\"nml\"],\"application/vnd.epson.esf\":[\"esf\"],\"application/vnd.epson.msf\":[\"msf\"],\"application/vnd.epson.quickanime\":[\"qam\"],\"application/vnd.epson.salt\":[\"slt\"],\"application/vnd.epson.ssf\":[\"ssf\"],\"application/vnd.eszigno3+xml\":[\"es3\",\"et3\"],\"application/vnd.ezpix-album\":[\"ez2\"],\"application/vnd.ezpix-package\":[\"ez3\"],\"application/vnd.fdf\":[\"fdf\"],\"application/vnd.fdsn.mseed\":[\"mseed\"],\"application/vnd.fdsn.seed\":[\"seed\",\"dataless\"],\"application/vnd.flographit\":[\"gph\"],\"application/vnd.fluxtime.clip\":[\"ftc\"],\"application/vnd.framemaker\":[\"fm\",\"frame\",\"maker\",\"book\"],\"application/vnd.frogans.fnc\":[\"fnc\"],\"application/vnd.frogans.ltf\":[\"ltf\"],\"application/vnd.fsc.weblaunch\":[\"fsc\"],\"application/vnd.fujitsu.oasys\":[\"oas\"],\"application/vnd.fujitsu.oasys2\":[\"oa2\"],\"application/vnd.fujitsu.oasys3\":[\"oa3\"],\"application/vnd.fujitsu.oasysgp\":[\"fg5\"],\"application/vnd.fujitsu.oasysprs\":[\"bh2\"],\"application/vnd.fujixerox.ddd\":[\"ddd\"],\"application/vnd.fujixerox.docuworks\":[\"xdw\"],\"application/vnd.fujixerox.docuworks.binder\":[\"xbd\"],\"application/vnd.fuzzysheet\":[\"fzs\"],\"application/vnd.genomatix.tuxedo\":[\"txd\"],\"application/vnd.geogebra.file\":[\"ggb\"],\"application/vnd.geogebra.tool\":[\"ggt\"],\"application/vnd.geometry-explorer\":[\"gex\",\"gre\"],\"application/vnd.geonext\":[\"gxt\"],\"application/vnd.geoplan\":[\"g2w\"],\"application/vnd.geospace\":[\"g3w\"],\"application/vnd.gmx\":[\"gmx\"],\"application/vnd.google-apps.document\":[\"gdoc\"],\"application/vnd.google-apps.presentation\":[\"gslides\"],\"application/vnd.google-apps.spreadsheet\":[\"gsheet\"],\"application/vnd.google-earth.kml+xml\":[\"kml\"],\"application/vnd.google-earth.kmz\":[\"kmz\"],\"application/vnd.grafeq\":[\"gqf\",\"gqs\"],\"application/vnd.groove-account\":[\"gac\"],\"application/vnd.groove-help\":[\"ghf\"],\"application/vnd.groove-identity-message\":[\"gim\"],\"application/vnd.groove-injector\":[\"grv\"],\"application/vnd.groove-tool-message\":[\"gtm\"],\"application/vnd.groove-tool-template\":[\"tpl\"],\"application/vnd.groove-vcard\":[\"vcg\"],\"application/vnd.hal+xml\":[\"hal\"],\"application/vnd.handheld-entertainment+xml\":[\"zmm\"],\"application/vnd.hbci\":[\"hbci\"],\"application/vnd.hhe.lesson-player\":[\"les\"],\"application/vnd.hp-hpgl\":[\"hpgl\"],\"application/vnd.hp-hpid\":[\"hpid\"],\"application/vnd.hp-hps\":[\"hps\"],\"application/vnd.hp-jlyt\":[\"jlt\"],\"application/vnd.hp-pcl\":[\"pcl\"],\"application/vnd.hp-pclxl\":[\"pclxl\"],\"application/vnd.hydrostatix.sof-data\":[\"sfd-hdstx\"],\"application/vnd.ibm.minipay\":[\"mpy\"],\"application/vnd.ibm.modcap\":[\"afp\",\"listafp\",\"list3820\"],\"application/vnd.ibm.rights-management\":[\"irm\"],\"application/vnd.ibm.secure-container\":[\"sc\"],\"application/vnd.iccprofile\":[\"icc\",\"icm\"],\"application/vnd.igloader\":[\"igl\"],\"application/vnd.immervision-ivp\":[\"ivp\"],\"application/vnd.immervision-ivu\":[\"ivu\"],\"application/vnd.insors.igm\":[\"igm\"],\"application/vnd.intercon.formnet\":[\"xpw\",\"xpx\"],\"application/vnd.intergeo\":[\"i2g\"],\"application/vnd.intu.qbo\":[\"qbo\"],\"application/vnd.intu.qfx\":[\"qfx\"],\"application/vnd.ipunplugged.rcprofile\":[\"rcprofile\"],\"application/vnd.irepository.package+xml\":[\"irp\"],\"application/vnd.is-xpr\":[\"xpr\"],\"application/vnd.isac.fcs\":[\"fcs\"],\"application/vnd.jam\":[\"jam\"],\"application/vnd.jcp.javame.midlet-rms\":[\"rms\"],\"application/vnd.jisp\":[\"jisp\"],\"application/vnd.joost.joda-archive\":[\"joda\"],\"application/vnd.kahootz\":[\"ktz\",\"ktr\"],\"application/vnd.kde.karbon\":[\"karbon\"],\"application/vnd.kde.kchart\":[\"chrt\"],\"application/vnd.kde.kformula\":[\"kfo\"],\"application/vnd.kde.kivio\":[\"flw\"],\"application/vnd.kde.kontour\":[\"kon\"],\"application/vnd.kde.kpresenter\":[\"kpr\",\"kpt\"],\"application/vnd.kde.kspread\":[\"ksp\"],\"application/vnd.kde.kword\":[\"kwd\",\"kwt\"],\"application/vnd.kenameaapp\":[\"htke\"],\"application/vnd.kidspiration\":[\"kia\"],\"application/vnd.kinar\":[\"kne\",\"knp\"],\"application/vnd.koan\":[\"skp\",\"skd\",\"skt\",\"skm\"],\"application/vnd.kodak-descriptor\":[\"sse\"],\"application/vnd.las.las+xml\":[\"lasxml\"],\"application/vnd.llamagraphics.life-balance.desktop\":[\"lbd\"],\"application/vnd.llamagraphics.life-balance.exchange+xml\":[\"lbe\"],\"application/vnd.lotus-1-2-3\":[\"123\"],\"application/vnd.lotus-approach\":[\"apr\"],\"application/vnd.lotus-freelance\":[\"pre\"],\"application/vnd.lotus-notes\":[\"nsf\"],\"application/vnd.lotus-organizer\":[\"org\"],\"application/vnd.lotus-screencam\":[\"scm\"],\"application/vnd.lotus-wordpro\":[\"lwp\"],\"application/vnd.macports.portpkg\":[\"portpkg\"],\"application/vnd.mcd\":[\"mcd\"],\"application/vnd.medcalcdata\":[\"mc1\"],\"application/vnd.mediastation.cdkey\":[\"cdkey\"],\"application/vnd.mfer\":[\"mwf\"],\"application/vnd.mfmp\":[\"mfm\"],\"application/vnd.micrografx.flo\":[\"flo\"],\"application/vnd.micrografx.igx\":[\"igx\"],\"application/vnd.mif\":[\"mif\"],\"application/vnd.mobius.daf\":[\"daf\"],\"application/vnd.mobius.dis\":[\"dis\"],\"application/vnd.mobius.mbk\":[\"mbk\"],\"application/vnd.mobius.mqy\":[\"mqy\"],\"application/vnd.mobius.msl\":[\"msl\"],\"application/vnd.mobius.plc\":[\"plc\"],\"application/vnd.mobius.txf\":[\"txf\"],\"application/vnd.mophun.application\":[\"mpn\"],\"application/vnd.mophun.certificate\":[\"mpc\"],\"application/vnd.mozilla.xul+xml\":[\"xul\"],\"application/vnd.ms-artgalry\":[\"cil\"],\"application/vnd.ms-cab-compressed\":[\"cab\"],\"application/vnd.ms-excel\":[\"xls\",\"xlm\",\"xla\",\"xlc\",\"xlt\",\"xlw\"],\"application/vnd.ms-excel.addin.macroenabled.12\":[\"xlam\"],\"application/vnd.ms-excel.sheet.binary.macroenabled.12\":[\"xlsb\"],\"application/vnd.ms-excel.sheet.macroenabled.12\":[\"xlsm\"],\"application/vnd.ms-excel.template.macroenabled.12\":[\"xltm\"],\"application/vnd.ms-fontobject\":[\"eot\"],\"application/vnd.ms-htmlhelp\":[\"chm\"],\"application/vnd.ms-ims\":[\"ims\"],\"application/vnd.ms-lrm\":[\"lrm\"],\"application/vnd.ms-officetheme\":[\"thmx\"],\"application/vnd.ms-outlook\":[\"msg\"],\"application/vnd.ms-pki.seccat\":[\"cat\"],\"application/vnd.ms-pki.stl\":[\"stl\"],\"application/vnd.ms-powerpoint\":[\"ppt\",\"pps\",\"pot\"],\"application/vnd.ms-powerpoint.addin.macroenabled.12\":[\"ppam\"],\"application/vnd.ms-powerpoint.presentation.macroenabled.12\":[\"pptm\"],\"application/vnd.ms-powerpoint.slide.macroenabled.12\":[\"sldm\"],\"application/vnd.ms-powerpoint.slideshow.macroenabled.12\":[\"ppsm\"],\"application/vnd.ms-powerpoint.template.macroenabled.12\":[\"potm\"],\"application/vnd.ms-project\":[\"mpp\",\"mpt\"],\"application/vnd.ms-word.document.macroenabled.12\":[\"docm\"],\"application/vnd.ms-word.template.macroenabled.12\":[\"dotm\"],\"application/vnd.ms-works\":[\"wps\",\"wks\",\"wcm\",\"wdb\"],\"application/vnd.ms-wpl\":[\"wpl\"],\"application/vnd.ms-xpsdocument\":[\"xps\"],\"application/vnd.mseq\":[\"mseq\"],\"application/vnd.musician\":[\"mus\"],\"application/vnd.muvee.style\":[\"msty\"],\"application/vnd.mynfc\":[\"taglet\"],\"application/vnd.neurolanguage.nlu\":[\"nlu\"],\"application/vnd.nitf\":[\"ntf\",\"nitf\"],\"application/vnd.noblenet-directory\":[\"nnd\"],\"application/vnd.noblenet-sealer\":[\"nns\"],\"application/vnd.noblenet-web\":[\"nnw\"],\"application/vnd.nokia.n-gage.data\":[\"ngdat\"],\"application/vnd.nokia.n-gage.symbian.install\":[\"n-gage\"],\"application/vnd.nokia.radio-preset\":[\"rpst\"],\"application/vnd.nokia.radio-presets\":[\"rpss\"],\"application/vnd.novadigm.edm\":[\"edm\"],\"application/vnd.novadigm.edx\":[\"edx\"],\"application/vnd.novadigm.ext\":[\"ext\"],\"application/vnd.oasis.opendocument.chart\":[\"odc\"],\"application/vnd.oasis.opendocument.chart-template\":[\"otc\"],\"application/vnd.oasis.opendocument.database\":[\"odb\"],\"application/vnd.oasis.opendocument.formula\":[\"odf\"],\"application/vnd.oasis.opendocument.formula-template\":[\"odft\"],\"application/vnd.oasis.opendocument.graphics\":[\"odg\"],\"application/vnd.oasis.opendocument.graphics-template\":[\"otg\"],\"application/vnd.oasis.opendocument.image\":[\"odi\"],\"application/vnd.oasis.opendocument.image-template\":[\"oti\"],\"application/vnd.oasis.opendocument.presentation\":[\"odp\"],\"application/vnd.oasis.opendocument.presentation-template\":[\"otp\"],\"application/vnd.oasis.opendocument.spreadsheet\":[\"ods\"],\"application/vnd.oasis.opendocument.spreadsheet-template\":[\"ots\"],\"application/vnd.oasis.opendocument.text\":[\"odt\"],\"application/vnd.oasis.opendocument.text-master\":[\"odm\"],\"application/vnd.oasis.opendocument.text-template\":[\"ott\"],\"application/vnd.oasis.opendocument.text-web\":[\"oth\"],\"application/vnd.olpc-sugar\":[\"xo\"],\"application/vnd.oma.dd2+xml\":[\"dd2\"],\"application/vnd.openofficeorg.extension\":[\"oxt\"],\"application/vnd.openxmlformats-officedocument.presentationml.presentation\":[\"pptx\"],\"application/vnd.openxmlformats-officedocument.presentationml.slide\":[\"sldx\"],\"application/vnd.openxmlformats-officedocument.presentationml.slideshow\":[\"ppsx\"],\"application/vnd.openxmlformats-officedocument.presentationml.template\":[\"potx\"],\"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\":[\"xlsx\"],\"application/vnd.openxmlformats-officedocument.spreadsheetml.template\":[\"xltx\"],\"application/vnd.openxmlformats-officedocument.wordprocessingml.document\":[\"docx\"],\"application/vnd.openxmlformats-officedocument.wordprocessingml.template\":[\"dotx\"],\"application/vnd.osgeo.mapguide.package\":[\"mgp\"],\"application/vnd.osgi.dp\":[\"dp\"],\"application/vnd.osgi.subsystem\":[\"esa\"],\"application/vnd.palm\":[\"pdb\",\"pqa\",\"oprc\"],\"application/vnd.pawaafile\":[\"paw\"],\"application/vnd.pg.format\":[\"str\"],\"application/vnd.pg.osasli\":[\"ei6\"],\"application/vnd.picsel\":[\"efif\"],\"application/vnd.pmi.widget\":[\"wg\"],\"application/vnd.pocketlearn\":[\"plf\"],\"application/vnd.powerbuilder6\":[\"pbd\"],\"application/vnd.previewsystems.box\":[\"box\"],\"application/vnd.proteus.magazine\":[\"mgz\"],\"application/vnd.publishare-delta-tree\":[\"qps\"],\"application/vnd.pvi.ptid1\":[\"ptid\"],\"application/vnd.quark.quarkxpress\":[\"qxd\",\"qxt\",\"qwd\",\"qwt\",\"qxl\",\"qxb\"],\"application/vnd.realvnc.bed\":[\"bed\"],\"application/vnd.recordare.musicxml\":[\"mxl\"],\"application/vnd.recordare.musicxml+xml\":[\"musicxml\"],\"application/vnd.rig.cryptonote\":[\"cryptonote\"],\"application/vnd.rim.cod\":[\"cod\"],\"application/vnd.rn-realmedia\":[\"rm\"],\"application/vnd.rn-realmedia-vbr\":[\"rmvb\"],\"application/vnd.route66.link66+xml\":[\"link66\"],\"application/vnd.sailingtracker.track\":[\"st\"],\"application/vnd.seemail\":[\"see\"],\"application/vnd.sema\":[\"sema\"],\"application/vnd.semd\":[\"semd\"],\"application/vnd.semf\":[\"semf\"],\"application/vnd.shana.informed.formdata\":[\"ifm\"],\"application/vnd.shana.informed.formtemplate\":[\"itp\"],\"application/vnd.shana.informed.interchange\":[\"iif\"],\"application/vnd.shana.informed.package\":[\"ipk\"],\"application/vnd.simtech-mindmapper\":[\"twd\",\"twds\"],\"application/vnd.smaf\":[\"mmf\"],\"application/vnd.smart.teacher\":[\"teacher\"],\"application/vnd.solent.sdkm+xml\":[\"sdkm\",\"sdkd\"],\"application/vnd.spotfire.dxp\":[\"dxp\"],\"application/vnd.spotfire.sfs\":[\"sfs\"],\"application/vnd.stardivision.calc\":[\"sdc\"],\"application/vnd.stardivision.draw\":[\"sda\"],\"application/vnd.stardivision.impress\":[\"sdd\"],\"application/vnd.stardivision.math\":[\"smf\"],\"application/vnd.stardivision.writer\":[\"sdw\",\"vor\"],\"application/vnd.stardivision.writer-global\":[\"sgl\"],\"application/vnd.stepmania.package\":[\"smzip\"],\"application/vnd.stepmania.stepchart\":[\"sm\"],\"application/vnd.sun.wadl+xml\":[\"wadl\"],\"application/vnd.sun.xml.calc\":[\"sxc\"],\"application/vnd.sun.xml.calc.template\":[\"stc\"],\"application/vnd.sun.xml.draw\":[\"sxd\"],\"application/vnd.sun.xml.draw.template\":[\"std\"],\"application/vnd.sun.xml.impress\":[\"sxi\"],\"application/vnd.sun.xml.impress.template\":[\"sti\"],\"application/vnd.sun.xml.math\":[\"sxm\"],\"application/vnd.sun.xml.writer\":[\"sxw\"],\"application/vnd.sun.xml.writer.global\":[\"sxg\"],\"application/vnd.sun.xml.writer.template\":[\"stw\"],\"application/vnd.sus-calendar\":[\"sus\",\"susp\"],\"application/vnd.svd\":[\"svd\"],\"application/vnd.symbian.install\":[\"sis\",\"sisx\"],\"application/vnd.syncml+xml\":[\"xsm\"],\"application/vnd.syncml.dm+wbxml\":[\"bdm\"],\"application/vnd.syncml.dm+xml\":[\"xdm\"],\"application/vnd.tao.intent-module-archive\":[\"tao\"],\"application/vnd.tcpdump.pcap\":[\"pcap\",\"cap\",\"dmp\"],\"application/vnd.tmobile-livetv\":[\"tmo\"],\"application/vnd.trid.tpt\":[\"tpt\"],\"application/vnd.triscape.mxs\":[\"mxs\"],\"application/vnd.trueapp\":[\"tra\"],\"application/vnd.ufdl\":[\"ufd\",\"ufdl\"],\"application/vnd.uiq.theme\":[\"utz\"],\"application/vnd.umajin\":[\"umj\"],\"application/vnd.unity\":[\"unityweb\"],\"application/vnd.uoml+xml\":[\"uoml\"],\"application/vnd.vcx\":[\"vcx\"],\"application/vnd.visio\":[\"vsd\",\"vst\",\"vss\",\"vsw\"],\"application/vnd.visionary\":[\"vis\"],\"application/vnd.vsf\":[\"vsf\"],\"application/vnd.wap.wbxml\":[\"wbxml\"],\"application/vnd.wap.wmlc\":[\"wmlc\"],\"application/vnd.wap.wmlscriptc\":[\"wmlsc\"],\"application/vnd.webturbo\":[\"wtb\"],\"application/vnd.wolfram.player\":[\"nbp\"],\"application/vnd.wordperfect\":[\"wpd\"],\"application/vnd.wqd\":[\"wqd\"],\"application/vnd.wt.stf\":[\"stf\"],\"application/vnd.xara\":[\"xar\"],\"application/vnd.xfdl\":[\"xfdl\"],\"application/vnd.yamaha.hv-dic\":[\"hvd\"],\"application/vnd.yamaha.hv-script\":[\"hvs\"],\"application/vnd.yamaha.hv-voice\":[\"hvp\"],\"application/vnd.yamaha.openscoreformat\":[\"osf\"],\"application/vnd.yamaha.openscoreformat.osfpvg+xml\":[\"osfpvg\"],\"application/vnd.yamaha.smaf-audio\":[\"saf\"],\"application/vnd.yamaha.smaf-phrase\":[\"spf\"],\"application/vnd.yellowriver-custom-menu\":[\"cmp\"],\"application/vnd.zul\":[\"zir\",\"zirz\"],\"application/vnd.zzazz.deck+xml\":[\"zaz\"],\"application/voicexml+xml\":[\"vxml\"],\"application/wasm\":[\"wasm\"],\"application/widget\":[\"wgt\"],\"application/winhlp\":[\"hlp\"],\"application/wsdl+xml\":[\"wsdl\"],\"application/wspolicy+xml\":[\"wspolicy\"],\"application/x-7z-compressed\":[\"7z\"],\"application/x-abiword\":[\"abw\"],\"application/x-ace-compressed\":[\"ace\"],\"application/x-apple-diskimage\":[],\"application/x-arj\":[\"arj\"],\"application/x-authorware-bin\":[\"aab\",\"x32\",\"u32\",\"vox\"],\"application/x-authorware-map\":[\"aam\"],\"application/x-authorware-seg\":[\"aas\"],\"application/x-bcpio\":[\"bcpio\"],\"application/x-bdoc\":[],\"application/x-bittorrent\":[\"torrent\"],\"application/x-blorb\":[\"blb\",\"blorb\"],\"application/x-bzip\":[\"bz\"],\"application/x-bzip2\":[\"bz2\",\"boz\"],\"application/x-cbr\":[\"cbr\",\"cba\",\"cbt\",\"cbz\",\"cb7\"],\"application/x-cdlink\":[\"vcd\"],\"application/x-cfs-compressed\":[\"cfs\"],\"application/x-chat\":[\"chat\"],\"application/x-chess-pgn\":[\"pgn\"],\"application/x-chrome-extension\":[\"crx\"],\"application/x-cocoa\":[\"cco\"],\"application/x-conference\":[\"nsc\"],\"application/x-cpio\":[\"cpio\"],\"application/x-csh\":[\"csh\"],\"application/x-debian-package\":[\"udeb\"],\"application/x-dgc-compressed\":[\"dgc\"],\"application/x-director\":[\"dir\",\"dcr\",\"dxr\",\"cst\",\"cct\",\"cxt\",\"w3d\",\"fgd\",\"swa\"],\"application/x-doom\":[\"wad\"],\"application/x-dtbncx+xml\":[\"ncx\"],\"application/x-dtbook+xml\":[\"dtb\"],\"application/x-dtbresource+xml\":[\"res\"],\"application/x-dvi\":[\"dvi\"],\"application/x-envoy\":[\"evy\"],\"application/x-eva\":[\"eva\"],\"application/x-font-bdf\":[\"bdf\"],\"application/x-font-ghostscript\":[\"gsf\"],\"application/x-font-linux-psf\":[\"psf\"],\"application/x-font-pcf\":[\"pcf\"],\"application/x-font-snf\":[\"snf\"],\"application/x-font-type1\":[\"pfa\",\"pfb\",\"pfm\",\"afm\"],\"application/x-freearc\":[\"arc\"],\"application/x-futuresplash\":[\"spl\"],\"application/x-gca-compressed\":[\"gca\"],\"application/x-glulx\":[\"ulx\"],\"application/x-gnumeric\":[\"gnumeric\"],\"application/x-gramps-xml\":[\"gramps\"],\"application/x-gtar\":[\"gtar\"],\"application/x-hdf\":[\"hdf\"],\"application/x-httpd-php\":[\"php\"],\"application/x-install-instructions\":[\"install\"],\"application/x-iso9660-image\":[],\"application/x-java-archive-diff\":[\"jardiff\"],\"application/x-java-jnlp-file\":[\"jnlp\"],\"application/x-latex\":[\"latex\"],\"application/x-lua-bytecode\":[\"luac\"],\"application/x-lzh-compressed\":[\"lzh\",\"lha\"],\"application/x-makeself\":[\"run\"],\"application/x-mie\":[\"mie\"],\"application/x-mobipocket-ebook\":[\"prc\",\"mobi\"],\"application/x-ms-application\":[\"application\"],\"application/x-ms-shortcut\":[\"lnk\"],\"application/x-ms-wmd\":[\"wmd\"],\"application/x-ms-wmz\":[\"wmz\"],\"application/x-ms-xbap\":[\"xbap\"],\"application/x-msaccess\":[\"mdb\"],\"application/x-msbinder\":[\"obd\"],\"application/x-mscardfile\":[\"crd\"],\"application/x-msclip\":[\"clp\"],\"application/x-msdos-program\":[],\"application/x-msdownload\":[\"com\",\"bat\"],\"application/x-msmediaview\":[\"mvb\",\"m13\",\"m14\"],\"application/x-msmetafile\":[\"wmf\",\"emf\",\"emz\"],\"application/x-msmoney\":[\"mny\"],\"application/x-mspublisher\":[\"pub\"],\"application/x-msschedule\":[\"scd\"],\"application/x-msterminal\":[\"trm\"],\"application/x-mswrite\":[\"wri\"],\"application/x-netcdf\":[\"nc\",\"cdf\"],\"application/x-ns-proxy-autoconfig\":[\"pac\"],\"application/x-nzb\":[\"nzb\"],\"application/x-perl\":[\"pl\",\"pm\"],\"application/x-pilot\":[],\"application/x-pkcs12\":[\"p12\",\"pfx\"],\"application/x-pkcs7-certificates\":[\"p7b\",\"spc\"],\"application/x-pkcs7-certreqresp\":[\"p7r\"],\"application/x-rar-compressed\":[\"rar\"],\"application/x-redhat-package-manager\":[\"rpm\"],\"application/x-research-info-systems\":[\"ris\"],\"application/x-sea\":[\"sea\"],\"application/x-sh\":[\"sh\"],\"application/x-shar\":[\"shar\"],\"application/x-shockwave-flash\":[\"swf\"],\"application/x-silverlight-app\":[\"xap\"],\"application/x-sql\":[\"sql\"],\"application/x-stuffit\":[\"sit\"],\"application/x-stuffitx\":[\"sitx\"],\"application/x-subrip\":[\"srt\"],\"application/x-sv4cpio\":[\"sv4cpio\"],\"application/x-sv4crc\":[\"sv4crc\"],\"application/x-t3vm-image\":[\"t3\"],\"application/x-tads\":[\"gam\"],\"application/x-tar\":[\"tar\"],\"application/x-tcl\":[\"tcl\",\"tk\"],\"application/x-tex\":[\"tex\"],\"application/x-tex-tfm\":[\"tfm\"],\"application/x-texinfo\":[\"texinfo\",\"texi\"],\"application/x-tgif\":[\"obj\"],\"application/x-ustar\":[\"ustar\"],\"application/x-virtualbox-hdd\":[\"hdd\"],\"application/x-virtualbox-ova\":[\"ova\"],\"application/x-virtualbox-ovf\":[\"ovf\"],\"application/x-virtualbox-vbox\":[\"vbox\"],\"application/x-virtualbox-vbox-extpack\":[\"vbox-extpack\"],\"application/x-virtualbox-vdi\":[\"vdi\"],\"application/x-virtualbox-vhd\":[\"vhd\"],\"application/x-virtualbox-vmdk\":[\"vmdk\"],\"application/x-wais-source\":[\"src\"],\"application/x-web-app-manifest+json\":[\"webapp\"],\"application/x-x509-ca-cert\":[\"der\",\"crt\",\"pem\"],\"application/x-xfig\":[\"fig\"],\"application/x-xliff+xml\":[\"xlf\"],\"application/x-xpinstall\":[\"xpi\"],\"application/x-xz\":[\"xz\"],\"application/x-zmachine\":[\"z1\",\"z2\",\"z3\",\"z4\",\"z5\",\"z6\",\"z7\",\"z8\"],\"application/xaml+xml\":[\"xaml\"],\"application/xcap-diff+xml\":[\"xdf\"],\"application/xenc+xml\":[\"xenc\"],\"application/xhtml+xml\":[\"xhtml\",\"xht\"],\"application/xml\":[\"xml\",\"xsl\",\"xsd\",\"rng\"],\"application/xml-dtd\":[\"dtd\"],\"application/xop+xml\":[\"xop\"],\"application/xproc+xml\":[\"xpl\"],\"application/xslt+xml\":[\"xslt\"],\"application/xspf+xml\":[\"xspf\"],\"application/xv+xml\":[\"mxml\",\"xhvml\",\"xvml\",\"xvm\"],\"application/yang\":[\"yang\"],\"application/yin+xml\":[\"yin\"],\"application/zip\":[\"zip\"],\"audio/3gpp\":[],\"audio/adpcm\":[\"adp\"],\"audio/basic\":[\"au\",\"snd\"],\"audio/midi\":[\"mid\",\"midi\",\"kar\",\"rmi\"],\"audio/mp3\":[],\"audio/mp4\":[\"m4a\",\"mp4a\"],\"audio/mpeg\":[\"mpga\",\"mp2\",\"mp2a\",\"mp3\",\"m2a\",\"m3a\"],\"audio/ogg\":[\"oga\",\"ogg\",\"spx\"],\"audio/s3m\":[\"s3m\"],\"audio/silk\":[\"sil\"],\"audio/vnd.dece.audio\":[\"uva\",\"uvva\"],\"audio/vnd.digital-winds\":[\"eol\"],\"audio/vnd.dra\":[\"dra\"],\"audio/vnd.dts\":[\"dts\"],\"audio/vnd.dts.hd\":[\"dtshd\"],\"audio/vnd.lucent.voice\":[\"lvp\"],\"audio/vnd.ms-playready.media.pya\":[\"pya\"],\"audio/vnd.nuera.ecelp4800\":[\"ecelp4800\"],\"audio/vnd.nuera.ecelp7470\":[\"ecelp7470\"],\"audio/vnd.nuera.ecelp9600\":[\"ecelp9600\"],\"audio/vnd.rip\":[\"rip\"],\"audio/wav\":[\"wav\"],\"audio/wave\":[],\"audio/webm\":[\"weba\"],\"audio/x-aac\":[\"aac\"],\"audio/x-aiff\":[\"aif\",\"aiff\",\"aifc\"],\"audio/x-caf\":[\"caf\"],\"audio/x-flac\":[\"flac\"],\"audio/x-m4a\":[],\"audio/x-matroska\":[\"mka\"],\"audio/x-mpegurl\":[\"m3u\"],\"audio/x-ms-wax\":[\"wax\"],\"audio/x-ms-wma\":[\"wma\"],\"audio/x-pn-realaudio\":[\"ram\",\"ra\"],\"audio/x-pn-realaudio-plugin\":[\"rmp\"],\"audio/x-realaudio\":[],\"audio/x-wav\":[],\"audio/xm\":[\"xm\"],\"chemical/x-cdx\":[\"cdx\"],\"chemical/x-cif\":[\"cif\"],\"chemical/x-cmdf\":[\"cmdf\"],\"chemical/x-cml\":[\"cml\"],\"chemical/x-csml\":[\"csml\"],\"chemical/x-xyz\":[\"xyz\"],\"font/collection\":[\"ttc\"],\"font/otf\":[\"otf\"],\"font/ttf\":[\"ttf\"],\"font/woff\":[\"woff\"],\"font/woff2\":[\"woff2\"],\"image/apng\":[\"apng\"],\"image/bmp\":[\"bmp\"],\"image/cgm\":[\"cgm\"],\"image/g3fax\":[\"g3\"],\"image/gif\":[\"gif\"],\"image/ief\":[\"ief\"],\"image/jp2\":[\"jp2\",\"jpg2\"],\"image/jpeg\":[\"jpeg\",\"jpg\",\"jpe\"],\"image/jpm\":[\"jpm\"],\"image/jpx\":[\"jpx\",\"jpf\"],\"image/ktx\":[\"ktx\"],\"image/png\":[\"png\"],\"image/prs.btif\":[\"btif\"],\"image/sgi\":[\"sgi\"],\"image/svg+xml\":[\"svg\",\"svgz\"],\"image/tiff\":[\"tiff\",\"tif\"],\"image/vnd.adobe.photoshop\":[\"psd\"],\"image/vnd.dece.graphic\":[\"uvi\",\"uvvi\",\"uvg\",\"uvvg\"],\"image/vnd.djvu\":[\"djvu\",\"djv\"],\"image/vnd.dvb.subtitle\":[],\"image/vnd.dwg\":[\"dwg\"],\"image/vnd.dxf\":[\"dxf\"],\"image/vnd.fastbidsheet\":[\"fbs\"],\"image/vnd.fpx\":[\"fpx\"],\"image/vnd.fst\":[\"fst\"],\"image/vnd.fujixerox.edmics-mmr\":[\"mmr\"],\"image/vnd.fujixerox.edmics-rlc\":[\"rlc\"],\"image/vnd.ms-modi\":[\"mdi\"],\"image/vnd.ms-photo\":[\"wdp\"],\"image/vnd.net-fpx\":[\"npx\"],\"image/vnd.wap.wbmp\":[\"wbmp\"],\"image/vnd.xiff\":[\"xif\"],\"image/webp\":[\"webp\"],\"image/x-3ds\":[\"3ds\"],\"image/x-cmu-raster\":[\"ras\"],\"image/x-cmx\":[\"cmx\"],\"image/x-freehand\":[\"fh\",\"fhc\",\"fh4\",\"fh5\",\"fh7\"],\"image/x-icon\":[\"ico\"],\"image/x-jng\":[\"jng\"],\"image/x-mrsid-image\":[\"sid\"],\"image/x-ms-bmp\":[],\"image/x-pcx\":[\"pcx\"],\"image/x-pict\":[\"pic\",\"pct\"],\"image/x-portable-anymap\":[\"pnm\"],\"image/x-portable-bitmap\":[\"pbm\"],\"image/x-portable-graymap\":[\"pgm\"],\"image/x-portable-pixmap\":[\"ppm\"],\"image/x-rgb\":[\"rgb\"],\"image/x-tga\":[\"tga\"],\"image/x-xbitmap\":[\"xbm\"],\"image/x-xpixmap\":[\"xpm\"],\"image/x-xwindowdump\":[\"xwd\"],\"message/rfc822\":[\"eml\",\"mime\"],\"model/gltf+json\":[\"gltf\"],\"model/gltf-binary\":[\"glb\"],\"model/iges\":[\"igs\",\"iges\"],\"model/mesh\":[\"msh\",\"mesh\",\"silo\"],\"model/vnd.collada+xml\":[\"dae\"],\"model/vnd.dwf\":[\"dwf\"],\"model/vnd.gdl\":[\"gdl\"],\"model/vnd.gtw\":[\"gtw\"],\"model/vnd.mts\":[\"mts\"],\"model/vnd.vtu\":[\"vtu\"],\"model/vrml\":[\"wrl\",\"vrml\"],\"model/x3d+binary\":[\"x3db\",\"x3dbz\"],\"model/x3d+vrml\":[\"x3dv\",\"x3dvz\"],\"model/x3d+xml\":[\"x3d\",\"x3dz\"],\"text/cache-manifest\":[\"appcache\",\"manifest\"],\"text/calendar\":[\"ics\",\"ifb\"],\"text/coffeescript\":[\"coffee\",\"litcoffee\"],\"text/css\":[\"css\"],\"text/csv\":[\"csv\"],\"text/hjson\":[\"hjson\"],\"text/html\":[\"html\",\"htm\",\"shtml\"],\"text/jade\":[\"jade\"],\"text/jsx\":[\"jsx\"],\"text/less\":[\"less\"],\"text/markdown\":[\"markdown\",\"md\"],\"text/mathml\":[\"mml\"],\"text/n3\":[\"n3\"],\"text/plain\":[\"txt\",\"text\",\"conf\",\"def\",\"list\",\"log\",\"in\",\"ini\"],\"text/prs.lines.tag\":[\"dsc\"],\"text/richtext\":[\"rtx\"],\"text/rtf\":[],\"text/sgml\":[\"sgml\",\"sgm\"],\"text/slim\":[\"slim\",\"slm\"],\"text/stylus\":[\"stylus\",\"styl\"],\"text/tab-separated-values\":[\"tsv\"],\"text/troff\":[\"t\",\"tr\",\"roff\",\"man\",\"me\",\"ms\"],\"text/turtle\":[\"ttl\"],\"text/uri-list\":[\"uri\",\"uris\",\"urls\"],\"text/vcard\":[\"vcard\"],\"text/vnd.curl\":[\"curl\"],\"text/vnd.curl.dcurl\":[\"dcurl\"],\"text/vnd.curl.mcurl\":[\"mcurl\"],\"text/vnd.curl.scurl\":[\"scurl\"],\"text/vnd.dvb.subtitle\":[\"sub\"],\"text/vnd.fly\":[\"fly\"],\"text/vnd.fmi.flexstor\":[\"flx\"],\"text/vnd.graphviz\":[\"gv\"],\"text/vnd.in3d.3dml\":[\"3dml\"],\"text/vnd.in3d.spot\":[\"spot\"],\"text/vnd.sun.j2me.app-descriptor\":[\"jad\"],\"text/vnd.wap.wml\":[\"wml\"],\"text/vnd.wap.wmlscript\":[\"wmls\"],\"text/vtt\":[\"vtt\"],\"text/x-asm\":[\"s\",\"asm\"],\"text/x-c\":[\"c\",\"cc\",\"cxx\",\"cpp\",\"h\",\"hh\",\"dic\"],\"text/x-component\":[\"htc\"],\"text/x-fortran\":[\"f\",\"for\",\"f77\",\"f90\"],\"text/x-handlebars-template\":[\"hbs\"],\"text/x-java-source\":[\"java\"],\"text/x-lua\":[\"lua\"],\"text/x-markdown\":[\"mkd\"],\"text/x-nfo\":[\"nfo\"],\"text/x-opml\":[\"opml\"],\"text/x-org\":[],\"text/x-pascal\":[\"p\",\"pas\"],\"text/x-processing\":[\"pde\"],\"text/x-sass\":[\"sass\"],\"text/x-scss\":[\"scss\"],\"text/x-setext\":[\"etx\"],\"text/x-sfv\":[\"sfv\"],\"text/x-suse-ymp\":[\"ymp\"],\"text/x-uuencode\":[\"uu\"],\"text/x-vcalendar\":[\"vcs\"],\"text/x-vcard\":[\"vcf\"],\"text/xml\":[],\"text/yaml\":[\"yaml\",\"yml\"],\"video/3gpp\":[\"3gp\",\"3gpp\"],\"video/3gpp2\":[\"3g2\"],\"video/h261\":[\"h261\"],\"video/h263\":[\"h263\"],\"video/h264\":[\"h264\"],\"video/jpeg\":[\"jpgv\"],\"video/jpm\":[\"jpgm\"],\"video/mj2\":[\"mj2\",\"mjp2\"],\"video/mp2t\":[\"ts\"],\"video/mp4\":[\"mp4\",\"mp4v\",\"mpg4\"],\"video/mpeg\":[\"mpeg\",\"mpg\",\"mpe\",\"m1v\",\"m2v\"],\"video/ogg\":[\"ogv\"],\"video/quicktime\":[\"qt\",\"mov\"],\"video/vnd.dece.hd\":[\"uvh\",\"uvvh\"],\"video/vnd.dece.mobile\":[\"uvm\",\"uvvm\"],\"video/vnd.dece.pd\":[\"uvp\",\"uvvp\"],\"video/vnd.dece.sd\":[\"uvs\",\"uvvs\"],\"video/vnd.dece.video\":[\"uvv\",\"uvvv\"],\"video/vnd.dvb.file\":[\"dvb\"],\"video/vnd.fvt\":[\"fvt\"],\"video/vnd.mpegurl\":[\"mxu\",\"m4u\"],\"video/vnd.ms-playready.media.pyv\":[\"pyv\"],\"video/vnd.uvvu.mp4\":[\"uvu\",\"uvvu\"],\"video/vnd.vivo\":[\"viv\"],\"video/webm\":[\"webm\"],\"video/x-f4v\":[\"f4v\"],\"video/x-fli\":[\"fli\"],\"video/x-flv\":[\"flv\"],\"video/x-m4v\":[\"m4v\"],\"video/x-matroska\":[\"mkv\",\"mk3d\",\"mks\"],\"video/x-mng\":[\"mng\"],\"video/x-ms-asf\":[\"asf\",\"asx\"],\"video/x-ms-vob\":[\"vob\"],\"video/x-ms-wm\":[\"wm\"],\"video/x-ms-wmv\":[\"wmv\"],\"video/x-ms-wmx\":[\"wmx\"],\"video/x-ms-wvx\":[\"wvx\"],\"video/x-msvideo\":[\"avi\"],\"video/x-sgi-movie\":[\"movie\"],\"video/x-smv\":[\"smv\"],\"x-conference/x-cooltalk\":[\"ice\"]}");

/***/ }),

/***/ "./node_modules/ms/index.js":
/*!**********************************!*\
  !*** ./node_modules/ms/index.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') ||
    plural(ms, h, 'hour') ||
    plural(ms, m, 'minute') ||
    plural(ms, s, 'second') ||
    ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return;
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }
  return Math.ceil(ms / n) + ' ' + name + 's';
}


/***/ }),

/***/ "./node_modules/negotiator/index.js":
/*!******************************************!*\
  !*** ./node_modules/negotiator/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * negotiator
 * Copyright(c) 2012 Federico Romero
 * Copyright(c) 2012-2014 Isaac Z. Schlueter
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Cached loaded submodules.
 * @private
 */

var modules = Object.create(null);

/**
 * Module exports.
 * @public
 */

module.exports = Negotiator;
module.exports.Negotiator = Negotiator;

/**
 * Create a Negotiator instance from a request.
 * @param {object} request
 * @public
 */

function Negotiator(request) {
  if (!(this instanceof Negotiator)) {
    return new Negotiator(request);
  }

  this.request = request;
}

Negotiator.prototype.charset = function charset(available) {
  var set = this.charsets(available);
  return set && set[0];
};

Negotiator.prototype.charsets = function charsets(available) {
  var preferredCharsets = loadModule('charset').preferredCharsets;
  return preferredCharsets(this.request.headers['accept-charset'], available);
};

Negotiator.prototype.encoding = function encoding(available) {
  var set = this.encodings(available);
  return set && set[0];
};

Negotiator.prototype.encodings = function encodings(available) {
  var preferredEncodings = loadModule('encoding').preferredEncodings;
  return preferredEncodings(this.request.headers['accept-encoding'], available);
};

Negotiator.prototype.language = function language(available) {
  var set = this.languages(available);
  return set && set[0];
};

Negotiator.prototype.languages = function languages(available) {
  var preferredLanguages = loadModule('language').preferredLanguages;
  return preferredLanguages(this.request.headers['accept-language'], available);
};

Negotiator.prototype.mediaType = function mediaType(available) {
  var set = this.mediaTypes(available);
  return set && set[0];
};

Negotiator.prototype.mediaTypes = function mediaTypes(available) {
  var preferredMediaTypes = loadModule('mediaType').preferredMediaTypes;
  return preferredMediaTypes(this.request.headers.accept, available);
};

// Backwards compatibility
Negotiator.prototype.preferredCharset = Negotiator.prototype.charset;
Negotiator.prototype.preferredCharsets = Negotiator.prototype.charsets;
Negotiator.prototype.preferredEncoding = Negotiator.prototype.encoding;
Negotiator.prototype.preferredEncodings = Negotiator.prototype.encodings;
Negotiator.prototype.preferredLanguage = Negotiator.prototype.language;
Negotiator.prototype.preferredLanguages = Negotiator.prototype.languages;
Negotiator.prototype.preferredMediaType = Negotiator.prototype.mediaType;
Negotiator.prototype.preferredMediaTypes = Negotiator.prototype.mediaTypes;

/**
 * Load the given module.
 * @private
 */

function loadModule(moduleName) {
  var module = modules[moduleName];

  if (module !== undefined) {
    return module;
  }

  // This uses a switch for static require analysis
  switch (moduleName) {
    case 'charset':
      module = __webpack_require__(/*! ./lib/charset */ "./node_modules/negotiator/lib/charset.js");
      break;
    case 'encoding':
      module = __webpack_require__(/*! ./lib/encoding */ "./node_modules/negotiator/lib/encoding.js");
      break;
    case 'language':
      module = __webpack_require__(/*! ./lib/language */ "./node_modules/negotiator/lib/language.js");
      break;
    case 'mediaType':
      module = __webpack_require__(/*! ./lib/mediaType */ "./node_modules/negotiator/lib/mediaType.js");
      break;
    default:
      throw new Error('Cannot find module \'' + moduleName + '\'');
  }

  // Store to prevent invoking require()
  modules[moduleName] = module;

  return module;
}


/***/ }),

/***/ "./node_modules/negotiator/lib/charset.js":
/*!************************************************!*\
  !*** ./node_modules/negotiator/lib/charset.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * negotiator
 * Copyright(c) 2012 Isaac Z. Schlueter
 * Copyright(c) 2014 Federico Romero
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = preferredCharsets;
module.exports.preferredCharsets = preferredCharsets;

/**
 * Module variables.
 * @private
 */

var simpleCharsetRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;

/**
 * Parse the Accept-Charset header.
 * @private
 */

function parseAcceptCharset(accept) {
  var accepts = accept.split(',');

  for (var i = 0, j = 0; i < accepts.length; i++) {
    var charset = parseCharset(accepts[i].trim(), i);

    if (charset) {
      accepts[j++] = charset;
    }
  }

  // trim accepts
  accepts.length = j;

  return accepts;
}

/**
 * Parse a charset from the Accept-Charset header.
 * @private
 */

function parseCharset(str, i) {
  var match = simpleCharsetRegExp.exec(str);
  if (!match) return null;

  var charset = match[1];
  var q = 1;
  if (match[2]) {
    var params = match[2].split(';')
    for (var j = 0; j < params.length; j++) {
      var p = params[j].trim().split('=');
      if (p[0] === 'q') {
        q = parseFloat(p[1]);
        break;
      }
    }
  }

  return {
    charset: charset,
    q: q,
    i: i
  };
}

/**
 * Get the priority of a charset.
 * @private
 */

function getCharsetPriority(charset, accepted, index) {
  var priority = {o: -1, q: 0, s: 0};

  for (var i = 0; i < accepted.length; i++) {
    var spec = specify(charset, accepted[i], index);

    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
      priority = spec;
    }
  }

  return priority;
}

/**
 * Get the specificity of the charset.
 * @private
 */

function specify(charset, spec, index) {
  var s = 0;
  if(spec.charset.toLowerCase() === charset.toLowerCase()){
    s |= 1;
  } else if (spec.charset !== '*' ) {
    return null
  }

  return {
    i: index,
    o: spec.i,
    q: spec.q,
    s: s
  }
}

/**
 * Get the preferred charsets from an Accept-Charset header.
 * @public
 */

function preferredCharsets(accept, provided) {
  // RFC 2616 sec 14.2: no header = *
  var accepts = parseAcceptCharset(accept === undefined ? '*' : accept || '');

  if (!provided) {
    // sorted list of all charsets
    return accepts
      .filter(isQuality)
      .sort(compareSpecs)
      .map(getFullCharset);
  }

  var priorities = provided.map(function getPriority(type, index) {
    return getCharsetPriority(type, accepts, index);
  });

  // sorted list of accepted charsets
  return priorities.filter(isQuality).sort(compareSpecs).map(function getCharset(priority) {
    return provided[priorities.indexOf(priority)];
  });
}

/**
 * Compare two specs.
 * @private
 */

function compareSpecs(a, b) {
  return (b.q - a.q) || (b.s - a.s) || (a.o - b.o) || (a.i - b.i) || 0;
}

/**
 * Get full charset string.
 * @private
 */

function getFullCharset(spec) {
  return spec.charset;
}

/**
 * Check if a spec has any quality.
 * @private
 */

function isQuality(spec) {
  return spec.q > 0;
}


/***/ }),

/***/ "./node_modules/negotiator/lib/encoding.js":
/*!*************************************************!*\
  !*** ./node_modules/negotiator/lib/encoding.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * negotiator
 * Copyright(c) 2012 Isaac Z. Schlueter
 * Copyright(c) 2014 Federico Romero
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = preferredEncodings;
module.exports.preferredEncodings = preferredEncodings;

/**
 * Module variables.
 * @private
 */

var simpleEncodingRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;

/**
 * Parse the Accept-Encoding header.
 * @private
 */

function parseAcceptEncoding(accept) {
  var accepts = accept.split(',');
  var hasIdentity = false;
  var minQuality = 1;

  for (var i = 0, j = 0; i < accepts.length; i++) {
    var encoding = parseEncoding(accepts[i].trim(), i);

    if (encoding) {
      accepts[j++] = encoding;
      hasIdentity = hasIdentity || specify('identity', encoding);
      minQuality = Math.min(minQuality, encoding.q || 1);
    }
  }

  if (!hasIdentity) {
    /*
     * If identity doesn't explicitly appear in the accept-encoding header,
     * it's added to the list of acceptable encoding with the lowest q
     */
    accepts[j++] = {
      encoding: 'identity',
      q: minQuality,
      i: i
    };
  }

  // trim accepts
  accepts.length = j;

  return accepts;
}

/**
 * Parse an encoding from the Accept-Encoding header.
 * @private
 */

function parseEncoding(str, i) {
  var match = simpleEncodingRegExp.exec(str);
  if (!match) return null;

  var encoding = match[1];
  var q = 1;
  if (match[2]) {
    var params = match[2].split(';');
    for (var j = 0; j < params.length; j++) {
      var p = params[j].trim().split('=');
      if (p[0] === 'q') {
        q = parseFloat(p[1]);
        break;
      }
    }
  }

  return {
    encoding: encoding,
    q: q,
    i: i
  };
}

/**
 * Get the priority of an encoding.
 * @private
 */

function getEncodingPriority(encoding, accepted, index) {
  var priority = {o: -1, q: 0, s: 0};

  for (var i = 0; i < accepted.length; i++) {
    var spec = specify(encoding, accepted[i], index);

    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
      priority = spec;
    }
  }

  return priority;
}

/**
 * Get the specificity of the encoding.
 * @private
 */

function specify(encoding, spec, index) {
  var s = 0;
  if(spec.encoding.toLowerCase() === encoding.toLowerCase()){
    s |= 1;
  } else if (spec.encoding !== '*' ) {
    return null
  }

  return {
    i: index,
    o: spec.i,
    q: spec.q,
    s: s
  }
};

/**
 * Get the preferred encodings from an Accept-Encoding header.
 * @public
 */

function preferredEncodings(accept, provided) {
  var accepts = parseAcceptEncoding(accept || '');

  if (!provided) {
    // sorted list of all encodings
    return accepts
      .filter(isQuality)
      .sort(compareSpecs)
      .map(getFullEncoding);
  }

  var priorities = provided.map(function getPriority(type, index) {
    return getEncodingPriority(type, accepts, index);
  });

  // sorted list of accepted encodings
  return priorities.filter(isQuality).sort(compareSpecs).map(function getEncoding(priority) {
    return provided[priorities.indexOf(priority)];
  });
}

/**
 * Compare two specs.
 * @private
 */

function compareSpecs(a, b) {
  return (b.q - a.q) || (b.s - a.s) || (a.o - b.o) || (a.i - b.i) || 0;
}

/**
 * Get full encoding string.
 * @private
 */

function getFullEncoding(spec) {
  return spec.encoding;
}

/**
 * Check if a spec has any quality.
 * @private
 */

function isQuality(spec) {
  return spec.q > 0;
}


/***/ }),

/***/ "./node_modules/negotiator/lib/language.js":
/*!*************************************************!*\
  !*** ./node_modules/negotiator/lib/language.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * negotiator
 * Copyright(c) 2012 Isaac Z. Schlueter
 * Copyright(c) 2014 Federico Romero
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = preferredLanguages;
module.exports.preferredLanguages = preferredLanguages;

/**
 * Module variables.
 * @private
 */

var simpleLanguageRegExp = /^\s*([^\s\-;]+)(?:-([^\s;]+))?\s*(?:;(.*))?$/;

/**
 * Parse the Accept-Language header.
 * @private
 */

function parseAcceptLanguage(accept) {
  var accepts = accept.split(',');

  for (var i = 0, j = 0; i < accepts.length; i++) {
    var language = parseLanguage(accepts[i].trim(), i);

    if (language) {
      accepts[j++] = language;
    }
  }

  // trim accepts
  accepts.length = j;

  return accepts;
}

/**
 * Parse a language from the Accept-Language header.
 * @private
 */

function parseLanguage(str, i) {
  var match = simpleLanguageRegExp.exec(str);
  if (!match) return null;

  var prefix = match[1],
    suffix = match[2],
    full = prefix;

  if (suffix) full += "-" + suffix;

  var q = 1;
  if (match[3]) {
    var params = match[3].split(';')
    for (var j = 0; j < params.length; j++) {
      var p = params[j].split('=');
      if (p[0] === 'q') q = parseFloat(p[1]);
    }
  }

  return {
    prefix: prefix,
    suffix: suffix,
    q: q,
    i: i,
    full: full
  };
}

/**
 * Get the priority of a language.
 * @private
 */

function getLanguagePriority(language, accepted, index) {
  var priority = {o: -1, q: 0, s: 0};

  for (var i = 0; i < accepted.length; i++) {
    var spec = specify(language, accepted[i], index);

    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
      priority = spec;
    }
  }

  return priority;
}

/**
 * Get the specificity of the language.
 * @private
 */

function specify(language, spec, index) {
  var p = parseLanguage(language)
  if (!p) return null;
  var s = 0;
  if(spec.full.toLowerCase() === p.full.toLowerCase()){
    s |= 4;
  } else if (spec.prefix.toLowerCase() === p.full.toLowerCase()) {
    s |= 2;
  } else if (spec.full.toLowerCase() === p.prefix.toLowerCase()) {
    s |= 1;
  } else if (spec.full !== '*' ) {
    return null
  }

  return {
    i: index,
    o: spec.i,
    q: spec.q,
    s: s
  }
};

/**
 * Get the preferred languages from an Accept-Language header.
 * @public
 */

function preferredLanguages(accept, provided) {
  // RFC 2616 sec 14.4: no header = *
  var accepts = parseAcceptLanguage(accept === undefined ? '*' : accept || '');

  if (!provided) {
    // sorted list of all languages
    return accepts
      .filter(isQuality)
      .sort(compareSpecs)
      .map(getFullLanguage);
  }

  var priorities = provided.map(function getPriority(type, index) {
    return getLanguagePriority(type, accepts, index);
  });

  // sorted list of accepted languages
  return priorities.filter(isQuality).sort(compareSpecs).map(function getLanguage(priority) {
    return provided[priorities.indexOf(priority)];
  });
}

/**
 * Compare two specs.
 * @private
 */

function compareSpecs(a, b) {
  return (b.q - a.q) || (b.s - a.s) || (a.o - b.o) || (a.i - b.i) || 0;
}

/**
 * Get full language string.
 * @private
 */

function getFullLanguage(spec) {
  return spec.full;
}

/**
 * Check if a spec has any quality.
 * @private
 */

function isQuality(spec) {
  return spec.q > 0;
}


/***/ }),

/***/ "./node_modules/negotiator/lib/mediaType.js":
/*!**************************************************!*\
  !*** ./node_modules/negotiator/lib/mediaType.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * negotiator
 * Copyright(c) 2012 Isaac Z. Schlueter
 * Copyright(c) 2014 Federico Romero
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = preferredMediaTypes;
module.exports.preferredMediaTypes = preferredMediaTypes;

/**
 * Module variables.
 * @private
 */

var simpleMediaTypeRegExp = /^\s*([^\s\/;]+)\/([^;\s]+)\s*(?:;(.*))?$/;

/**
 * Parse the Accept header.
 * @private
 */

function parseAccept(accept) {
  var accepts = splitMediaTypes(accept);

  for (var i = 0, j = 0; i < accepts.length; i++) {
    var mediaType = parseMediaType(accepts[i].trim(), i);

    if (mediaType) {
      accepts[j++] = mediaType;
    }
  }

  // trim accepts
  accepts.length = j;

  return accepts;
}

/**
 * Parse a media type from the Accept header.
 * @private
 */

function parseMediaType(str, i) {
  var match = simpleMediaTypeRegExp.exec(str);
  if (!match) return null;

  var params = Object.create(null);
  var q = 1;
  var subtype = match[2];
  var type = match[1];

  if (match[3]) {
    var kvps = splitParameters(match[3]).map(splitKeyValuePair);

    for (var j = 0; j < kvps.length; j++) {
      var pair = kvps[j];
      var key = pair[0].toLowerCase();
      var val = pair[1];

      // get the value, unwrapping quotes
      var value = val && val[0] === '"' && val[val.length - 1] === '"'
        ? val.substr(1, val.length - 2)
        : val;

      if (key === 'q') {
        q = parseFloat(value);
        break;
      }

      // store parameter
      params[key] = value;
    }
  }

  return {
    type: type,
    subtype: subtype,
    params: params,
    q: q,
    i: i
  };
}

/**
 * Get the priority of a media type.
 * @private
 */

function getMediaTypePriority(type, accepted, index) {
  var priority = {o: -1, q: 0, s: 0};

  for (var i = 0; i < accepted.length; i++) {
    var spec = specify(type, accepted[i], index);

    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
      priority = spec;
    }
  }

  return priority;
}

/**
 * Get the specificity of the media type.
 * @private
 */

function specify(type, spec, index) {
  var p = parseMediaType(type);
  var s = 0;

  if (!p) {
    return null;
  }

  if(spec.type.toLowerCase() == p.type.toLowerCase()) {
    s |= 4
  } else if(spec.type != '*') {
    return null;
  }

  if(spec.subtype.toLowerCase() == p.subtype.toLowerCase()) {
    s |= 2
  } else if(spec.subtype != '*') {
    return null;
  }

  var keys = Object.keys(spec.params);
  if (keys.length > 0) {
    if (keys.every(function (k) {
      return spec.params[k] == '*' || (spec.params[k] || '').toLowerCase() == (p.params[k] || '').toLowerCase();
    })) {
      s |= 1
    } else {
      return null
    }
  }

  return {
    i: index,
    o: spec.i,
    q: spec.q,
    s: s,
  }
}

/**
 * Get the preferred media types from an Accept header.
 * @public
 */

function preferredMediaTypes(accept, provided) {
  // RFC 2616 sec 14.2: no header = */*
  var accepts = parseAccept(accept === undefined ? '*/*' : accept || '');

  if (!provided) {
    // sorted list of all types
    return accepts
      .filter(isQuality)
      .sort(compareSpecs)
      .map(getFullType);
  }

  var priorities = provided.map(function getPriority(type, index) {
    return getMediaTypePriority(type, accepts, index);
  });

  // sorted list of accepted types
  return priorities.filter(isQuality).sort(compareSpecs).map(function getType(priority) {
    return provided[priorities.indexOf(priority)];
  });
}

/**
 * Compare two specs.
 * @private
 */

function compareSpecs(a, b) {
  return (b.q - a.q) || (b.s - a.s) || (a.o - b.o) || (a.i - b.i) || 0;
}

/**
 * Get full type string.
 * @private
 */

function getFullType(spec) {
  return spec.type + '/' + spec.subtype;
}

/**
 * Check if a spec has any quality.
 * @private
 */

function isQuality(spec) {
  return spec.q > 0;
}

/**
 * Count the number of quotes in a string.
 * @private
 */

function quoteCount(string) {
  var count = 0;
  var index = 0;

  while ((index = string.indexOf('"', index)) !== -1) {
    count++;
    index++;
  }

  return count;
}

/**
 * Split a key value pair.
 * @private
 */

function splitKeyValuePair(str) {
  var index = str.indexOf('=');
  var key;
  var val;

  if (index === -1) {
    key = str;
  } else {
    key = str.substr(0, index);
    val = str.substr(index + 1);
  }

  return [key, val];
}

/**
 * Split an Accept header into media types.
 * @private
 */

function splitMediaTypes(accept) {
  var accepts = accept.split(',');

  for (var i = 1, j = 0; i < accepts.length; i++) {
    if (quoteCount(accepts[j]) % 2 == 0) {
      accepts[++j] = accepts[i];
    } else {
      accepts[j] += ',' + accepts[i];
    }
  }

  // trim accepts
  accepts.length = j + 1;

  return accepts;
}

/**
 * Split a string of parameters.
 * @private
 */

function splitParameters(str) {
  var parameters = str.split(';');

  for (var i = 1, j = 0; i < parameters.length; i++) {
    if (quoteCount(parameters[j]) % 2 == 0) {
      parameters[++j] = parameters[i];
    } else {
      parameters[j] += ';' + parameters[i];
    }
  }

  // trim parameters
  parameters.length = j + 1;

  for (var i = 0; i < parameters.length; i++) {
    parameters[i] = parameters[i].trim();
  }

  return parameters;
}


/***/ }),

/***/ "./node_modules/normalize-path/index.js":
/*!**********************************************!*\
  !*** ./node_modules/normalize-path/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*!
 * normalize-path <https://github.com/jonschlinkert/normalize-path>
 *
 * Copyright (c) 2014-2018, Jon Schlinkert.
 * Released under the MIT License.
 */

module.exports = function(path, stripTrailing) {
  if (typeof path !== 'string') {
    throw new TypeError('expected path to be a string');
  }

  if (path === '\\' || path === '/') return '/';

  var len = path.length;
  if (len <= 1) return path;

  // ensure that win32 namespaces has two leading slashes, so that the path is
  // handled properly by the win32 version of path.parse() after being normalized
  // https://msdn.microsoft.com/library/windows/desktop/aa365247(v=vs.85).aspx#namespaces
  var prefix = '';
  if (len > 4 && path[3] === '\\') {
    var ch = path[2];
    if ((ch === '?' || ch === '.') && path.slice(0, 2) === '\\\\') {
      path = path.slice(2);
      prefix = '//';
    }
  }

  var segs = path.split(/[/\\]+/);
  if (stripTrailing !== false && segs[segs.length - 1] === '') {
    segs.pop();
  }
  return prefix + segs.join('/');
};


/***/ }),

/***/ "./node_modules/on-finished/index.js":
/*!*******************************************!*\
  !*** ./node_modules/on-finished/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * on-finished
 * Copyright(c) 2013 Jonathan Ong
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = onFinished
module.exports.isFinished = isFinished

/**
 * Module dependencies.
 * @private
 */

var first = __webpack_require__(/*! ee-first */ "./node_modules/ee-first/index.js")

/**
 * Variables.
 * @private
 */

/* istanbul ignore next */
var defer = typeof setImmediate === 'function'
  ? setImmediate
  : function(fn){ process.nextTick(fn.bind.apply(fn, arguments)) }

/**
 * Invoke callback when the response has finished, useful for
 * cleaning up resources afterwards.
 *
 * @param {object} msg
 * @param {function} listener
 * @return {object}
 * @public
 */

function onFinished(msg, listener) {
  if (isFinished(msg) !== false) {
    defer(listener, null, msg)
    return msg
  }

  // attach the listener to the message
  attachListener(msg, listener)

  return msg
}

/**
 * Determine if message is already finished.
 *
 * @param {object} msg
 * @return {boolean}
 * @public
 */

function isFinished(msg) {
  var socket = msg.socket

  if (typeof msg.finished === 'boolean') {
    // OutgoingMessage
    return Boolean(msg.finished || (socket && !socket.writable))
  }

  if (typeof msg.complete === 'boolean') {
    // IncomingMessage
    return Boolean(msg.upgrade || !socket || !socket.readable || (msg.complete && !msg.readable))
  }

  // don't know
  return undefined
}

/**
 * Attach a finished listener to the message.
 *
 * @param {object} msg
 * @param {function} callback
 * @private
 */

function attachFinishedListener(msg, callback) {
  var eeMsg
  var eeSocket
  var finished = false

  function onFinish(error) {
    eeMsg.cancel()
    eeSocket.cancel()

    finished = true
    callback(error)
  }

  // finished on first message event
  eeMsg = eeSocket = first([[msg, 'end', 'finish']], onFinish)

  function onSocket(socket) {
    // remove listener
    msg.removeListener('socket', onSocket)

    if (finished) return
    if (eeMsg !== eeSocket) return

    // finished on first socket event
    eeSocket = first([[socket, 'error', 'close']], onFinish)
  }

  if (msg.socket) {
    // socket already assigned
    onSocket(msg.socket)
    return
  }

  // wait for socket to be assigned
  msg.on('socket', onSocket)

  if (msg.socket === undefined) {
    // node.js 0.8 patch
    patchAssignSocket(msg, onSocket)
  }
}

/**
 * Attach the listener to the message.
 *
 * @param {object} msg
 * @return {function}
 * @private
 */

function attachListener(msg, listener) {
  var attached = msg.__onFinished

  // create a private single listener with queue
  if (!attached || !attached.queue) {
    attached = msg.__onFinished = createListener(msg)
    attachFinishedListener(msg, attached)
  }

  attached.queue.push(listener)
}

/**
 * Create listener on message.
 *
 * @param {object} msg
 * @return {function}
 * @private
 */

function createListener(msg) {
  function listener(err) {
    if (msg.__onFinished === listener) msg.__onFinished = null
    if (!listener.queue) return

    var queue = listener.queue
    listener.queue = null

    for (var i = 0; i < queue.length; i++) {
      queue[i](err, msg)
    }
  }

  listener.queue = []

  return listener
}

/**
 * Patch ServerResponse.prototype.assignSocket for node.js 0.8.
 *
 * @param {ServerResponse} res
 * @param {function} callback
 * @private
 */

function patchAssignSocket(res, callback) {
  var assignSocket = res.assignSocket

  if (typeof assignSocket !== 'function') return

  // res.on('socket', callback) is broken in 0.8
  res.assignSocket = function _assignSocket(socket) {
    assignSocket.call(this, socket)
    callback(socket)
  }
}


/***/ }),

/***/ "./node_modules/parseurl/index.js":
/*!****************************************!*\
  !*** ./node_modules/parseurl/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * parseurl
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var url = __webpack_require__(/*! url */ "url")
var parse = url.parse
var Url = url.Url

/**
 * Module exports.
 * @public
 */

module.exports = parseurl
module.exports.original = originalurl

/**
 * Parse the `req` url with memoization.
 *
 * @param {ServerRequest} req
 * @return {Object}
 * @public
 */

function parseurl (req) {
  var url = req.url

  if (url === undefined) {
    // URL is undefined
    return undefined
  }

  var parsed = req._parsedUrl

  if (fresh(url, parsed)) {
    // Return cached URL parse
    return parsed
  }

  // Parse the URL
  parsed = fastparse(url)
  parsed._raw = url

  return (req._parsedUrl = parsed)
};

/**
 * Parse the `req` original url with fallback and memoization.
 *
 * @param {ServerRequest} req
 * @return {Object}
 * @public
 */

function originalurl (req) {
  var url = req.originalUrl

  if (typeof url !== 'string') {
    // Fallback
    return parseurl(req)
  }

  var parsed = req._parsedOriginalUrl

  if (fresh(url, parsed)) {
    // Return cached URL parse
    return parsed
  }

  // Parse the URL
  parsed = fastparse(url)
  parsed._raw = url

  return (req._parsedOriginalUrl = parsed)
};

/**
 * Parse the `str` url with fast-path short-cut.
 *
 * @param {string} str
 * @return {Object}
 * @private
 */

function fastparse (str) {
  if (typeof str !== 'string' || str.charCodeAt(0) !== 0x2f /* / */) {
    return parse(str)
  }

  var pathname = str
  var query = null
  var search = null

  // This takes the regexp from https://github.com/joyent/node/pull/7878
  // Which is /^(\/[^?#\s]*)(\?[^#\s]*)?$/
  // And unrolls it into a for loop
  for (var i = 1; i < str.length; i++) {
    switch (str.charCodeAt(i)) {
      case 0x3f: /* ?  */
        if (search === null) {
          pathname = str.substring(0, i)
          query = str.substring(i + 1)
          search = str.substring(i)
        }
        break
      case 0x09: /* \t */
      case 0x0a: /* \n */
      case 0x0c: /* \f */
      case 0x0d: /* \r */
      case 0x20: /*    */
      case 0x23: /* #  */
      case 0xa0:
      case 0xfeff:
        return parse(str)
    }
  }

  var url = Url !== undefined
    ? new Url()
    : {}

  url.path = str
  url.href = str
  url.pathname = pathname

  if (search !== null) {
    url.query = query
    url.search = search
  }

  return url
}

/**
 * Determine if parsed is still fresh for url.
 *
 * @param {string} url
 * @param {object} parsedUrl
 * @return {boolean}
 * @private
 */

function fresh (url, parsedUrl) {
  return typeof parsedUrl === 'object' &&
    parsedUrl !== null &&
    (Url === undefined || parsedUrl instanceof Url) &&
    parsedUrl._raw === url
}


/***/ }),

/***/ "./node_modules/path-to-regexp/index.js":
/*!**********************************************!*\
  !*** ./node_modules/path-to-regexp/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Expose `pathtoRegexp`.
 */

module.exports = pathtoRegexp;

/**
 * Match matching groups in a regular expression.
 */
var MATCHING_GROUP_REGEXP = /\((?!\?)/g;

/**
 * Normalize the given path string,
 * returning a regular expression.
 *
 * An empty array should be passed,
 * which will contain the placeholder
 * key names. For example "/user/:id" will
 * then contain ["id"].
 *
 * @param  {String|RegExp|Array} path
 * @param  {Array} keys
 * @param  {Object} options
 * @return {RegExp}
 * @api private
 */

function pathtoRegexp(path, keys, options) {
  options = options || {};
  keys = keys || [];
  var strict = options.strict;
  var end = options.end !== false;
  var flags = options.sensitive ? '' : 'i';
  var extraOffset = 0;
  var keysOffset = keys.length;
  var i = 0;
  var name = 0;
  var m;

  if (path instanceof RegExp) {
    while (m = MATCHING_GROUP_REGEXP.exec(path.source)) {
      keys.push({
        name: name++,
        optional: false,
        offset: m.index
      });
    }

    return path;
  }

  if (Array.isArray(path)) {
    // Map array parts into regexps and return their source. We also pass
    // the same keys and options instance into every generation to get
    // consistent matching groups before we join the sources together.
    path = path.map(function (value) {
      return pathtoRegexp(value, keys, options).source;
    });

    return new RegExp('(?:' + path.join('|') + ')', flags);
  }

  path = ('^' + path + (strict ? '' : path[path.length - 1] === '/' ? '?' : '/?'))
    .replace(/\/\(/g, '/(?:')
    .replace(/([\/\.])/g, '\\$1')
    .replace(/(\\\/)?(\\\.)?:(\w+)(\(.*?\))?(\*)?(\?)?/g, function (match, slash, format, key, capture, star, optional, offset) {
      slash = slash || '';
      format = format || '';
      capture = capture || '([^\\/' + format + ']+?)';
      optional = optional || '';

      keys.push({
        name: key,
        optional: !!optional,
        offset: offset + extraOffset
      });

      var result = ''
        + (optional ? '' : slash)
        + '(?:'
        + format + (optional ? slash : '') + capture
        + (star ? '((?:[\\/' + format + '].+?)?)' : '')
        + ')'
        + optional;

      extraOffset += result.length - match.length;

      return result;
    })
    .replace(/\*/g, function (star, index) {
      var len = keys.length

      while (len-- > keysOffset && keys[len].offset > index) {
        keys[len].offset += 3; // Replacement length minus asterisk length.
      }

      return '(.*)';
    });

  // This is a workaround for handling unnamed matching groups.
  while (m = MATCHING_GROUP_REGEXP.exec(path)) {
    var escapeCount = 0;
    var index = m.index;

    while (path.charAt(--index) === '\\') {
      escapeCount++;
    }

    // It's possible to escape the bracket.
    if (escapeCount % 2 === 1) {
      continue;
    }

    if (keysOffset + i === keys.length || keys[keysOffset + i].offset > m.index) {
      keys.splice(keysOffset + i, 0, {
        name: name++, // Unnamed matching groups must be consistently linear.
        optional: false,
        offset: m.index
      });
    }

    i++;
  }

  // If the path is non-ending, match until the end or a slash.
  path += (end ? '$' : (path[path.length - 1] === '/' ? '' : '(?=\\/|$)'));

  return new RegExp(path, flags);
};


/***/ }),

/***/ "./node_modules/picomatch/index.js":
/*!*****************************************!*\
  !*** ./node_modules/picomatch/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(/*! ./lib/picomatch */ "./node_modules/picomatch/lib/picomatch.js");


/***/ }),

/***/ "./node_modules/picomatch/lib/constants.js":
/*!*************************************************!*\
  !*** ./node_modules/picomatch/lib/constants.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const path = __webpack_require__(/*! path */ "path");
const WIN_SLASH = '\\\\/';
const WIN_NO_SLASH = `[^${WIN_SLASH}]`;

/**
 * Posix glob regex
 */

const DOT_LITERAL = '\\.';
const PLUS_LITERAL = '\\+';
const QMARK_LITERAL = '\\?';
const SLASH_LITERAL = '\\/';
const ONE_CHAR = '(?=.)';
const QMARK = '[^/]';
const END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
const START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
const DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
const NO_DOT = `(?!${DOT_LITERAL})`;
const NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
const NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
const NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
const QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
const STAR = `${QMARK}*?`;

const POSIX_CHARS = {
  DOT_LITERAL,
  PLUS_LITERAL,
  QMARK_LITERAL,
  SLASH_LITERAL,
  ONE_CHAR,
  QMARK,
  END_ANCHOR,
  DOTS_SLASH,
  NO_DOT,
  NO_DOTS,
  NO_DOT_SLASH,
  NO_DOTS_SLASH,
  QMARK_NO_DOT,
  STAR,
  START_ANCHOR
};

/**
 * Windows glob regex
 */

const WINDOWS_CHARS = {
  ...POSIX_CHARS,

  SLASH_LITERAL: `[${WIN_SLASH}]`,
  QMARK: WIN_NO_SLASH,
  STAR: `${WIN_NO_SLASH}*?`,
  DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
  NO_DOT: `(?!${DOT_LITERAL})`,
  NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
  NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
  NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
  QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
  START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
  END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
};

/**
 * POSIX Bracket Regex
 */

const POSIX_REGEX_SOURCE = {
  alnum: 'a-zA-Z0-9',
  alpha: 'a-zA-Z',
  ascii: '\\x00-\\x7F',
  blank: ' \\t',
  cntrl: '\\x00-\\x1F\\x7F',
  digit: '0-9',
  graph: '\\x21-\\x7E',
  lower: 'a-z',
  print: '\\x20-\\x7E ',
  punct: '\\-!"#$%&\'()\\*+,./:;<=>?@[\\]^_`{|}~',
  space: ' \\t\\r\\n\\v\\f',
  upper: 'A-Z',
  word: 'A-Za-z0-9_',
  xdigit: 'A-Fa-f0-9'
};

module.exports = {
  MAX_LENGTH: 1024 * 64,
  POSIX_REGEX_SOURCE,

  // regular expressions
  REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
  REGEX_NON_SPECIAL_CHAR: /^[^@![\].,$*+?^{}()|\\/]+/,
  REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
  REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
  REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
  REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,

  // Replace globs with equivalent patterns to reduce parsing time.
  REPLACEMENTS: {
    '***': '*',
    '**/**': '**',
    '**/**/**': '**'
  },

  // Digits
  CHAR_0: 48, /* 0 */
  CHAR_9: 57, /* 9 */

  // Alphabet chars.
  CHAR_UPPERCASE_A: 65, /* A */
  CHAR_LOWERCASE_A: 97, /* a */
  CHAR_UPPERCASE_Z: 90, /* Z */
  CHAR_LOWERCASE_Z: 122, /* z */

  CHAR_LEFT_PARENTHESES: 40, /* ( */
  CHAR_RIGHT_PARENTHESES: 41, /* ) */

  CHAR_ASTERISK: 42, /* * */

  // Non-alphabetic chars.
  CHAR_AMPERSAND: 38, /* & */
  CHAR_AT: 64, /* @ */
  CHAR_BACKWARD_SLASH: 92, /* \ */
  CHAR_CARRIAGE_RETURN: 13, /* \r */
  CHAR_CIRCUMFLEX_ACCENT: 94, /* ^ */
  CHAR_COLON: 58, /* : */
  CHAR_COMMA: 44, /* , */
  CHAR_DOT: 46, /* . */
  CHAR_DOUBLE_QUOTE: 34, /* " */
  CHAR_EQUAL: 61, /* = */
  CHAR_EXCLAMATION_MARK: 33, /* ! */
  CHAR_FORM_FEED: 12, /* \f */
  CHAR_FORWARD_SLASH: 47, /* / */
  CHAR_GRAVE_ACCENT: 96, /* ` */
  CHAR_HASH: 35, /* # */
  CHAR_HYPHEN_MINUS: 45, /* - */
  CHAR_LEFT_ANGLE_BRACKET: 60, /* < */
  CHAR_LEFT_CURLY_BRACE: 123, /* { */
  CHAR_LEFT_SQUARE_BRACKET: 91, /* [ */
  CHAR_LINE_FEED: 10, /* \n */
  CHAR_NO_BREAK_SPACE: 160, /* \u00A0 */
  CHAR_PERCENT: 37, /* % */
  CHAR_PLUS: 43, /* + */
  CHAR_QUESTION_MARK: 63, /* ? */
  CHAR_RIGHT_ANGLE_BRACKET: 62, /* > */
  CHAR_RIGHT_CURLY_BRACE: 125, /* } */
  CHAR_RIGHT_SQUARE_BRACKET: 93, /* ] */
  CHAR_SEMICOLON: 59, /* ; */
  CHAR_SINGLE_QUOTE: 39, /* ' */
  CHAR_SPACE: 32, /*   */
  CHAR_TAB: 9, /* \t */
  CHAR_UNDERSCORE: 95, /* _ */
  CHAR_VERTICAL_LINE: 124, /* | */
  CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279, /* \uFEFF */

  SEP: path.sep,

  /**
   * Create EXTGLOB_CHARS
   */

  extglobChars(chars) {
    return {
      '!': { type: 'negate', open: '(?:(?!(?:', close: `))${chars.STAR})` },
      '?': { type: 'qmark', open: '(?:', close: ')?' },
      '+': { type: 'plus', open: '(?:', close: ')+' },
      '*': { type: 'star', open: '(?:', close: ')*' },
      '@': { type: 'at', open: '(?:', close: ')' }
    };
  },

  /**
   * Create GLOB_CHARS
   */

  globChars(win32) {
    return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
  }
};


/***/ }),

/***/ "./node_modules/picomatch/lib/parse.js":
/*!*********************************************!*\
  !*** ./node_modules/picomatch/lib/parse.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const utils = __webpack_require__(/*! ./utils */ "./node_modules/picomatch/lib/utils.js");
const constants = __webpack_require__(/*! ./constants */ "./node_modules/picomatch/lib/constants.js");

/**
 * Constants
 */

const {
  MAX_LENGTH,
  POSIX_REGEX_SOURCE,
  REGEX_NON_SPECIAL_CHAR,
  REGEX_SPECIAL_CHARS_BACKREF,
  REPLACEMENTS
} = constants;

/**
 * Helpers
 */

const expandRange = (args, options) => {
  if (typeof options.expandRange === 'function') {
    return options.expandRange(...args, options);
  }

  args.sort();
  let value = `[${args.join('-')}]`;

  try {
    /* eslint-disable no-new */
    new RegExp(value);
  } catch (ex) {
    return args.map(v => utils.escapeRegex(v)).join('..');
  }

  return value;
};

const negate = state => {
  let count = 1;

  while (state.peek() === '!' && (state.peek(2) !== '(' || state.peek(3) === '?')) {
    state.advance();
    state.start++;
    count++;
  }

  if (count % 2 === 0) {
    return false;
  }

  state.negated = true;
  state.start++;
  return true;
};

/**
 * Create the message for a syntax error
 */

const syntaxError = (type, char) => {
  return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
};

/**
 * Parse the given input string.
 * @param {String} input
 * @param {Object} options
 * @return {Object}
 */

const parse = (input, options) => {
  if (typeof input !== 'string') {
    throw new TypeError('Expected a string');
  }

  input = REPLACEMENTS[input] || input;

  let opts = { ...options };
  let max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
  let len = input.length;
  if (len > max) {
    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
  }

  let bos = { type: 'bos', value: '', output: opts.prepend || '' };
  let tokens = [bos];

  let capture = opts.capture ? '' : '?:';
  let win32 = utils.isWindows(options);

  // create constants based on platform, for windows or posix
  const PLATFORM_CHARS = constants.globChars(win32);
  const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);

  const {
    DOT_LITERAL,
    PLUS_LITERAL,
    SLASH_LITERAL,
    ONE_CHAR,
    DOTS_SLASH,
    NO_DOT,
    NO_DOT_SLASH,
    NO_DOTS_SLASH,
    QMARK,
    QMARK_NO_DOT,
    STAR,
    START_ANCHOR
  } = PLATFORM_CHARS;

  const globstar = (opts) => {
    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
  };

  let nodot = opts.dot ? '' : NO_DOT;
  let star = opts.bash === true ? globstar(opts) : STAR;
  let qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;

  if (opts.capture) {
    star = `(${star})`;
  }

  // minimatch options support
  if (typeof opts.noext === 'boolean') {
    opts.noextglob = opts.noext;
  }

  let state = {
    index: -1,
    start: 0,
    consumed: '',
    output: '',
    backtrack: false,
    brackets: 0,
    braces: 0,
    parens: 0,
    quotes: 0,
    tokens
  };

  let extglobs = [];
  let stack = [];
  let prev = bos;
  let value;

  /**
   * Tokenizing helpers
   */

  const eos = () => state.index === len - 1;
  const peek = state.peek = (n = 1) => input[state.index + n];
  const advance = state.advance = () => input[++state.index];
  const append = token => {
    state.output += token.output != null ? token.output : token.value;
    state.consumed += token.value || '';
  };

  const increment = type => {
    state[type]++;
    stack.push(type);
  };

  const decrement = type => {
    state[type]--;
    stack.pop();
  };

  /**
   * Push tokens onto the tokens array. This helper speeds up
   * tokenizing by 1) helping us avoid backtracking as much as possible,
   * and 2) helping us avoid creating extra tokens when consecutive
   * characters are plain text. This improves performance and simplifies
   * lookbehinds.
   */

  const push = tok => {
    if (prev.type === 'globstar') {
      let isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');
      let isExtglob = extglobs.length && (tok.type === 'pipe' || tok.type === 'paren');
      if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {
        state.output = state.output.slice(0, -prev.output.length);
        prev.type = 'star';
        prev.value = '*';
        prev.output = star;
        state.output += prev.output;
      }
    }

    if (extglobs.length && tok.type !== 'paren' && !EXTGLOB_CHARS[tok.value]) {
      extglobs[extglobs.length - 1].inner += tok.value;
    }

    if (tok.value || tok.output) append(tok);
    if (prev && prev.type === 'text' && tok.type === 'text') {
      prev.value += tok.value;
      return;
    }

    tok.prev = prev;
    tokens.push(tok);
    prev = tok;
  };

  const extglobOpen = (type, value) => {
    let token = { ...EXTGLOB_CHARS[value], conditions: 1, inner: '' };

    token.prev = prev;
    token.parens = state.parens;
    token.output = state.output;
    let output = (opts.capture ? '(' : '') + token.open;

    push({ type, value, output: state.output ? '' : ONE_CHAR });
    push({ type: 'paren', extglob: true, value: advance(), output });
    increment('parens');
    extglobs.push(token);
  };

  const extglobClose = token => {
    let output = token.close + (opts.capture ? ')' : '');

    if (token.type === 'negate') {
      let extglobStar = star;

      if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {
        extglobStar = globstar(opts);
      }

      if (extglobStar !== star || eos() || /^\)+$/.test(input.slice(state.index + 1))) {
        output = token.close = ')$))' + extglobStar;
      }

      if (token.prev.type === 'bos' && eos()) {
        state.negatedExtglob = true;
      }
    }

    push({ type: 'paren', extglob: true, value, output });
    decrement('parens');
  };

  if (opts.fastpaths !== false && !/(^[*!]|[/{[()\]}"])/.test(input)) {
    let backslashes = false;

    let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {
      if (first === '\\') {
        backslashes = true;
        return m;
      }

      if (first === '?') {
        if (esc) {
          return esc + first + (rest ? QMARK.repeat(rest.length) : '');
        }
        if (index === 0) {
          return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');
        }
        return QMARK.repeat(chars.length);
      }

      if (first === '.') {
        return DOT_LITERAL.repeat(chars.length);
      }

      if (first === '*') {
        if (esc) {
          return esc + first + (rest ? star : '');
        }
        return star;
      }
      return esc ? m : '\\' + m;
    });

    if (backslashes === true) {
      if (opts.unescape === true) {
        output = output.replace(/\\/g, '');
      } else {
        output = output.replace(/\\+/g, m => {
          return m.length % 2 === 0 ? '\\\\' : (m ? '\\' : '');
        });
      }
    }

    state.output = output;
    return state;
  }

  /**
   * Tokenize input until we reach end-of-string
   */

  while (!eos()) {
    value = advance();

    if (value === '\u0000') {
      continue;
    }

    /**
     * Escaped characters
     */

    if (value === '\\') {
      let next = peek();

      if (next === '/' && opts.bash !== true) {
        continue;
      }

      if (next === '.' || next === ';') {
        continue;
      }

      if (!next) {
        value += '\\';
        push({ type: 'text', value });
        continue;
      }

      // collapse slashes to reduce potential for exploits
      let match = /^\\+/.exec(input.slice(state.index + 1));
      let slashes = 0;

      if (match && match[0].length > 2) {
        slashes = match[0].length;
        state.index += slashes;
        if (slashes % 2 !== 0) {
          value += '\\';
        }
      }

      if (opts.unescape === true) {
        value = advance() || '';
      } else {
        value += advance() || '';
      }

      if (state.brackets === 0) {
        push({ type: 'text', value });
        continue;
      }
    }

    /**
     * If we're inside a regex character class, continue
     * until we reach the closing bracket.
     */

    if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {
      if (opts.posix !== false && value === ':') {
        let inner = prev.value.slice(1);
        if (inner.includes('[')) {
          prev.posix = true;

          if (inner.includes(':')) {
            let idx = prev.value.lastIndexOf('[');
            let pre = prev.value.slice(0, idx);
            let rest = prev.value.slice(idx + 2);
            let posix = POSIX_REGEX_SOURCE[rest];
            if (posix) {
              prev.value = pre + posix;
              state.backtrack = true;
              advance();

              if (!bos.output && tokens.indexOf(prev) === 1) {
                bos.output = ONE_CHAR;
              }
              continue;
            }
          }
        }
      }

      if ((value === '[' && peek() !== ':') || (value === '-' && peek() === ']')) {
        value = '\\' + value;
      }

      if (value === ']' && (prev.value === '[' || prev.value === '[^')) {
        value = '\\' + value;
      }

      if (opts.posix === true && value === '!' && prev.value === '[') {
        value = '^';
      }

      prev.value += value;
      append({ value });
      continue;
    }

    /**
     * If we're inside a quoted string, continue
     * until we reach the closing double quote.
     */

    if (state.quotes === 1 && value !== '"') {
      value = utils.escapeRegex(value);
      prev.value += value;
      append({ value });
      continue;
    }

    /**
     * Double quotes
     */

    if (value === '"') {
      state.quotes = state.quotes === 1 ? 0 : 1;
      if (opts.keepQuotes === true) {
        push({ type: 'text', value });
      }
      continue;
    }

    /**
     * Parentheses
     */

    if (value === '(') {
      push({ type: 'paren', value });
      increment('parens');
      continue;
    }

    if (value === ')') {
      if (state.parens === 0 && opts.strictBrackets === true) {
        throw new SyntaxError(syntaxError('opening', '('));
      }

      let extglob = extglobs[extglobs.length - 1];
      if (extglob && state.parens === extglob.parens + 1) {
        extglobClose(extglobs.pop());
        continue;
      }

      push({ type: 'paren', value, output: state.parens ? ')' : '\\)' });
      decrement('parens');
      continue;
    }

    /**
     * Brackets
     */

    if (value === '[') {
      if (opts.nobracket === true || !input.slice(state.index + 1).includes(']')) {
        if (opts.nobracket !== true && opts.strictBrackets === true) {
          throw new SyntaxError(syntaxError('closing', ']'));
        }

        value = '\\' + value;
      } else {
        increment('brackets');
      }

      push({ type: 'bracket', value });
      continue;
    }

    if (value === ']') {
      if (opts.nobracket === true || (prev && prev.type === 'bracket' && prev.value.length === 1)) {
        push({ type: 'text', value, output: '\\' + value });
        continue;
      }

      if (state.brackets === 0) {
        if (opts.strictBrackets === true) {
          throw new SyntaxError(syntaxError('opening', '['));
        }

        push({ type: 'text', value, output: '\\' + value });
        continue;
      }

      decrement('brackets');

      let prevValue = prev.value.slice(1);
      if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {
        value = '/' + value;
      }

      prev.value += value;
      append({ value });

      // when literal brackets are explicitly disabled
      // assume we should match with a regex character class
      if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
        continue;
      }

      let escaped = utils.escapeRegex(prev.value);
      state.output = state.output.slice(0, -prev.value.length);

      // when literal brackets are explicitly enabled
      // assume we should escape the brackets to match literal characters
      if (opts.literalBrackets === true) {
        state.output += escaped;
        prev.value = escaped;
        continue;
      }

      // when the user specifies nothing, try to match both
      prev.value = `(${capture}${escaped}|${prev.value})`;
      state.output += prev.value;
      continue;
    }

    /**
     * Braces
     */

    if (value === '{' && opts.nobrace !== true) {
      push({ type: 'brace', value, output: '(' });
      increment('braces');
      continue;
    }

    if (value === '}') {
      if (opts.nobrace === true || state.braces === 0) {
        push({ type: 'text', value, output: '\\' + value });
        continue;
      }

      let output = ')';

      if (state.dots === true) {
        let arr = tokens.slice();
        let range = [];

        for (let i = arr.length - 1; i >= 0; i--) {
          tokens.pop();
          if (arr[i].type === 'brace') {
            break;
          }
          if (arr[i].type !== 'dots') {
            range.unshift(arr[i].value);
          }
        }

        output = expandRange(range, opts);
        state.backtrack = true;
      }

      push({ type: 'brace', value, output });
      decrement('braces');
      continue;
    }

    /**
     * Pipes
     */

    if (value === '|') {
      if (extglobs.length > 0) {
        extglobs[extglobs.length - 1].conditions++;
      }
      push({ type: 'text', value });
      continue;
    }

    /**
     * Commas
     */

    if (value === ',') {
      let output = value;

      if (state.braces > 0 && stack[stack.length - 1] === 'braces') {
        output = '|';
      }

      push({ type: 'comma', value, output });
      continue;
    }

    /**
     * Slashes
     */

    if (value === '/') {
      // if the beginning of the glob is "./", advance the start
      // to the current index, and don't add the "./" characters
      // to the state. This greatly simplifies lookbehinds when
      // checking for BOS characters like "!" and "." (not "./")
      if (prev.type === 'dot' && state.index === 1) {
        state.start = state.index + 1;
        state.consumed = '';
        state.output = '';
        tokens.pop();
        prev = bos; // reset "prev" to the first token
        continue;
      }

      push({ type: 'slash', value, output: SLASH_LITERAL });
      continue;
    }

    /**
     * Dots
     */

    if (value === '.') {
      if (state.braces > 0 && prev.type === 'dot') {
        if (prev.value === '.') prev.output = DOT_LITERAL;
        prev.type = 'dots';
        prev.output += value;
        prev.value += value;
        state.dots = true;
        continue;
      }

      push({ type: 'dot', value, output: DOT_LITERAL });
      continue;
    }

    /**
     * Question marks
     */

    if (value === '?') {
      if (prev && prev.type === 'paren') {
        let next = peek();
        let output = value;

        if (next === '<' && !utils.supportsLookbehinds()) {
          throw new Error('Node.js v10 or higher is required for regex lookbehinds');
        }

        if (prev.value === '(' && !/[!=<:]/.test(next) || (next === '<' && !/[!=]/.test(peek(2)))) {
          output = '\\' + value;
        }

        push({ type: 'text', value, output });
        continue;
      }

      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
        extglobOpen('qmark', value);
        continue;
      }

      if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {
        push({ type: 'qmark', value, output: QMARK_NO_DOT });
        continue;
      }

      push({ type: 'qmark', value, output: QMARK });
      continue;
    }

    /**
     * Exclamation
     */

    if (value === '!') {
      if (opts.noextglob !== true && peek() === '(') {
        if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {
          extglobOpen('negate', value);
          continue;
        }
      }

      if (opts.nonegate !== true && state.index === 0) {
        negate(state);
        continue;
      }
    }

    /**
     * Plus
     */

    if (value === '+') {
      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
        extglobOpen('plus', value);
        continue;
      }

      if (prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace')) {
        let output = prev.extglob === true ? '\\' + value : value;
        push({ type: 'plus', value, output });
        continue;
      }

      // use regex behavior inside parens
      if (state.parens > 0 && opts.regex !== false) {
        push({ type: 'plus', value });
        continue;
      }

      push({ type: 'plus', value: PLUS_LITERAL });
      continue;
    }

    /**
     * Plain text
     */

    if (value === '@') {
      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
        push({ type: 'at', value, output: '' });
        continue;
      }

      push({ type: 'text', value });
      continue;
    }

    /**
     * Plain text
     */

    if (value !== '*') {
      if (value === '$' || value === '^') {
        value = '\\' + value;
      }

      let match = REGEX_NON_SPECIAL_CHAR.exec(input.slice(state.index + 1));
      if (match) {
        value += match[0];
        state.index += match[0].length;
      }

      push({ type: 'text', value });
      continue;
    }

    /**
     * Stars
     */

    if (prev && (prev.type === 'globstar' || prev.star === true)) {
      prev.type = 'star';
      prev.star = true;
      prev.value += value;
      prev.output = star;
      state.backtrack = true;
      state.consumed += value;
      continue;
    }

    if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
      extglobOpen('star', value);
      continue;
    }

    if (prev.type === 'star') {
      if (opts.noglobstar === true) {
        state.consumed += value;
        continue;
      }

      let prior = prev.prev;
      let before = prior.prev;
      let isStart = prior.type === 'slash' || prior.type === 'bos';
      let afterStar = before && (before.type === 'star' || before.type === 'globstar');

      if (opts.bash === true && (!isStart || (!eos() && peek() !== '/'))) {
        push({ type: 'star', value, output: '' });
        continue;
      }

      let isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');
      let isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');
      if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {
        push({ type: 'star', value, output: '' });
        continue;
      }

      // strip consecutive `/**/`
      while (input.slice(state.index + 1, state.index + 4) === '/**') {
        let after = input[state.index + 4];
        if (after && after !== '/') {
          break;
        }
        state.consumed += '/**';
        state.index += 3;
      }

      if (prior.type === 'bos' && eos()) {
        prev.type = 'globstar';
        prev.value += value;
        prev.output = globstar(opts);
        state.output = prev.output;
        state.consumed += value;
        continue;
      }

      if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {
        state.output = state.output.slice(0, -(prior.output + prev.output).length);
        prior.output = '(?:' + prior.output;

        prev.type = 'globstar';
        prev.output = globstar(opts) + '|$)';
        prev.value += value;

        state.output += prior.output + prev.output;
        state.consumed += value;
        continue;
      }

      let next = peek();
      if (prior.type === 'slash' && prior.prev.type !== 'bos' && next === '/') {
        let end = peek(2) !== void 0 ? '|$' : '';

        state.output = state.output.slice(0, -(prior.output + prev.output).length);
        prior.output = '(?:' + prior.output;

        prev.type = 'globstar';
        prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
        prev.value += value;

        state.output += prior.output + prev.output;
        state.consumed += value + advance();

        push({ type: 'slash', value, output: '' });
        continue;
      }

      if (prior.type === 'bos' && next === '/') {
        prev.type = 'globstar';
        prev.value += value;
        prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
        state.output = prev.output;
        state.consumed += value + advance();
        push({ type: 'slash', value, output: '' });
        continue;
      }

      // remove single star from output
      state.output = state.output.slice(0, -prev.output.length);

      // reset previous token to globstar
      prev.type = 'globstar';
      prev.output = globstar(opts);
      prev.value += value;

      // reset output with globstar
      state.output += prev.output;
      state.consumed += value;
      continue;
    }

    let token = { type: 'star', value, output: star };

    if (opts.bash === true) {
      token.output = '.*?';
      if (prev.type === 'bos' || prev.type === 'slash') {
        token.output = nodot + token.output;
      }
      push(token);
      continue;
    }

    if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {
      token.output = value;
      push(token);
      continue;
    }

    if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {
      if (prev.type === 'dot') {
        state.output += NO_DOT_SLASH;
        prev.output += NO_DOT_SLASH;

      } else if (opts.dot === true) {
        state.output += NO_DOTS_SLASH;
        prev.output += NO_DOTS_SLASH;

      } else {
        state.output += nodot;
        prev.output += nodot;
      }

      if (peek() !== '*') {
        state.output += ONE_CHAR;
        prev.output += ONE_CHAR;
      }
    }

    push(token);
  }

  while (state.brackets > 0) {
    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));
    state.output = utils.escapeLast(state.output, '[');
    decrement('brackets');
  }

  while (state.parens > 0) {
    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));
    state.output = utils.escapeLast(state.output, '(');
    decrement('parens');
  }

  while (state.braces > 0) {
    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));
    state.output = utils.escapeLast(state.output, '{');
    decrement('braces');
  }

  if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {
    push({ type: 'maybe_slash', value: '', output: `${SLASH_LITERAL}?` });
  }

  // rebuild the output if we had to backtrack at any point
  if (state.backtrack === true) {
    state.output = '';

    for (let token of state.tokens) {
      state.output += token.output != null ? token.output : token.value;

      if (token.suffix) {
        state.output += token.suffix;
      }
    }
  }

  return state;
};

/**
 * Fast paths for creating regular expressions for common glob patterns.
 * This can significantly speed up processing and has very little downside
 * impact when none of the fast paths match.
 */

parse.fastpaths = (input, options) => {
  let opts = { ...options };
  let max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
  let len = input.length;
  if (len > max) {
    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
  }

  input = REPLACEMENTS[input] || input;
  let win32 = utils.isWindows(options);

  // create constants based on platform, for windows or posix
  const {
    DOT_LITERAL,
    SLASH_LITERAL,
    ONE_CHAR,
    DOTS_SLASH,
    NO_DOT,
    NO_DOTS,
    NO_DOTS_SLASH,
    STAR,
    START_ANCHOR
  } = constants.globChars(win32);

  let capture = opts.capture ? '' : '?:';
  let star = opts.bash === true ? '.*?' : STAR;
  let nodot = opts.dot ? NO_DOTS : NO_DOT;
  let slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;

  if (opts.capture) {
    star = `(${star})`;
  }

  const globstar = (opts) => {
    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
  };

  const create = str => {
    switch (str) {
      case '*':
        return `${nodot}${ONE_CHAR}${star}`;

      case '.*':
        return `${DOT_LITERAL}${ONE_CHAR}${star}`;

      case '*.*':
        return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;

      case '*/*':
        return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;

      case '**':
        return nodot + globstar(opts);

      case '**/*':
        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;

      case '**/*.*':
        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;

      case '**/.*':
        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;

      default: {
        let match = /^(.*?)\.(\w+)$/.exec(str);
        if (!match) return;

        let source = create(match[1], options);
        if (!source) return;

        return source + DOT_LITERAL + match[2];
      }
    }
  };

  let output = create(input);
  if (output && opts.strictSlashes !== true) {
    output += `${SLASH_LITERAL}?`;
  }

  return output;
};

module.exports = parse;


/***/ }),

/***/ "./node_modules/picomatch/lib/picomatch.js":
/*!*************************************************!*\
  !*** ./node_modules/picomatch/lib/picomatch.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const path = __webpack_require__(/*! path */ "path");
const scan = __webpack_require__(/*! ./scan */ "./node_modules/picomatch/lib/scan.js");
const parse = __webpack_require__(/*! ./parse */ "./node_modules/picomatch/lib/parse.js");
const utils = __webpack_require__(/*! ./utils */ "./node_modules/picomatch/lib/utils.js");

/**
 * Creates a matcher function from one or more glob patterns. The
 * returned function takes a string to match as its first argument,
 * and returns true if the string is a match. The returned matcher
 * function also takes a boolean as the second argument that, when true,
 * returns an object with additional information.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch(glob[, options]);
 *
 * const isMatch = picomatch('*.!(*a)');
 * console.log(isMatch('a.a')); //=> false
 * console.log(isMatch('a.b')); //=> true
 * ```
 * @name picomatch
 * @param {String|Array} `globs` One or more glob patterns.
 * @param {Object=} `options`
 * @return {Function=} Returns a matcher function.
 * @api public
 */

const picomatch = (glob, options, returnState = false) => {
  if (Array.isArray(glob)) {
    let fns = glob.map(input => picomatch(input, options, returnState));
    return str => {
      for (let isMatch of fns) {
        let state = isMatch(str);
        if (state) return state;
      }
      return false;
    };
  }

  if (typeof glob !== 'string' || glob === '') {
    throw new TypeError('Expected pattern to be a non-empty string');
  }

  let opts = options || {};
  let posix = utils.isWindows(options);
  let regex = picomatch.makeRe(glob, options, false, true);
  let state = regex.state;
  delete regex.state;

  let isIgnored = () => false;
  if (opts.ignore) {
    let ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
    isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
  }

  const matcher = (input, returnObject = false) => {
    let { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });
    let result = { glob, state, regex, posix, input, output, match, isMatch };

    if (typeof opts.onResult === 'function') {
      opts.onResult(result);
    }

    if (isMatch === false) {
      result.isMatch = false;
      return returnObject ? result : false;
    }

    if (isIgnored(input)) {
      if (typeof opts.onIgnore === 'function') {
        opts.onIgnore(result);
      }
      result.isMatch = false;
      return returnObject ? result : false;
    }

    if (typeof opts.onMatch === 'function') {
      opts.onMatch(result);
    }
    return returnObject ? result : true;
  };

  if (returnState) {
    matcher.state = state;
  }

  return matcher;
};

/**
 * Test `input` with the given `regex`. This is used by the main
 * `picomatch()` function to test the input string.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.test(input, regex[, options]);
 *
 * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\/([^/]*?))$/));
 * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }
 * ```
 * @param {String} `input` String to test.
 * @param {RegExp} `regex`
 * @return {Object} Returns an object with matching info.
 * @api public
 */

picomatch.test = (input, regex, options, { glob, posix } = {}) => {
  if (typeof input !== 'string') {
    throw new TypeError('Expected input to be a string');
  }

  if (input === '') {
    return { isMatch: false, output: '' };
  }

  let opts = options || {};
  let format = opts.format || (posix ? utils.toPosixSlashes : null);
  let match = input === glob;
  let output = (match && format) ? format(input) : input;

  if (match === false) {
    output = format ? format(input) : input;
    match = output === glob;
  }

  if (match === false || opts.capture === true) {
    if (opts.matchBase === true || opts.basename === true) {
      match = picomatch.matchBase(input, regex, options, posix);
    } else {
      match = regex.exec(output);
    }
  }

  return { isMatch: !!match, match, output };
};

/**
 * Match the basename of a filepath.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.matchBase(input, glob[, options]);
 * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true
 * ```
 * @param {String} `input` String to test.
 * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).
 * @return {Boolean}
 * @api public
 */

picomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {
  let regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
  return regex.test(path.basename(input));
};

/**
 * Returns true if **any** of the given glob `patterns` match the specified `string`.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.isMatch(string, patterns[, options]);
 *
 * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true
 * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false
 * ```
 * @param {String|Array} str The string to test.
 * @param {String|Array} patterns One or more glob patterns to use for matching.
 * @param {Object} [options] See available [options](#options).
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);

/**
 * Parse a glob pattern to create the source string for a regular
 * expression.
 *
 * ```js
 * const picomatch = require('picomatch');
 * const result = picomatch.parse(glob[, options]);
 * ```
 * @param {String} `glob`
 * @param {Object} `options`
 * @return {Object} Returns an object with useful properties and output to be used as a regex source string.
 * @api public
 */

picomatch.parse = (glob, options) => parse(glob, options);

/**
 * Scan a glob pattern to separate the pattern into segments.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.scan(input[, options]);
 *
 * const result = picomatch.scan('!./foo/*.js');
 * console.log(result);
 * // { prefix: '!./',
 * //   input: '!./foo/*.js',
 * //   base: 'foo',
 * //   glob: '*.js',
 * //   negated: true,
 * //   isGlob: true }
 * ```
 * @param {String} `input` Glob pattern to scan.
 * @param {Object} `options`
 * @return {Object} Returns an object with
 * @api public
 */

picomatch.scan = (input, options) => scan(input, options);

/**
 * Create a regular expression from a glob pattern.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.makeRe(input[, options]);
 *
 * console.log(picomatch.makeRe('*.js'));
 * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
 * ```
 * @param {String} `input` A glob pattern to convert to regex.
 * @param {Object} `options`
 * @return {RegExp} Returns a regex created from the given pattern.
 * @api public
 */

picomatch.makeRe = (input, options, returnOutput = false, returnState = false) => {
  if (!input || typeof input !== 'string') {
    throw new TypeError('Expected a non-empty string');
  }

  let opts = options || {};
  let prepend = opts.contains ? '' : '^';
  let append = opts.contains ? '' : '$';
  let state = { negated: false, fastpaths: true };
  let prefix = '';
  let output;

  if (input.startsWith('./')) {
    input = input.slice(2);
    prefix = state.prefix = './';
  }

  if (opts.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {
    output = parse.fastpaths(input, options);
  }

  if (output === void 0) {
    state = picomatch.parse(input, options);
    state.prefix = prefix + (state.prefix || '');
    output = state.output;
  }

  if (returnOutput === true) {
    return output;
  }

  let source = `${prepend}(?:${output})${append}`;
  if (state && state.negated === true) {
    source = `^(?!${source}).*$`;
  }

  let regex = picomatch.toRegex(source, options);
  if (returnState === true) {
    regex.state = state;
  }

  return regex;
};

/**
 * Create a regular expression from the given regex source string.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.toRegex(source[, options]);
 *
 * const { output } = picomatch.parse('*.js');
 * console.log(picomatch.toRegex(output));
 * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
 * ```
 * @param {String} `source` Regular expression source string.
 * @param {Object} `options`
 * @return {RegExp}
 * @api public
 */

picomatch.toRegex = (source, options) => {
  try {
    let opts = options || {};
    return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));
  } catch (err) {
    if (options && options.debug === true) throw err;
    return /$^/;
  }
};

/**
 * Picomatch constants.
 * @return {Object}
 */

picomatch.constants = __webpack_require__(/*! ./constants */ "./node_modules/picomatch/lib/constants.js");

/**
 * Expose "picomatch"
 */

module.exports = picomatch;


/***/ }),

/***/ "./node_modules/picomatch/lib/scan.js":
/*!********************************************!*\
  !*** ./node_modules/picomatch/lib/scan.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const utils = __webpack_require__(/*! ./utils */ "./node_modules/picomatch/lib/utils.js");

const {
  CHAR_ASTERISK,             /* * */
  CHAR_AT,                   /* @ */
  CHAR_BACKWARD_SLASH,       /* \ */
  CHAR_COMMA,                /* , */
  CHAR_DOT,                  /* . */
  CHAR_EXCLAMATION_MARK,     /* ! */
  CHAR_FORWARD_SLASH,        /* / */
  CHAR_LEFT_CURLY_BRACE,     /* { */
  CHAR_LEFT_PARENTHESES,     /* ( */
  CHAR_LEFT_SQUARE_BRACKET,  /* [ */
  CHAR_PLUS,                 /* + */
  CHAR_QUESTION_MARK,        /* ? */
  CHAR_RIGHT_CURLY_BRACE,    /* } */
  CHAR_RIGHT_PARENTHESES,    /* ) */
  CHAR_RIGHT_SQUARE_BRACKET /* ] */
} = __webpack_require__(/*! ./constants */ "./node_modules/picomatch/lib/constants.js");

const isPathSeparator = code => {
  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
};

/**
 * Quickly scans a glob pattern and returns an object with a handful of
 * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),
 * `glob` (the actual pattern), and `negated` (true if the path starts with `!`).
 *
 * ```js
 * const pm = require('picomatch');
 * console.log(pm.scan('foo/bar/*.js'));
 * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }
 * ```
 * @param {String} `str`
 * @param {Object} `options`
 * @return {Object} Returns an object with tokens and regex source string.
 * @api public
 */

module.exports = (input, options) => {
  let opts = options || {};
  let length = input.length - 1;
  let index = -1;
  let start = 0;
  let lastIndex = 0;
  let isGlob = false;
  let backslashes = false;
  let negated = false;
  let braces = 0;
  let prev;
  let code;

  let braceEscaped = false;

  let eos = () => index >= length;
  let advance = () => {
    prev = code;
    return input.charCodeAt(++index);
  };

  while (index < length) {
    code = advance();
    let next;

    if (code === CHAR_BACKWARD_SLASH) {
      backslashes = true;
      next = advance();

      if (next === CHAR_LEFT_CURLY_BRACE) {
        braceEscaped = true;
      }
      continue;
    }

    if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
      braces++;

      while (!eos() && (next = advance())) {
        if (next === CHAR_BACKWARD_SLASH) {
          backslashes = true;
          next = advance();
          continue;
        }

        if (next === CHAR_LEFT_CURLY_BRACE) {
          braces++;
          continue;
        }

        if (!braceEscaped && next === CHAR_DOT && (next = advance()) === CHAR_DOT) {
          isGlob = true;
          break;
        }

        if (!braceEscaped && next === CHAR_COMMA) {
          isGlob = true;
          break;
        }

        if (next === CHAR_RIGHT_CURLY_BRACE) {
          braces--;
          if (braces === 0) {
            braceEscaped = false;
            break;
          }
        }
      }
    }

    if (code === CHAR_FORWARD_SLASH) {
      if (prev === CHAR_DOT && index === (start + 1)) {
        start += 2;
        continue;
      }

      lastIndex = index + 1;
      continue;
    }

    if (code === CHAR_ASTERISK) {
      isGlob = true;
      break;
    }

    if (code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK) {
      isGlob = true;
      break;
    }

    if (code === CHAR_LEFT_SQUARE_BRACKET) {
      while (!eos() && (next = advance())) {
        if (next === CHAR_BACKWARD_SLASH) {
          backslashes = true;
          next = advance();
          continue;
        }

        if (next === CHAR_RIGHT_SQUARE_BRACKET) {
          isGlob = true;
          break;
        }
      }
    }

    let isExtglobChar = code === CHAR_PLUS
      || code === CHAR_AT
      || code === CHAR_EXCLAMATION_MARK;

    if (isExtglobChar && input.charCodeAt(index + 1) === CHAR_LEFT_PARENTHESES) {
      isGlob = true;
      break;
    }

    if (code === CHAR_EXCLAMATION_MARK && index === start) {
      negated = true;
      start++;
      continue;
    }

    if (code === CHAR_LEFT_PARENTHESES) {
      while (!eos() && (next = advance())) {
        if (next === CHAR_BACKWARD_SLASH) {
          backslashes = true;
          next = advance();
          continue;
        }

        if (next === CHAR_RIGHT_PARENTHESES) {
          isGlob = true;
          break;
        }
      }
    }

    if (isGlob) {
      break;
    }
  }

  let prefix = '';
  let orig = input;
  let base = input;
  let glob = '';

  if (start > 0) {
    prefix = input.slice(0, start);
    input = input.slice(start);
    lastIndex -= start;
  }

  if (base && isGlob === true && lastIndex > 0) {
    base = input.slice(0, lastIndex);
    glob = input.slice(lastIndex);
  } else if (isGlob === true) {
    base = '';
    glob = input;
  } else {
    base = input;
  }

  if (base && base !== '' && base !== '/' && base !== input) {
    if (isPathSeparator(base.charCodeAt(base.length - 1))) {
      base = base.slice(0, -1);
    }
  }

  if (opts.unescape === true) {
    if (glob) glob = utils.removeBackslashes(glob);

    if (base && backslashes === true) {
      base = utils.removeBackslashes(base);
    }
  }

  return { prefix, input: orig, base, glob, negated, isGlob };
};


/***/ }),

/***/ "./node_modules/picomatch/lib/utils.js":
/*!*********************************************!*\
  !*** ./node_modules/picomatch/lib/utils.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const path = __webpack_require__(/*! path */ "path");
const win32 = process.platform === 'win32';
const {
  REGEX_SPECIAL_CHARS,
  REGEX_SPECIAL_CHARS_GLOBAL,
  REGEX_REMOVE_BACKSLASH
} = __webpack_require__(/*! ./constants */ "./node_modules/picomatch/lib/constants.js");

exports.isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);
exports.hasRegexChars = str => REGEX_SPECIAL_CHARS.test(str);
exports.isRegexChar = str => str.length === 1 && exports.hasRegexChars(str);
exports.escapeRegex = str => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\$1');
exports.toPosixSlashes = str => str.replace(/\\/g, '/');

exports.removeBackslashes = str => {
  return str.replace(REGEX_REMOVE_BACKSLASH, match => {
    return match === '\\' ? '' : match;
  });
}

exports.supportsLookbehinds = () => {
  let segs = process.version.slice(1).split('.');
  if (segs.length === 3 && +segs[0] >= 9 || (+segs[0] === 8 && +segs[1] >= 10)) {
    return true;
  }
  return false;
};

exports.isWindows = options => {
  if (options && typeof options.windows === 'boolean') {
    return options.windows;
  }
  return win32 === true || path.sep === '\\';
};

exports.escapeLast = (input, char, lastIdx) => {
  let idx = input.lastIndexOf(char, lastIdx);
  if (idx === -1) return input;
  if (input[idx - 1] === '\\') return exports.escapeLast(input, char, idx - 1);
  return input.slice(0, idx) + '\\' + input.slice(idx);
};


/***/ }),

/***/ "./node_modules/proxy-addr/index.js":
/*!******************************************!*\
  !*** ./node_modules/proxy-addr/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * proxy-addr
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = proxyaddr
module.exports.all = alladdrs
module.exports.compile = compile

/**
 * Module dependencies.
 * @private
 */

var forwarded = __webpack_require__(/*! forwarded */ "./node_modules/forwarded/index.js")
var ipaddr = __webpack_require__(/*! ipaddr.js */ "./node_modules/ipaddr.js/lib/ipaddr.js")

/**
 * Variables.
 * @private
 */

var DIGIT_REGEXP = /^[0-9]+$/
var isip = ipaddr.isValid
var parseip = ipaddr.parse

/**
 * Pre-defined IP ranges.
 * @private
 */

var IP_RANGES = {
  linklocal: ['169.254.0.0/16', 'fe80::/10'],
  loopback: ['127.0.0.1/8', '::1/128'],
  uniquelocal: ['10.0.0.0/8', '172.16.0.0/12', '192.168.0.0/16', 'fc00::/7']
}

/**
 * Get all addresses in the request, optionally stopping
 * at the first untrusted.
 *
 * @param {Object} request
 * @param {Function|Array|String} [trust]
 * @public
 */

function alladdrs (req, trust) {
  // get addresses
  var addrs = forwarded(req)

  if (!trust) {
    // Return all addresses
    return addrs
  }

  if (typeof trust !== 'function') {
    trust = compile(trust)
  }

  for (var i = 0; i < addrs.length - 1; i++) {
    if (trust(addrs[i], i)) continue

    addrs.length = i + 1
  }

  return addrs
}

/**
 * Compile argument into trust function.
 *
 * @param {Array|String} val
 * @private
 */

function compile (val) {
  if (!val) {
    throw new TypeError('argument is required')
  }

  var trust

  if (typeof val === 'string') {
    trust = [val]
  } else if (Array.isArray(val)) {
    trust = val.slice()
  } else {
    throw new TypeError('unsupported trust argument')
  }

  for (var i = 0; i < trust.length; i++) {
    val = trust[i]

    if (!IP_RANGES.hasOwnProperty(val)) {
      continue
    }

    // Splice in pre-defined range
    val = IP_RANGES[val]
    trust.splice.apply(trust, [i, 1].concat(val))
    i += val.length - 1
  }

  return compileTrust(compileRangeSubnets(trust))
}

/**
 * Compile `arr` elements into range subnets.
 *
 * @param {Array} arr
 * @private
 */

function compileRangeSubnets (arr) {
  var rangeSubnets = new Array(arr.length)

  for (var i = 0; i < arr.length; i++) {
    rangeSubnets[i] = parseipNotation(arr[i])
  }

  return rangeSubnets
}

/**
 * Compile range subnet array into trust function.
 *
 * @param {Array} rangeSubnets
 * @private
 */

function compileTrust (rangeSubnets) {
  // Return optimized function based on length
  var len = rangeSubnets.length
  return len === 0
    ? trustNone
    : len === 1
      ? trustSingle(rangeSubnets[0])
      : trustMulti(rangeSubnets)
}

/**
 * Parse IP notation string into range subnet.
 *
 * @param {String} note
 * @private
 */

function parseipNotation (note) {
  var pos = note.lastIndexOf('/')
  var str = pos !== -1
    ? note.substring(0, pos)
    : note

  if (!isip(str)) {
    throw new TypeError('invalid IP address: ' + str)
  }

  var ip = parseip(str)

  if (pos === -1 && ip.kind() === 'ipv6' && ip.isIPv4MappedAddress()) {
    // Store as IPv4
    ip = ip.toIPv4Address()
  }

  var max = ip.kind() === 'ipv6'
    ? 128
    : 32

  var range = pos !== -1
    ? note.substring(pos + 1, note.length)
    : null

  if (range === null) {
    range = max
  } else if (DIGIT_REGEXP.test(range)) {
    range = parseInt(range, 10)
  } else if (ip.kind() === 'ipv4' && isip(range)) {
    range = parseNetmask(range)
  } else {
    range = null
  }

  if (range <= 0 || range > max) {
    throw new TypeError('invalid range on address: ' + note)
  }

  return [ip, range]
}

/**
 * Parse netmask string into CIDR range.
 *
 * @param {String} netmask
 * @private
 */

function parseNetmask (netmask) {
  var ip = parseip(netmask)
  var kind = ip.kind()

  return kind === 'ipv4'
    ? ip.prefixLengthFromSubnetMask()
    : null
}

/**
 * Determine address of proxied request.
 *
 * @param {Object} request
 * @param {Function|Array|String} trust
 * @public
 */

function proxyaddr (req, trust) {
  if (!req) {
    throw new TypeError('req argument is required')
  }

  if (!trust) {
    throw new TypeError('trust argument is required')
  }

  var addrs = alladdrs(req, trust)
  var addr = addrs[addrs.length - 1]

  return addr
}

/**
 * Static trust function to trust nothing.
 *
 * @private
 */

function trustNone () {
  return false
}

/**
 * Compile trust function for multiple subnets.
 *
 * @param {Array} subnets
 * @private
 */

function trustMulti (subnets) {
  return function trust (addr) {
    if (!isip(addr)) return false

    var ip = parseip(addr)
    var ipconv
    var kind = ip.kind()

    for (var i = 0; i < subnets.length; i++) {
      var subnet = subnets[i]
      var subnetip = subnet[0]
      var subnetkind = subnetip.kind()
      var subnetrange = subnet[1]
      var trusted = ip

      if (kind !== subnetkind) {
        if (subnetkind === 'ipv4' && !ip.isIPv4MappedAddress()) {
          // Incompatible IP addresses
          continue
        }

        if (!ipconv) {
          // Convert IP to match subnet IP kind
          ipconv = subnetkind === 'ipv4'
            ? ip.toIPv4Address()
            : ip.toIPv4MappedAddress()
        }

        trusted = ipconv
      }

      if (trusted.match(subnetip, subnetrange)) {
        return true
      }
    }

    return false
  }
}

/**
 * Compile trust function for single subnet.
 *
 * @param {Object} subnet
 * @private
 */

function trustSingle (subnet) {
  var subnetip = subnet[0]
  var subnetkind = subnetip.kind()
  var subnetisipv4 = subnetkind === 'ipv4'
  var subnetrange = subnet[1]

  return function trust (addr) {
    if (!isip(addr)) return false

    var ip = parseip(addr)
    var kind = ip.kind()

    if (kind !== subnetkind) {
      if (subnetisipv4 && !ip.isIPv4MappedAddress()) {
        // Incompatible IP addresses
        return false
      }

      // Convert IP to match subnet IP kind
      ip = subnetisipv4
        ? ip.toIPv4Address()
        : ip.toIPv4MappedAddress()
    }

    return ip.match(subnetip, subnetrange)
  }
}


/***/ }),

/***/ "./node_modules/range-parser/index.js":
/*!********************************************!*\
  !*** ./node_modules/range-parser/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * range-parser
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015-2016 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = rangeParser

/**
 * Parse "Range" header `str` relative to the given file `size`.
 *
 * @param {Number} size
 * @param {String} str
 * @param {Object} [options]
 * @return {Array}
 * @public
 */

function rangeParser (size, str, options) {
  if (typeof str !== 'string') {
    throw new TypeError('argument str must be a string')
  }

  var index = str.indexOf('=')

  if (index === -1) {
    return -2
  }

  // split the range string
  var arr = str.slice(index + 1).split(',')
  var ranges = []

  // add ranges type
  ranges.type = str.slice(0, index)

  // parse all ranges
  for (var i = 0; i < arr.length; i++) {
    var range = arr[i].split('-')
    var start = parseInt(range[0], 10)
    var end = parseInt(range[1], 10)

    // -nnn
    if (isNaN(start)) {
      start = size - end
      end = size - 1
    // nnn-
    } else if (isNaN(end)) {
      end = size - 1
    }

    // limit last-byte-pos to current length
    if (end > size - 1) {
      end = size - 1
    }

    // invalid or unsatisifiable
    if (isNaN(start) || isNaN(end) || start > end || start < 0) {
      continue
    }

    // add range
    ranges.push({
      start: start,
      end: end
    })
  }

  if (ranges.length < 1) {
    // unsatisifiable
    return -1
  }

  return options && options.combine
    ? combineRanges(ranges)
    : ranges
}

/**
 * Combine overlapping & adjacent ranges.
 * @private
 */

function combineRanges (ranges) {
  var ordered = ranges.map(mapWithIndex).sort(sortByRangeStart)

  for (var j = 0, i = 1; i < ordered.length; i++) {
    var range = ordered[i]
    var current = ordered[j]

    if (range.start > current.end + 1) {
      // next range
      ordered[++j] = range
    } else if (range.end > current.end) {
      // extend range
      current.end = range.end
      current.index = Math.min(current.index, range.index)
    }
  }

  // trim ordered array
  ordered.length = j + 1

  // generate combined range
  var combined = ordered.sort(sortByRangeIndex).map(mapWithoutIndex)

  // copy ranges type
  combined.type = ranges.type

  return combined
}

/**
 * Map function to add index value to ranges.
 * @private
 */

function mapWithIndex (range, index) {
  return {
    start: range.start,
    end: range.end,
    index: index
  }
}

/**
 * Map function to remove index value from ranges.
 * @private
 */

function mapWithoutIndex (range) {
  return {
    start: range.start,
    end: range.end
  }
}

/**
 * Sort function to sort ranges by index.
 * @private
 */

function sortByRangeIndex (a, b) {
  return a.index - b.index
}

/**
 * Sort function to sort ranges by start position.
 * @private
 */

function sortByRangeStart (a, b) {
  return a.start - b.start
}


/***/ }),

/***/ "./node_modules/raw-body/index.js":
/*!****************************************!*\
  !*** ./node_modules/raw-body/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * raw-body
 * Copyright(c) 2013-2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var bytes = __webpack_require__(/*! bytes */ "./node_modules/bytes/index.js")
var createError = __webpack_require__(/*! http-errors */ "./node_modules/http-errors/index.js")
var iconv = __webpack_require__(/*! iconv-lite */ "./node_modules/iconv-lite/lib/index.js")
var unpipe = __webpack_require__(/*! unpipe */ "./node_modules/unpipe/index.js")

/**
 * Module exports.
 * @public
 */

module.exports = getRawBody

/**
 * Module variables.
 * @private
 */

var ICONV_ENCODING_MESSAGE_REGEXP = /^Encoding not recognized: /

/**
 * Get the decoder for a given encoding.
 *
 * @param {string} encoding
 * @private
 */

function getDecoder (encoding) {
  if (!encoding) return null

  try {
    return iconv.getDecoder(encoding)
  } catch (e) {
    // error getting decoder
    if (!ICONV_ENCODING_MESSAGE_REGEXP.test(e.message)) throw e

    // the encoding was not found
    throw createError(415, 'specified encoding unsupported', {
      encoding: encoding,
      type: 'encoding.unsupported'
    })
  }
}

/**
 * Get the raw body of a stream (typically HTTP).
 *
 * @param {object} stream
 * @param {object|string|function} [options]
 * @param {function} [callback]
 * @public
 */

function getRawBody (stream, options, callback) {
  var done = callback
  var opts = options || {}

  if (options === true || typeof options === 'string') {
    // short cut for encoding
    opts = {
      encoding: options
    }
  }

  if (typeof options === 'function') {
    done = options
    opts = {}
  }

  // validate callback is a function, if provided
  if (done !== undefined && typeof done !== 'function') {
    throw new TypeError('argument callback must be a function')
  }

  // require the callback without promises
  if (!done && !global.Promise) {
    throw new TypeError('argument callback is required')
  }

  // get encoding
  var encoding = opts.encoding !== true
    ? opts.encoding
    : 'utf-8'

  // convert the limit to an integer
  var limit = bytes.parse(opts.limit)

  // convert the expected length to an integer
  var length = opts.length != null && !isNaN(opts.length)
    ? parseInt(opts.length, 10)
    : null

  if (done) {
    // classic callback style
    return readStream(stream, encoding, length, limit, done)
  }

  return new Promise(function executor (resolve, reject) {
    readStream(stream, encoding, length, limit, function onRead (err, buf) {
      if (err) return reject(err)
      resolve(buf)
    })
  })
}

/**
 * Halt a stream.
 *
 * @param {Object} stream
 * @private
 */

function halt (stream) {
  // unpipe everything from the stream
  unpipe(stream)

  // pause stream
  if (typeof stream.pause === 'function') {
    stream.pause()
  }
}

/**
 * Read the data from the stream.
 *
 * @param {object} stream
 * @param {string} encoding
 * @param {number} length
 * @param {number} limit
 * @param {function} callback
 * @public
 */

function readStream (stream, encoding, length, limit, callback) {
  var complete = false
  var sync = true

  // check the length and limit options.
  // note: we intentionally leave the stream paused,
  // so users should handle the stream themselves.
  if (limit !== null && length !== null && length > limit) {
    return done(createError(413, 'request entity too large', {
      expected: length,
      length: length,
      limit: limit,
      type: 'entity.too.large'
    }))
  }

  // streams1: assert request encoding is buffer.
  // streams2+: assert the stream encoding is buffer.
  //   stream._decoder: streams1
  //   state.encoding: streams2
  //   state.decoder: streams2, specifically < 0.10.6
  var state = stream._readableState
  if (stream._decoder || (state && (state.encoding || state.decoder))) {
    // developer error
    return done(createError(500, 'stream encoding should not be set', {
      type: 'stream.encoding.set'
    }))
  }

  var received = 0
  var decoder

  try {
    decoder = getDecoder(encoding)
  } catch (err) {
    return done(err)
  }

  var buffer = decoder
    ? ''
    : []

  // attach listeners
  stream.on('aborted', onAborted)
  stream.on('close', cleanup)
  stream.on('data', onData)
  stream.on('end', onEnd)
  stream.on('error', onEnd)

  // mark sync section complete
  sync = false

  function done () {
    var args = new Array(arguments.length)

    // copy arguments
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i]
    }

    // mark complete
    complete = true

    if (sync) {
      process.nextTick(invokeCallback)
    } else {
      invokeCallback()
    }

    function invokeCallback () {
      cleanup()

      if (args[0]) {
        // halt the stream on error
        halt(stream)
      }

      callback.apply(null, args)
    }
  }

  function onAborted () {
    if (complete) return

    done(createError(400, 'request aborted', {
      code: 'ECONNABORTED',
      expected: length,
      length: length,
      received: received,
      type: 'request.aborted'
    }))
  }

  function onData (chunk) {
    if (complete) return

    received += chunk.length

    if (limit !== null && received > limit) {
      done(createError(413, 'request entity too large', {
        limit: limit,
        received: received,
        type: 'entity.too.large'
      }))
    } else if (decoder) {
      buffer += decoder.write(chunk)
    } else {
      buffer.push(chunk)
    }
  }

  function onEnd (err) {
    if (complete) return
    if (err) return done(err)

    if (length !== null && received !== length) {
      done(createError(400, 'request size did not match content length', {
        expected: length,
        length: length,
        received: received,
        type: 'request.size.invalid'
      }))
    } else {
      var string = decoder
        ? buffer + (decoder.end() || '')
        : Buffer.concat(buffer)
      done(null, string)
    }
  }

  function cleanup () {
    buffer = null

    stream.removeListener('aborted', onAborted)
    stream.removeListener('data', onData)
    stream.removeListener('end', onEnd)
    stream.removeListener('error', onEnd)
    stream.removeListener('close', cleanup)
  }
}


/***/ }),

/***/ "./node_modules/readdirp/index.js":
/*!****************************************!*\
  !*** ./node_modules/readdirp/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const fs = __webpack_require__(/*! fs */ "fs");
const {Readable} = __webpack_require__(/*! stream */ "stream");
const sysPath = __webpack_require__(/*! path */ "path");
const picomatch = __webpack_require__(/*! picomatch */ "./node_modules/picomatch/index.js");
const {promisify} = __webpack_require__(/*! util */ "util");
const [readdir, stat, lstat] = [promisify(fs.readdir), promisify(fs.stat), promisify(fs.lstat)];
const supportsDirent = 'Dirent' in fs;

/**
 * @typedef {Object} EntryInfo
 * @property {String} path
 * @property {String} fullPath
 * @property {fs.Stats=} stats
 * @property {fs.Dirent=} dirent
 * @property {String} basename
 */

const isWindows = process.platform === 'win32';
const supportsBigint = !/^v8\./.test(process.version);
const BANG = '!';
const NORMAL_FLOW_ERRORS = new Set(['ENOENT', 'EPERM', 'EACCES', 'ELOOP']);
const FILE_TYPE = 'files';
const DIR_TYPE = 'directories';
const FILE_DIR_TYPE = 'files_directories';
const EVERYTHING_TYPE = 'all';
const FILE_TYPES = new Set([FILE_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE]);
const DIR_TYPES = new Set([DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE]);
const ALL_TYPES = [FILE_TYPE, DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE];

const isNormalFlowError = (errorCode) => NORMAL_FLOW_ERRORS.has(errorCode);

const normalizeFilter = (filter) => {
  if (filter === undefined) return;
  if (typeof filter === 'function') return filter;

  if (typeof filter === 'string') {
    const glob = picomatch(filter.trim());
    return (entry) => glob(entry.basename);
  }

  if (Array.isArray(filter)) {
    const positive = [];
    const negative = [];
    for (const item of filter) {
      const trimmed = item.trim();
      if (trimmed.charAt(0) === BANG) {
        negative.push(picomatch(trimmed.slice(1)));
      } else {
        positive.push(picomatch(trimmed));
      }
    }

    if (negative.length > 0) {
      if (positive.length > 0) {
        return (entry) => positive.some(f => f(entry.basename)) &&
          !negative.some(f => f(entry.basename));
      } else {
        return (entry) => !negative.some(f => f(entry.basename));
      }
    } else {
      return (entry) => positive.some(f => f(entry.basename));
    }
  }
};

class ExploringDir {
  constructor(path, depth) {
    this.path = path;
    this.depth = depth;
  }
}

class ReaddirpStream extends Readable {
  static get defaultOptions() {
    return {
      root: '.',
      fileFilter: (path) => true,
      directoryFilter: (path) => true,
      type: 'files',
      lstat: false,
      depth: 2147483648,
      alwaysStat: false
    }
  }

  constructor(options = {}) {
    super({objectMode: true, highWaterMark: 1});
    const opts = Object.assign({}, ReaddirpStream.defaultOptions, options);
    const {root} = opts;

    this._fileFilter = normalizeFilter(opts.fileFilter);
    this._directoryFilter = normalizeFilter(opts.directoryFilter);
    this._statMethod = opts.lstat ? lstat : stat;
    this._statOpts = {bigint: isWindows};
    this._maxDepth = opts.depth;
    this._entryType = opts.type
    this._root = root;
    this._isDirent = !opts.alwaysStat && supportsDirent;
    this._statsProp = this._isDirent ? 'dirent' : 'stats';
    this._readdir_options = {encoding: 'utf8', withFileTypes: this._isDirent};

    // Launch stream with one parent, the root dir.
    /** @type Array<[string, number]>  */
    this.parents = [new ExploringDir(root, 0)];
    this.filesToRead = 0;
  }

  async _read() {
    // If the stream was destroyed, we must not proceed.
    if (!this.readable) return;

    do {
      const parent = this.parents.pop();
      if (!parent) {
        // ...we have files to process; but not directories.
        // hence, parent is undefined; and we cannot execute fs.readdir().
        // The files are being processed anywhere.
        break;
      }
      await this._exploreDirectory(parent);
    } while(!this.isPaused() && !this._isQueueEmpty());

    this._endStreamIfQueueIsEmpty();
  }

  async _exploreDirectory(parent) {
    /** @type Array<fs.Dirent|string> */
    let files = [];

    // To prevent race conditions, we increase counter while awaiting readdir.
    this.filesToRead++;
    try {
      files = await readdir(parent.path, this._readdir_options);
    } catch (error) {
      if (isNormalFlowError(error.code)) {
        this._handleError(error);
      } else {
        this._handleFatalError(error);
      }
    }
    this.filesToRead--;

    // If the stream was destroyed, after readdir is completed
    if (!this.readable) return;

    this.filesToRead += files.length;

    const entries = await Promise.all(files.map(dirent =>  this._formatEntry(dirent, parent)));

    if (!this.readable) return;

    for (let i = 0; i < entries.length; i++) {
      const entry = entries[i];
      this.filesToRead--;
      if (!entry) {
        continue;
      }
      if (this._isDirAndMatchesFilter(entry)) {
        this._pushNewParentIfLessThanMaxDepth(entry.fullPath, parent.depth + 1);
        this._emitPushIfUserWantsDir(entry);
      } else if (this._isFileAndMatchesFilter(entry)) {
        this._emitPushIfUserWantsFile(entry);
      }
    }
  }

  _stat(fullPath) {
    if (isWindows && supportsBigint) {
      return this._statMethod(fullPath, this._statOpts);
    } else {
      return this._statMethod(fullPath);
    }
  }

  async _formatEntry(dirent, parent) {
    const relativePath = this._isDirent ? dirent.name : dirent;
    const fullPath = sysPath.resolve(sysPath.join(parent.path, relativePath));

    let stats;
    if (this._isDirent) {
      stats = dirent;
    } else {
      try {
        stats = await this._stat(fullPath);
      } catch (error) {
        if (isNormalFlowError(error.code)) {
          this._handleError(error);
        } else {
          this._handleFatalError(error);
        }
        return;
      }
    }
    const path = sysPath.relative(this._root, fullPath);
    const basename = sysPath.basename(path);

    /** @type {EntryInfo} */
    const entry = {path, fullPath, basename, [this._statsProp]: stats};

    return entry;
  }

  _isQueueEmpty() {
    return this.parents.length === 0 && this.filesToRead === 0 && this.readable;
  }

  _endStreamIfQueueIsEmpty() {
    if (this._isQueueEmpty()) {
      this.push(null);
    }
  }

  _pushNewParentIfLessThanMaxDepth(parentPath, depth) {
    if (depth <= this._maxDepth) {
      this.parents.push(new ExploringDir(parentPath, depth));
      return true
    } else {
      return false;
    }
  }

  _isDirAndMatchesFilter(entry) {
    return entry[this._statsProp].isDirectory() && this._directoryFilter(entry);
  }

  _isFileAndMatchesFilter(entry) {
    const stats = entry[this._statsProp];
    const isFileType = (
      (this._entryType === EVERYTHING_TYPE && !stats.isDirectory()) ||
      (stats.isFile() || stats.isSymbolicLink())
    );
    return isFileType && this._fileFilter(entry);
  }

  _emitPushIfUserWantsDir(entry) {
    if (DIR_TYPES.has(this._entryType)) {
      // TODO: Understand why this happens.
      const fn = () => {this._push(entry)};
      if (this._isDirent) setImmediate(fn);
      else fn();
    }
  }

  _emitPushIfUserWantsFile(entry) {
    if (FILE_TYPES.has(this._entryType)) {
      this._push(entry);
    }
  }

  _push(entry) {
    if (this.readable) {
      this.push(entry);
    }
  }

  _handleError(error) {
    if (!this.readable) {
      return;
    }
    this.emit('warn', error);
  }

  _handleFatalError(error) {
    if (!this.readable) {
      return;
    }
    this.emit('error', error);
    this.destroy();
  }

  destroy() {
    this.emit('close');
  }
}

/**
 * @typedef {Object} ReaddirpArguments
 * @property {Function=} fileFilter
 * @property {Function=} directoryFilter
 * @property {String=} type
 * @property {Number=} depth
 * @property {String=} root
 * @property {Boolean=} lstat
 * @property {Boolean=} bigint
 */

/**
 * Main function which ends up calling readdirRec and reads all files and directories in given root recursively.
 * @param {String} root Root directory
 * @param {ReaddirpArguments=} options Options to specify root (start directory), filters and recursion depth
 */
const readdirp = (root, options = {}) => {
  let type = options['entryType'] || options.type;
  if (type === 'both') type = FILE_DIR_TYPE; // backwards-compatibility
  if (type) options.type = type;
  if (root == null || typeof root === 'undefined') {
    throw new Error('readdirp: root argument is required. Usage: readdirp(root, options)');
  } else if (typeof root !== 'string') {
    throw new Error(`readdirp: root argument must be a string. Usage: readdirp(root, options)`);
  } else if (type && !ALL_TYPES.includes(type)) {
    throw new Error(`readdirp: Invalid type passed. Use one of ${ALL_TYPES.join(', ')}`);
  }

  options.root = root;
  return new ReaddirpStream(options);
};

const readdirpPromise = (root, options = {}) => {
  return new Promise((resolve, reject) => {
    const files = [];
    readdirp(root, options)
      .on('data', (entry) => files.push(entry))
      .on('end', () => resolve(files))
      .on('error', (error) => reject(error));
  });
};

readdirp.promise = readdirpPromise;
readdirp.ReaddirpStream = ReaddirpStream;
readdirp.default = readdirp;

module.exports = readdirp;


/***/ }),

/***/ "./node_modules/safe-buffer/index.js":
/*!*******************************************!*\
  !*** ./node_modules/safe-buffer/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(/*! buffer */ "buffer")
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}


/***/ }),

/***/ "./node_modules/safer-buffer/safer.js":
/*!********************************************!*\
  !*** ./node_modules/safer-buffer/safer.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* eslint-disable node/no-deprecated-api */



var buffer = __webpack_require__(/*! buffer */ "buffer")
var Buffer = buffer.Buffer

var safer = {}

var key

for (key in buffer) {
  if (!buffer.hasOwnProperty(key)) continue
  if (key === 'SlowBuffer' || key === 'Buffer') continue
  safer[key] = buffer[key]
}

var Safer = safer.Buffer = {}
for (key in Buffer) {
  if (!Buffer.hasOwnProperty(key)) continue
  if (key === 'allocUnsafe' || key === 'allocUnsafeSlow') continue
  Safer[key] = Buffer[key]
}

safer.Buffer.prototype = Buffer.prototype

if (!Safer.from || Safer.from === Uint8Array.from) {
  Safer.from = function (value, encodingOrOffset, length) {
    if (typeof value === 'number') {
      throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value)
    }
    if (value && typeof value.length === 'undefined') {
      throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' + typeof value)
    }
    return Buffer(value, encodingOrOffset, length)
  }
}

if (!Safer.alloc) {
  Safer.alloc = function (size, fill, encoding) {
    if (typeof size !== 'number') {
      throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size)
    }
    if (size < 0 || size >= 2 * (1 << 30)) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"')
    }
    var buf = Buffer(size)
    if (!fill || fill.length === 0) {
      buf.fill(0)
    } else if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
    return buf
  }
}

if (!safer.kStringMaxLength) {
  try {
    safer.kStringMaxLength = process.binding('buffer').kStringMaxLength
  } catch (e) {
    // we can't determine kStringMaxLength in environments where process.binding
    // is unsupported, so let's not set it
  }
}

if (!safer.constants) {
  safer.constants = {
    MAX_LENGTH: safer.kMaxLength
  }
  if (safer.kStringMaxLength) {
    safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength
  }
}

module.exports = safer


/***/ }),

/***/ "./node_modules/sass/sass.dart.js":
/*!****************************************!*\
  !*** ./node_modules/sass/sass.dart.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(__dirname, __filename) {// make sure to keep this as 'var'
// we don't want block scoping

var url = __webpack_require__(/*! url */ "url");
var dartNodePreambleSelf = typeof global !== "undefined" ? global : window;

var self = Object.create(dartNodePreambleSelf);

self.scheduleImmediate = self.setImmediate
    ? function (cb) {
        dartNodePreambleSelf.setImmediate(cb);
      }
    : function(cb) {
        setTimeout(cb, 0);
      };

// CommonJS globals.
self.exports = exports;

// Node.js specific exports, check to see if they exist & or polyfilled

if (typeof process !== "undefined") {
  self.process = process;
}

if (true) {
  self.__dirname = __dirname;
}

if (true) {
  self.__filename = __filename;
}

// if we're running in a browser, Dart supports most of this out of box
// make sure we only run these in Node.js environment
if (!dartNodePreambleSelf.window) {
  self.location = {
    get href() {
      if (url.pathToFileURL) {
        return url.pathToFileURL(process.cwd()).href + "/";
      } else {
        // This isn't really a correct transformation, but it's the best we have
        // for versions of Node <10.12.0 which introduced `url.pathToFileURL()`.
        // For example, it will fail for paths that contain characters that need
        // to be escaped in URLs.
        return "file://" + (function() {
          var cwd = process.cwd();
          if (process.platform != "win32") return cwd;
          return "/" + cwd.replace(/\\/g, "/");
        })() + "/"
      }
    }
  };

  (function() {
    function computeCurrentScript() {
      try {
        throw new Error();
      } catch(e) {
        var stack = e.stack;
        var re = new RegExp("^ *at [^(]*\\((.*):[0-9]*:[0-9]*\\)$", "mg");
        var lastMatch = null;
        do {
          var match = re.exec(stack);
          if (match != null) lastMatch = match;
        } while (match != null);
        return lastMatch[1];
      }
    }

    var cachedCurrentScript = null;
    self.document = {
      get currentScript() {
        if (cachedCurrentScript == null) {
          cachedCurrentScript = {src: computeCurrentScript()};
        }
        return cachedCurrentScript;
      }
    };
  })();

  self.dartDeferredLibraryLoader = function(uri, successCallback, errorCallback) {
    try {
     load(uri);
      successCallback();
    } catch (error) {
      errorCallback(error);
    }
  };
}

self.fs = __webpack_require__(/*! fs */ "fs");
self.chokidar = __webpack_require__(/*! chokidar */ "./node_modules/chokidar/index.js");
self.readline = __webpack_require__(/*! readline */ "readline");
// Generated by dart2js (fast startup emitter, strong, trust primitives, omit checks, lax runtime type), the Dart to JavaScript compiler version: 2.4.1.
// The code supports the following hooks:
// dartPrint(message):
//    if this function is defined it is called instead of the Dart [print]
//    method.
//
// dartMainRunner(main, args):
//    if this function is defined, the Dart [main] method will not be invoked
//    directly. Instead, a closure that will invoke [main], and its arguments
//    [args] is passed to [dartMainRunner].
//
// dartDeferredLibraryLoader(uri, successCallback, errorCallback):
//    if this function is defined, it will be called when a deferred library
//    is loaded. It should load and eval the javascript of `uri`, and call
//    successCallback. If it fails to do so, it should call errorCallback with
//    an error.
//
// dartCallInstrumentation(id, qualifiedName):
//    if this function is defined, it will be called at each entry of a
//    method or constructor. Used only when compiling programs with
//    --experiment-call-instrumentation.
{
}
(function dartProgram() {
  function copyProperties(from, to) {
    var keys = Object.keys(from);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      to[key] = from[key];
    }
  }
  var supportsDirectProtoAccess = function() {
    var cls = function() {
    };
    cls.prototype = {p: {}};
    var object = new cls();
    if (!(object.__proto__ && object.__proto__.p === cls.prototype.p))
      return false;
    try {
      if (typeof navigator != "undefined" && typeof navigator.userAgent == "string" && navigator.userAgent.indexOf("Chrome/") >= 0)
        return true;
      if (typeof version == "function" && version.length == 0) {
        var v = version();
        if (/^\d+\.\d+\.\d+\.\d+$/.test(v))
          return true;
      }
    } catch (_) {
    }
    return false;
  }();
  function setFunctionNamesIfNecessary(holders) {
    function t() {
    }
    ;
    if (typeof t.name == "string")
      return;
    for (var i = 0; i < holders.length; i++) {
      var holder = holders[i];
      var keys = Object.keys(holder);
      for (var j = 0; j < keys.length; j++) {
        var key = keys[j];
        var f = holder[key];
        if (typeof f == 'function')
          f.name = key;
      }
    }
  }
  function inherit(cls, sup) {
    cls.prototype.constructor = cls;
    cls.prototype["$is" + cls.name] = cls;
    if (sup != null) {
      if (supportsDirectProtoAccess) {
        cls.prototype.__proto__ = sup.prototype;
        return;
      }
      var clsPrototype = Object.create(sup.prototype);
      copyProperties(cls.prototype, clsPrototype);
      cls.prototype = clsPrototype;
    }
  }
  function inheritMany(sup, classes) {
    for (var i = 0; i < classes.length; i++)
      inherit(classes[i], sup);
  }
  function mixin(cls, mixin) {
    copyProperties(mixin.prototype, cls.prototype);
    cls.prototype.constructor = cls;
  }
  function lazy(holder, name, getterName, initializer) {
    var uninitializedSentinel = holder;
    holder[name] = uninitializedSentinel;
    holder[getterName] = function() {
      holder[getterName] = function() {
        H.throwCyclicInit(name);
      };
      var result;
      var sentinelInProgress = initializer;
      try {
        if (holder[name] === uninitializedSentinel) {
          result = holder[name] = sentinelInProgress;
          result = holder[name] = initializer();
        } else
          result = holder[name];
      } finally {
        if (result === sentinelInProgress)
          holder[name] = null;
        holder[getterName] = function() {
          return this[name];
        };
      }
      return result;
    };
  }
  function makeConstList(list) {
    list.immutable$list = Array;
    list.fixed$length = Array;
    return list;
  }
  function convertToFastObject(properties) {
    function t() {
    }
    t.prototype = properties;
    new t();
    return properties;
  }
  function convertAllToFastObject(arrayOfObjects) {
    for (var i = 0; i < arrayOfObjects.length; ++i)
      convertToFastObject(arrayOfObjects[i]);
  }
  var functionCounter = 0;
  function tearOffGetter(funcs, applyTrampolineIndex, reflectionInfo, name, isIntercepted) {
    return isIntercepted ? new Function("funcs", "applyTrampolineIndex", "reflectionInfo", "name", "H", "c", "return function tearOff_" + name + functionCounter++ + "(receiver) {" + "if (c === null) c = " + "H.closureFromTearOff" + "(" + "this, funcs, applyTrampolineIndex, reflectionInfo, false, true, name);" + "return new c(this, funcs[0], receiver, name);" + "}")(funcs, applyTrampolineIndex, reflectionInfo, name, H, null) : new Function("funcs", "applyTrampolineIndex", "reflectionInfo", "name", "H", "c", "return function tearOff_" + name + functionCounter++ + "() {" + "if (c === null) c = " + "H.closureFromTearOff" + "(" + "this, funcs, applyTrampolineIndex, reflectionInfo, false, false, name);" + "return new c(this, funcs[0], null, name);" + "}")(funcs, applyTrampolineIndex, reflectionInfo, name, H, null);
  }
  function tearOff(funcs, applyTrampolineIndex, reflectionInfo, isStatic, name, isIntercepted) {
    var cache = null;
    return isStatic ? function() {
      if (cache === null)
        cache = H.closureFromTearOff(this, funcs, applyTrampolineIndex, reflectionInfo, true, false, name).prototype;
      return cache;
    } : tearOffGetter(funcs, applyTrampolineIndex, reflectionInfo, name, isIntercepted);
  }
  var typesOffset = 0;
  function installTearOff(container, getterName, isStatic, isIntercepted, requiredParameterCount, optionalParameterDefaultValues, callNames, funsOrNames, funType, applyIndex) {
    var funs = [];
    for (var i = 0; i < funsOrNames.length; i++) {
      var fun = funsOrNames[i];
      if (typeof fun == 'string')
        fun = container[fun];
      fun.$callName = callNames[i];
      funs.push(fun);
    }
    var fun = funs[0];
    fun.$requiredArgCount = requiredParameterCount;
    fun.$defaultValues = optionalParameterDefaultValues;
    var reflectionInfo = funType;
    if (typeof reflectionInfo == "number")
      reflectionInfo += typesOffset;
    var name = funsOrNames[0];
    fun.$stubName = name;
    var getterFunction = tearOff(funs, applyIndex || 0, reflectionInfo, isStatic, name, isIntercepted);
    container[getterName] = getterFunction;
    if (isStatic)
      fun.$tearOff = getterFunction;
  }
  function installStaticTearOff(container, getterName, requiredParameterCount, optionalParameterDefaultValues, callNames, funsOrNames, funType, applyIndex) {
    return installTearOff(container, getterName, true, false, requiredParameterCount, optionalParameterDefaultValues, callNames, funsOrNames, funType, applyIndex);
  }
  function installInstanceTearOff(container, getterName, isIntercepted, requiredParameterCount, optionalParameterDefaultValues, callNames, funsOrNames, funType, applyIndex) {
    return installTearOff(container, getterName, false, isIntercepted, requiredParameterCount, optionalParameterDefaultValues, callNames, funsOrNames, funType, applyIndex);
  }
  function setOrUpdateInterceptorsByTag(newTags) {
    var tags = init.interceptorsByTag;
    if (!tags) {
      init.interceptorsByTag = newTags;
      return;
    }
    copyProperties(newTags, tags);
  }
  function setOrUpdateLeafTags(newTags) {
    var tags = init.leafTags;
    if (!tags) {
      init.leafTags = newTags;
      return;
    }
    copyProperties(newTags, tags);
  }
  function updateTypes(newTypes) {
    var types = init.types;
    var length = types.length;
    types.push.apply(types, newTypes);
    return length;
  }
  function updateHolder(holder, newHolder) {
    copyProperties(newHolder, holder);
    return holder;
  }
  var hunkHelpers = function() {
    var mkInstance = function(isIntercepted, requiredParameterCount, optionalParameterDefaultValues, callNames, applyIndex) {
        return function(container, getterName, name, funType) {
          return installInstanceTearOff(container, getterName, isIntercepted, requiredParameterCount, optionalParameterDefaultValues, callNames, [name], funType, applyIndex);
        };
      },
      mkStatic = function(requiredParameterCount, optionalParameterDefaultValues, callNames, applyIndex) {
        return function(container, getterName, name, funType) {
          return installStaticTearOff(container, getterName, requiredParameterCount, optionalParameterDefaultValues, callNames, [name], funType, applyIndex);
        };
      };
    return {inherit: inherit, inheritMany: inheritMany, mixin: mixin, installStaticTearOff: installStaticTearOff, installInstanceTearOff: installInstanceTearOff, _instance_0u: mkInstance(0, 0, null, ["call$0"], 0), _instance_1u: mkInstance(0, 1, null, ["call$1"], 0), _instance_2u: mkInstance(0, 2, null, ["call$2"], 0), _instance_0i: mkInstance(1, 0, null, ["call$0"], 0), _instance_1i: mkInstance(1, 1, null, ["call$1"], 0), _instance_2i: mkInstance(1, 2, null, ["call$2"], 0), _static_0: mkStatic(0, null, ["call$0"], 0), _static_1: mkStatic(1, null, ["call$1"], 0), _static_2: mkStatic(2, null, ["call$2"], 0), makeConstList: makeConstList, lazy: lazy, updateHolder: updateHolder, convertToFastObject: convertToFastObject, setFunctionNamesIfNecessary: setFunctionNamesIfNecessary, updateTypes: updateTypes, setOrUpdateInterceptorsByTag: setOrUpdateInterceptorsByTag, setOrUpdateLeafTags: setOrUpdateLeafTags};
  }();
  function initializeDeferredHunk(hunk) {
    typesOffset = init.types.length;
    hunk(hunkHelpers, init, holders, $);
  }
  function getGlobalFromName(name) {
    for (var i = 0; i < holders.length; i++) {
      if (holders[i] == C)
        continue;
      if (holders[i][name])
        return holders[i][name];
    }
  }
  var C = {},
  H = {JS_CONST: function JS_CONST() {
    },
    CastIterable_CastIterable: function(source, $S, $T) {
      if (H.checkSubtype(source, "$isEfficientLengthIterable", [$S], "$asEfficientLengthIterable"))
        return new H._EfficientLengthCastIterable(source, [$S, $T]);
      return new H.CastIterable(source, [$S, $T]);
    },
    hexDigitValue: function(char) {
      var letter,
        digit = char ^ 48;
      if (digit <= 9)
        return digit;
      letter = char | 32;
      if (97 <= letter && letter <= 102)
        return letter - 87;
      return -1;
    },
    SubListIterable$: function(_iterable, _start, _endOrLength, $E) {
      P.RangeError_checkNotNegative(_start, "start");
      if (_endOrLength != null) {
        P.RangeError_checkNotNegative(_endOrLength, "end");
        if (_start > _endOrLength)
          H.throwExpression(P.RangeError$range(_start, 0, _endOrLength, "start", null));
      }
      return new H.SubListIterable(_iterable, _start, _endOrLength, [$E]);
    },
    MappedIterable_MappedIterable: function(iterable, $function, $S, $T) {
      if (!!J.getInterceptor$(iterable).$isEfficientLengthIterable)
        return new H.EfficientLengthMappedIterable(iterable, $function, [$S, $T]);
      return new H.MappedIterable(iterable, $function, [$S, $T]);
    },
    TakeIterable_TakeIterable: function(iterable, takeCount, $E) {
      P.RangeError_checkNotNegative(takeCount, "takeCount");
      if (!!J.getInterceptor$(iterable).$isEfficientLengthIterable)
        return new H.EfficientLengthTakeIterable(iterable, takeCount, [$E]);
      return new H.TakeIterable(iterable, takeCount, [$E]);
    },
    SkipIterable_SkipIterable: function(iterable, count, $E) {
      var _s5_ = "count";
      if (!!J.getInterceptor$(iterable).$isEfficientLengthIterable) {
        if (count == null)
          H.throwExpression(P.ArgumentError$notNull(_s5_));
        P.RangeError_checkNotNegative(count, _s5_);
        return new H.EfficientLengthSkipIterable(iterable, count, [$E]);
      }
      if (count == null)
        H.throwExpression(P.ArgumentError$notNull(_s5_));
      P.RangeError_checkNotNegative(count, _s5_);
      return new H.SkipIterable(iterable, count, [$E]);
    },
    FollowedByIterable_FollowedByIterable$firstEfficient: function(first, second, $E) {
      if (H.checkSubtype(second, "$isEfficientLengthIterable", [$E], "$asEfficientLengthIterable"))
        return new H.EfficientLengthFollowedByIterable(first, second, [$E]);
      return new H.FollowedByIterable(first, second, [$E]);
    },
    IterableElementError_noElement: function() {
      return new P.StateError("No element");
    },
    IterableElementError_tooMany: function() {
      return new P.StateError("Too many elements");
    },
    IterableElementError_tooFew: function() {
      return new P.StateError("Too few elements");
    },
    Sort_sort: function(a, compare) {
      H.Sort__doSort(a, 0, J.get$length$asx(a) - 1, compare);
    },
    Sort__doSort: function(a, left, right, compare) {
      if (right - left <= 32)
        H.Sort__insertionSort(a, left, right, compare);
      else
        H.Sort__dualPivotQuicksort(a, left, right, compare);
    },
    Sort__insertionSort: function(a, left, right, compare) {
      var i, t1, el, j, j0;
      for (i = left + 1, t1 = J.getInterceptor$asx(a); i <= right; ++i) {
        el = t1.$index(a, i);
        j = i;
        while (true) {
          if (!(j > left && compare.call$2(t1.$index(a, j - 1), el) > 0))
            break;
          j0 = j - 1;
          t1.$indexSet(a, j, t1.$index(a, j0));
          j = j0;
        }
        t1.$indexSet(a, j, el);
      }
    },
    Sort__dualPivotQuicksort: function(a, left, right, compare) {
      var t0, less, great, k, ak, comp, great0, less0, pivots_are_equal, t2,
        sixth = C.JSInt_methods._tdivFast$1(right - left + 1, 6),
        index1 = left + sixth,
        index5 = right - sixth,
        index3 = C.JSInt_methods._tdivFast$1(left + right, 2),
        index2 = index3 - sixth,
        index4 = index3 + sixth,
        t1 = J.getInterceptor$asx(a),
        el1 = t1.$index(a, index1),
        el2 = t1.$index(a, index2),
        el3 = t1.$index(a, index3),
        el4 = t1.$index(a, index4),
        el5 = t1.$index(a, index5);
      if (compare.call$2(el1, el2) > 0) {
        t0 = el2;
        el2 = el1;
        el1 = t0;
      }
      if (compare.call$2(el4, el5) > 0) {
        t0 = el5;
        el5 = el4;
        el4 = t0;
      }
      if (compare.call$2(el1, el3) > 0) {
        t0 = el3;
        el3 = el1;
        el1 = t0;
      }
      if (compare.call$2(el2, el3) > 0) {
        t0 = el3;
        el3 = el2;
        el2 = t0;
      }
      if (compare.call$2(el1, el4) > 0) {
        t0 = el4;
        el4 = el1;
        el1 = t0;
      }
      if (compare.call$2(el3, el4) > 0) {
        t0 = el4;
        el4 = el3;
        el3 = t0;
      }
      if (compare.call$2(el2, el5) > 0) {
        t0 = el5;
        el5 = el2;
        el2 = t0;
      }
      if (compare.call$2(el2, el3) > 0) {
        t0 = el3;
        el3 = el2;
        el2 = t0;
      }
      if (compare.call$2(el4, el5) > 0) {
        t0 = el5;
        el5 = el4;
        el4 = t0;
      }
      t1.$indexSet(a, index1, el1);
      t1.$indexSet(a, index3, el3);
      t1.$indexSet(a, index5, el5);
      t1.$indexSet(a, index2, t1.$index(a, left));
      t1.$indexSet(a, index4, t1.$index(a, right));
      less = left + 1;
      great = right - 1;
      if (J.$eq$(compare.call$2(el2, el4), 0)) {
        for (k = less; k <= great; ++k) {
          ak = t1.$index(a, k);
          comp = compare.call$2(ak, el2);
          if (comp === 0)
            continue;
          if (comp < 0) {
            if (k !== less) {
              t1.$indexSet(a, k, t1.$index(a, less));
              t1.$indexSet(a, less, ak);
            }
            ++less;
          } else
            for (; true;) {
              comp = compare.call$2(t1.$index(a, great), el2);
              if (comp > 0) {
                --great;
                continue;
              } else {
                great0 = great - 1;
                if (comp < 0) {
                  t1.$indexSet(a, k, t1.$index(a, less));
                  less0 = less + 1;
                  t1.$indexSet(a, less, t1.$index(a, great));
                  t1.$indexSet(a, great, ak);
                  great = great0;
                  less = less0;
                  break;
                } else {
                  t1.$indexSet(a, k, t1.$index(a, great));
                  t1.$indexSet(a, great, ak);
                  great = great0;
                  break;
                }
              }
            }
        }
        pivots_are_equal = true;
      } else {
        for (k = less; k <= great; ++k) {
          ak = t1.$index(a, k);
          if (compare.call$2(ak, el2) < 0) {
            if (k !== less) {
              t1.$indexSet(a, k, t1.$index(a, less));
              t1.$indexSet(a, less, ak);
            }
            ++less;
          } else if (compare.call$2(ak, el4) > 0)
            for (; true;)
              if (compare.call$2(t1.$index(a, great), el4) > 0) {
                --great;
                if (great < k)
                  break;
                continue;
              } else {
                great0 = great - 1;
                if (compare.call$2(t1.$index(a, great), el2) < 0) {
                  t1.$indexSet(a, k, t1.$index(a, less));
                  less0 = less + 1;
                  t1.$indexSet(a, less, t1.$index(a, great));
                  t1.$indexSet(a, great, ak);
                  less = less0;
                } else {
                  t1.$indexSet(a, k, t1.$index(a, great));
                  t1.$indexSet(a, great, ak);
                }
                great = great0;
                break;
              }
        }
        pivots_are_equal = false;
      }
      t2 = less - 1;
      t1.$indexSet(a, left, t1.$index(a, t2));
      t1.$indexSet(a, t2, el2);
      t2 = great + 1;
      t1.$indexSet(a, right, t1.$index(a, t2));
      t1.$indexSet(a, t2, el4);
      H.Sort__doSort(a, left, less - 2, compare);
      H.Sort__doSort(a, great + 2, right, compare);
      if (pivots_are_equal)
        return;
      if (less < index1 && great > index5) {
        for (; J.$eq$(compare.call$2(t1.$index(a, less), el2), 0);)
          ++less;
        for (; J.$eq$(compare.call$2(t1.$index(a, great), el4), 0);)
          --great;
        for (k = less; k <= great; ++k) {
          ak = t1.$index(a, k);
          if (compare.call$2(ak, el2) === 0) {
            if (k !== less) {
              t1.$indexSet(a, k, t1.$index(a, less));
              t1.$indexSet(a, less, ak);
            }
            ++less;
          } else if (compare.call$2(ak, el4) === 0)
            for (; true;)
              if (compare.call$2(t1.$index(a, great), el4) === 0) {
                --great;
                if (great < k)
                  break;
                continue;
              } else {
                great0 = great - 1;
                if (compare.call$2(t1.$index(a, great), el2) < 0) {
                  t1.$indexSet(a, k, t1.$index(a, less));
                  less0 = less + 1;
                  t1.$indexSet(a, less, t1.$index(a, great));
                  t1.$indexSet(a, great, ak);
                  less = less0;
                } else {
                  t1.$indexSet(a, k, t1.$index(a, great));
                  t1.$indexSet(a, great, ak);
                }
                great = great0;
                break;
              }
        }
        H.Sort__doSort(a, less, great, compare);
      } else
        H.Sort__doSort(a, less, great, compare);
    },
    _CastIterableBase: function _CastIterableBase() {
    },
    CastIterator: function CastIterator(t0, t1) {
      this._source = t0;
      this.$ti = t1;
    },
    CastIterable: function CastIterable(t0, t1) {
      this._source = t0;
      this.$ti = t1;
    },
    _EfficientLengthCastIterable: function _EfficientLengthCastIterable(t0, t1) {
      this._source = t0;
      this.$ti = t1;
    },
    _CastListBase: function _CastListBase() {
    },
    CastList: function CastList(t0, t1) {
      this._source = t0;
      this.$ti = t1;
    },
    CastSet: function CastSet(t0, t1, t2) {
      this._source = t0;
      this._emptySet = t1;
      this.$ti = t2;
    },
    CastQueue: function CastQueue(t0, t1) {
      this._source = t0;
      this.$ti = t1;
    },
    CodeUnits: function CodeUnits(t0) {
      this.__internal$_string = t0;
    },
    EfficientLengthIterable: function EfficientLengthIterable() {
    },
    ListIterable: function ListIterable() {
    },
    SubListIterable: function SubListIterable(t0, t1, t2, t3) {
      var _ = this;
      _.__internal$_iterable = t0;
      _.__internal$_start = t1;
      _._endOrLength = t2;
      _.$ti = t3;
    },
    ListIterator: function ListIterator(t0, t1) {
      var _ = this;
      _.__internal$_iterable = t0;
      _.__internal$_length = t1;
      _.__internal$_index = 0;
      _.__internal$_current = null;
    },
    MappedIterable: function MappedIterable(t0, t1, t2) {
      this.__internal$_iterable = t0;
      this._f = t1;
      this.$ti = t2;
    },
    EfficientLengthMappedIterable: function EfficientLengthMappedIterable(t0, t1, t2) {
      this.__internal$_iterable = t0;
      this._f = t1;
      this.$ti = t2;
    },
    MappedIterator: function MappedIterator(t0, t1) {
      this.__internal$_current = null;
      this._iterator = t0;
      this._f = t1;
    },
    MappedListIterable: function MappedListIterable(t0, t1, t2) {
      this._source = t0;
      this._f = t1;
      this.$ti = t2;
    },
    WhereIterable: function WhereIterable(t0, t1, t2) {
      this.__internal$_iterable = t0;
      this._f = t1;
      this.$ti = t2;
    },
    WhereIterator: function WhereIterator(t0, t1) {
      this._iterator = t0;
      this._f = t1;
    },
    ExpandIterable: function ExpandIterable(t0, t1, t2) {
      this.__internal$_iterable = t0;
      this._f = t1;
      this.$ti = t2;
    },
    ExpandIterator: function ExpandIterator(t0, t1, t2) {
      var _ = this;
      _._iterator = t0;
      _._f = t1;
      _._currentExpansion = t2;
      _.__internal$_current = null;
    },
    TakeIterable: function TakeIterable(t0, t1, t2) {
      this.__internal$_iterable = t0;
      this._takeCount = t1;
      this.$ti = t2;
    },
    EfficientLengthTakeIterable: function EfficientLengthTakeIterable(t0, t1, t2) {
      this.__internal$_iterable = t0;
      this._takeCount = t1;
      this.$ti = t2;
    },
    TakeIterator: function TakeIterator(t0, t1) {
      this._iterator = t0;
      this._remaining = t1;
    },
    SkipIterable: function SkipIterable(t0, t1, t2) {
      this.__internal$_iterable = t0;
      this._skipCount = t1;
      this.$ti = t2;
    },
    EfficientLengthSkipIterable: function EfficientLengthSkipIterable(t0, t1, t2) {
      this.__internal$_iterable = t0;
      this._skipCount = t1;
      this.$ti = t2;
    },
    SkipIterator: function SkipIterator(t0, t1) {
      this._iterator = t0;
      this._skipCount = t1;
    },
    SkipWhileIterable: function SkipWhileIterable(t0, t1, t2) {
      this.__internal$_iterable = t0;
      this._f = t1;
      this.$ti = t2;
    },
    SkipWhileIterator: function SkipWhileIterator(t0, t1) {
      this._iterator = t0;
      this._f = t1;
      this._hasSkipped = false;
    },
    EmptyIterable: function EmptyIterable(t0) {
      this.$ti = t0;
    },
    EmptyIterator: function EmptyIterator() {
    },
    FollowedByIterable: function FollowedByIterable(t0, t1, t2) {
      this.__internal$_first = t0;
      this._second = t1;
      this.$ti = t2;
    },
    EfficientLengthFollowedByIterable: function EfficientLengthFollowedByIterable(t0, t1, t2) {
      this.__internal$_first = t0;
      this._second = t1;
      this.$ti = t2;
    },
    FollowedByIterator: function FollowedByIterator(t0, t1) {
      this._currentIterator = t0;
      this._nextIterable = t1;
    },
    WhereTypeIterable: function WhereTypeIterable(t0, t1) {
      this._source = t0;
      this.$ti = t1;
    },
    WhereTypeIterator: function WhereTypeIterator(t0, t1) {
      this._source = t0;
      this.$ti = t1;
    },
    FixedLengthListMixin: function FixedLengthListMixin() {
    },
    UnmodifiableListMixin: function UnmodifiableListMixin() {
    },
    UnmodifiableListBase: function UnmodifiableListBase() {
    },
    ReversedListIterable: function ReversedListIterable(t0, t1) {
      this._source = t0;
      this.$ti = t1;
    },
    Symbol0: function Symbol0(t0) {
      this._name = t0;
    },
    __CastListBase__CastIterableBase_ListMixin: function __CastListBase__CastIterableBase_ListMixin() {
    },
    ConstantMap_ConstantMap$from: function(other, $K, $V) {
      var allStrings, k, object, containsProto, protoValue, $length, v,
        keys = P.List_List$from(other.get$keys(), true, $K),
        t1 = keys.length,
        _i = 0;
      while (true) {
        if (!(_i < t1)) {
          allStrings = true;
          break;
        }
        k = keys[_i];
        if (typeof k !== "string") {
          allStrings = false;
          break;
        }
        ++_i;
      }
      if (allStrings) {
        object = {};
        for (containsProto = false, protoValue = null, $length = 0, _i = 0; _i < keys.length; keys.length === t1 || (0, H.throwConcurrentModificationError)(keys), ++_i) {
          k = keys[_i];
          v = other.$index(0, k);
          if (!J.$eq$(k, "__proto__")) {
            if (!object.hasOwnProperty(k))
              ++$length;
            object[k] = v;
          } else {
            protoValue = v;
            containsProto = true;
          }
        }
        if (containsProto)
          return new H.ConstantProtoMap(protoValue, $length + 1, object, keys, [$K, $V]);
        return new H.ConstantStringMap($length, object, keys, [$K, $V]);
      }
      return new H.ConstantMapView(P.LinkedHashMap_LinkedHashMap$from(other, $K, $V), [$K, $V]);
    },
    ConstantMap__throwUnmodifiable: function() {
      throw H.wrapException(P.UnsupportedError$("Cannot modify unmodifiable Map"));
    },
    instantiate1: function(f, T1) {
      var t1 = new H.Instantiation1(f, [T1]);
      t1.Instantiation$1(f);
      return t1;
    },
    unminifyOrTag: function(rawClassName) {
      var t1 = init.mangledGlobalNames[rawClassName];
      if (typeof t1 === "string")
        return t1;
      return rawClassName;
    },
    getType: function(index) {
      return init.types[index];
    },
    isJsIndexable: function(object, record) {
      var result;
      if (record != null) {
        result = record.x;
        if (result != null)
          return result;
      }
      return !!J.getInterceptor$(object).$isJavaScriptIndexingBehavior;
    },
    S: function(value) {
      var res;
      if (typeof value === "string")
        return value;
      if (typeof value === "number") {
        if (value !== 0)
          return "" + value;
      } else if (true === value)
        return "true";
      else if (false === value)
        return "false";
      else if (value == null)
        return "null";
      res = J.toString$0$(value);
      if (typeof res !== "string")
        throw H.wrapException(H.argumentErrorValue(value));
      return res;
    },
    Primitives_objectHashCode: function(object) {
      var hash = object.$identityHash;
      if (hash == null) {
        hash = Math.random() * 0x3fffffff | 0;
        object.$identityHash = hash;
      }
      return hash;
    },
    Primitives_parseInt: function(source, radix) {
      var match, decimalMatch, maxCharCode, digitsPart, t1, i;
      if (typeof source !== "string")
        H.throwExpression(H.argumentErrorValue(source));
      match = /^\s*[+-]?((0x[a-f0-9]+)|(\d+)|([a-z0-9]+))\s*$/i.exec(source);
      if (match == null)
        return;
      decimalMatch = match[3];
      if (radix == null) {
        if (decimalMatch != null)
          return parseInt(source, 10);
        if (match[2] != null)
          return parseInt(source, 16);
        return;
      }
      if (radix < 2 || radix > 36)
        throw H.wrapException(P.RangeError$range(radix, 2, 36, "radix", null));
      if (radix === 10 && decimalMatch != null)
        return parseInt(source, 10);
      if (radix < 10 || decimalMatch == null) {
        maxCharCode = radix <= 10 ? 47 + radix : 86 + radix;
        digitsPart = match[1];
        for (t1 = digitsPart.length, i = 0; i < t1; ++i)
          if ((C.JSString_methods._codeUnitAt$1(digitsPart, i) | 32) > maxCharCode)
            return;
      }
      return parseInt(source, radix);
    },
    Primitives_parseDouble: function(source) {
      var result, trimmed;
      if (!/^\s*[+-]?(?:Infinity|NaN|(?:\.\d+|\d+(?:\.\d*)?)(?:[eE][+-]?\d+)?)\s*$/.test(source))
        return;
      result = parseFloat(source);
      if (isNaN(result)) {
        trimmed = C.JSString_methods.trim$0(source);
        if (trimmed === "NaN" || trimmed === "+NaN" || trimmed === "-NaN")
          return result;
        return;
      }
      return result;
    },
    Primitives_objectTypeName: function(object) {
      return H.Primitives__objectClassName(object) + H._joinArguments(H.getRuntimeTypeInfo(object), 0, null);
    },
    Primitives__objectClassName: function(object) {
      var interceptorConstructorName, $name, t1, dispatchName, objectConstructor, match, decompiledName,
        interceptor = J.getInterceptor$(object),
        interceptorConstructor = interceptor.constructor;
      if (typeof interceptorConstructor == "function") {
        interceptorConstructorName = interceptorConstructor.name;
        $name = typeof interceptorConstructorName === "string" ? interceptorConstructorName : null;
      } else
        $name = null;
      t1 = $name == null;
      if (t1 || interceptor === C.Interceptor_methods || !!interceptor.$isUnknownJavaScriptObject) {
        dispatchName = C.C_JS_CONST(object);
        if (t1)
          $name = dispatchName;
        if (dispatchName === "Object") {
          objectConstructor = object.constructor;
          if (typeof objectConstructor == "function") {
            match = String(objectConstructor).match(/^\s*function\s*([\w$]*)\s*\(/);
            decompiledName = match == null ? null : match[1];
            if (typeof decompiledName === "string" && /^\w+$/.test(decompiledName))
              $name = decompiledName;
          }
        }
        return $name;
      }
      $name = $name;
      return H.unminifyOrTag($name.length > 1 && C.JSString_methods._codeUnitAt$1($name, 0) === 36 ? C.JSString_methods.substring$1($name, 1) : $name);
    },
    Primitives_currentUri: function() {
      if (!!self.location)
        return self.location.href;
      return;
    },
    Primitives__fromCharCodeApply: function(array) {
      var result, i, i0, chunkEnd,
        end = J.get$length$asx(array);
      if (end <= 500)
        return String.fromCharCode.apply(null, array);
      for (result = "", i = 0; i < end; i = i0) {
        i0 = i + 500;
        chunkEnd = i0 < end ? i0 : end;
        result += String.fromCharCode.apply(null, array.slice(i, chunkEnd));
      }
      return result;
    },
    Primitives_stringFromCodePoints: function(codePoints) {
      var t1, i,
        a = H.setRuntimeTypeInfo([], [P.int]);
      for (t1 = J.get$iterator$ax(codePoints); t1.moveNext$0();) {
        i = t1.get$current(t1);
        if (typeof i !== "number" || Math.floor(i) !== i)
          throw H.wrapException(H.argumentErrorValue(i));
        if (i <= 65535)
          a.push(i);
        else if (i <= 1114111) {
          a.push(55296 + (C.JSInt_methods._shrOtherPositive$1(i - 65536, 10) & 1023));
          a.push(56320 + (i & 1023));
        } else
          throw H.wrapException(H.argumentErrorValue(i));
      }
      return H.Primitives__fromCharCodeApply(a);
    },
    Primitives_stringFromCharCodes: function(charCodes) {
      var t1, i;
      for (t1 = J.get$iterator$ax(charCodes); t1.moveNext$0();) {
        i = t1.get$current(t1);
        if (typeof i !== "number" || Math.floor(i) !== i)
          throw H.wrapException(H.argumentErrorValue(i));
        if (i < 0)
          throw H.wrapException(H.argumentErrorValue(i));
        if (i > 65535)
          return H.Primitives_stringFromCodePoints(charCodes);
      }
      return H.Primitives__fromCharCodeApply(charCodes);
    },
    Primitives_stringFromNativeUint8List: function(charCodes, start, end) {
      var i, result, i0, chunkEnd;
      if (end <= 500 && start === 0 && end === charCodes.length)
        return String.fromCharCode.apply(null, charCodes);
      for (i = start, result = ""; i < end; i = i0) {
        i0 = i + 500;
        chunkEnd = i0 < end ? i0 : end;
        result += String.fromCharCode.apply(null, charCodes.subarray(i, chunkEnd));
      }
      return result;
    },
    Primitives_stringFromCharCode: function(charCode) {
      var bits;
      if (0 <= charCode) {
        if (charCode <= 65535)
          return String.fromCharCode(charCode);
        if (charCode <= 1114111) {
          bits = charCode - 65536;
          return String.fromCharCode((55296 | C.JSInt_methods._shrOtherPositive$1(bits, 10)) >>> 0, 56320 | bits & 1023);
        }
      }
      throw H.wrapException(P.RangeError$range(charCode, 0, 1114111, null, null));
    },
    Primitives_lazyAsJsDate: function(receiver) {
      if (receiver.date === void 0)
        receiver.date = new Date(receiver._value);
      return receiver.date;
    },
    Primitives_getYear: function(receiver) {
      var t1 = H.Primitives_lazyAsJsDate(receiver).getFullYear() + 0;
      return t1;
    },
    Primitives_getMonth: function(receiver) {
      var t1 = H.Primitives_lazyAsJsDate(receiver).getMonth() + 1;
      return t1;
    },
    Primitives_getDay: function(receiver) {
      var t1 = H.Primitives_lazyAsJsDate(receiver).getDate() + 0;
      return t1;
    },
    Primitives_getHours: function(receiver) {
      var t1 = H.Primitives_lazyAsJsDate(receiver).getHours() + 0;
      return t1;
    },
    Primitives_getMinutes: function(receiver) {
      var t1 = H.Primitives_lazyAsJsDate(receiver).getMinutes() + 0;
      return t1;
    },
    Primitives_getSeconds: function(receiver) {
      var t1 = H.Primitives_lazyAsJsDate(receiver).getSeconds() + 0;
      return t1;
    },
    Primitives_getMilliseconds: function(receiver) {
      var t1 = H.Primitives_lazyAsJsDate(receiver).getMilliseconds() + 0;
      return t1;
    },
    Primitives_functionNoSuchMethod: function($function, positionalArguments, namedArguments) {
      var $arguments, namedArgumentList, t1 = {};
      t1.argumentCount = 0;
      $arguments = [];
      namedArgumentList = [];
      t1.argumentCount = positionalArguments.length;
      C.JSArray_methods.addAll$1($arguments, positionalArguments);
      t1.names = "";
      if (namedArguments != null && !namedArguments.get$isEmpty(namedArguments))
        namedArguments.forEach$1(0, new H.Primitives_functionNoSuchMethod_closure(t1, namedArgumentList, $arguments));
      "" + t1.argumentCount;
      return J.noSuchMethod$1$($function, new H.JSInvocationMirror(C.Symbol_call, 0, $arguments, namedArgumentList, 0));
    },
    Primitives_applyFunction: function($function, positionalArguments, namedArguments) {
      var t1, $arguments, argumentCount, jsStub;
      if (positionalArguments instanceof Array)
        t1 = namedArguments == null || namedArguments.get$isEmpty(namedArguments);
      else
        t1 = false;
      if (t1) {
        $arguments = positionalArguments;
        argumentCount = $arguments.length;
        if (argumentCount === 0) {
          if (!!$function.call$0)
            return $function.call$0();
        } else if (argumentCount === 1) {
          if (!!$function.call$1)
            return $function.call$1($arguments[0]);
        } else if (argumentCount === 2) {
          if (!!$function.call$2)
            return $function.call$2($arguments[0], $arguments[1]);
        } else if (argumentCount === 3) {
          if (!!$function.call$3)
            return $function.call$3($arguments[0], $arguments[1], $arguments[2]);
        } else if (argumentCount === 4) {
          if (!!$function.call$4)
            return $function.call$4($arguments[0], $arguments[1], $arguments[2], $arguments[3]);
        } else if (argumentCount === 5)
          if (!!$function.call$5)
            return $function.call$5($arguments[0], $arguments[1], $arguments[2], $arguments[3], $arguments[4]);
        jsStub = $function["call" + "$" + argumentCount];
        if (jsStub != null)
          return jsStub.apply($function, $arguments);
      }
      return H.Primitives__genericApplyFunction2($function, positionalArguments, namedArguments);
    },
    Primitives__genericApplyFunction2: function($function, positionalArguments, namedArguments) {
      var $arguments, argumentCount, requiredParameterCount, defaultValuesClosure, t1, defaultValues, interceptor, jsFunction, keys, _i, used, t2;
      if (positionalArguments != null)
        $arguments = positionalArguments instanceof Array ? positionalArguments : P.List_List$from(positionalArguments, true, null);
      else
        $arguments = [];
      argumentCount = $arguments.length;
      requiredParameterCount = $function.$requiredArgCount;
      if (argumentCount < requiredParameterCount)
        return H.Primitives_functionNoSuchMethod($function, $arguments, namedArguments);
      defaultValuesClosure = $function.$defaultValues;
      t1 = defaultValuesClosure == null;
      defaultValues = !t1 ? defaultValuesClosure() : null;
      interceptor = J.getInterceptor$($function);
      jsFunction = interceptor["call*"];
      if (typeof jsFunction === "string")
        jsFunction = interceptor[jsFunction];
      if (t1) {
        if (namedArguments != null && namedArguments.get$isNotEmpty(namedArguments))
          return H.Primitives_functionNoSuchMethod($function, $arguments, namedArguments);
        if (argumentCount === requiredParameterCount)
          return jsFunction.apply($function, $arguments);
        return H.Primitives_functionNoSuchMethod($function, $arguments, namedArguments);
      }
      if (defaultValues instanceof Array) {
        if (namedArguments != null && namedArguments.get$isNotEmpty(namedArguments))
          return H.Primitives_functionNoSuchMethod($function, $arguments, namedArguments);
        if (argumentCount > requiredParameterCount + defaultValues.length)
          return H.Primitives_functionNoSuchMethod($function, $arguments, null);
        C.JSArray_methods.addAll$1($arguments, defaultValues.slice(argumentCount - requiredParameterCount));
        return jsFunction.apply($function, $arguments);
      } else {
        if (argumentCount > requiredParameterCount)
          return H.Primitives_functionNoSuchMethod($function, $arguments, namedArguments);
        keys = Object.keys(defaultValues);
        if (namedArguments == null)
          for (t1 = keys.length, _i = 0; _i < keys.length; keys.length === t1 || (0, H.throwConcurrentModificationError)(keys), ++_i)
            C.JSArray_methods.add$1($arguments, defaultValues[keys[_i]]);
        else {
          for (t1 = keys.length, used = 0, _i = 0; _i < keys.length; keys.length === t1 || (0, H.throwConcurrentModificationError)(keys), ++_i) {
            t2 = keys[_i];
            if (namedArguments.containsKey$1(t2)) {
              ++used;
              C.JSArray_methods.add$1($arguments, namedArguments.$index(0, t2));
            } else
              C.JSArray_methods.add$1($arguments, defaultValues[t2]);
          }
          if (used !== namedArguments.get$length(namedArguments))
            return H.Primitives_functionNoSuchMethod($function, $arguments, namedArguments);
        }
        return jsFunction.apply($function, $arguments);
      }
    },
    diagnoseIndexError: function(indexable, index) {
      var $length, _s5_ = "index";
      if (typeof index !== "number" || Math.floor(index) !== index)
        return new P.ArgumentError(true, index, _s5_, null);
      $length = J.get$length$asx(indexable);
      if (index < 0 || index >= $length)
        return P.IndexError$(index, indexable, _s5_, null, $length);
      return P.RangeError$value(index, _s5_, null);
    },
    diagnoseRangeError: function(start, end, $length) {
      var _s13_ = "Invalid value";
      if (typeof start !== "number" || Math.floor(start) !== start)
        return new P.ArgumentError(true, start, "start", null);
      if (start < 0 || start > $length)
        return new P.RangeError(0, $length, true, start, "start", _s13_);
      if (end != null)
        if (end < start || end > $length)
          return new P.RangeError(start, $length, true, end, "end", _s13_);
      return new P.ArgumentError(true, end, "end", null);
    },
    argumentErrorValue: function(object) {
      return new P.ArgumentError(true, object, null, null);
    },
    checkNum: function(value) {
      if (typeof value !== "number")
        throw H.wrapException(H.argumentErrorValue(value));
      return value;
    },
    wrapException: function(ex) {
      var wrapper;
      if (ex == null)
        ex = new P.NullThrownError();
      wrapper = new Error();
      wrapper.dartException = ex;
      if ("defineProperty" in Object) {
        Object.defineProperty(wrapper, "message", {get: H.toStringWrapper});
        wrapper.name = "";
      } else
        wrapper.toString = H.toStringWrapper;
      return wrapper;
    },
    toStringWrapper: function() {
      return J.toString$0$(this.dartException);
    },
    throwExpression: function(ex) {
      throw H.wrapException(ex);
    },
    throwConcurrentModificationError: function(collection) {
      throw H.wrapException(P.ConcurrentModificationError$(collection));
    },
    TypeErrorDecoder_extractPattern: function(message) {
      var match, $arguments, argumentsExpr, expr, method, receiver;
      message = H.quoteStringForRegExp(message.replace(String({}), '$receiver$'));
      match = message.match(/\\\$[a-zA-Z]+\\\$/g);
      if (match == null)
        match = H.setRuntimeTypeInfo([], [P.String]);
      $arguments = match.indexOf("\\$arguments\\$");
      argumentsExpr = match.indexOf("\\$argumentsExpr\\$");
      expr = match.indexOf("\\$expr\\$");
      method = match.indexOf("\\$method\\$");
      receiver = match.indexOf("\\$receiver\\$");
      return new H.TypeErrorDecoder(message.replace(new RegExp('\\\\\\$arguments\\\\\\$', 'g'), '((?:x|[^x])*)').replace(new RegExp('\\\\\\$argumentsExpr\\\\\\$', 'g'), '((?:x|[^x])*)').replace(new RegExp('\\\\\\$expr\\\\\\$', 'g'), '((?:x|[^x])*)').replace(new RegExp('\\\\\\$method\\\\\\$', 'g'), '((?:x|[^x])*)').replace(new RegExp('\\\\\\$receiver\\\\\\$', 'g'), '((?:x|[^x])*)'), $arguments, argumentsExpr, expr, method, receiver);
    },
    TypeErrorDecoder_provokeCallErrorOn: function(expression) {
      return function($expr$) {
        var $argumentsExpr$ = '$arguments$';
        try {
          $expr$.$method$($argumentsExpr$);
        } catch (e) {
          return e.message;
        }
      }(expression);
    },
    TypeErrorDecoder_provokePropertyErrorOn: function(expression) {
      return function($expr$) {
        try {
          $expr$.$method$;
        } catch (e) {
          return e.message;
        }
      }(expression);
    },
    NullError$: function(_message, match) {
      return new H.NullError(_message, match == null ? null : match.method);
    },
    JsNoSuchMethodError$: function(_message, match) {
      var t1 = match == null,
        t2 = t1 ? null : match.method;
      return new H.JsNoSuchMethodError(_message, t2, t1 ? null : match.receiver);
    },
    unwrapException: function(ex) {
      var message, number, ieErrorCode, nsme, notClosure, nullCall, nullLiteralCall, undefCall, undefLiteralCall, nullProperty, undefProperty, undefLiteralProperty, match, t2, _null = null,
        t1 = new H.unwrapException_saveStackTrace(ex);
      if (ex == null)
        return;
      if (ex instanceof H.ExceptionAndStackTrace)
        return t1.call$1(ex.dartException);
      if (typeof ex !== "object")
        return ex;
      if ("dartException" in ex)
        return t1.call$1(ex.dartException);
      else if (!("message" in ex))
        return ex;
      message = ex.message;
      if ("number" in ex && typeof ex.number == "number") {
        number = ex.number;
        ieErrorCode = number & 65535;
        if ((C.JSInt_methods._shrOtherPositive$1(number, 16) & 8191) === 10)
          switch (ieErrorCode) {
            case 438:
              return t1.call$1(H.JsNoSuchMethodError$(H.S(message) + " (Error " + ieErrorCode + ")", _null));
            case 445:
            case 5007:
              return t1.call$1(H.NullError$(H.S(message) + " (Error " + ieErrorCode + ")", _null));
          }
      }
      if (ex instanceof TypeError) {
        nsme = $.$get$TypeErrorDecoder_noSuchMethodPattern();
        notClosure = $.$get$TypeErrorDecoder_notClosurePattern();
        nullCall = $.$get$TypeErrorDecoder_nullCallPattern();
        nullLiteralCall = $.$get$TypeErrorDecoder_nullLiteralCallPattern();
        undefCall = $.$get$TypeErrorDecoder_undefinedCallPattern();
        undefLiteralCall = $.$get$TypeErrorDecoder_undefinedLiteralCallPattern();
        nullProperty = $.$get$TypeErrorDecoder_nullPropertyPattern();
        $.$get$TypeErrorDecoder_nullLiteralPropertyPattern();
        undefProperty = $.$get$TypeErrorDecoder_undefinedPropertyPattern();
        undefLiteralProperty = $.$get$TypeErrorDecoder_undefinedLiteralPropertyPattern();
        match = nsme.matchTypeError$1(message);
        if (match != null)
          return t1.call$1(H.JsNoSuchMethodError$(message, match));
        else {
          match = notClosure.matchTypeError$1(message);
          if (match != null) {
            match.method = "call";
            return t1.call$1(H.JsNoSuchMethodError$(message, match));
          } else {
            match = nullCall.matchTypeError$1(message);
            if (match == null) {
              match = nullLiteralCall.matchTypeError$1(message);
              if (match == null) {
                match = undefCall.matchTypeError$1(message);
                if (match == null) {
                  match = undefLiteralCall.matchTypeError$1(message);
                  if (match == null) {
                    match = nullProperty.matchTypeError$1(message);
                    if (match == null) {
                      match = nullLiteralCall.matchTypeError$1(message);
                      if (match == null) {
                        match = undefProperty.matchTypeError$1(message);
                        if (match == null) {
                          match = undefLiteralProperty.matchTypeError$1(message);
                          t2 = match != null;
                        } else
                          t2 = true;
                      } else
                        t2 = true;
                    } else
                      t2 = true;
                  } else
                    t2 = true;
                } else
                  t2 = true;
              } else
                t2 = true;
            } else
              t2 = true;
            if (t2)
              return t1.call$1(H.NullError$(message, match));
          }
        }
        return t1.call$1(new H.UnknownJsTypeError(typeof message === "string" ? message : ""));
      }
      if (ex instanceof RangeError) {
        if (typeof message === "string" && message.indexOf("call stack") !== -1)
          return new P.StackOverflowError();
        message = function(ex) {
          try {
            return String(ex);
          } catch (e) {
          }
          return null;
        }(ex);
        return t1.call$1(new P.ArgumentError(false, _null, _null, typeof message === "string" ? message.replace(/^RangeError:\s*/, "") : message));
      }
      if (typeof InternalError == "function" && ex instanceof InternalError)
        if (typeof message === "string" && message === "too much recursion")
          return new P.StackOverflowError();
      return ex;
    },
    getTraceFromException: function(exception) {
      var trace;
      if (exception instanceof H.ExceptionAndStackTrace)
        return exception.stackTrace;
      if (exception == null)
        return new H._StackTrace(exception);
      trace = exception.$cachedTrace;
      if (trace != null)
        return trace;
      return exception.$cachedTrace = new H._StackTrace(exception);
    },
    objectHashCode: function(object) {
      if (object == null || typeof object != 'object')
        return J.get$hashCode$(object);
      else
        return H.Primitives_objectHashCode(object);
    },
    fillLiteralMap: function(keyValuePairs, result) {
      var index, index0, index1,
        $length = keyValuePairs.length;
      for (index = 0; index < $length; index = index1) {
        index0 = index + 1;
        index1 = index0 + 1;
        result.$indexSet(0, keyValuePairs[index], keyValuePairs[index0]);
      }
      return result;
    },
    fillLiteralSet: function(values, result) {
      var index,
        $length = values.length;
      for (index = 0; index < $length; ++index)
        result.add$1(0, values[index]);
      return result;
    },
    invokeClosure: function(closure, numberOfArguments, arg1, arg2, arg3, arg4) {
      switch (numberOfArguments) {
        case 0:
          return closure.call$0();
        case 1:
          return closure.call$1(arg1);
        case 2:
          return closure.call$2(arg1, arg2);
        case 3:
          return closure.call$3(arg1, arg2, arg3);
        case 4:
          return closure.call$4(arg1, arg2, arg3, arg4);
      }
      throw H.wrapException(new P._Exception("Unsupported number of arguments for wrapped closure"));
    },
    convertDartClosureToJS: function(closure, arity) {
      var $function;
      if (closure == null)
        return;
      $function = closure.$identity;
      if (!!$function)
        return $function;
      $function = function(closure, arity, invoke) {
        return function(a1, a2, a3, a4) {
          return invoke(closure, arity, a1, a2, a3, a4);
        };
      }(closure, arity, H.invokeClosure);
      closure.$identity = $function;
      return $function;
    },
    Closure_fromTearOff: function(receiver, functions, applyTrampolineIndex, reflectionInfo, isStatic, isIntercepted, propertyName) {
      var $constructor, t1, trampoline, signatureFunction, getReceiver, applyTrampoline, i, stub, stubCallName, _null = null,
        $function = functions[0],
        callName = $function.$callName,
        $prototype = isStatic ? Object.create(new H.StaticClosure().constructor.prototype) : Object.create(new H.BoundClosure(_null, _null, _null, _null).constructor.prototype);
      $prototype.$initialize = $prototype.constructor;
      if (isStatic)
        $constructor = function static_tear_off() {
          this.$initialize();
        };
      else {
        t1 = $.Closure_functionCounter;
        $.Closure_functionCounter = t1 + 1;
        t1 = new Function("a,b,c,d" + t1, "this.$initialize(a,b,c,d" + t1 + ")");
        $constructor = t1;
      }
      $prototype.constructor = $constructor;
      $constructor.prototype = $prototype;
      if (!isStatic) {
        trampoline = H.Closure_forwardCallTo(receiver, $function, isIntercepted);
        trampoline.$reflectionInfo = reflectionInfo;
      } else {
        $prototype.$static_name = propertyName;
        trampoline = $function;
      }
      if (typeof reflectionInfo == "number")
        signatureFunction = function(getType, t) {
          return function() {
            return getType(t);
          };
        }(H.getType, reflectionInfo);
      else if (typeof reflectionInfo == "function")
        if (isStatic)
          signatureFunction = reflectionInfo;
        else {
          getReceiver = isIntercepted ? H.BoundClosure_receiverOf : H.BoundClosure_selfOf;
          signatureFunction = function(f, r) {
            return function() {
              return f.apply({$receiver: r(this)}, arguments);
            };
          }(reflectionInfo, getReceiver);
        }
      else
        throw H.wrapException("Error in reflectionInfo.");
      $prototype.$signature = signatureFunction;
      $prototype[callName] = trampoline;
      for (applyTrampoline = trampoline, i = 1; i < functions.length; ++i) {
        stub = functions[i];
        stubCallName = stub.$callName;
        if (stubCallName != null) {
          stub = isStatic ? stub : H.Closure_forwardCallTo(receiver, stub, isIntercepted);
          $prototype[stubCallName] = stub;
        }
        if (i === applyTrampolineIndex) {
          stub.$reflectionInfo = reflectionInfo;
          applyTrampoline = stub;
        }
      }
      $prototype["call*"] = applyTrampoline;
      $prototype.$requiredArgCount = $function.$requiredArgCount;
      $prototype.$defaultValues = $function.$defaultValues;
      return $constructor;
    },
    Closure_cspForwardCall: function(arity, isSuperCall, stubName, $function) {
      var getSelf = H.BoundClosure_selfOf;
      switch (isSuperCall ? -1 : arity) {
        case 0:
          return function(n, S) {
            return function() {
              return S(this)[n]();
            };
          }(stubName, getSelf);
        case 1:
          return function(n, S) {
            return function(a) {
              return S(this)[n](a);
            };
          }(stubName, getSelf);
        case 2:
          return function(n, S) {
            return function(a, b) {
              return S(this)[n](a, b);
            };
          }(stubName, getSelf);
        case 3:
          return function(n, S) {
            return function(a, b, c) {
              return S(this)[n](a, b, c);
            };
          }(stubName, getSelf);
        case 4:
          return function(n, S) {
            return function(a, b, c, d) {
              return S(this)[n](a, b, c, d);
            };
          }(stubName, getSelf);
        case 5:
          return function(n, S) {
            return function(a, b, c, d, e) {
              return S(this)[n](a, b, c, d, e);
            };
          }(stubName, getSelf);
        default:
          return function(f, s) {
            return function() {
              return f.apply(s(this), arguments);
            };
          }($function, getSelf);
      }
    },
    Closure_forwardCallTo: function(receiver, $function, isIntercepted) {
      var stubName, arity, lookedUpFunction, t1, t2, selfName, $arguments;
      if (isIntercepted)
        return H.Closure_forwardInterceptedCallTo(receiver, $function);
      stubName = $function.$stubName;
      arity = $function.length;
      lookedUpFunction = receiver[stubName];
      t1 = $function == null ? lookedUpFunction == null : $function === lookedUpFunction;
      t2 = !t1 || arity >= 27;
      if (t2)
        return H.Closure_cspForwardCall(arity, !t1, stubName, $function);
      if (arity === 0) {
        t1 = $.Closure_functionCounter;
        $.Closure_functionCounter = t1 + 1;
        selfName = "self" + H.S(t1);
        t1 = "return function(){var " + selfName + " = this.";
        t2 = $.BoundClosure_selfFieldNameCache;
        return new Function(t1 + H.S(t2 == null ? $.BoundClosure_selfFieldNameCache = H.BoundClosure_computeFieldNamed("self") : t2) + ";return " + selfName + "." + H.S(stubName) + "();}")();
      }
      $arguments = "abcdefghijklmnopqrstuvwxyz".split("").splice(0, arity).join(",");
      t1 = $.Closure_functionCounter;
      $.Closure_functionCounter = t1 + 1;
      $arguments += H.S(t1);
      t1 = "return function(" + $arguments + "){return this.";
      t2 = $.BoundClosure_selfFieldNameCache;
      return new Function(t1 + H.S(t2 == null ? $.BoundClosure_selfFieldNameCache = H.BoundClosure_computeFieldNamed("self") : t2) + "." + H.S(stubName) + "(" + $arguments + ");}")();
    },
    Closure_cspForwardInterceptedCall: function(arity, isSuperCall, $name, $function) {
      var getSelf = H.BoundClosure_selfOf,
        getReceiver = H.BoundClosure_receiverOf;
      switch (isSuperCall ? -1 : arity) {
        case 0:
          throw H.wrapException(H.RuntimeError$("Intercepted function with no arguments."));
        case 1:
          return function(n, s, r) {
            return function() {
              return s(this)[n](r(this));
            };
          }($name, getSelf, getReceiver);
        case 2:
          return function(n, s, r) {
            return function(a) {
              return s(this)[n](r(this), a);
            };
          }($name, getSelf, getReceiver);
        case 3:
          return function(n, s, r) {
            return function(a, b) {
              return s(this)[n](r(this), a, b);
            };
          }($name, getSelf, getReceiver);
        case 4:
          return function(n, s, r) {
            return function(a, b, c) {
              return s(this)[n](r(this), a, b, c);
            };
          }($name, getSelf, getReceiver);
        case 5:
          return function(n, s, r) {
            return function(a, b, c, d) {
              return s(this)[n](r(this), a, b, c, d);
            };
          }($name, getSelf, getReceiver);
        case 6:
          return function(n, s, r) {
            return function(a, b, c, d, e) {
              return s(this)[n](r(this), a, b, c, d, e);
            };
          }($name, getSelf, getReceiver);
        default:
          return function(f, s, r, a) {
            return function() {
              a = [r(this)];
              Array.prototype.push.apply(a, arguments);
              return f.apply(s(this), a);
            };
          }($function, getSelf, getReceiver);
      }
    },
    Closure_forwardInterceptedCallTo: function(receiver, $function) {
      var t2, stubName, arity, lookedUpFunction, t3, t4, $arguments,
        t1 = $.BoundClosure_selfFieldNameCache;
      if (t1 == null)
        t1 = $.BoundClosure_selfFieldNameCache = H.BoundClosure_computeFieldNamed("self");
      t2 = $.BoundClosure_receiverFieldNameCache;
      if (t2 == null)
        t2 = $.BoundClosure_receiverFieldNameCache = H.BoundClosure_computeFieldNamed("receiver");
      stubName = $function.$stubName;
      arity = $function.length;
      lookedUpFunction = receiver[stubName];
      t3 = $function == null ? lookedUpFunction == null : $function === lookedUpFunction;
      t4 = !t3 || arity >= 28;
      if (t4)
        return H.Closure_cspForwardInterceptedCall(arity, !t3, stubName, $function);
      if (arity === 1) {
        t1 = "return function(){return this." + H.S(t1) + "." + H.S(stubName) + "(this." + H.S(t2) + ");";
        t2 = $.Closure_functionCounter;
        $.Closure_functionCounter = t2 + 1;
        return new Function(t1 + H.S(t2) + "}")();
      }
      $arguments = "abcdefghijklmnopqrstuvwxyz".split("").splice(0, arity - 1).join(",");
      t1 = "return function(" + $arguments + "){return this." + H.S(t1) + "." + H.S(stubName) + "(this." + H.S(t2) + ", " + $arguments + ");";
      t2 = $.Closure_functionCounter;
      $.Closure_functionCounter = t2 + 1;
      return new Function(t1 + H.S(t2) + "}")();
    },
    closureFromTearOff: function(receiver, functions, applyTrampolineIndex, reflectionInfo, isStatic, isIntercepted, $name) {
      return H.Closure_fromTearOff(receiver, functions, applyTrampolineIndex, reflectionInfo, !!isStatic, !!isIntercepted, $name);
    },
    BoundClosure_selfOf: function(closure) {
      return closure._self;
    },
    BoundClosure_receiverOf: function(closure) {
      return closure.__js_helper$_receiver;
    },
    BoundClosure_computeFieldNamed: function(fieldName) {
      var t1, i, $name,
        template = new H.BoundClosure("self", "target", "receiver", "name"),
        names = J.JSArray_markFixedList(Object.getOwnPropertyNames(template));
      for (t1 = names.length, i = 0; i < t1; ++i) {
        $name = names[i];
        if (template[$name] === fieldName)
          return $name;
      }
    },
    stringTypeCast: function(value) {
      if (typeof value === "string" || value == null)
        return value;
      throw H.wrapException(H.CastErrorImplementation$(value, "String"));
    },
    boolTypeCast: function(value) {
      if (typeof value === "boolean" || value == null)
        return value;
      throw H.wrapException(H.CastErrorImplementation$(value, "bool"));
    },
    intTypeCast: function(value) {
      if (typeof value === "number" && Math.floor(value) === value || value == null)
        return value;
      throw H.wrapException(H.CastErrorImplementation$(value, "int"));
    },
    propertyTypeCastError: function(value, property) {
      throw H.wrapException(H.CastErrorImplementation$(value, H.unminifyOrTag(property.substring(3))));
    },
    interceptedTypeCast: function(value, property) {
      var t1;
      if (value != null)
        t1 = (typeof value === "object" || typeof value === "function") && J.getInterceptor$(value)[property];
      else
        t1 = true;
      if (t1)
        return value;
      H.propertyTypeCastError(value, property);
    },
    numberOrStringSuperNativeTypeCast: function(value, property) {
      if (value == null)
        return value;
      if (typeof value === "string")
        return value;
      if (typeof value === "number")
        return value;
      if (J.getInterceptor$(value)[property])
        return value;
      H.propertyTypeCastError(value, property);
    },
    extractFunctionTypeObjectFromInternal: function(o) {
      var signature;
      if ("$signature" in o) {
        signature = o.$signature;
        if (typeof signature == "number")
          return init.types[signature];
        else
          return o.$signature();
      }
      return;
    },
    functionTypeTest: function(value, functionTypeRti) {
      var functionTypeObject;
      if (typeof value == "function")
        return true;
      functionTypeObject = H.extractFunctionTypeObjectFromInternal(J.getInterceptor$(value));
      if (functionTypeObject == null)
        return false;
      return H._isFunctionSubtype(functionTypeObject, null, functionTypeRti, null);
    },
    CastErrorImplementation$: function(value, type) {
      return new H.CastErrorImplementation("CastError: " + P.Error_safeToString(value) + ": type '" + H._typeDescription(value) + "' is not a subtype of type '" + type + "'");
    },
    _typeDescription: function(value) {
      var functionTypeObject,
        t1 = J.getInterceptor$(value);
      if (!!t1.$isClosure) {
        functionTypeObject = H.extractFunctionTypeObjectFromInternal(t1);
        if (functionTypeObject != null)
          return H.runtimeTypeToString(functionTypeObject);
        return "Closure";
      }
      return H.Primitives_objectTypeName(value);
    },
    throwCyclicInit: function(staticName) {
      throw H.wrapException(new P.CyclicInitializationError(staticName));
    },
    RuntimeError$: function(message) {
      return new H.RuntimeError(message);
    },
    getIsolateAffinityTag: function($name) {
      return init.getIsolateTag($name);
    },
    setRuntimeTypeInfo: function(target, rti) {
      target.$ti = rti;
      return target;
    },
    getRuntimeTypeInfo: function(target) {
      if (target == null)
        return;
      return target.$ti;
    },
    getRuntimeTypeArguments: function(interceptor, object, substitutionName) {
      return H.substitute(interceptor["$as" + H.S(substitutionName)], H.getRuntimeTypeInfo(object));
    },
    getRuntimeTypeArgumentIntercepted: function(interceptor, target, substitutionName, index) {
      var $arguments = H.substitute(interceptor["$as" + H.S(substitutionName)], H.getRuntimeTypeInfo(target));
      return $arguments == null ? null : $arguments[index];
    },
    getRuntimeTypeArgument: function(target, substitutionName, index) {
      var $arguments = H.substitute(target["$as" + H.S(substitutionName)], H.getRuntimeTypeInfo(target));
      return $arguments == null ? null : $arguments[index];
    },
    getTypeArgumentByIndex: function(target, index) {
      var rti = H.getRuntimeTypeInfo(target);
      return rti == null ? null : rti[index];
    },
    runtimeTypeToString: function(rti) {
      return H._runtimeTypeToString(rti, null);
    },
    _runtimeTypeToString: function(rti, genericContext) {
      if (rti == null)
        return "dynamic";
      if (rti === -1)
        return "void";
      if (typeof rti === "object" && rti !== null && rti.constructor === Array)
        return H.unminifyOrTag(rti[0].name) + H._joinArguments(rti, 1, genericContext);
      if (typeof rti == "function")
        return H.unminifyOrTag(rti.name);
      if (rti === -2)
        return "dynamic";
      if (typeof rti === "number") {
        if (genericContext == null || rti < 0 || rti >= genericContext.length)
          return "unexpected-generic-index:" + H.S(rti);
        return H.S(genericContext[genericContext.length - rti - 1]);
      }
      if ('func' in rti)
        return H._functionRtiToString(rti, genericContext);
      if ('futureOr' in rti)
        return "FutureOr<" + H._runtimeTypeToString("type" in rti ? rti.type : null, genericContext) + ">";
      return "unknown-reified-type";
    },
    _functionRtiToString: function(rti, genericContext) {
      var boundsRti, outerContextLength, offset, i, i0, typeParameters, typeSep, boundRti, returnTypeText, $arguments, t1, argumentsText, sep, _i, argument, optionalArguments, namedArguments, t2, t3, _s2_ = ", ";
      if ("bounds" in rti) {
        boundsRti = rti.bounds;
        if (genericContext == null) {
          genericContext = H.setRuntimeTypeInfo([], [P.String]);
          outerContextLength = null;
        } else
          outerContextLength = genericContext.length;
        offset = genericContext.length;
        for (i = boundsRti.length, i0 = i; i0 > 0; --i0)
          genericContext.push("T" + (offset + i0));
        for (typeParameters = "<", typeSep = "", i0 = 0; i0 < i; ++i0, typeSep = _s2_) {
          typeParameters = C.JSString_methods.$add(typeParameters + typeSep, genericContext[genericContext.length - i0 - 1]);
          boundRti = boundsRti[i0];
          if (boundRti != null && boundRti !== P.Object)
            typeParameters += " extends " + H._runtimeTypeToString(boundRti, genericContext);
        }
        typeParameters += ">";
      } else {
        typeParameters = "";
        outerContextLength = null;
      }
      returnTypeText = !!rti.v ? "void" : H._runtimeTypeToString(rti.ret, genericContext);
      if ("args" in rti) {
        $arguments = rti.args;
        for (t1 = $arguments.length, argumentsText = "", sep = "", _i = 0; _i < t1; ++_i, sep = _s2_) {
          argument = $arguments[_i];
          argumentsText = argumentsText + sep + H._runtimeTypeToString(argument, genericContext);
        }
      } else {
        argumentsText = "";
        sep = "";
      }
      if ("opt" in rti) {
        optionalArguments = rti.opt;
        argumentsText += sep + "[";
        for (t1 = optionalArguments.length, sep = "", _i = 0; _i < t1; ++_i, sep = _s2_) {
          argument = optionalArguments[_i];
          argumentsText = argumentsText + sep + H._runtimeTypeToString(argument, genericContext);
        }
        argumentsText += "]";
      }
      if ("named" in rti) {
        namedArguments = rti.named;
        argumentsText += sep + "{";
        for (t1 = H.extractKeys(namedArguments), t2 = t1.length, sep = "", _i = 0; _i < t2; ++_i, sep = _s2_) {
          t3 = t1[_i];
          argumentsText = argumentsText + sep + H._runtimeTypeToString(namedArguments[t3], genericContext) + (" " + H.S(t3));
        }
        argumentsText += "}";
      }
      if (outerContextLength != null)
        genericContext.length = outerContextLength;
      return typeParameters + "(" + argumentsText + ") => " + returnTypeText;
    },
    _joinArguments: function(types, startIndex, genericContext) {
      var buffer, index, separator, allDynamic, t1, argument;
      if (types == null)
        return "";
      buffer = new P.StringBuffer("");
      for (index = startIndex, separator = "", allDynamic = true, t1 = ""; index < types.length; ++index, separator = ", ") {
        buffer._contents = t1 + separator;
        argument = types[index];
        if (argument != null)
          allDynamic = false;
        t1 = buffer._contents += H._runtimeTypeToString(argument, genericContext);
      }
      return "<" + buffer.toString$0(0) + ">";
    },
    getRti: function(o) {
      var functionRti, type, rti,
        t1 = J.getInterceptor$(o);
      if (!!t1.$isClosure) {
        functionRti = H.extractFunctionTypeObjectFromInternal(t1);
        if (functionRti != null)
          return functionRti;
      }
      type = t1.constructor;
      if (typeof o != "object")
        return type;
      rti = H.getRuntimeTypeInfo(o);
      if (rti != null) {
        rti = rti.slice();
        rti.splice(0, 0, type);
        type = rti;
      }
      return type;
    },
    getRuntimeType: function(object) {
      return new H.TypeImpl(H.getRti(object));
    },
    substitute: function(substitution, $arguments) {
      if (substitution == null)
        return $arguments;
      substitution = substitution.apply(null, $arguments);
      if (substitution == null)
        return;
      if (typeof substitution === "object" && substitution !== null && substitution.constructor === Array)
        return substitution;
      if (typeof substitution == "function")
        return substitution.apply(null, $arguments);
      return $arguments;
    },
    checkSubtype: function(object, isField, checks, asField) {
      var $arguments, interceptor;
      if (object == null)
        return false;
      $arguments = H.getRuntimeTypeInfo(object);
      interceptor = J.getInterceptor$(object);
      if (interceptor[isField] == null)
        return false;
      return H.areSubtypes(H.substitute(interceptor[asField], $arguments), null, checks, null);
    },
    subtypeCast: function(object, isField, checks, asField) {
      if (object == null)
        return object;
      if (H.checkSubtype(object, isField, checks, asField))
        return object;
      throw H.wrapException(H.CastErrorImplementation$(object, function(str, names) {
        return str.replace(/[^<,> ]+/g, function(m) {
          return names[m] || m;
        });
      }(H.unminifyOrTag(isField.substring(3)) + H._joinArguments(checks, 0, null), init.mangledGlobalNames)));
    },
    areSubtypes: function(s, sEnv, t, tEnv) {
      var len, i;
      if (t == null)
        return true;
      if (s == null) {
        len = t.length;
        for (i = 0; i < len; ++i)
          if (!H._isSubtype(null, null, t[i], tEnv))
            return false;
        return true;
      }
      len = s.length;
      for (i = 0; i < len; ++i)
        if (!H._isSubtype(s[i], sEnv, t[i], tEnv))
          return false;
      return true;
    },
    computeSignature: function(signature, context, contextName) {
      return signature.apply(context, H.substitute(J.getInterceptor$(context)["$as" + H.S(contextName)], H.getRuntimeTypeInfo(context)));
    },
    isSupertypeOfNullRecursive: function(type) {
      var typeArgument;
      if (typeof type === "number")
        return false;
      if ('futureOr' in type) {
        typeArgument = "type" in type ? type.type : null;
        return type == null || type.name === "Object" || type.name === "Null" || type === -1 || type === -2 || H.isSupertypeOfNullRecursive(typeArgument);
      }
      return false;
    },
    checkSubtypeOfRuntimeType: function(o, t) {
      var type, rti;
      if (o == null)
        return t == null || t.name === "Object" || t.name === "Null" || t === -1 || t === -2 || H.isSupertypeOfNullRecursive(t);
      if (t == null || t === -1 || t.name === "Object" || t === -2)
        return true;
      if (typeof t == "object") {
        if ('futureOr' in t)
          if (H.checkSubtypeOfRuntimeType(o, "type" in t ? t.type : null))
            return true;
        if ('func' in t)
          return H.functionTypeTest(o, t);
      }
      type = J.getInterceptor$(o).constructor;
      rti = H.getRuntimeTypeInfo(o);
      if (rti != null) {
        rti = rti.slice();
        rti.splice(0, 0, type);
        type = rti;
      }
      return H._isSubtype(type, null, t, null);
    },
    subtypeOfRuntimeTypeCast: function(object, type) {
      if (object != null && !H.checkSubtypeOfRuntimeType(object, type))
        throw H.wrapException(H.CastErrorImplementation$(object, H.runtimeTypeToString(type)));
      return object;
    },
    _isSubtype: function(s, sEnv, t, tEnv) {
      var t1, typeOfS, tTypeArgument, futureSubstitution, futureArguments, t2, typeOfT, typeOfTString, substitution, _null = null;
      if (s === t)
        return true;
      if (t == null || t === -1 || t.name === "Object" || t === -2)
        return true;
      if (s === -2)
        return true;
      if (s == null || s === -1 || s.name === "Object" || s === -2) {
        if (typeof t === "number")
          return false;
        if ('futureOr' in t)
          return H._isSubtype(s, sEnv, "type" in t ? t.type : _null, tEnv);
        return false;
      }
      if (typeof s === "number")
        return false;
      if (typeof t === "number")
        return false;
      if (s.name === "Null")
        return true;
      if ('func' in t)
        return H._isFunctionSubtype(s, sEnv, t, tEnv);
      if ('func' in s)
        return t.name === "Function";
      t1 = typeof s === "object" && s !== null && s.constructor === Array;
      typeOfS = t1 ? s[0] : s;
      if ('futureOr' in t) {
        tTypeArgument = "type" in t ? t.type : _null;
        if ('futureOr' in s)
          return H._isSubtype("type" in s ? s.type : _null, sEnv, tTypeArgument, tEnv);
        else if (H._isSubtype(s, sEnv, tTypeArgument, tEnv))
          return true;
        else {
          if (!('$is' + "Future" in typeOfS.prototype))
            return false;
          futureSubstitution = typeOfS.prototype["$as" + "Future"];
          futureArguments = H.substitute(futureSubstitution, t1 ? s.slice(1) : _null);
          return H._isSubtype(typeof futureArguments === "object" && futureArguments !== null && futureArguments.constructor === Array ? futureArguments[0] : _null, sEnv, tTypeArgument, tEnv);
        }
      }
      t2 = typeof t === "object" && t !== null && t.constructor === Array;
      typeOfT = t2 ? t[0] : t;
      if (typeOfT !== typeOfS) {
        typeOfTString = typeOfT.name;
        if (!('$is' + typeOfTString in typeOfS.prototype))
          return false;
        substitution = typeOfS.prototype["$as" + typeOfTString];
      } else
        substitution = _null;
      if (!t2)
        return true;
      t1 = t1 ? s.slice(1) : _null;
      t2 = t.slice(1);
      return H.areSubtypes(H.substitute(substitution, t1), sEnv, t2, tEnv);
    },
    _isFunctionSubtype: function(s, sEnv, t, tEnv) {
      var sBounds, tBounds, sParameterTypes, tParameterTypes, sOptionalParameterTypes, tOptionalParameterTypes, sParametersLen, tParametersLen, sOptionalParametersLen, tOptionalParametersLen, pos, tPos, sPos, sNamedParameters, tNamedParameters;
      if (!('func' in s))
        return false;
      if ("bounds" in s) {
        if (!("bounds" in t))
          return false;
        sBounds = s.bounds;
        tBounds = t.bounds;
        if (sBounds.length !== tBounds.length)
          return false;
      } else if ("bounds" in t)
        return false;
      if (!H._isSubtype(s.ret, sEnv, t.ret, tEnv))
        return false;
      sParameterTypes = s.args;
      tParameterTypes = t.args;
      sOptionalParameterTypes = s.opt;
      tOptionalParameterTypes = t.opt;
      sParametersLen = sParameterTypes != null ? sParameterTypes.length : 0;
      tParametersLen = tParameterTypes != null ? tParameterTypes.length : 0;
      sOptionalParametersLen = sOptionalParameterTypes != null ? sOptionalParameterTypes.length : 0;
      tOptionalParametersLen = tOptionalParameterTypes != null ? tOptionalParameterTypes.length : 0;
      if (sParametersLen > tParametersLen)
        return false;
      if (sParametersLen + sOptionalParametersLen < tParametersLen + tOptionalParametersLen)
        return false;
      for (pos = 0; pos < sParametersLen; ++pos)
        if (!H._isSubtype(tParameterTypes[pos], tEnv, sParameterTypes[pos], sEnv))
          return false;
      for (tPos = pos, sPos = 0; tPos < tParametersLen; ++sPos, ++tPos)
        if (!H._isSubtype(tParameterTypes[tPos], tEnv, sOptionalParameterTypes[sPos], sEnv))
          return false;
      for (tPos = 0; tPos < tOptionalParametersLen; ++sPos, ++tPos)
        if (!H._isSubtype(tOptionalParameterTypes[tPos], tEnv, sOptionalParameterTypes[sPos], sEnv))
          return false;
      sNamedParameters = s.named;
      tNamedParameters = t.named;
      if (tNamedParameters == null)
        return true;
      if (sNamedParameters == null)
        return false;
      return H.namedParametersSubtypeCheck(sNamedParameters, sEnv, tNamedParameters, tEnv);
    },
    namedParametersSubtypeCheck: function(s, sEnv, t, tEnv) {
      var t1, i, $name,
        names = Object.getOwnPropertyNames(t);
      for (t1 = names.length, i = 0; i < t1; ++i) {
        $name = names[i];
        if (!Object.hasOwnProperty.call(s, $name))
          return false;
        if (!H._isSubtype(t[$name], tEnv, s[$name], sEnv))
          return false;
      }
      return true;
    },
    instantiatedGenericFunctionType: function(genericFunctionRti, parameters) {
      if (genericFunctionRti == null)
        return;
      return H.finishBindInstantiatedFunctionType(genericFunctionRti, {func: 1}, parameters, 0);
    },
    finishBindInstantiatedFunctionType: function(rti, result, parameters, depth) {
      var namedParameters, boundNamed, names, t1, _i, $name;
      if ("v" in rti)
        result.v = rti.v;
      else if ("ret" in rti)
        result.ret = H.bindInstantiatedType(rti.ret, parameters, depth);
      if ("args" in rti)
        result.args = H.bindInstantiatedTypes(rti.args, parameters, depth);
      if ("opt" in rti)
        result.opt = H.bindInstantiatedTypes(rti.opt, parameters, depth);
      if ("named" in rti) {
        namedParameters = rti.named;
        boundNamed = {};
        names = Object.keys(namedParameters);
        for (t1 = names.length, _i = 0; _i < t1; ++_i) {
          $name = names[_i];
          boundNamed[$name] = H.bindInstantiatedType(namedParameters[$name], parameters, depth);
        }
        result.named = boundNamed;
      }
      return result;
    },
    bindInstantiatedType: function(rti, parameters, depth) {
      var result, bounds;
      if (rti == null)
        return rti;
      if (rti === -1)
        return rti;
      if (typeof rti == "function")
        return rti;
      if (typeof rti === "number") {
        if (rti < depth)
          return rti;
        return parameters[rti - depth];
      }
      if (typeof rti === "object" && rti !== null && rti.constructor === Array)
        return H.bindInstantiatedTypes(rti, parameters, depth);
      if ('func' in rti) {
        result = {func: 1};
        if ("bounds" in rti) {
          bounds = rti.bounds;
          depth += bounds.length;
          result.bounds = H.bindInstantiatedTypes(bounds, parameters, depth);
        }
        return H.finishBindInstantiatedFunctionType(rti, result, parameters, depth);
      }
      throw H.wrapException(P.ArgumentError$("Unknown RTI format in bindInstantiatedType."));
    },
    bindInstantiatedTypes: function(rti, parameters, depth) {
      var t1, i,
        array = rti.slice();
      for (t1 = array.length, i = 0; i < t1; ++i)
        array[i] = H.bindInstantiatedType(array[i], parameters, depth);
      return array;
    },
    defineProperty: function(obj, property, value) {
      Object.defineProperty(obj, property, {value: value, enumerable: false, writable: true, configurable: true});
    },
    lookupAndCacheInterceptor: function(obj) {
      var interceptor, interceptorClass, mark, t1,
        tag = $.getTagFunction.call$1(obj),
        record = $.dispatchRecordsForInstanceTags[tag];
      if (record != null) {
        Object.defineProperty(obj, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
        return record.i;
      }
      interceptor = $.interceptorsForUncacheableTags[tag];
      if (interceptor != null)
        return interceptor;
      interceptorClass = init.interceptorsByTag[tag];
      if (interceptorClass == null) {
        tag = $.alternateTagFunction.call$2(obj, tag);
        if (tag != null) {
          record = $.dispatchRecordsForInstanceTags[tag];
          if (record != null) {
            Object.defineProperty(obj, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
            return record.i;
          }
          interceptor = $.interceptorsForUncacheableTags[tag];
          if (interceptor != null)
            return interceptor;
          interceptorClass = init.interceptorsByTag[tag];
        }
      }
      if (interceptorClass == null)
        return;
      interceptor = interceptorClass.prototype;
      mark = tag[0];
      if (mark === "!") {
        record = H.makeLeafDispatchRecord(interceptor);
        $.dispatchRecordsForInstanceTags[tag] = record;
        Object.defineProperty(obj, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
        return record.i;
      }
      if (mark === "~") {
        $.interceptorsForUncacheableTags[tag] = interceptor;
        return interceptor;
      }
      if (mark === "-") {
        t1 = H.makeLeafDispatchRecord(interceptor);
        Object.defineProperty(Object.getPrototypeOf(obj), init.dispatchPropertyName, {value: t1, enumerable: false, writable: true, configurable: true});
        return t1.i;
      }
      if (mark === "+")
        return H.patchInteriorProto(obj, interceptor);
      if (mark === "*")
        throw H.wrapException(P.UnimplementedError$(tag));
      if (init.leafTags[tag] === true) {
        t1 = H.makeLeafDispatchRecord(interceptor);
        Object.defineProperty(Object.getPrototypeOf(obj), init.dispatchPropertyName, {value: t1, enumerable: false, writable: true, configurable: true});
        return t1.i;
      } else
        return H.patchInteriorProto(obj, interceptor);
    },
    patchInteriorProto: function(obj, interceptor) {
      var proto = Object.getPrototypeOf(obj);
      Object.defineProperty(proto, init.dispatchPropertyName, {value: J.makeDispatchRecord(interceptor, proto, null, null), enumerable: false, writable: true, configurable: true});
      return interceptor;
    },
    makeLeafDispatchRecord: function(interceptor) {
      return J.makeDispatchRecord(interceptor, false, null, !!interceptor.$isJavaScriptIndexingBehavior);
    },
    makeDefaultDispatchRecord: function(tag, interceptorClass, proto) {
      var interceptor = interceptorClass.prototype;
      if (init.leafTags[tag] === true)
        return H.makeLeafDispatchRecord(interceptor);
      else
        return J.makeDispatchRecord(interceptor, proto, null, null);
    },
    initNativeDispatch: function() {
      if (true === $.initNativeDispatchFlag)
        return;
      $.initNativeDispatchFlag = true;
      H.initNativeDispatchContinue();
    },
    initNativeDispatchContinue: function() {
      var map, tags, fun, i, tag, proto, record, interceptorClass;
      $.dispatchRecordsForInstanceTags = Object.create(null);
      $.interceptorsForUncacheableTags = Object.create(null);
      H.initHooks();
      map = init.interceptorsByTag;
      tags = Object.getOwnPropertyNames(map);
      if (typeof window != "undefined") {
        window;
        fun = function() {
        };
        for (i = 0; i < tags.length; ++i) {
          tag = tags[i];
          proto = $.prototypeForTagFunction.call$1(tag);
          if (proto != null) {
            record = H.makeDefaultDispatchRecord(tag, map[tag], proto);
            if (record != null) {
              Object.defineProperty(proto, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
              fun.prototype = proto;
            }
          }
        }
      }
      for (i = 0; i < tags.length; ++i) {
        tag = tags[i];
        if (/^[A-Za-z_]/.test(tag)) {
          interceptorClass = map[tag];
          map["!" + tag] = interceptorClass;
          map["~" + tag] = interceptorClass;
          map["-" + tag] = interceptorClass;
          map["+" + tag] = interceptorClass;
          map["*" + tag] = interceptorClass;
        }
      }
    },
    initHooks: function() {
      var transformers, i, transformer, getTag, getUnknownTag, prototypeForTag,
        hooks = C.C_JS_CONST0();
      hooks = H.applyHooksTransformer(C.C_JS_CONST1, H.applyHooksTransformer(C.C_JS_CONST2, H.applyHooksTransformer(C.C_JS_CONST3, H.applyHooksTransformer(C.C_JS_CONST3, H.applyHooksTransformer(C.C_JS_CONST4, H.applyHooksTransformer(C.C_JS_CONST5, H.applyHooksTransformer(C.C_JS_CONST6(C.C_JS_CONST), hooks)))))));
      if (typeof dartNativeDispatchHooksTransformer != "undefined") {
        transformers = dartNativeDispatchHooksTransformer;
        if (typeof transformers == "function")
          transformers = [transformers];
        if (transformers.constructor == Array)
          for (i = 0; i < transformers.length; ++i) {
            transformer = transformers[i];
            if (typeof transformer == "function")
              hooks = transformer(hooks) || hooks;
          }
      }
      getTag = hooks.getTag;
      getUnknownTag = hooks.getUnknownTag;
      prototypeForTag = hooks.prototypeForTag;
      $.getTagFunction = new H.initHooks_closure(getTag);
      $.alternateTagFunction = new H.initHooks_closure0(getUnknownTag);
      $.prototypeForTagFunction = new H.initHooks_closure1(prototypeForTag);
    },
    applyHooksTransformer: function(transformer, hooks) {
      return transformer(hooks) || hooks;
    },
    JSSyntaxRegExp_makeNative: function(source, multiLine, caseSensitive, unicode, dotAll, global) {
      var m = multiLine ? "m" : "",
        i = caseSensitive ? "" : "i",
        u = unicode ? "u" : "",
        s = dotAll ? "s" : "",
        g = global ? "g" : "",
        regexp = function(source, modifiers) {
          try {
            return new RegExp(source, modifiers);
          } catch (e) {
            return e;
          }
        }(source, m + i + u + s + g);
      if (regexp instanceof RegExp)
        return regexp;
      throw H.wrapException(P.FormatException$("Illegal RegExp pattern (" + String(regexp) + ")", source, null));
    },
    stringContainsUnchecked: function(receiver, other, startIndex) {
      var t1, t2;
      if (typeof other === "string")
        return receiver.indexOf(other, startIndex) >= 0;
      else {
        t1 = J.getInterceptor$(other);
        if (!!t1.$isJSSyntaxRegExp) {
          t1 = C.JSString_methods.substring$1(receiver, startIndex);
          t2 = other._nativeRegExp;
          return t2.test(t1);
        } else {
          t1 = t1.allMatches$1(other, C.JSString_methods.substring$1(receiver, startIndex));
          return !t1.get$isEmpty(t1);
        }
      }
    },
    escapeReplacement: function(replacement) {
      if (replacement.indexOf("$", 0) >= 0)
        return replacement.replace(/\$/g, "$$$$");
      return replacement;
    },
    stringReplaceFirstRE: function(receiver, regexp, replacement, startIndex) {
      var match = regexp._execGlobal$2(receiver, startIndex);
      if (match == null)
        return receiver;
      return H.stringReplaceRangeUnchecked(receiver, match._match.index, match.get$end(match), replacement);
    },
    quoteStringForRegExp: function(string) {
      if (/[[\]{}()*+?.\\^$|]/.test(string))
        return string.replace(/[[\]{}()*+?.\\^$|]/g, "\\$&");
      return string;
    },
    stringReplaceAllUnchecked: function(receiver, pattern, replacement) {
      var nativeRegexp;
      if (typeof pattern === "string")
        return H.stringReplaceAllUncheckedString(receiver, pattern, replacement);
      if (pattern instanceof H.JSSyntaxRegExp) {
        nativeRegexp = pattern.get$_nativeGlobalVersion();
        nativeRegexp.lastIndex = 0;
        return receiver.replace(nativeRegexp, H.escapeReplacement(replacement));
      }
      if (pattern == null)
        H.throwExpression(H.argumentErrorValue(pattern));
      throw H.wrapException("String.replaceAll(Pattern) UNIMPLEMENTED");
    },
    stringReplaceAllUncheckedString: function(receiver, pattern, replacement) {
      var $length, t1, i, index;
      if (pattern === "") {
        if (receiver === "")
          return replacement;
        $length = receiver.length;
        for (t1 = replacement, i = 0; i < $length; ++i)
          t1 = t1 + receiver[i] + replacement;
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      }
      index = receiver.indexOf(pattern, 0);
      if (index < 0)
        return receiver;
      if (receiver.length < 500 || replacement.indexOf("$", 0) >= 0)
        return receiver.split(pattern).join(replacement);
      return receiver.replace(new RegExp(H.quoteStringForRegExp(pattern), 'g'), H.escapeReplacement(replacement));
    },
    stringReplaceFirstUnchecked: function(receiver, pattern, replacement, startIndex) {
      var index, t1, matches, match;
      if (typeof pattern === "string") {
        index = receiver.indexOf(pattern, startIndex);
        if (index < 0)
          return receiver;
        return H.stringReplaceRangeUnchecked(receiver, index, index + pattern.length, replacement);
      }
      t1 = J.getInterceptor$(pattern);
      if (!!t1.$isJSSyntaxRegExp)
        return startIndex === 0 ? receiver.replace(pattern._nativeRegExp, H.escapeReplacement(replacement)) : H.stringReplaceFirstRE(receiver, pattern, replacement, startIndex);
      if (pattern == null)
        H.throwExpression(H.argumentErrorValue(pattern));
      t1 = t1.allMatches$2(pattern, receiver, startIndex);
      matches = t1.get$iterator(t1);
      if (!matches.moveNext$0())
        return receiver;
      match = matches.get$current(matches);
      return C.JSString_methods.replaceRange$3(receiver, match.get$start(match), match.get$end(match), replacement);
    },
    stringReplaceRangeUnchecked: function(receiver, start, end, replacement) {
      var prefix = receiver.substring(0, start),
        suffix = receiver.substring(end);
      return prefix + H.S(replacement) + suffix;
    },
    ConstantMapView: function ConstantMapView(t0, t1) {
      this._collection$_map = t0;
      this.$ti = t1;
    },
    ConstantMap: function ConstantMap() {
    },
    ConstantStringMap: function ConstantStringMap(t0, t1, t2, t3) {
      var _ = this;
      _.__js_helper$_length = t0;
      _._jsObject = t1;
      _._keys = t2;
      _.$ti = t3;
    },
    ConstantStringMap_values_closure: function ConstantStringMap_values_closure(t0) {
      this.$this = t0;
    },
    ConstantProtoMap: function ConstantProtoMap(t0, t1, t2, t3, t4) {
      var _ = this;
      _._protoValue = t0;
      _.__js_helper$_length = t1;
      _._jsObject = t2;
      _._keys = t3;
      _.$ti = t4;
    },
    _ConstantMapKeyIterable: function _ConstantMapKeyIterable(t0, t1) {
      this._map = t0;
      this.$ti = t1;
    },
    Instantiation: function Instantiation() {
    },
    Instantiation1: function Instantiation1(t0, t1) {
      this._genericClosure = t0;
      this.$ti = t1;
    },
    JSInvocationMirror: function JSInvocationMirror(t0, t1, t2, t3, t4) {
      var _ = this;
      _.__js_helper$_memberName = t0;
      _._kind = t1;
      _.__js_helper$_arguments = t2;
      _._namedArgumentNames = t3;
      _._typeArgumentCount = t4;
    },
    Primitives_functionNoSuchMethod_closure: function Primitives_functionNoSuchMethod_closure(t0, t1, t2) {
      this._box_0 = t0;
      this.namedArgumentList = t1;
      this.$arguments = t2;
    },
    TypeErrorDecoder: function TypeErrorDecoder(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _._pattern = t0;
      _.__js_helper$_arguments = t1;
      _._argumentsExpr = t2;
      _._expr = t3;
      _._method = t4;
      _.__js_helper$_receiver = t5;
    },
    NullError: function NullError(t0, t1) {
      this._message = t0;
      this._method = t1;
    },
    JsNoSuchMethodError: function JsNoSuchMethodError(t0, t1, t2) {
      this._message = t0;
      this._method = t1;
      this.__js_helper$_receiver = t2;
    },
    UnknownJsTypeError: function UnknownJsTypeError(t0) {
      this._message = t0;
    },
    ExceptionAndStackTrace: function ExceptionAndStackTrace(t0, t1) {
      this.dartException = t0;
      this.stackTrace = t1;
    },
    unwrapException_saveStackTrace: function unwrapException_saveStackTrace(t0) {
      this.ex = t0;
    },
    _StackTrace: function _StackTrace(t0) {
      this._exception = t0;
      this._trace = null;
    },
    Closure: function Closure() {
    },
    TearOffClosure: function TearOffClosure() {
    },
    StaticClosure: function StaticClosure() {
    },
    BoundClosure: function BoundClosure(t0, t1, t2, t3) {
      var _ = this;
      _._self = t0;
      _._target = t1;
      _.__js_helper$_receiver = t2;
      _.__js_helper$_name = t3;
    },
    CastErrorImplementation: function CastErrorImplementation(t0) {
      this.message = t0;
    },
    RuntimeError: function RuntimeError(t0) {
      this.message = t0;
    },
    TypeImpl: function TypeImpl(t0) {
      this._rti = t0;
      this._hashCode = this.__typeName = null;
    },
    JsLinkedHashMap: function JsLinkedHashMap(t0) {
      var _ = this;
      _.__js_helper$_length = 0;
      _._last = _._first = _._rest = _._nums = _._strings = null;
      _._modifications = 0;
      _.$ti = t0;
    },
    JsLinkedHashMap_values_closure: function JsLinkedHashMap_values_closure(t0) {
      this.$this = t0;
    },
    JsLinkedHashMap_addAll_closure: function JsLinkedHashMap_addAll_closure(t0) {
      this.$this = t0;
    },
    LinkedHashMapCell: function LinkedHashMapCell(t0, t1) {
      var _ = this;
      _.hashMapCellKey = t0;
      _.hashMapCellValue = t1;
      _._previous = _._next = null;
    },
    LinkedHashMapKeyIterable: function LinkedHashMapKeyIterable(t0, t1) {
      this._map = t0;
      this.$ti = t1;
    },
    LinkedHashMapKeyIterator: function LinkedHashMapKeyIterator(t0, t1) {
      var _ = this;
      _._map = t0;
      _._modifications = t1;
      _.__js_helper$_current = _._cell = null;
    },
    initHooks_closure: function initHooks_closure(t0) {
      this.getTag = t0;
    },
    initHooks_closure0: function initHooks_closure0(t0) {
      this.getUnknownTag = t0;
    },
    initHooks_closure1: function initHooks_closure1(t0) {
      this.prototypeForTag = t0;
    },
    JSSyntaxRegExp: function JSSyntaxRegExp(t0, t1) {
      var _ = this;
      _.pattern = t0;
      _._nativeRegExp = t1;
      _._nativeAnchoredRegExp = _._nativeGlobalRegExp = null;
    },
    _MatchImplementation: function _MatchImplementation(t0) {
      this._match = t0;
    },
    _AllMatchesIterable: function _AllMatchesIterable(t0, t1, t2) {
      this._re = t0;
      this._string = t1;
      this.__js_helper$_start = t2;
    },
    _AllMatchesIterator: function _AllMatchesIterator(t0, t1, t2) {
      var _ = this;
      _._regExp = t0;
      _._string = t1;
      _._nextIndex = t2;
      _.__js_helper$_current = null;
    },
    StringMatch: function StringMatch(t0, t1) {
      this.start = t0;
      this.pattern = t1;
    },
    _StringAllMatchesIterable: function _StringAllMatchesIterable(t0, t1, t2) {
      this._input = t0;
      this._pattern = t1;
      this.__js_helper$_index = t2;
    },
    _StringAllMatchesIterator: function _StringAllMatchesIterator(t0, t1, t2) {
      var _ = this;
      _._input = t0;
      _._pattern = t1;
      _.__js_helper$_index = t2;
      _.__js_helper$_current = null;
    },
    _ensureNativeList: function(list) {
      return list;
    },
    NativeInt8List__create1: function(arg) {
      return new Int8Array(arg);
    },
    NativeUint8List_NativeUint8List$view: function(buffer, offsetInBytes, $length) {
      var t1 = new Uint8Array(buffer, offsetInBytes, $length);
      return t1;
    },
    _checkValidIndex: function(index, list, $length) {
      if (index >>> 0 !== index || index >= $length)
        throw H.wrapException(H.diagnoseIndexError(list, index));
    },
    _checkValidRange: function(start, end, $length) {
      var t1;
      if (!(start >>> 0 !== start))
        if (end == null)
          t1 = start > $length;
        else
          t1 = end >>> 0 !== end || start > end || end > $length;
      else
        t1 = true;
      if (t1)
        throw H.wrapException(H.diagnoseRangeError(start, end, $length));
      if (end == null)
        return $length;
      return end;
    },
    NativeTypedData: function NativeTypedData() {
    },
    NativeTypedArray: function NativeTypedArray() {
    },
    NativeTypedArrayOfDouble: function NativeTypedArrayOfDouble() {
    },
    NativeTypedArrayOfInt: function NativeTypedArrayOfInt() {
    },
    NativeFloat32List: function NativeFloat32List() {
    },
    NativeFloat64List: function NativeFloat64List() {
    },
    NativeInt16List: function NativeInt16List() {
    },
    NativeInt32List: function NativeInt32List() {
    },
    NativeInt8List: function NativeInt8List() {
    },
    NativeUint16List: function NativeUint16List() {
    },
    NativeUint32List: function NativeUint32List() {
    },
    NativeUint8ClampedList: function NativeUint8ClampedList() {
    },
    NativeUint8List: function NativeUint8List() {
    },
    _NativeTypedArrayOfDouble_NativeTypedArray_ListMixin: function _NativeTypedArrayOfDouble_NativeTypedArray_ListMixin() {
    },
    _NativeTypedArrayOfDouble_NativeTypedArray_ListMixin_FixedLengthListMixin: function _NativeTypedArrayOfDouble_NativeTypedArray_ListMixin_FixedLengthListMixin() {
    },
    _NativeTypedArrayOfInt_NativeTypedArray_ListMixin: function _NativeTypedArrayOfInt_NativeTypedArray_ListMixin() {
    },
    _NativeTypedArrayOfInt_NativeTypedArray_ListMixin_FixedLengthListMixin: function _NativeTypedArrayOfInt_NativeTypedArray_ListMixin_FixedLengthListMixin() {
    },
    extractKeys: function(victim) {
      return J.JSArray_JSArray$markFixed(victim ? Object.keys(victim) : [], null);
    },
    printString: function(string) {
      if (typeof dartPrint == "function") {
        dartPrint(string);
        return;
      }
      if (typeof console == "object" && typeof console.log != "undefined") {
        console.log(string);
        return;
      }
      if (typeof window == "object")
        return;
      if (typeof print == "function") {
        print(string);
        return;
      }
      throw "Unable to print message: " + String(string);
    }
  },
  J = {
    makeDispatchRecord: function(interceptor, proto, extension, indexability) {
      return {i: interceptor, p: proto, e: extension, x: indexability};
    },
    getNativeInterceptor: function(object) {
      var proto, objectProto, $constructor, interceptor,
        record = object[init.dispatchPropertyName];
      if (record == null)
        if ($.initNativeDispatchFlag == null) {
          H.initNativeDispatch();
          record = object[init.dispatchPropertyName];
        }
      if (record != null) {
        proto = record.p;
        if (false === proto)
          return record.i;
        if (true === proto)
          return object;
        objectProto = Object.getPrototypeOf(object);
        if (proto === objectProto)
          return record.i;
        if (record.e === objectProto)
          throw H.wrapException(P.UnimplementedError$("Return interceptor for " + H.S(proto(object, record))));
      }
      $constructor = object.constructor;
      interceptor = $constructor == null ? null : $constructor[$.$get$JS_INTEROP_INTERCEPTOR_TAG()];
      if (interceptor != null)
        return interceptor;
      interceptor = H.lookupAndCacheInterceptor(object);
      if (interceptor != null)
        return interceptor;
      if (typeof object == "function")
        return C.JavaScriptFunction_methods;
      proto = Object.getPrototypeOf(object);
      if (proto == null)
        return C.PlainJavaScriptObject_methods;
      if (proto === Object.prototype)
        return C.PlainJavaScriptObject_methods;
      if (typeof $constructor == "function") {
        Object.defineProperty($constructor, $.$get$JS_INTEROP_INTERCEPTOR_TAG(), {value: C.UnknownJavaScriptObject_methods, enumerable: false, writable: true, configurable: true});
        return C.UnknownJavaScriptObject_methods;
      }
      return C.UnknownJavaScriptObject_methods;
    },
    JSArray_JSArray$fixed: function($length, $E) {
      if (typeof $length !== "number" || Math.floor($length) !== $length)
        throw H.wrapException(P.ArgumentError$value($length, "length", "is not an integer"));
      if ($length < 0 || $length > 4294967295)
        throw H.wrapException(P.RangeError$range($length, 0, 4294967295, "length", null));
      return J.JSArray_JSArray$markFixed(new Array($length), $E);
    },
    JSArray_JSArray$markFixed: function(allocation, $E) {
      return J.JSArray_markFixedList(H.setRuntimeTypeInfo(allocation, [$E]));
    },
    JSArray_markFixedList: function(list) {
      list.fixed$length = Array;
      return list;
    },
    JSArray_markUnmodifiableList: function(list) {
      list.fixed$length = Array;
      list.immutable$list = Array;
      return list;
    },
    JSArray__compareAny: function(a, b) {
      return J.compareTo$1$ns(a, b);
    },
    JSString__isWhitespace: function(codeUnit) {
      if (codeUnit < 256)
        switch (codeUnit) {
          case 9:
          case 10:
          case 11:
          case 12:
          case 13:
          case 32:
          case 133:
          case 160:
            return true;
          default:
            return false;
        }
      switch (codeUnit) {
        case 5760:
        case 8192:
        case 8193:
        case 8194:
        case 8195:
        case 8196:
        case 8197:
        case 8198:
        case 8199:
        case 8200:
        case 8201:
        case 8202:
        case 8232:
        case 8233:
        case 8239:
        case 8287:
        case 12288:
        case 65279:
          return true;
        default:
          return false;
      }
    },
    JSString__skipLeadingWhitespace: function(string, index) {
      var t1, codeUnit;
      for (t1 = string.length; index < t1;) {
        codeUnit = C.JSString_methods._codeUnitAt$1(string, index);
        if (codeUnit !== 32 && codeUnit !== 13 && !J.JSString__isWhitespace(codeUnit))
          break;
        ++index;
      }
      return index;
    },
    JSString__skipTrailingWhitespace: function(string, index) {
      var index0, codeUnit;
      for (; index > 0; index = index0) {
        index0 = index - 1;
        codeUnit = C.JSString_methods.codeUnitAt$1(string, index0);
        if (codeUnit !== 32 && codeUnit !== 13 && !J.JSString__isWhitespace(codeUnit))
          break;
      }
      return index;
    },
    getInterceptor$: function(receiver) {
      if (typeof receiver == "number") {
        if (Math.floor(receiver) == receiver)
          return J.JSInt.prototype;
        return J.JSDouble.prototype;
      }
      if (typeof receiver == "string")
        return J.JSString.prototype;
      if (receiver == null)
        return J.JSNull.prototype;
      if (typeof receiver == "boolean")
        return J.JSBool.prototype;
      if (receiver.constructor == Array)
        return J.JSArray.prototype;
      if (typeof receiver != "object") {
        if (typeof receiver == "function")
          return J.JavaScriptFunction.prototype;
        return receiver;
      }
      if (receiver instanceof P.Object)
        return receiver;
      return J.getNativeInterceptor(receiver);
    },
    getInterceptor$ansx: function(receiver) {
      if (typeof receiver == "number")
        return J.JSNumber.prototype;
      if (typeof receiver == "string")
        return J.JSString.prototype;
      if (receiver == null)
        return receiver;
      if (receiver.constructor == Array)
        return J.JSArray.prototype;
      if (typeof receiver != "object") {
        if (typeof receiver == "function")
          return J.JavaScriptFunction.prototype;
        return receiver;
      }
      if (receiver instanceof P.Object)
        return receiver;
      return J.getNativeInterceptor(receiver);
    },
    getInterceptor$asx: function(receiver) {
      if (typeof receiver == "string")
        return J.JSString.prototype;
      if (receiver == null)
        return receiver;
      if (receiver.constructor == Array)
        return J.JSArray.prototype;
      if (typeof receiver != "object") {
        if (typeof receiver == "function")
          return J.JavaScriptFunction.prototype;
        return receiver;
      }
      if (receiver instanceof P.Object)
        return receiver;
      return J.getNativeInterceptor(receiver);
    },
    getInterceptor$ax: function(receiver) {
      if (receiver == null)
        return receiver;
      if (receiver.constructor == Array)
        return J.JSArray.prototype;
      if (typeof receiver != "object") {
        if (typeof receiver == "function")
          return J.JavaScriptFunction.prototype;
        return receiver;
      }
      if (receiver instanceof P.Object)
        return receiver;
      return J.getNativeInterceptor(receiver);
    },
    getInterceptor$n: function(receiver) {
      if (typeof receiver == "number")
        return J.JSNumber.prototype;
      if (receiver == null)
        return receiver;
      if (!(receiver instanceof P.Object))
        return J.UnknownJavaScriptObject.prototype;
      return receiver;
    },
    getInterceptor$ns: function(receiver) {
      if (typeof receiver == "number")
        return J.JSNumber.prototype;
      if (typeof receiver == "string")
        return J.JSString.prototype;
      if (receiver == null)
        return receiver;
      if (!(receiver instanceof P.Object))
        return J.UnknownJavaScriptObject.prototype;
      return receiver;
    },
    getInterceptor$s: function(receiver) {
      if (typeof receiver == "string")
        return J.JSString.prototype;
      if (receiver == null)
        return receiver;
      if (!(receiver instanceof P.Object))
        return J.UnknownJavaScriptObject.prototype;
      return receiver;
    },
    getInterceptor$x: function(receiver) {
      if (receiver == null)
        return receiver;
      if (typeof receiver != "object") {
        if (typeof receiver == "function")
          return J.JavaScriptFunction.prototype;
        return receiver;
      }
      if (receiver instanceof P.Object)
        return receiver;
      return J.getNativeInterceptor(receiver);
    },
    set$context$x: function(receiver, value) {
      return J.getInterceptor$x(receiver).set$context(receiver, value);
    },
    set$dartValue$x: function(receiver, value) {
      return J.getInterceptor$x(receiver).set$dartValue(receiver, value);
    },
    set$info$x: function(receiver, value) {
      return J.getInterceptor$x(receiver).set$info(receiver, value);
    },
    set$length$asx: function(receiver, value) {
      return J.getInterceptor$asx(receiver).set$length(receiver, value);
    },
    set$render$x: function(receiver, value) {
      return J.getInterceptor$x(receiver).set$render(receiver, value);
    },
    set$renderSync$x: function(receiver, value) {
      return J.getInterceptor$x(receiver).set$renderSync(receiver, value);
    },
    set$run_$x: function(receiver, value) {
      return J.getInterceptor$x(receiver).set$run_(receiver, value);
    },
    set$types$x: function(receiver, value) {
      return J.getInterceptor$x(receiver).set$types(receiver, value);
    },
    get$code$x: function(receiver) {
      return J.getInterceptor$x(receiver).get$code(receiver);
    },
    get$current$x: function(receiver) {
      return J.getInterceptor$x(receiver).get$current(receiver);
    },
    get$dartValue$x: function(receiver) {
      return J.getInterceptor$x(receiver).get$dartValue(receiver);
    },
    get$end$x: function(receiver) {
      return J.getInterceptor$x(receiver).get$end(receiver);
    },
    get$env$x: function(receiver) {
      return J.getInterceptor$x(receiver).get$env(receiver);
    },
    get$fiber$x: function(receiver) {
      return J.getInterceptor$x(receiver).get$fiber(receiver);
    },
    get$file$x: function(receiver) {
      return J.getInterceptor$x(receiver).get$file(receiver);
    },
    get$first$ax: function(receiver) {
      return J.getInterceptor$ax(receiver).get$first(receiver);
    },
    get$hashCode$: function(receiver) {
      return J.getInterceptor$(receiver).get$hashCode(receiver);
    },
    get$isEmpty$asx: function(receiver) {
      return J.getInterceptor$asx(receiver).get$isEmpty(receiver);
    },
    get$isNotEmpty$asx: function(receiver) {
      return J.getInterceptor$asx(receiver).get$isNotEmpty(receiver);
    },
    get$isTTY$x: function(receiver) {
      return J.getInterceptor$x(receiver).get$isTTY(receiver);
    },
    get$iterator$ax: function(receiver) {
      return J.getInterceptor$ax(receiver).get$iterator(receiver);
    },
    get$last$ax: function(receiver) {
      return J.getInterceptor$ax(receiver).get$last(receiver);
    },
    get$length$asx: function(receiver) {
      return J.getInterceptor$asx(receiver).get$length(receiver);
    },
    get$message$x: function(receiver) {
      return J.getInterceptor$x(receiver).get$message(receiver);
    },
    get$mtime$x: function(receiver) {
      return J.getInterceptor$x(receiver).get$mtime(receiver);
    },
    get$options$x: function(receiver) {
      return J.getInterceptor$x(receiver).get$options(receiver);
    },
    get$path$x: function(receiver) {
      return J.getInterceptor$x(receiver).get$path(receiver);
    },
    get$platform$x: function(receiver) {
      return J.getInterceptor$x(receiver).get$platform(receiver);
    },
    get$reversed$ax: function(receiver) {
      return J.getInterceptor$ax(receiver).get$reversed(receiver);
    },
    get$single$ax: function(receiver) {
      return J.getInterceptor$ax(receiver).get$single(receiver);
    },
    $add$ansx: function(receiver, a0) {
      if (typeof receiver == "number" && typeof a0 == "number")
        return receiver + a0;
      return J.getInterceptor$ansx(receiver).$add(receiver, a0);
    },
    $eq$: function(receiver, a0) {
      if (receiver == null)
        return a0 == null;
      if (typeof receiver != "object")
        return a0 != null && receiver === a0;
      return J.getInterceptor$(receiver).$eq(receiver, a0);
    },
    $index$asx: function(receiver, a0) {
      if (typeof a0 === "number")
        if (receiver.constructor == Array || typeof receiver == "string" || H.isJsIndexable(receiver, receiver[init.dispatchPropertyName]))
          if (a0 >>> 0 === a0 && a0 < receiver.length)
            return receiver[a0];
      return J.getInterceptor$asx(receiver).$index(receiver, a0);
    },
    $indexSet$ax: function(receiver, a0, a1) {
      if (typeof a0 === "number")
        if ((receiver.constructor == Array || H.isJsIndexable(receiver, receiver[init.dispatchPropertyName])) && !receiver.immutable$list && a0 >>> 0 === a0 && a0 < receiver.length)
          return receiver[a0] = a1;
      return J.getInterceptor$ax(receiver).$indexSet(receiver, a0, a1);
    },
    _codeUnitAt$1$s: function(receiver, a0) {
      return J.getInterceptor$s(receiver)._codeUnitAt$1(receiver, a0);
    },
    add$1$ax: function(receiver, a0) {
      return J.getInterceptor$ax(receiver).add$1(receiver, a0);
    },
    any$1$ax: function(receiver, a0) {
      return J.getInterceptor$ax(receiver).any$1(receiver, a0);
    },
    apply$2$x: function(receiver, a0, a1) {
      return J.getInterceptor$x(receiver).apply$2(receiver, a0, a1);
    },
    cast$1$0$ax: function(receiver, $T1) {
      return J.getInterceptor$ax(receiver).cast$1$0(receiver, $T1);
    },
    ceil$0$n: function(receiver) {
      return J.getInterceptor$n(receiver).ceil$0(receiver);
    },
    clamp$2$n: function(receiver, a0, a1) {
      return J.getInterceptor$n(receiver).clamp$2(receiver, a0, a1);
    },
    close$0$x: function(receiver) {
      return J.getInterceptor$x(receiver).close$0(receiver);
    },
    codeUnitAt$1$s: function(receiver, a0) {
      return J.getInterceptor$s(receiver).codeUnitAt$1(receiver, a0);
    },
    compareTo$1$ns: function(receiver, a0) {
      return J.getInterceptor$ns(receiver).compareTo$1(receiver, a0);
    },
    contains$1$asx: function(receiver, a0) {
      return J.getInterceptor$asx(receiver).contains$1(receiver, a0);
    },
    createInterface$1$x: function(receiver, a0) {
      return J.getInterceptor$x(receiver).createInterface$1(receiver, a0);
    },
    elementAt$1$ax: function(receiver, a0) {
      return J.getInterceptor$ax(receiver).elementAt$1(receiver, a0);
    },
    endsWith$1$s: function(receiver, a0) {
      return J.getInterceptor$s(receiver).endsWith$1(receiver, a0);
    },
    every$1$ax: function(receiver, a0) {
      return J.getInterceptor$ax(receiver).every$1(receiver, a0);
    },
    expand$1$1$ax: function(receiver, a0, $T1) {
      return J.getInterceptor$ax(receiver).expand$1$1(receiver, a0, $T1);
    },
    fillRange$3$ax: function(receiver, a0, a1, a2) {
      return J.getInterceptor$ax(receiver).fillRange$3(receiver, a0, a1, a2);
    },
    floor$0$n: function(receiver) {
      return J.getInterceptor$n(receiver).floor$0(receiver);
    },
    fold$2$ax: function(receiver, a0, a1) {
      return J.getInterceptor$ax(receiver).fold$2(receiver, a0, a1);
    },
    getTime$0$x: function(receiver) {
      return J.getInterceptor$x(receiver).getTime$0(receiver);
    },
    indexOf$1$asx: function(receiver, a0) {
      return J.getInterceptor$asx(receiver).indexOf$1(receiver, a0);
    },
    isDirectory$0$x: function(receiver) {
      return J.getInterceptor$x(receiver).isDirectory$0(receiver);
    },
    isFile$0$x: function(receiver) {
      return J.getInterceptor$x(receiver).isFile$0(receiver);
    },
    join$0$ax: function(receiver) {
      return J.getInterceptor$ax(receiver).join$0(receiver);
    },
    join$1$ax: function(receiver, a0) {
      return J.getInterceptor$ax(receiver).join$1(receiver, a0);
    },
    map$1$ax: function(receiver, a0) {
      return J.getInterceptor$ax(receiver).map$1(receiver, a0);
    },
    map$1$1$ax: function(receiver, a0, $T1) {
      return J.getInterceptor$ax(receiver).map$1$1(receiver, a0, $T1);
    },
    matchAsPrefix$2$s: function(receiver, a0, a1) {
      return J.getInterceptor$s(receiver).matchAsPrefix$2(receiver, a0, a1);
    },
    mkdirSync$1$x: function(receiver, a0) {
      return J.getInterceptor$x(receiver).mkdirSync$1(receiver, a0);
    },
    noSuchMethod$1$: function(receiver, a0) {
      return J.getInterceptor$(receiver).noSuchMethod$1(receiver, a0);
    },
    on$2$x: function(receiver, a0, a1) {
      return J.getInterceptor$x(receiver).on$2(receiver, a0, a1);
    },
    padRight$1$s: function(receiver, a0) {
      return J.getInterceptor$s(receiver).padRight$1(receiver, a0);
    },
    readFileSync$2$x: function(receiver, a0, a1) {
      return J.getInterceptor$x(receiver).readFileSync$2(receiver, a0, a1);
    },
    readdirSync$1$x: function(receiver, a0) {
      return J.getInterceptor$x(receiver).readdirSync$1(receiver, a0);
    },
    remove$1$ax: function(receiver, a0) {
      return J.getInterceptor$ax(receiver).remove$1(receiver, a0);
    },
    replaceRange$3$asx: function(receiver, a0, a1, a2) {
      return J.getInterceptor$asx(receiver).replaceRange$3(receiver, a0, a1, a2);
    },
    round$0$n: function(receiver) {
      return J.getInterceptor$n(receiver).round$0(receiver);
    },
    run$0$x: function(receiver) {
      return J.getInterceptor$x(receiver).run$0(receiver);
    },
    run$1$x: function(receiver, a0) {
      return J.getInterceptor$x(receiver).run$1(receiver, a0);
    },
    setPrompt$1$x: function(receiver, a0) {
      return J.getInterceptor$x(receiver).setPrompt$1(receiver, a0);
    },
    setRange$4$ax: function(receiver, a0, a1, a2, a3) {
      return J.getInterceptor$ax(receiver).setRange$4(receiver, a0, a1, a2, a3);
    },
    skip$1$ax: function(receiver, a0) {
      return J.getInterceptor$ax(receiver).skip$1(receiver, a0);
    },
    startsWith$1$s: function(receiver, a0) {
      return J.getInterceptor$s(receiver).startsWith$1(receiver, a0);
    },
    startsWith$2$s: function(receiver, a0, a1) {
      return J.getInterceptor$s(receiver).startsWith$2(receiver, a0, a1);
    },
    statSync$1$x: function(receiver, a0) {
      return J.getInterceptor$x(receiver).statSync$1(receiver, a0);
    },
    substring$1$s: function(receiver, a0) {
      return J.getInterceptor$s(receiver).substring$1(receiver, a0);
    },
    substring$2$s: function(receiver, a0, a1) {
      return J.getInterceptor$s(receiver).substring$2(receiver, a0, a1);
    },
    take$1$ax: function(receiver, a0) {
      return J.getInterceptor$ax(receiver).take$1(receiver, a0);
    },
    toList$0$ax: function(receiver) {
      return J.getInterceptor$ax(receiver).toList$0(receiver);
    },
    toRadixString$1$n: function(receiver, a0) {
      return J.getInterceptor$n(receiver).toRadixString$1(receiver, a0);
    },
    toSet$0$ax: function(receiver) {
      return J.getInterceptor$ax(receiver).toSet$0(receiver);
    },
    toString$0$: function(receiver) {
      return J.getInterceptor$(receiver).toString$0(receiver);
    },
    toString$1$color$: function(receiver, a0) {
      return J.getInterceptor$(receiver).toString$1$color(receiver, a0);
    },
    trim$0$s: function(receiver) {
      return J.getInterceptor$s(receiver).trim$0(receiver);
    },
    unlinkSync$1$x: function(receiver, a0) {
      return J.getInterceptor$x(receiver).unlinkSync$1(receiver, a0);
    },
    watch$2$x: function(receiver, a0, a1) {
      return J.getInterceptor$x(receiver).watch$2(receiver, a0, a1);
    },
    where$1$ax: function(receiver, a0) {
      return J.getInterceptor$ax(receiver).where$1(receiver, a0);
    },
    write$1$x: function(receiver, a0) {
      return J.getInterceptor$x(receiver).write$1(receiver, a0);
    },
    writeFileSync$2$x: function(receiver, a0, a1) {
      return J.getInterceptor$x(receiver).writeFileSync$2(receiver, a0, a1);
    },
    yield$0$x: function(receiver) {
      return J.getInterceptor$x(receiver).yield$0(receiver);
    },
    Interceptor: function Interceptor() {
    },
    JSBool: function JSBool() {
    },
    JSNull: function JSNull() {
    },
    JavaScriptObject: function JavaScriptObject() {
    },
    PlainJavaScriptObject: function PlainJavaScriptObject() {
    },
    UnknownJavaScriptObject: function UnknownJavaScriptObject() {
    },
    JavaScriptFunction: function JavaScriptFunction() {
    },
    JSArray: function JSArray(t0) {
      this.$ti = t0;
    },
    JSUnmodifiableArray: function JSUnmodifiableArray(t0) {
      this.$ti = t0;
    },
    ArrayIterator: function ArrayIterator(t0, t1) {
      var _ = this;
      _._iterable = t0;
      _._length = t1;
      _._index = 0;
      _._current = null;
    },
    JSNumber: function JSNumber() {
    },
    JSInt: function JSInt() {
    },
    JSDouble: function JSDouble() {
    },
    JSString: function JSString() {
    }
  },
  P = {
    _AsyncRun__initializeScheduleImmediate: function() {
      var div, span, t1 = {};
      if (self.scheduleImmediate != null)
        return P.async__AsyncRun__scheduleImmediateJsOverride$closure();
      if (self.MutationObserver != null && self.document != null) {
        div = self.document.createElement("div");
        span = self.document.createElement("span");
        t1.storedCallback = null;
        new self.MutationObserver(H.convertDartClosureToJS(new P._AsyncRun__initializeScheduleImmediate_internalCallback(t1), 1)).observe(div, {childList: true});
        return new P._AsyncRun__initializeScheduleImmediate_closure(t1, div, span);
      } else if (self.setImmediate != null)
        return P.async__AsyncRun__scheduleImmediateWithSetImmediate$closure();
      return P.async__AsyncRun__scheduleImmediateWithTimer$closure();
    },
    _AsyncRun__scheduleImmediateJsOverride: function(callback) {
      self.scheduleImmediate(H.convertDartClosureToJS(new P._AsyncRun__scheduleImmediateJsOverride_internalCallback(callback), 0));
    },
    _AsyncRun__scheduleImmediateWithSetImmediate: function(callback) {
      self.setImmediate(H.convertDartClosureToJS(new P._AsyncRun__scheduleImmediateWithSetImmediate_internalCallback(callback), 0));
    },
    _AsyncRun__scheduleImmediateWithTimer: function(callback) {
      P.Timer__createTimer(C.Duration_0, callback);
    },
    Timer__createTimer: function(duration, callback) {
      var milliseconds = C.JSInt_methods._tdivFast$1(duration._duration, 1000);
      return P._TimerImpl$(milliseconds < 0 ? 0 : milliseconds, callback);
    },
    _TimerImpl$: function(milliseconds, callback) {
      var t1 = new P._TimerImpl(true);
      t1._TimerImpl$2(milliseconds, callback);
      return t1;
    },
    _TimerImpl$periodic: function(milliseconds, callback) {
      var t1 = new P._TimerImpl(false);
      t1._TimerImpl$periodic$2(milliseconds, callback);
      return t1;
    },
    _makeAsyncAwaitCompleter: function($T) {
      return new P._AsyncAwaitCompleter(new P._SyncCompleter(new P._Future($.Zone__current, [$T]), [$T]), [$T]);
    },
    _asyncStartSync: function(bodyFunction, completer) {
      bodyFunction.call$2(0, null);
      completer.isSync = true;
      return completer._completer.future;
    },
    _asyncAwait: function(object, bodyFunction) {
      P._awaitOnObject(object, bodyFunction);
    },
    _asyncReturn: function(object, completer) {
      completer.complete$1(object);
    },
    _asyncRethrow: function(object, completer) {
      completer.completeError$2(H.unwrapException(object), H.getTraceFromException(object));
    },
    _awaitOnObject: function(object, bodyFunction) {
      var future, _null = null,
        thenCallback = new P._awaitOnObject_closure(bodyFunction),
        errorCallback = new P._awaitOnObject_closure0(bodyFunction),
        t1 = J.getInterceptor$(object);
      if (!!t1.$is_Future)
        object._thenNoZoneRegistration$1$2(thenCallback, errorCallback, _null);
      else if (!!t1.$isFuture)
        object.then$1$2$onError(thenCallback, errorCallback, _null);
      else {
        future = new P._Future($.Zone__current, [null]);
        future._async$_state = 4;
        future._resultOrListeners = object;
        future._thenNoZoneRegistration$1$2(thenCallback, _null, _null);
      }
    },
    _wrapJsFunctionForAsync: function($function) {
      var $protected = function(fn, ERROR) {
        return function(errorCode, result) {
          while (true)
            try {
              fn(errorCode, result);
              break;
            } catch (error) {
              result = error;
              errorCode = ERROR;
            }
        };
      }($function, 1);
      return $.Zone__current.registerBinaryCallback$1(new P._wrapJsFunctionForAsync_closure($protected));
    },
    _asyncStarHelper: function(object, bodyFunctionOrErrorCode, controller) {
      var t1, t2, stream;
      if (bodyFunctionOrErrorCode === 0) {
        t1 = controller.cancelationCompleter;
        if (t1 != null)
          t1.complete$0();
        else
          controller.controller.close$0(0);
        return;
      } else if (bodyFunctionOrErrorCode === 1) {
        t1 = controller.cancelationCompleter;
        if (t1 != null)
          t1.completeError$2(H.unwrapException(object), H.getTraceFromException(object));
        else {
          t1 = H.unwrapException(object);
          t2 = H.getTraceFromException(object);
          controller.controller.addError$2(t1, t2);
          controller.controller.close$0(0);
        }
        return;
      }
      if (object instanceof P._IterationMarker) {
        if (controller.cancelationCompleter != null) {
          bodyFunctionOrErrorCode.call$2(2, null);
          return;
        }
        t1 = object.state;
        if (t1 === 0) {
          t1 = object.value;
          controller.controller.add$1(0, t1);
          P.scheduleMicrotask(new P._asyncStarHelper_closure(controller, bodyFunctionOrErrorCode));
          return;
        } else if (t1 === 1) {
          stream = object.value;
          controller.controller.addStream$2$cancelOnError(stream, false).then$1(new P._asyncStarHelper_closure0(controller, bodyFunctionOrErrorCode));
          return;
        }
      }
      P._awaitOnObject(object, bodyFunctionOrErrorCode);
    },
    _streamOfController: function(controller) {
      var t1 = controller.controller;
      t1.toString;
      return new P._ControllerStream(t1, [H.getTypeArgumentByIndex(t1, 0)]);
    },
    _AsyncStarStreamController$: function(body, $T) {
      var t1 = new P._AsyncStarStreamController([$T]);
      t1._AsyncStarStreamController$1(body, $T);
      return t1;
    },
    _makeAsyncStarStreamController: function(body, $T) {
      return P._AsyncStarStreamController$(body, $T);
    },
    _IterationMarker_yieldStar: function(values) {
      return new P._IterationMarker(values, 1);
    },
    _IterationMarker_endOfIteration: function() {
      return C._IterationMarker_null_2;
    },
    _IterationMarker_yieldSingle: function(value) {
      return new P._IterationMarker(value, 0);
    },
    _IterationMarker_uncaughtError: function(error) {
      return new P._IterationMarker(error, 3);
    },
    _makeSyncStarIterable: function(body, $T) {
      return new P._SyncStarIterable(body, [$T]);
    },
    Future_Future$error: function(error, stackTrace, $T) {
      var t1, replacement;
      if (error == null)
        error = new P.NullThrownError();
      t1 = $.Zone__current;
      if (t1 !== C.C__RootZone) {
        replacement = t1.errorCallback$2(error, stackTrace);
        if (replacement != null) {
          error = replacement.error;
          if (error == null)
            error = new P.NullThrownError();
          stackTrace = replacement.stackTrace;
        }
      }
      t1 = new P._Future($.Zone__current, [$T]);
      t1._asyncCompleteError$2(error, stackTrace);
      return t1;
    },
    Future_wait: function(futures, $T) {
      var handleError, future, pos, e, st, t3, exception, _box_0 = {}, cleanUp = null,
        eagerError = false,
        t1 = [P.List, $T],
        t2 = [t1],
        result = new P._Future($.Zone__current, t2);
      _box_0.values = null;
      _box_0.remaining = 0;
      _box_0.stackTrace = _box_0.error = null;
      handleError = new P.Future_wait_handleError(_box_0, cleanUp, eagerError, result);
      try {
        for (t3 = J.get$iterator$ax(futures); t3.moveNext$0();) {
          future = t3.get$current(t3);
          pos = _box_0.remaining;
          future.then$1$2$onError(new P.Future_wait_closure(_box_0, pos, result, cleanUp, eagerError, $T), handleError, null);
          ++_box_0.remaining;
        }
        t3 = _box_0.remaining;
        if (t3 === 0) {
          t2 = new P._Future($.Zone__current, t2);
          t2._asyncComplete$1(C.List_empty14);
          return t2;
        }
        t2 = new Array(t3);
        t2.fixed$length = Array;
        _box_0.values = H.setRuntimeTypeInfo(t2, [$T]);
      } catch (exception) {
        e = H.unwrapException(exception);
        st = H.getTraceFromException(exception);
        if (_box_0.remaining === 0 || eagerError)
          return P.Future_Future$error(e, st, t1);
        else {
          _box_0.error = e;
          _box_0.stackTrace = st;
        }
      }
      return result;
    },
    _Future$zoneValue: function(value, _zone, $T) {
      var t1 = new P._Future(_zone, [$T]);
      t1._async$_state = 4;
      t1._resultOrListeners = value;
      return t1;
    },
    _Future__chainForeignFuture: function(source, target) {
      var e, s, exception;
      target._async$_state = 1;
      try {
        source.then$1$2$onError(new P._Future__chainForeignFuture_closure(target), new P._Future__chainForeignFuture_closure0(target), null);
      } catch (exception) {
        e = H.unwrapException(exception);
        s = H.getTraceFromException(exception);
        P.scheduleMicrotask(new P._Future__chainForeignFuture_closure1(target, e, s));
      }
    },
    _Future__chainCoreFuture: function(source, target) {
      var t1, listeners;
      for (; t1 = source._async$_state, t1 === 2;)
        source = source._resultOrListeners;
      if (t1 >= 4) {
        listeners = target._removeListeners$0();
        target._async$_state = source._async$_state;
        target._resultOrListeners = source._resultOrListeners;
        P._Future__propagateToListeners(target, listeners);
      } else {
        listeners = target._resultOrListeners;
        target._async$_state = 2;
        target._resultOrListeners = source;
        source._prependListeners$1(listeners);
      }
    },
    _Future__propagateToListeners: function(source, listeners) {
      var _box_0, hasError, t2, listeners0, sourceResult, t3, zone, oldZone, current, result, _box_1 = {},
        t1 = _box_1.source = source;
      for (; true;) {
        _box_0 = {};
        hasError = t1._async$_state === 8;
        if (listeners == null) {
          if (hasError) {
            t2 = t1._resultOrListeners;
            t1._zone.handleUncaughtError$2(t2.error, t2.stackTrace);
          }
          return;
        }
        for (; listeners0 = listeners._nextListener, listeners0 != null; listeners = listeners0) {
          listeners._nextListener = null;
          P._Future__propagateToListeners(_box_1.source, listeners);
        }
        t1 = _box_1.source;
        sourceResult = t1._resultOrListeners;
        _box_0.listenerHasError = hasError;
        _box_0.listenerValueOrError = sourceResult;
        t2 = !hasError;
        if (t2) {
          t3 = listeners.state;
          t3 = (t3 & 1) !== 0 || t3 === 8;
        } else
          t3 = true;
        if (t3) {
          t3 = listeners.result;
          zone = t3._zone;
          if (hasError) {
            t1 = t1._zone;
            t1.toString;
            t1 = !(t1 == zone || t1.get$errorZone() === zone.get$errorZone());
          } else
            t1 = false;
          if (t1) {
            t1 = _box_1.source;
            t2 = t1._resultOrListeners;
            t1._zone.handleUncaughtError$2(t2.error, t2.stackTrace);
            return;
          }
          oldZone = $.Zone__current;
          if (oldZone != zone)
            $.Zone__current = zone;
          else
            oldZone = null;
          t1 = listeners.state;
          if (t1 === 8)
            new P._Future__propagateToListeners_handleWhenCompleteCallback(_box_1, _box_0, listeners, hasError).call$0();
          else if (t2) {
            if ((t1 & 1) !== 0)
              new P._Future__propagateToListeners_handleValueCallback(_box_0, listeners, sourceResult).call$0();
          } else if ((t1 & 2) !== 0)
            new P._Future__propagateToListeners_handleError(_box_1, _box_0, listeners).call$0();
          if (oldZone != null)
            $.Zone__current = oldZone;
          t1 = _box_0.listenerValueOrError;
          if (!!J.getInterceptor$(t1).$isFuture) {
            if (t1._async$_state >= 4) {
              current = t3._resultOrListeners;
              t3._resultOrListeners = null;
              listeners = t3._reverseListeners$1(current);
              t3._async$_state = t1._async$_state;
              t3._resultOrListeners = t1._resultOrListeners;
              _box_1.source = t1;
              continue;
            } else
              P._Future__chainCoreFuture(t1, t3);
            return;
          }
        }
        result = listeners.result;
        current = result._resultOrListeners;
        result._resultOrListeners = null;
        listeners = result._reverseListeners$1(current);
        t1 = _box_0.listenerHasError;
        t2 = _box_0.listenerValueOrError;
        if (!t1) {
          result._async$_state = 4;
          result._resultOrListeners = t2;
        } else {
          result._async$_state = 8;
          result._resultOrListeners = t2;
        }
        _box_1.source = result;
        t1 = result;
      }
    },
    _registerErrorHandler: function(errorHandler, zone) {
      if (H.functionTypeTest(errorHandler, {func: 1, args: [P.Object, P.StackTrace]}))
        return zone.registerBinaryCallback$1(errorHandler);
      if (H.functionTypeTest(errorHandler, {func: 1, args: [P.Object]}))
        return zone.registerUnaryCallback$1(errorHandler);
      throw H.wrapException(P.ArgumentError$value(errorHandler, "onError", "Error handler must accept one Object or one Object and a StackTrace as arguments, and return a a valid result"));
    },
    _microtaskLoop: function() {
      var t1, t2;
      for (; t1 = $._nextCallback, t1 != null;) {
        $._lastPriorityCallback = null;
        t2 = t1.next;
        $._nextCallback = t2;
        if (t2 == null)
          $._lastCallback = null;
        t1.callback.call$0();
      }
    },
    _startMicrotaskLoop: function() {
      $._isInCallbackLoop = true;
      try {
        P._microtaskLoop();
      } finally {
        $._lastPriorityCallback = null;
        $._isInCallbackLoop = false;
        if ($._nextCallback != null)
          $.$get$_AsyncRun__scheduleImmediateClosure().call$1(P.async___startMicrotaskLoop$closure());
      }
    },
    _scheduleAsyncCallback: function(callback) {
      var newEntry = new P._AsyncCallbackEntry(callback);
      if ($._nextCallback == null) {
        $._nextCallback = $._lastCallback = newEntry;
        if (!$._isInCallbackLoop)
          $.$get$_AsyncRun__scheduleImmediateClosure().call$1(P.async___startMicrotaskLoop$closure());
      } else
        $._lastCallback = $._lastCallback.next = newEntry;
    },
    _schedulePriorityAsyncCallback: function(callback) {
      var entry, t2,
        t1 = $._nextCallback;
      if (t1 == null) {
        P._scheduleAsyncCallback(callback);
        $._lastPriorityCallback = $._lastCallback;
        return;
      }
      entry = new P._AsyncCallbackEntry(callback);
      t2 = $._lastPriorityCallback;
      if (t2 == null) {
        entry.next = t1;
        $._nextCallback = $._lastPriorityCallback = entry;
      } else {
        entry.next = t2.next;
        $._lastPriorityCallback = t2.next = entry;
        if (entry.next == null)
          $._lastCallback = entry;
      }
    },
    scheduleMicrotask: function(callback) {
      var t1, _null = null,
        currentZone = $.Zone__current;
      if (C.C__RootZone === currentZone) {
        P._rootScheduleMicrotask(_null, _null, C.C__RootZone, callback);
        return;
      }
      if (C.C__RootZone === currentZone.get$_scheduleMicrotask().zone)
        t1 = C.C__RootZone.get$errorZone() === currentZone.get$errorZone();
      else
        t1 = false;
      if (t1) {
        P._rootScheduleMicrotask(_null, _null, currentZone, currentZone.registerCallback$1(callback));
        return;
      }
      t1 = $.Zone__current;
      t1.scheduleMicrotask$1(t1.bindCallbackGuarded$1(callback));
    },
    Stream_Stream$fromFuture: function(future, $T) {
      var _null = null,
        controller = P.StreamController_StreamController(_null, _null, _null, _null, true, $T);
      future.then$1$2$onError(new P.Stream_Stream$fromFuture_closure(controller, $T), new P.Stream_Stream$fromFuture_closure0(controller), _null);
      return new P._ControllerStream(controller, [H.getTypeArgumentByIndex(controller, 0)]);
    },
    StreamIterator_StreamIterator: function(stream) {
      return new P._StreamIterator(stream == null ? H.throwExpression(P.ArgumentError$notNull("stream")) : stream);
    },
    StreamController_StreamController: function(onCancel, onListen, onPause, onResume, sync, $T) {
      return sync ? new P._SyncStreamController(onListen, onPause, onResume, onCancel, [$T]) : new P._AsyncStreamController(onListen, onPause, onResume, onCancel, [$T]);
    },
    _runGuarded: function(notificationHandler) {
      var e, s, exception;
      if (notificationHandler == null)
        return;
      try {
        notificationHandler.call$0();
      } catch (exception) {
        e = H.unwrapException(exception);
        s = H.getTraceFromException(exception);
        $.Zone__current.handleUncaughtError$2(e, s);
      }
    },
    _nullDataHandler: function(value) {
    },
    _nullErrorHandler: function(error, stackTrace) {
      $.Zone__current.handleUncaughtError$2(error, stackTrace);
    },
    _nullDoneHandler: function() {
    },
    _StreamIterator$: function(stream) {
      return new P._StreamIterator(stream == null ? H.throwExpression(P.ArgumentError$notNull("stream")) : stream);
    },
    _addErrorWithReplacement: function(sink, error, stackTrace) {
      var replacement = $.Zone__current.errorCallback$2(error, stackTrace);
      if (replacement != null) {
        error = replacement.error;
        if (error == null)
          error = new P.NullThrownError();
        stackTrace = replacement.stackTrace;
      }
      sink._addError$2(error, stackTrace);
    },
    Timer_Timer: function(duration, callback) {
      var t1 = $.Zone__current;
      if (t1 === C.C__RootZone)
        return t1.createTimer$2(duration, callback);
      return t1.createTimer$2(duration, t1.bindCallbackGuarded$1(callback));
    },
    _parentDelegate: function(zone) {
      if (zone.get$parent() == null)
        return;
      return zone.get$parent().get$_delegate();
    },
    _rootHandleUncaughtError: function($self, $parent, zone, error, stackTrace) {
      var t1 = {};
      t1.error = error;
      P._schedulePriorityAsyncCallback(new P._rootHandleUncaughtError_closure(t1, stackTrace));
    },
    _rootRun: function($self, $parent, zone, f) {
      var old,
        t1 = $.Zone__current;
      if (t1 == zone)
        return f.call$0();
      $.Zone__current = zone;
      old = t1;
      try {
        t1 = f.call$0();
        return t1;
      } finally {
        $.Zone__current = old;
      }
    },
    _rootRunUnary: function($self, $parent, zone, f, arg) {
      var old,
        t1 = $.Zone__current;
      if (t1 == zone)
        return f.call$1(arg);
      $.Zone__current = zone;
      old = t1;
      try {
        t1 = f.call$1(arg);
        return t1;
      } finally {
        $.Zone__current = old;
      }
    },
    _rootRunBinary: function($self, $parent, zone, f, arg1, arg2) {
      var old,
        t1 = $.Zone__current;
      if (t1 == zone)
        return f.call$2(arg1, arg2);
      $.Zone__current = zone;
      old = t1;
      try {
        t1 = f.call$2(arg1, arg2);
        return t1;
      } finally {
        $.Zone__current = old;
      }
    },
    _rootRegisterCallback: function($self, $parent, zone, f) {
      return f;
    },
    _rootRegisterUnaryCallback: function($self, $parent, zone, f) {
      return f;
    },
    _rootRegisterBinaryCallback: function($self, $parent, zone, f) {
      return f;
    },
    _rootErrorCallback: function($self, $parent, zone, error, stackTrace) {
      return;
    },
    _rootScheduleMicrotask: function($self, $parent, zone, f) {
      var t1 = C.C__RootZone !== zone;
      if (t1)
        f = !(!t1 || C.C__RootZone.get$errorZone() === zone.get$errorZone()) ? zone.bindCallbackGuarded$1(f) : zone.bindCallback$1(f);
      P._scheduleAsyncCallback(f);
    },
    _rootCreateTimer: function($self, $parent, zone, duration, callback) {
      callback = zone.bindCallback$1(callback);
      return P.Timer__createTimer(duration, callback);
    },
    _rootCreatePeriodicTimer: function($self, $parent, zone, duration, callback) {
      var milliseconds;
      callback = zone.bindUnaryCallback$2$1(callback, null, P.Timer);
      milliseconds = C.JSInt_methods._tdivFast$1(duration._duration, 1000);
      return P._TimerImpl$periodic(milliseconds < 0 ? 0 : milliseconds, callback);
    },
    _rootPrint: function($self, $parent, zone, line) {
      H.printString(line);
    },
    _printToZone: function(line) {
      $.Zone__current.print$1(line);
    },
    _rootFork: function($self, $parent, zone, specification, zoneValues) {
      var valueMap, t1, t2;
      $.printToZone = P.async___printToZone$closure();
      if (specification == null)
        specification = C._ZoneSpecification_ALf;
      if (zoneValues == null)
        valueMap = zone.get$_async$_map();
      else
        valueMap = P.HashMap_HashMap$from(zoneValues, null, null);
      t1 = new P._CustomZone(zone, valueMap);
      t2 = zone.get$_run();
      t1._run = t2;
      t2 = zone.get$_runUnary();
      t1._runUnary = t2;
      t2 = zone.get$_runBinary();
      t1._runBinary = t2;
      t2 = zone.get$_registerCallback();
      t1._registerCallback = t2;
      t2 = zone.get$_registerUnaryCallback();
      t1._registerUnaryCallback = t2;
      t2 = zone.get$_registerBinaryCallback();
      t1._registerBinaryCallback = t2;
      t2 = zone.get$_errorCallback();
      t1._errorCallback = t2;
      t2 = zone.get$_scheduleMicrotask();
      t1._scheduleMicrotask = t2;
      t2 = zone.get$_createTimer();
      t1._createTimer = t2;
      t2 = zone.get$_createPeriodicTimer();
      t1._createPeriodicTimer = t2;
      t2 = zone.get$_print();
      t1._print = t2;
      t2 = zone.get$_fork();
      t1._fork = t2;
      t2 = specification.handleUncaughtError;
      t1._handleUncaughtError = t2 != null ? new P._ZoneFunction(t1, t2) : zone.get$_handleUncaughtError();
      return t1;
    },
    runZoned: function(body, zoneValues) {
      var zoneSpecification = null,
        t1 = P._runZoned(body, zoneValues, zoneSpecification);
      return t1;
    },
    _runZoned: function(body, zoneValues, specification) {
      return $.Zone__current.fork$2$specification$zoneValues(specification, zoneValues).run$1(0, body);
    },
    _AsyncRun__initializeScheduleImmediate_internalCallback: function _AsyncRun__initializeScheduleImmediate_internalCallback(t0) {
      this._box_0 = t0;
    },
    _AsyncRun__initializeScheduleImmediate_closure: function _AsyncRun__initializeScheduleImmediate_closure(t0, t1, t2) {
      this._box_0 = t0;
      this.div = t1;
      this.span = t2;
    },
    _AsyncRun__scheduleImmediateJsOverride_internalCallback: function _AsyncRun__scheduleImmediateJsOverride_internalCallback(t0) {
      this.callback = t0;
    },
    _AsyncRun__scheduleImmediateWithSetImmediate_internalCallback: function _AsyncRun__scheduleImmediateWithSetImmediate_internalCallback(t0) {
      this.callback = t0;
    },
    _TimerImpl: function _TimerImpl(t0) {
      this._once = t0;
      this._handle = null;
      this._tick = 0;
    },
    _TimerImpl_internalCallback: function _TimerImpl_internalCallback(t0, t1) {
      this.$this = t0;
      this.callback = t1;
    },
    _TimerImpl$periodic_closure: function _TimerImpl$periodic_closure(t0, t1, t2, t3) {
      var _ = this;
      _.$this = t0;
      _.milliseconds = t1;
      _.start = t2;
      _.callback = t3;
    },
    _AsyncAwaitCompleter: function _AsyncAwaitCompleter(t0, t1) {
      this._completer = t0;
      this.isSync = false;
      this.$ti = t1;
    },
    _AsyncAwaitCompleter_complete_closure: function _AsyncAwaitCompleter_complete_closure(t0, t1) {
      this.$this = t0;
      this.value = t1;
    },
    _AsyncAwaitCompleter_completeError_closure: function _AsyncAwaitCompleter_completeError_closure(t0, t1, t2) {
      this.$this = t0;
      this.e = t1;
      this.st = t2;
    },
    _awaitOnObject_closure: function _awaitOnObject_closure(t0) {
      this.bodyFunction = t0;
    },
    _awaitOnObject_closure0: function _awaitOnObject_closure0(t0) {
      this.bodyFunction = t0;
    },
    _wrapJsFunctionForAsync_closure: function _wrapJsFunctionForAsync_closure(t0) {
      this.$protected = t0;
    },
    _asyncStarHelper_closure: function _asyncStarHelper_closure(t0, t1) {
      this.controller = t0;
      this.bodyFunctionOrErrorCode = t1;
    },
    _asyncStarHelper_closure0: function _asyncStarHelper_closure0(t0, t1) {
      this.controller = t0;
      this.bodyFunctionOrErrorCode = t1;
    },
    _AsyncStarStreamController: function _AsyncStarStreamController(t0) {
      var _ = this;
      _.controller = null;
      _.isSuspended = false;
      _.cancelationCompleter = null;
      _.$ti = t0;
    },
    _AsyncStarStreamController__resumeBody: function _AsyncStarStreamController__resumeBody(t0) {
      this.body = t0;
    },
    _AsyncStarStreamController__resumeBody_closure: function _AsyncStarStreamController__resumeBody_closure(t0) {
      this.body = t0;
    },
    _AsyncStarStreamController_closure0: function _AsyncStarStreamController_closure0(t0) {
      this._resumeBody = t0;
    },
    _AsyncStarStreamController_closure1: function _AsyncStarStreamController_closure1(t0, t1) {
      this.$this = t0;
      this._resumeBody = t1;
    },
    _AsyncStarStreamController_closure: function _AsyncStarStreamController_closure(t0, t1) {
      this.$this = t0;
      this.body = t1;
    },
    _AsyncStarStreamController__closure: function _AsyncStarStreamController__closure(t0) {
      this.body = t0;
    },
    _IterationMarker: function _IterationMarker(t0, t1) {
      this.value = t0;
      this.state = t1;
    },
    _SyncStarIterator: function _SyncStarIterator(t0) {
      var _ = this;
      _._body = t0;
      _._suspendedBodies = _._nestedIterator = _._async$_current = null;
    },
    _SyncStarIterable: function _SyncStarIterable(t0, t1) {
      this._outerHelper = t0;
      this.$ti = t1;
    },
    _BroadcastStream: function _BroadcastStream(t0, t1) {
      this._async$_controller = t0;
      this.$ti = t1;
    },
    _BroadcastSubscription: function _BroadcastSubscription(t0, t1, t2, t3) {
      var _ = this;
      _._eventState = 0;
      _._async$_previous = _._async$_next = null;
      _._async$_controller = t0;
      _._onDone = _._onError = _._onData = null;
      _._zone = t1;
      _._async$_state = t2;
      _._pending = _._cancelFuture = null;
      _.$ti = t3;
    },
    _BroadcastStreamController: function _BroadcastStreamController() {
    },
    _SyncBroadcastStreamController: function _SyncBroadcastStreamController(t0, t1, t2) {
      var _ = this;
      _.onListen = t0;
      _.onCancel = t1;
      _._async$_state = 0;
      _._doneFuture = _._addStreamState = _._lastSubscription = _._firstSubscription = null;
      _.$ti = t2;
    },
    _SyncBroadcastStreamController__sendData_closure: function _SyncBroadcastStreamController__sendData_closure(t0) {
      this.data = t0;
    },
    _SyncBroadcastStreamController__sendError_closure: function _SyncBroadcastStreamController__sendError_closure(t0, t1) {
      this.error = t0;
      this.stackTrace = t1;
    },
    _SyncBroadcastStreamController__sendDone_closure: function _SyncBroadcastStreamController__sendDone_closure() {
    },
    Future: function Future() {
    },
    Future_wait_handleError: function Future_wait_handleError(t0, t1, t2, t3) {
      var _ = this;
      _._box_0 = t0;
      _.cleanUp = t1;
      _.eagerError = t2;
      _.result = t3;
    },
    Future_wait_closure: function Future_wait_closure(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _._box_0 = t0;
      _.pos = t1;
      _.result = t2;
      _.cleanUp = t3;
      _.eagerError = t4;
      _.T = t5;
    },
    _Completer: function _Completer() {
    },
    _AsyncCompleter: function _AsyncCompleter(t0, t1) {
      this.future = t0;
      this.$ti = t1;
    },
    _SyncCompleter: function _SyncCompleter(t0, t1) {
      this.future = t0;
      this.$ti = t1;
    },
    _FutureListener: function _FutureListener(t0, t1, t2, t3) {
      var _ = this;
      _._nextListener = null;
      _.result = t0;
      _.state = t1;
      _.callback = t2;
      _.errorCallback = t3;
    },
    _Future: function _Future(t0, t1) {
      var _ = this;
      _._async$_state = 0;
      _._zone = t0;
      _._resultOrListeners = null;
      _.$ti = t1;
    },
    _Future__addListener_closure: function _Future__addListener_closure(t0, t1) {
      this.$this = t0;
      this.listener = t1;
    },
    _Future__prependListeners_closure: function _Future__prependListeners_closure(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    _Future__chainForeignFuture_closure: function _Future__chainForeignFuture_closure(t0) {
      this.target = t0;
    },
    _Future__chainForeignFuture_closure0: function _Future__chainForeignFuture_closure0(t0) {
      this.target = t0;
    },
    _Future__chainForeignFuture_closure1: function _Future__chainForeignFuture_closure1(t0, t1, t2) {
      this.target = t0;
      this.e = t1;
      this.s = t2;
    },
    _Future__asyncComplete_closure: function _Future__asyncComplete_closure(t0, t1) {
      this.$this = t0;
      this.value = t1;
    },
    _Future__chainFuture_closure: function _Future__chainFuture_closure(t0, t1) {
      this.$this = t0;
      this.value = t1;
    },
    _Future__asyncCompleteError_closure: function _Future__asyncCompleteError_closure(t0, t1, t2) {
      this.$this = t0;
      this.error = t1;
      this.stackTrace = t2;
    },
    _Future__propagateToListeners_handleWhenCompleteCallback: function _Future__propagateToListeners_handleWhenCompleteCallback(t0, t1, t2, t3) {
      var _ = this;
      _._box_1 = t0;
      _._box_0 = t1;
      _.listener = t2;
      _.hasError = t3;
    },
    _Future__propagateToListeners_handleWhenCompleteCallback_closure: function _Future__propagateToListeners_handleWhenCompleteCallback_closure(t0) {
      this.originalSource = t0;
    },
    _Future__propagateToListeners_handleValueCallback: function _Future__propagateToListeners_handleValueCallback(t0, t1, t2) {
      this._box_0 = t0;
      this.listener = t1;
      this.sourceResult = t2;
    },
    _Future__propagateToListeners_handleError: function _Future__propagateToListeners_handleError(t0, t1, t2) {
      this._box_1 = t0;
      this._box_0 = t1;
      this.listener = t2;
    },
    _AsyncCallbackEntry: function _AsyncCallbackEntry(t0) {
      this.callback = t0;
      this.next = null;
    },
    Stream: function Stream() {
    },
    Stream_Stream$fromFuture_closure: function Stream_Stream$fromFuture_closure(t0, t1) {
      this.controller = t0;
      this.T = t1;
    },
    Stream_Stream$fromFuture_closure0: function Stream_Stream$fromFuture_closure0(t0) {
      this.controller = t0;
    },
    Stream_length_closure: function Stream_length_closure(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    Stream_length_closure0: function Stream_length_closure0(t0, t1) {
      this._box_0 = t0;
      this.future = t1;
    },
    StreamSubscription: function StreamSubscription() {
    },
    EventSink: function EventSink() {
    },
    StreamTransformerBase: function StreamTransformerBase() {
    },
    _StreamController: function _StreamController() {
    },
    _StreamController__subscribe_closure: function _StreamController__subscribe_closure(t0) {
      this.$this = t0;
    },
    _StreamController__recordCancel_complete: function _StreamController__recordCancel_complete(t0) {
      this.$this = t0;
    },
    _SyncStreamControllerDispatch: function _SyncStreamControllerDispatch() {
    },
    _AsyncStreamControllerDispatch: function _AsyncStreamControllerDispatch() {
    },
    _AsyncStreamController: function _AsyncStreamController(t0, t1, t2, t3, t4) {
      var _ = this;
      _._varData = null;
      _._async$_state = 0;
      _._doneFuture = null;
      _.onListen = t0;
      _.onPause = t1;
      _.onResume = t2;
      _.onCancel = t3;
      _.$ti = t4;
    },
    _SyncStreamController: function _SyncStreamController(t0, t1, t2, t3, t4) {
      var _ = this;
      _._varData = null;
      _._async$_state = 0;
      _._doneFuture = null;
      _.onListen = t0;
      _.onPause = t1;
      _.onResume = t2;
      _.onCancel = t3;
      _.$ti = t4;
    },
    _ControllerStream: function _ControllerStream(t0, t1) {
      this._async$_controller = t0;
      this.$ti = t1;
    },
    _ControllerSubscription: function _ControllerSubscription(t0, t1, t2, t3) {
      var _ = this;
      _._async$_controller = t0;
      _._onDone = _._onError = _._onData = null;
      _._zone = t1;
      _._async$_state = t2;
      _._pending = _._cancelFuture = null;
      _.$ti = t3;
    },
    _AddStreamState: function _AddStreamState() {
    },
    _AddStreamState_cancel_closure: function _AddStreamState_cancel_closure(t0) {
      this.$this = t0;
    },
    _StreamControllerAddStreamState: function _StreamControllerAddStreamState(t0, t1, t2) {
      this.varData = t0;
      this.addStreamFuture = t1;
      this.addSubscription = t2;
    },
    _BufferingStreamSubscription: function _BufferingStreamSubscription() {
    },
    _BufferingStreamSubscription__sendError_sendError: function _BufferingStreamSubscription__sendError_sendError(t0, t1, t2) {
      this.$this = t0;
      this.error = t1;
      this.stackTrace = t2;
    },
    _BufferingStreamSubscription__sendDone_sendDone: function _BufferingStreamSubscription__sendDone_sendDone(t0) {
      this.$this = t0;
    },
    _StreamImpl: function _StreamImpl() {
    },
    _DelayedEvent: function _DelayedEvent() {
    },
    _DelayedData: function _DelayedData(t0) {
      this.value = t0;
      this.next = null;
    },
    _DelayedError: function _DelayedError(t0, t1) {
      this.error = t0;
      this.stackTrace = t1;
      this.next = null;
    },
    _DelayedDone: function _DelayedDone() {
    },
    _PendingEvents: function _PendingEvents() {
    },
    _PendingEvents_schedule_closure: function _PendingEvents_schedule_closure(t0, t1) {
      this.$this = t0;
      this.dispatch = t1;
    },
    _StreamImplEvents: function _StreamImplEvents() {
      this.lastPendingEvent = this.firstPendingEvent = null;
      this._async$_state = 0;
    },
    _DoneStreamSubscription: function _DoneStreamSubscription(t0, t1, t2) {
      var _ = this;
      _._zone = t0;
      _._async$_state = 0;
      _._onDone = t1;
      _.$ti = t2;
    },
    _StreamIterator: function _StreamIterator(t0) {
      this._subscription = null;
      this._stateData = t0;
      this._isPaused = false;
    },
    _ForwardingStream: function _ForwardingStream() {
    },
    _ForwardingStreamSubscription: function _ForwardingStreamSubscription(t0, t1, t2, t3) {
      var _ = this;
      _._stream = t0;
      _._onDone = _._onError = _._onData = _._subscription = null;
      _._zone = t1;
      _._async$_state = t2;
      _._pending = _._cancelFuture = null;
      _.$ti = t3;
    },
    _ExpandStream: function _ExpandStream(t0, t1, t2) {
      this._expand = t0;
      this._async$_source = t1;
      this.$ti = t2;
    },
    Timer: function Timer() {
    },
    AsyncError: function AsyncError(t0, t1) {
      this.error = t0;
      this.stackTrace = t1;
    },
    _ZoneFunction: function _ZoneFunction(t0, t1) {
      this.zone = t0;
      this.$function = t1;
    },
    ZoneSpecification: function ZoneSpecification() {
    },
    _ZoneSpecification: function _ZoneSpecification(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12) {
      var _ = this;
      _.handleUncaughtError = t0;
      _.run = t1;
      _.runUnary = t2;
      _.runBinary = t3;
      _.registerCallback = t4;
      _.registerUnaryCallback = t5;
      _.registerBinaryCallback = t6;
      _.errorCallback = t7;
      _.scheduleMicrotask = t8;
      _.createTimer = t9;
      _.createPeriodicTimer = t10;
      _.print = t11;
      _.fork = t12;
    },
    ZoneDelegate: function ZoneDelegate() {
    },
    Zone: function Zone() {
    },
    _ZoneDelegate: function _ZoneDelegate(t0) {
      this._delegationTarget = t0;
    },
    _Zone: function _Zone() {
    },
    _CustomZone: function _CustomZone(t0, t1) {
      var _ = this;
      _._delegateCache = _._handleUncaughtError = _._fork = _._print = _._createPeriodicTimer = _._createTimer = _._scheduleMicrotask = _._errorCallback = _._registerBinaryCallback = _._registerUnaryCallback = _._registerCallback = _._runBinary = _._runUnary = _._run = null;
      _.parent = t0;
      _._async$_map = t1;
    },
    _CustomZone_bindCallback_closure: function _CustomZone_bindCallback_closure(t0, t1) {
      this.$this = t0;
      this.registered = t1;
    },
    _CustomZone_bindUnaryCallback_closure: function _CustomZone_bindUnaryCallback_closure(t0, t1, t2, t3) {
      var _ = this;
      _.$this = t0;
      _.registered = t1;
      _.T = t2;
      _.R = t3;
    },
    _CustomZone_bindCallbackGuarded_closure: function _CustomZone_bindCallbackGuarded_closure(t0, t1) {
      this.$this = t0;
      this.registered = t1;
    },
    _rootHandleUncaughtError_closure: function _rootHandleUncaughtError_closure(t0, t1) {
      this._box_0 = t0;
      this.stackTrace = t1;
    },
    _RootZone: function _RootZone() {
    },
    _RootZone_bindCallback_closure: function _RootZone_bindCallback_closure(t0, t1) {
      this.$this = t0;
      this.f = t1;
    },
    _RootZone_bindCallbackGuarded_closure: function _RootZone_bindCallbackGuarded_closure(t0, t1) {
      this.$this = t0;
      this.f = t1;
    },
    HashMap_HashMap: function($K, $V) {
      return new P._HashMap([$K, $V]);
    },
    _HashMap__getTableEntry: function(table, key) {
      var entry = table[key];
      return entry === table ? null : entry;
    },
    _HashMap__setTableEntry: function(table, key, value) {
      if (value == null)
        table[key] = table;
      else
        table[key] = value;
    },
    _HashMap__newHashTable: function() {
      var table = Object.create(null);
      P._HashMap__setTableEntry(table, "<non-identifier-key>", table);
      delete table["<non-identifier-key>"];
      return table;
    },
    LinkedHashMap_LinkedHashMap: function(equals, hashCode, isValidKey, $K, $V) {
      if (isValidKey == null)
        if (hashCode == null) {
          if (equals == null)
            return new H.JsLinkedHashMap([$K, $V]);
          hashCode = P.collection___defaultHashCode$closure();
        } else {
          if (P.core__identityHashCode$closure() === hashCode && P.core__identical$closure() === equals)
            return P._LinkedIdentityHashMap__LinkedIdentityHashMap$es6($K, $V);
          if (equals == null)
            equals = P.collection___defaultEquals$closure();
        }
      else {
        if (hashCode == null)
          hashCode = P.collection___defaultHashCode$closure();
        if (equals == null)
          equals = P.collection___defaultEquals$closure();
      }
      return P._LinkedCustomHashMap$(equals, hashCode, isValidKey, $K, $V);
    },
    LinkedHashMap_LinkedHashMap$_literal: function(keyValuePairs, $K, $V) {
      return H.fillLiteralMap(keyValuePairs, new H.JsLinkedHashMap([$K, $V]));
    },
    LinkedHashMap_LinkedHashMap$_empty: function($K, $V) {
      return new H.JsLinkedHashMap([$K, $V]);
    },
    LinkedHashMap__makeLiteral: function(keyValuePairs) {
      return H.fillLiteralMap(keyValuePairs, new H.JsLinkedHashMap([null, null]));
    },
    _LinkedIdentityHashMap__LinkedIdentityHashMap$es6: function($K, $V) {
      return new P._LinkedIdentityHashMap([$K, $V]);
    },
    _LinkedCustomHashMap$: function(_equals, _hashCode, validKey, $K, $V) {
      var t1 = validKey != null ? validKey : new P._LinkedCustomHashMap_closure($K);
      return new P._LinkedCustomHashMap(_equals, _hashCode, t1, [$K, $V]);
    },
    LinkedHashSet_LinkedHashSet: function($E) {
      return new P._LinkedHashSet([$E]);
    },
    LinkedHashSet_LinkedHashSet$_empty: function($E) {
      return new P._LinkedHashSet([$E]);
    },
    LinkedHashSet_LinkedHashSet$_literal: function(values, $E) {
      return H.fillLiteralSet(values, new P._LinkedHashSet([$E]));
    },
    _LinkedHashSet__newHashTable: function() {
      var table = Object.create(null);
      table["<non-identifier-key>"] = table;
      delete table["<non-identifier-key>"];
      return table;
    },
    _LinkedHashSetIterator$: function(_set, _modifications) {
      var t1 = new P._LinkedHashSetIterator(_set, _modifications);
      t1._collection$_cell = _set._collection$_first;
      return t1;
    },
    UnmodifiableListView$: function(source, $E) {
      return new P.UnmodifiableListView(source, [$E]);
    },
    _defaultEquals: function(a, b) {
      return J.$eq$(a, b);
    },
    _defaultHashCode: function(a) {
      return J.get$hashCode$(a);
    },
    HashMap_HashMap$from: function(other, $K, $V) {
      var result = P.HashMap_HashMap($K, $V);
      other.forEach$1(0, new P.HashMap_HashMap$from_closure(result));
      return result;
    },
    IterableBase_iterableToShortString: function(iterable, leftDelimiter, rightDelimiter) {
      var parts, t1;
      if (P._isToStringVisiting(iterable)) {
        if (leftDelimiter === "(" && rightDelimiter === ")")
          return "(...)";
        return leftDelimiter + "..." + rightDelimiter;
      }
      parts = H.setRuntimeTypeInfo([], [P.String]);
      $._toStringVisiting.push(iterable);
      try {
        P._iterablePartsToStrings(iterable, parts);
      } finally {
        $._toStringVisiting.pop();
      }
      t1 = P.StringBuffer__writeAll(leftDelimiter, parts, ", ") + rightDelimiter;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    IterableBase_iterableToFullString: function(iterable, leftDelimiter, rightDelimiter) {
      var buffer, t1;
      if (P._isToStringVisiting(iterable))
        return leftDelimiter + "..." + rightDelimiter;
      buffer = new P.StringBuffer(leftDelimiter);
      $._toStringVisiting.push(iterable);
      try {
        t1 = buffer;
        t1._contents = P.StringBuffer__writeAll(t1._contents, iterable, ", ");
      } finally {
        $._toStringVisiting.pop();
      }
      buffer._contents += rightDelimiter;
      t1 = buffer._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    _isToStringVisiting: function(o) {
      var t1, i;
      for (t1 = $._toStringVisiting.length, i = 0; i < t1; ++i)
        if (o === $._toStringVisiting[i])
          return true;
      return false;
    },
    _iterablePartsToStrings: function(iterable, parts) {
      var next, ultimateString, penultimateString, penultimate, ultimate, ultimate0, elision,
        it = iterable.get$iterator(iterable),
        $length = 0, count = 0;
      while (true) {
        if (!($length < 80 || count < 3))
          break;
        if (!it.moveNext$0())
          return;
        next = H.S(it.get$current(it));
        parts.push(next);
        $length += next.length + 2;
        ++count;
      }
      if (!it.moveNext$0()) {
        if (count <= 5)
          return;
        ultimateString = parts.pop();
        penultimateString = parts.pop();
      } else {
        penultimate = it.get$current(it);
        ++count;
        if (!it.moveNext$0()) {
          if (count <= 4) {
            parts.push(H.S(penultimate));
            return;
          }
          ultimateString = H.S(penultimate);
          penultimateString = parts.pop();
          $length += ultimateString.length + 2;
        } else {
          ultimate = it.get$current(it);
          ++count;
          for (; it.moveNext$0(); penultimate = ultimate, ultimate = ultimate0) {
            ultimate0 = it.get$current(it);
            ++count;
            if (count > 100) {
              while (true) {
                if (!($length > 75 && count > 3))
                  break;
                $length -= parts.pop().length + 2;
                --count;
              }
              parts.push("...");
              return;
            }
          }
          penultimateString = H.S(penultimate);
          ultimateString = H.S(ultimate);
          $length += ultimateString.length + penultimateString.length + 4;
        }
      }
      if (count > parts.length + 2) {
        $length += 5;
        elision = "...";
      } else
        elision = null;
      while (true) {
        if (!($length > 80 && parts.length > 3))
          break;
        $length -= parts.pop().length + 2;
        if (elision == null) {
          $length += 5;
          elision = "...";
        }
      }
      if (elision != null)
        parts.push(elision);
      parts.push(penultimateString);
      parts.push(ultimateString);
    },
    LinkedHashMap_LinkedHashMap$from: function(other, $K, $V) {
      var result = P.LinkedHashMap_LinkedHashMap(null, null, null, $K, $V);
      other.forEach$1(0, new P.LinkedHashMap_LinkedHashMap$from_closure(result));
      return result;
    },
    LinkedHashMap_LinkedHashMap$of: function(other, $K, $V) {
      var t1 = P.LinkedHashMap_LinkedHashMap(null, null, null, $K, $V);
      t1.addAll$1(0, other);
      return t1;
    },
    LinkedHashSet_LinkedHashSet$from: function(elements, $E) {
      var t1,
        result = P.LinkedHashSet_LinkedHashSet($E);
      for (t1 = J.get$iterator$ax(elements); t1.moveNext$0();)
        result.add$1(0, t1.get$current(t1));
      return result;
    },
    LinkedHashSet_LinkedHashSet$of: function(elements, $E) {
      var t1 = P.LinkedHashSet_LinkedHashSet($E);
      t1.addAll$1(0, elements);
      return t1;
    },
    MapBase_mapToString: function(m) {
      var result, t1 = {};
      if (P._isToStringVisiting(m))
        return "{...}";
      result = new P.StringBuffer("");
      try {
        $._toStringVisiting.push(m);
        result._contents += "{";
        t1.first = true;
        m.forEach$1(0, new P.MapBase_mapToString_closure(t1, result));
        result._contents += "}";
      } finally {
        $._toStringVisiting.pop();
      }
      t1 = result._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    MapBase__id: function(x) {
      return x;
    },
    MapBase__fillMapWithMappedIterable: function(map, iterable, key, value) {
      var t1, _i, element;
      for (t1 = iterable.length, _i = 0; _i < t1; ++_i) {
        element = iterable[_i];
        map.$indexSet(0, P.collection_MapBase__id$closure().call$1(element), value.call$1(element));
      }
    },
    MapBase__fillMapWithIterables: function(map, keys, values) {
      var keyIterator = keys.get$iterator(keys),
        valueIterator = values.get$iterator(values),
        hasNextKey = keyIterator.moveNext$0(),
        hasNextValue = valueIterator.moveNext$0();
      while (true) {
        if (!(hasNextKey && hasNextValue))
          break;
        map.$indexSet(0, keyIterator.get$current(keyIterator), valueIterator.get$current(valueIterator));
        hasNextKey = keyIterator.moveNext$0();
        hasNextValue = valueIterator.moveNext$0();
      }
      if (hasNextKey || hasNextValue)
        throw H.wrapException(P.ArgumentError$("Iterables do not have same length."));
    },
    ListQueue$: function($E) {
      var t1 = new P.ListQueue([$E]),
        t2 = new Array(8);
      t2.fixed$length = Array;
      t1._collection$_table = H.setRuntimeTypeInfo(t2, [$E]);
      return t1;
    },
    ListQueue_ListQueue$of: function(elements, $E) {
      var t1 = P.ListQueue$($E);
      t1.addAll$1(0, elements);
      return t1;
    },
    ListQueue__nextPowerOf2: function(number) {
      var nextNumber;
      number = (number << 1 >>> 0) - 1;
      for (; true; number = nextNumber) {
        nextNumber = (number & number - 1) >>> 0;
        if (nextNumber === 0)
          return number;
      }
    },
    _ListQueueIterator$: function(queue) {
      return new P._ListQueueIterator(queue, queue._collection$_tail, queue._modificationCount, queue._collection$_head);
    },
    _HashMap: function _HashMap(t0) {
      var _ = this;
      _._collection$_length = 0;
      _._collection$_keys = _._collection$_rest = _._collection$_nums = _._collection$_strings = null;
      _.$ti = t0;
    },
    _HashMap_values_closure: function _HashMap_values_closure(t0) {
      this.$this = t0;
    },
    _HashMap_addAll_closure: function _HashMap_addAll_closure(t0) {
      this.$this = t0;
    },
    _HashMapKeyIterable: function _HashMapKeyIterable(t0, t1) {
      this._collection$_map = t0;
      this.$ti = t1;
    },
    _HashMapKeyIterator: function _HashMapKeyIterator(t0, t1) {
      var _ = this;
      _._collection$_map = t0;
      _._collection$_keys = t1;
      _._offset = 0;
      _._collection$_current = null;
    },
    _LinkedIdentityHashMap: function _LinkedIdentityHashMap(t0) {
      var _ = this;
      _.__js_helper$_length = 0;
      _._last = _._first = _._rest = _._nums = _._strings = null;
      _._modifications = 0;
      _.$ti = t0;
    },
    _LinkedCustomHashMap: function _LinkedCustomHashMap(t0, t1, t2, t3) {
      var _ = this;
      _._equals = t0;
      _._collection$_hashCode = t1;
      _._validKey = t2;
      _.__js_helper$_length = 0;
      _._last = _._first = _._rest = _._nums = _._strings = null;
      _._modifications = 0;
      _.$ti = t3;
    },
    _LinkedCustomHashMap_closure: function _LinkedCustomHashMap_closure(t0) {
      this.K = t0;
    },
    _LinkedHashSet: function _LinkedHashSet(t0) {
      var _ = this;
      _._collection$_length = 0;
      _._collection$_last = _._collection$_first = _._collection$_rest = _._collection$_nums = _._collection$_strings = null;
      _._collection$_modifications = 0;
      _.$ti = t0;
    },
    _LinkedIdentityHashSet: function _LinkedIdentityHashSet(t0) {
      var _ = this;
      _._collection$_length = 0;
      _._collection$_last = _._collection$_first = _._collection$_rest = _._collection$_nums = _._collection$_strings = null;
      _._collection$_modifications = 0;
      _.$ti = t0;
    },
    _LinkedHashSetCell: function _LinkedHashSetCell(t0) {
      this._element = t0;
      this._collection$_previous = this._collection$_next = null;
    },
    _LinkedHashSetIterator: function _LinkedHashSetIterator(t0, t1) {
      var _ = this;
      _._set = t0;
      _._collection$_modifications = t1;
      _._collection$_current = _._collection$_cell = null;
    },
    UnmodifiableListView: function UnmodifiableListView(t0, t1) {
      this._collection$_source = t0;
      this.$ti = t1;
    },
    HashMap_HashMap$from_closure: function HashMap_HashMap$from_closure(t0) {
      this.result = t0;
    },
    IterableBase: function IterableBase() {
    },
    LinkedHashMap_LinkedHashMap$from_closure: function LinkedHashMap_LinkedHashMap$from_closure(t0) {
      this.result = t0;
    },
    ListBase: function ListBase() {
    },
    ListMixin: function ListMixin() {
    },
    MapBase: function MapBase() {
    },
    MapBase_mapToString_closure: function MapBase_mapToString_closure(t0, t1) {
      this._box_0 = t0;
      this.result = t1;
    },
    MapMixin: function MapMixin() {
    },
    MapMixin_entries_closure: function MapMixin_entries_closure(t0) {
      this.$this = t0;
    },
    UnmodifiableMapBase: function UnmodifiableMapBase() {
    },
    _MapBaseValueIterable: function _MapBaseValueIterable(t0, t1) {
      this._collection$_map = t0;
      this.$ti = t1;
    },
    _MapBaseValueIterator: function _MapBaseValueIterator(t0, t1) {
      this._collection$_keys = t0;
      this._collection$_map = t1;
      this._collection$_current = null;
    },
    _UnmodifiableMapMixin: function _UnmodifiableMapMixin() {
    },
    MapView: function MapView() {
    },
    UnmodifiableMapView: function UnmodifiableMapView(t0, t1) {
      this._collection$_map = t0;
      this.$ti = t1;
    },
    Queue: function Queue() {
    },
    ListQueue: function ListQueue(t0) {
      var _ = this;
      _._collection$_table = null;
      _._modificationCount = _._collection$_tail = _._collection$_head = 0;
      _.$ti = t0;
    },
    _ListQueueIterator: function _ListQueueIterator(t0, t1, t2, t3) {
      var _ = this;
      _._queue = t0;
      _._collection$_end = t1;
      _._modificationCount = t2;
      _._position = t3;
      _._collection$_current = null;
    },
    _SetBase: function _SetBase() {
    },
    _ListBase_Object_ListMixin: function _ListBase_Object_ListMixin() {
    },
    _UnmodifiableMapView_MapView__UnmodifiableMapMixin: function _UnmodifiableMapView_MapView__UnmodifiableMapMixin() {
    },
    Utf8Decoder__convertIntercepted: function(allowMalformed, codeUnits, start, end) {
      if (codeUnits instanceof Uint8Array)
        return P.Utf8Decoder__convertInterceptedUint8List(false, codeUnits, start, end);
      return;
    },
    Utf8Decoder__convertInterceptedUint8List: function(allowMalformed, codeUnits, start, end) {
      var t1, $length,
        decoder = $.$get$Utf8Decoder__decoder();
      if (decoder == null)
        return;
      t1 = 0 === start;
      if (t1 && true)
        return P.Utf8Decoder__useTextDecoderChecked(decoder, codeUnits);
      $length = codeUnits.length;
      end = P.RangeError_checkValidRange(start, end, $length);
      if (t1 && end === $length)
        return P.Utf8Decoder__useTextDecoderChecked(decoder, codeUnits);
      return P.Utf8Decoder__useTextDecoderChecked(decoder, codeUnits.subarray(start, end));
    },
    Utf8Decoder__useTextDecoderChecked: function(decoder, codeUnits) {
      if (P.Utf8Decoder__unsafe(codeUnits))
        return;
      return P.Utf8Decoder__useTextDecoderUnchecked(decoder, codeUnits);
    },
    Utf8Decoder__useTextDecoderUnchecked: function(decoder, codeUnits) {
      var t1, exception;
      try {
        t1 = decoder.decode(codeUnits);
        return t1;
      } catch (exception) {
        H.unwrapException(exception);
      }
      return;
    },
    Utf8Decoder__unsafe: function(codeUnits) {
      var i,
        limit = codeUnits.length - 2;
      for (i = 0; i < limit; ++i)
        if (codeUnits[i] === 237)
          if ((codeUnits[i + 1] & 224) === 160)
            return true;
      return false;
    },
    Utf8Decoder__makeDecoder: function() {
      var t1, exception;
      try {
        t1 = new TextDecoder("utf-8", {fatal: true});
        return t1;
      } catch (exception) {
        H.unwrapException(exception);
      }
      return;
    },
    _scanOneByteCharacters: function(units, from, endIndex) {
      var t1, i, unit;
      for (t1 = J.getInterceptor$asx(units), i = from; i < endIndex; ++i) {
        unit = t1.$index(units, i);
        if ((unit & 127) !== unit)
          return i - from;
      }
      return endIndex - from;
    },
    Base64Codec__checkPadding: function(source, sourceIndex, sourceEnd, firstPadding, paddingCount, $length) {
      if (C.JSInt_methods.$mod($length, 4) !== 0)
        throw H.wrapException(P.FormatException$("Invalid base64 padding, padded length must be multiple of four, is " + $length, source, sourceEnd));
      if (firstPadding + paddingCount !== $length)
        throw H.wrapException(P.FormatException$("Invalid base64 padding, '=' not at the end", source, sourceIndex));
      if (paddingCount > 2)
        throw H.wrapException(P.FormatException$("Invalid base64 padding, more than two '=' characters", source, sourceIndex));
    },
    _Base64Encoder_encodeChunk: function(alphabet, bytes, start, end, isLast, output, outputIndex, state) {
      var t1, i, byteOr, byte, outputIndex0, outputIndex1,
        bits = state >>> 2,
        expectedChars = 3 - (state & 3);
      for (t1 = J.getInterceptor$asx(bytes), i = start, byteOr = 0; i < end; ++i) {
        byte = t1.$index(bytes, i);
        byteOr = (byteOr | byte) >>> 0;
        bits = (bits << 8 | byte) & 16777215;
        --expectedChars;
        if (expectedChars === 0) {
          outputIndex0 = outputIndex + 1;
          output[outputIndex] = C.JSString_methods._codeUnitAt$1(alphabet, bits >>> 18 & 63);
          outputIndex = outputIndex0 + 1;
          output[outputIndex0] = C.JSString_methods._codeUnitAt$1(alphabet, bits >>> 12 & 63);
          outputIndex0 = outputIndex + 1;
          output[outputIndex] = C.JSString_methods._codeUnitAt$1(alphabet, bits >>> 6 & 63);
          outputIndex = outputIndex0 + 1;
          output[outputIndex0] = C.JSString_methods._codeUnitAt$1(alphabet, bits & 63);
          bits = 0;
          expectedChars = 3;
        }
      }
      if (byteOr >= 0 && byteOr <= 255) {
        if (isLast && expectedChars < 3) {
          outputIndex0 = outputIndex + 1;
          outputIndex1 = outputIndex0 + 1;
          if (3 - expectedChars === 1) {
            output[outputIndex] = C.JSString_methods._codeUnitAt$1(alphabet, bits >>> 2 & 63);
            output[outputIndex0] = C.JSString_methods._codeUnitAt$1(alphabet, bits << 4 & 63);
            output[outputIndex1] = 61;
            output[outputIndex1 + 1] = 61;
          } else {
            output[outputIndex] = C.JSString_methods._codeUnitAt$1(alphabet, bits >>> 10 & 63);
            output[outputIndex0] = C.JSString_methods._codeUnitAt$1(alphabet, bits >>> 4 & 63);
            output[outputIndex1] = C.JSString_methods._codeUnitAt$1(alphabet, bits << 2 & 63);
            output[outputIndex1 + 1] = 61;
          }
          return 0;
        }
        return (bits << 2 | 3 - expectedChars) >>> 0;
      }
      for (i = start; i < end;) {
        byte = t1.$index(bytes, i);
        if (byte < 0 || byte > 255)
          break;
        ++i;
      }
      throw H.wrapException(P.ArgumentError$value(bytes, "Not a byte value at index " + i + ": 0x" + J.toRadixString$1$n(t1.$index(bytes, i), 16), null));
    },
    JsonUnsupportedObjectError$: function(unsupportedObject, cause, partialResult) {
      return new P.JsonUnsupportedObjectError(unsupportedObject, cause);
    },
    _defaultToEncodable: function(object) {
      return object.toJson$0();
    },
    _JsonStringStringifier_stringify: function(object, toEncodable, indent) {
      var t1,
        output = new P.StringBuffer("");
      P._JsonStringStringifier_printOn(object, output, toEncodable, indent);
      t1 = output._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    _JsonStringStringifier_printOn: function(object, output, toEncodable, indent) {
      var stringifier = new P._JsonStringStringifier(output, [], P.convert___defaultToEncodable$closure());
      stringifier.writeObject$1(object);
    },
    AsciiCodec: function AsciiCodec() {
    },
    _UnicodeSubsetEncoder: function _UnicodeSubsetEncoder() {
    },
    AsciiEncoder: function AsciiEncoder(t0) {
      this._subsetMask = t0;
    },
    Base64Codec: function Base64Codec() {
    },
    Base64Encoder: function Base64Encoder() {
    },
    _Base64Encoder: function _Base64Encoder(t0) {
      this._state = 0;
      this._alphabet = t0;
    },
    _BufferCachingBase64Encoder: function _BufferCachingBase64Encoder(t0) {
      this.bufferCache = null;
      this._state = 0;
      this._alphabet = t0;
    },
    _Base64EncoderSink: function _Base64EncoderSink() {
    },
    _AsciiBase64EncoderSink: function _AsciiBase64EncoderSink(t0, t1) {
      this._sink = t0;
      this._encoder = t1;
    },
    _Utf8Base64EncoderSink: function _Utf8Base64EncoderSink(t0, t1) {
      this._sink = t0;
      this._encoder = t1;
    },
    ByteConversionSink: function ByteConversionSink() {
    },
    ByteConversionSinkBase: function ByteConversionSinkBase() {
    },
    ChunkedConversionSink: function ChunkedConversionSink() {
    },
    Codec: function Codec() {
    },
    Converter: function Converter() {
    },
    Encoding: function Encoding() {
    },
    JsonUnsupportedObjectError: function JsonUnsupportedObjectError(t0, t1) {
      this.unsupportedObject = t0;
      this.cause = t1;
    },
    JsonCyclicError: function JsonCyclicError(t0, t1) {
      this.unsupportedObject = t0;
      this.cause = t1;
    },
    JsonCodec: function JsonCodec() {
    },
    JsonEncoder: function JsonEncoder(t0) {
      this._toEncodable = t0;
    },
    _JsonStringifier: function _JsonStringifier() {
    },
    _JsonStringifier_writeMap_closure: function _JsonStringifier_writeMap_closure(t0, t1) {
      this._box_0 = t0;
      this.keyValueList = t1;
    },
    _JsonStringStringifier: function _JsonStringStringifier(t0, t1, t2) {
      this._sink = t0;
      this._seen = t1;
      this._toEncodable = t2;
    },
    StringConversionSinkBase: function StringConversionSinkBase() {
    },
    StringConversionSinkMixin: function StringConversionSinkMixin() {
    },
    _StringSinkConversionSink: function _StringSinkConversionSink(t0) {
      this._stringSink = t0;
    },
    _StringCallbackSink: function _StringCallbackSink(t0, t1) {
      this._callback = t0;
      this._stringSink = t1;
    },
    _StringAdapterSink: function _StringAdapterSink(t0) {
      this._sink = t0;
    },
    _Utf8StringSinkAdapter: function _Utf8StringSinkAdapter(t0, t1) {
      this._decoder = t0;
      this._sink = t1;
    },
    _Utf8ConversionSink: function _Utf8ConversionSink(t0, t1, t2) {
      this._decoder = t0;
      this._chunkedSink = t1;
      this._convert$_buffer = t2;
    },
    Utf8Codec: function Utf8Codec() {
    },
    Utf8Encoder: function Utf8Encoder() {
    },
    _Utf8Encoder: function _Utf8Encoder(t0) {
      this._bufferIndex = this._carry = 0;
      this._convert$_buffer = t0;
    },
    Utf8Decoder: function Utf8Decoder(t0) {
      this._allowMalformed = t0;
    },
    _Utf8Decoder: function _Utf8Decoder(t0, t1) {
      var _ = this;
      _._allowMalformed = t0;
      _._stringSink = t1;
      _._isFirstCharacter = true;
      _._extraUnits = _._expectedUnits = _._convert$_value = 0;
    },
    identityHashCode: function(object) {
      return H.objectHashCode(object);
    },
    Function_apply: function($function, positionalArguments) {
      return H.Primitives_applyFunction($function, positionalArguments, null);
    },
    int_parse: function(source, onError, radix) {
      var value = H.Primitives_parseInt(source, radix);
      if (value != null)
        return value;
      if (onError != null)
        return onError.call$1(source);
      throw H.wrapException(P.FormatException$(source, null, null));
    },
    double_parse: function(source) {
      var value = H.Primitives_parseDouble(source);
      if (value != null)
        return value;
      throw H.wrapException(P.FormatException$("Invalid double", source, null));
    },
    Error__objectToString: function(object) {
      if (object instanceof H.Closure)
        return object.toString$0(0);
      return "Instance of '" + H.Primitives_objectTypeName(object) + "'";
    },
    List_List$filled: function($length, fill, $E) {
      var t1, i,
        result = J.JSArray_JSArray$fixed($length, $E);
      if ($length !== 0 && fill != null)
        for (t1 = result.length, i = 0; i < t1; ++i)
          result[i] = fill;
      return result;
    },
    List_List$from: function(elements, growable, $E) {
      var t1,
        list = H.setRuntimeTypeInfo([], [$E]);
      for (t1 = J.get$iterator$ax(elements); t1.moveNext$0();)
        list.push(t1.get$current(t1));
      if (growable)
        return list;
      return J.JSArray_markFixedList(list);
    },
    List_List$unmodifiable: function(elements, $E) {
      return J.JSArray_markUnmodifiableList(P.List_List$from(elements, false, $E));
    },
    String_String$fromCharCodes: function(charCodes, start, end) {
      var len;
      if (typeof charCodes === "object" && charCodes !== null && charCodes.constructor === Array) {
        len = charCodes.length;
        end = P.RangeError_checkValidRange(start, end, len);
        return H.Primitives_stringFromCharCodes(start > 0 || end < len ? C.JSArray_methods.sublist$2(charCodes, start, end) : charCodes);
      }
      if (!!J.getInterceptor$(charCodes).$isNativeUint8List)
        return H.Primitives_stringFromNativeUint8List(charCodes, start, P.RangeError_checkValidRange(start, end, charCodes.length));
      return P.String__stringFromIterable(charCodes, start, end);
    },
    String_String$fromCharCode: function(charCode) {
      return H.Primitives_stringFromCharCode(charCode);
    },
    String__stringFromIterable: function(charCodes, start, end) {
      var t1, it, i, list, _null = null;
      if (start < 0)
        throw H.wrapException(P.RangeError$range(start, 0, J.get$length$asx(charCodes), _null, _null));
      t1 = end == null;
      if (!t1 && end < start)
        throw H.wrapException(P.RangeError$range(end, start, J.get$length$asx(charCodes), _null, _null));
      it = J.get$iterator$ax(charCodes);
      for (i = 0; i < start; ++i)
        if (!it.moveNext$0())
          throw H.wrapException(P.RangeError$range(start, 0, i, _null, _null));
      list = [];
      if (t1)
        for (; it.moveNext$0();)
          list.push(it.get$current(it));
      else
        for (i = start; i < end; ++i) {
          if (!it.moveNext$0())
            throw H.wrapException(P.RangeError$range(end, start, i, _null, _null));
          list.push(it.get$current(it));
        }
      return H.Primitives_stringFromCharCodes(list);
    },
    RegExp_RegExp: function(source, multiLine) {
      return new H.JSSyntaxRegExp(source, H.JSSyntaxRegExp_makeNative(source, multiLine, true, false, false, false));
    },
    identical: function(a, b) {
      return a == null ? b == null : a === b;
    },
    StringBuffer__writeAll: function(string, objects, separator) {
      var iterator = J.get$iterator$ax(objects);
      if (!iterator.moveNext$0())
        return string;
      if (separator.length === 0) {
        do
          string += H.S(iterator.get$current(iterator));
        while (iterator.moveNext$0());
      } else {
        string += H.S(iterator.get$current(iterator));
        for (; iterator.moveNext$0();)
          string = string + separator + H.S(iterator.get$current(iterator));
      }
      return string;
    },
    NoSuchMethodError$: function(receiver, memberName, positionalArguments, namedArguments) {
      return new P.NoSuchMethodError(receiver, memberName, positionalArguments, namedArguments);
    },
    Uri_base: function() {
      var uri = H.Primitives_currentUri();
      if (uri != null)
        return P.Uri_parse(uri);
      throw H.wrapException(P.UnsupportedError$("'Uri.base' is not supported"));
    },
    _Uri__uriEncode: function(canonicalTable, text, encoding, spaceToPlus) {
      var t1, bytes, i, t2, byte,
        _s16_ = "0123456789ABCDEF";
      if (encoding === C.C_Utf8Codec) {
        t1 = $.$get$_Uri__needsNoEncoding()._nativeRegExp;
        if (typeof text !== "string")
          H.throwExpression(H.argumentErrorValue(text));
        t1 = t1.test(text);
      } else
        t1 = false;
      if (t1)
        return text;
      bytes = encoding.get$encoder().convert$1(text);
      for (t1 = bytes.length, i = 0, t2 = ""; i < t1; ++i) {
        byte = bytes[i];
        if (byte < 128 && (canonicalTable[byte >>> 4] & 1 << (byte & 15)) !== 0)
          t2 += H.Primitives_stringFromCharCode(byte);
        else
          t2 = spaceToPlus && byte === 32 ? t2 + "+" : t2 + "%" + _s16_[byte >>> 4 & 15] + _s16_[byte & 15];
      }
      return t2.charCodeAt(0) == 0 ? t2 : t2;
    },
    StackTrace_current: function() {
      var stackTrace, exception;
      if ($.$get$_hasErrorStackProperty())
        return H.getTraceFromException(new Error());
      try {
        throw H.wrapException("");
      } catch (exception) {
        H.unwrapException(exception);
        stackTrace = H.getTraceFromException(exception);
        return stackTrace;
      }
    },
    DateTime$_withValue: function(_value, isUtc) {
      var t1;
      if (Math.abs(_value) <= 864e13)
        t1 = false;
      else
        t1 = true;
      if (t1)
        H.throwExpression(P.ArgumentError$("DateTime is outside valid range: " + _value));
      return new P.DateTime(_value, false);
    },
    DateTime__fourDigits: function(n) {
      var absN = Math.abs(n),
        sign = n < 0 ? "-" : "";
      if (absN >= 1000)
        return "" + n;
      if (absN >= 100)
        return sign + "0" + absN;
      if (absN >= 10)
        return sign + "00" + absN;
      return sign + "000" + absN;
    },
    DateTime__threeDigits: function(n) {
      if (n >= 100)
        return "" + n;
      if (n >= 10)
        return "0" + n;
      return "00" + n;
    },
    DateTime__twoDigits: function(n) {
      if (n >= 10)
        return "" + n;
      return "0" + n;
    },
    Duration$: function(milliseconds, seconds) {
      return new P.Duration(1000000 * seconds + 1000 * milliseconds);
    },
    Error_safeToString: function(object) {
      if (typeof object === "number" || typeof object === "boolean" || null == object)
        return J.toString$0$(object);
      if (typeof object === "string")
        return JSON.stringify(object);
      return P.Error__objectToString(object);
    },
    ArgumentError$: function(message) {
      return new P.ArgumentError(false, null, null, message);
    },
    ArgumentError$value: function(value, $name, message) {
      return new P.ArgumentError(true, value, $name, message);
    },
    ArgumentError$notNull: function($name) {
      return new P.ArgumentError(false, null, $name, "Must not be null");
    },
    RangeError$: function(message) {
      var _null = null;
      return new P.RangeError(_null, _null, false, _null, _null, message);
    },
    RangeError$value: function(value, $name, message) {
      return new P.RangeError(null, null, true, value, $name, message != null ? message : "Value not in range");
    },
    RangeError$range: function(invalidValue, minValue, maxValue, $name, message) {
      return new P.RangeError(minValue, maxValue, true, invalidValue, $name, "Invalid value");
    },
    RangeError_checkValueInInterval: function(value, minValue, maxValue, $name) {
      if (value < minValue || value > maxValue)
        throw H.wrapException(P.RangeError$range(value, minValue, maxValue, $name, null));
    },
    RangeError_checkValidIndex: function(index, indexable, $name) {
      var $length = indexable.get$length(indexable);
      if (0 > index || index >= $length)
        throw H.wrapException(P.IndexError$(index, indexable, $name == null ? "index" : $name, null, $length));
    },
    RangeError_checkValidRange: function(start, end, $length) {
      if (0 > start || start > $length)
        throw H.wrapException(P.RangeError$range(start, 0, $length, "start", null));
      if (end != null) {
        if (start > end || end > $length)
          throw H.wrapException(P.RangeError$range(end, start, $length, "end", null));
        return end;
      }
      return $length;
    },
    RangeError_checkNotNegative: function(value, $name) {
      if (value < 0)
        throw H.wrapException(P.RangeError$range(value, 0, null, $name, null));
    },
    IndexError$: function(invalidValue, indexable, $name, message, $length) {
      var t1 = $length == null ? J.get$length$asx(indexable) : $length;
      return new P.IndexError(t1, true, invalidValue, $name, "Index out of range");
    },
    UnsupportedError$: function(message) {
      return new P.UnsupportedError(message);
    },
    UnimplementedError$: function(message) {
      return new P.UnimplementedError(message);
    },
    StateError$: function(message) {
      return new P.StateError(message);
    },
    ConcurrentModificationError$: function(modifiedObject) {
      return new P.ConcurrentModificationError(modifiedObject);
    },
    FormatException$: function(message, source, offset) {
      return new P.FormatException(message, source, offset);
    },
    Iterable_Iterable$generate: function(count, generator, $E) {
      if (count <= 0)
        return new H.EmptyIterable([$E]);
      return new P._GeneratorIterable(count, generator, [$E]);
    },
    List_List$generate: function($length, generator, growable, $E) {
      var result, t1, i;
      if (growable) {
        result = H.setRuntimeTypeInfo([], [$E]);
        C.JSArray_methods.set$length(result, $length);
      } else {
        t1 = new Array($length);
        t1.fixed$length = Array;
        result = H.setRuntimeTypeInfo(t1, [$E]);
      }
      for (i = 0; i < $length; ++i)
        result[i] = generator.call$1(i);
      return result;
    },
    print: function(object) {
      var line = H.S(object),
        t1 = $.printToZone;
      if (t1 == null)
        H.printString(line);
      else
        t1.call$1(line);
    },
    Set_castFrom: function(source, newSet, $S, $T) {
      return new H.CastSet(source, newSet, [$S, $T]);
    },
    _combineSurrogatePair: function(start, end) {
      return 65536 + ((start & 1023) << 10) + (end & 1023);
    },
    Uri_Uri$dataFromString: function($content, encoding, mimeType) {
      var encodingName, t1,
        buffer = new P.StringBuffer(""),
        indices = H.setRuntimeTypeInfo([-1], [P.int]);
      if (encoding == null)
        encodingName = null;
      else
        encodingName = "utf-8";
      if (encoding == null)
        encoding = C.C_AsciiCodec;
      P.UriData__writeUri(mimeType, encodingName, null, buffer, indices);
      indices.push(buffer._contents.length);
      buffer._contents += ",";
      P.UriData__uriEncodeBytes(C.List_CVk, encoding.encode$1($content), buffer);
      t1 = buffer._contents;
      return new P.UriData(t1.charCodeAt(0) == 0 ? t1 : t1, indices, null).get$uri();
    },
    Uri_parse: function(uri) {
      var delta, t1, indices, schemeEnd, hostStart, portStart, pathStart, queryStart, fragmentStart, isSimple, scheme, t2, schemeAuth, queryStart0, pathStart0, _null = null,
        end = uri.length;
      if (end >= 5) {
        delta = ((J._codeUnitAt$1$s(uri, 4) ^ 58) * 3 | C.JSString_methods._codeUnitAt$1(uri, 0) ^ 100 | C.JSString_methods._codeUnitAt$1(uri, 1) ^ 97 | C.JSString_methods._codeUnitAt$1(uri, 2) ^ 116 | C.JSString_methods._codeUnitAt$1(uri, 3) ^ 97) >>> 0;
        if (delta === 0)
          return P.UriData__parse(end < end ? C.JSString_methods.substring$2(uri, 0, end) : uri, 5, _null).get$uri();
        else if (delta === 32)
          return P.UriData__parse(C.JSString_methods.substring$2(uri, 5, end), 0, _null).get$uri();
      }
      t1 = new Array(8);
      t1.fixed$length = Array;
      indices = H.setRuntimeTypeInfo(t1, [P.int]);
      indices[0] = 0;
      indices[1] = -1;
      indices[2] = -1;
      indices[7] = -1;
      indices[3] = 0;
      indices[4] = 0;
      indices[5] = end;
      indices[6] = end;
      if (P._scan(uri, 0, end, 0, indices) >= 14)
        indices[7] = end;
      schemeEnd = indices[1];
      if (schemeEnd >= 0)
        if (P._scan(uri, 0, schemeEnd, 20, indices) === 20)
          indices[7] = schemeEnd;
      hostStart = indices[2] + 1;
      portStart = indices[3];
      pathStart = indices[4];
      queryStart = indices[5];
      fragmentStart = indices[6];
      if (fragmentStart < queryStart)
        queryStart = fragmentStart;
      if (pathStart < hostStart)
        pathStart = queryStart;
      else if (pathStart <= schemeEnd)
        pathStart = schemeEnd + 1;
      if (portStart < hostStart)
        portStart = pathStart;
      isSimple = indices[7] < 0;
      if (isSimple)
        if (hostStart > schemeEnd + 3) {
          scheme = _null;
          isSimple = false;
        } else {
          t1 = portStart > 0;
          if (t1 && portStart + 1 === pathStart) {
            scheme = _null;
            isSimple = false;
          } else {
            if (!(queryStart < end && queryStart === pathStart + 2 && J.startsWith$2$s(uri, "..", pathStart)))
              t2 = queryStart > pathStart + 2 && J.startsWith$2$s(uri, "/..", queryStart - 3);
            else
              t2 = true;
            if (t2) {
              scheme = _null;
              isSimple = false;
            } else {
              if (schemeEnd === 4)
                if (J.startsWith$2$s(uri, "file", 0)) {
                  if (hostStart <= 0) {
                    if (!C.JSString_methods.startsWith$2(uri, "/", pathStart)) {
                      schemeAuth = "file:///";
                      delta = 3;
                    } else {
                      schemeAuth = "file://";
                      delta = 2;
                    }
                    uri = schemeAuth + C.JSString_methods.substring$2(uri, pathStart, end);
                    schemeEnd -= 0;
                    t1 = delta - 0;
                    queryStart += t1;
                    fragmentStart += t1;
                    end = uri.length;
                    hostStart = 7;
                    portStart = 7;
                    pathStart = 7;
                  } else if (pathStart === queryStart) {
                    queryStart0 = queryStart + 1;
                    ++fragmentStart;
                    uri = C.JSString_methods.replaceRange$3(uri, pathStart, queryStart, "/");
                    ++end;
                    queryStart = queryStart0;
                  }
                  scheme = "file";
                } else if (C.JSString_methods.startsWith$2(uri, "http", 0)) {
                  if (t1 && portStart + 3 === pathStart && C.JSString_methods.startsWith$2(uri, "80", portStart + 1)) {
                    pathStart0 = pathStart - 3;
                    queryStart -= 3;
                    fragmentStart -= 3;
                    uri = C.JSString_methods.replaceRange$3(uri, portStart, pathStart, "");
                    end -= 3;
                    pathStart = pathStart0;
                  }
                  scheme = "http";
                } else
                  scheme = _null;
              else if (schemeEnd === 5 && J.startsWith$2$s(uri, "https", 0)) {
                if (t1 && portStart + 4 === pathStart && J.startsWith$2$s(uri, "443", portStart + 1)) {
                  pathStart0 = pathStart - 4;
                  queryStart -= 4;
                  fragmentStart -= 4;
                  uri = J.replaceRange$3$asx(uri, portStart, pathStart, "");
                  end -= 3;
                  pathStart = pathStart0;
                }
                scheme = "https";
              } else
                scheme = _null;
              isSimple = true;
            }
          }
        }
      else
        scheme = _null;
      if (isSimple) {
        t1 = uri.length;
        if (end < t1) {
          uri = J.substring$2$s(uri, 0, end);
          schemeEnd -= 0;
          hostStart -= 0;
          portStart -= 0;
          pathStart -= 0;
          queryStart -= 0;
          fragmentStart -= 0;
        }
        return new P._SimpleUri(uri, schemeEnd, hostStart, portStart, pathStart, queryStart, fragmentStart, scheme);
      }
      return P._Uri__Uri$notSimple(uri, 0, end, schemeEnd, hostStart, portStart, pathStart, queryStart, fragmentStart, scheme);
    },
    Uri_decodeComponent: function(encodedComponent) {
      return P._Uri__uriDecode(encodedComponent, 0, encodedComponent.length, C.C_Utf8Codec, false);
    },
    Uri__parseIPv4Address: function(host, start, end) {
      var i, partStart, partIndex, char, part, partIndex0, _null = null,
        _s43_ = "IPv4 address should contain exactly 4 parts",
        _s37_ = "each part must be in the range 0..255",
        error = new P.Uri__parseIPv4Address_error(host),
        result = new Uint8Array(4);
      for (i = start, partStart = i, partIndex = 0; i < end; ++i) {
        char = C.JSString_methods.codeUnitAt$1(host, i);
        if (char !== 46) {
          if ((char ^ 48) > 9)
            error.call$2("invalid character", i);
        } else {
          if (partIndex === 3)
            error.call$2(_s43_, i);
          part = P.int_parse(C.JSString_methods.substring$2(host, partStart, i), _null, _null);
          if (part > 255)
            error.call$2(_s37_, partStart);
          partIndex0 = partIndex + 1;
          result[partIndex] = part;
          partStart = i + 1;
          partIndex = partIndex0;
        }
      }
      if (partIndex !== 3)
        error.call$2(_s43_, end);
      part = P.int_parse(C.JSString_methods.substring$2(host, partStart, end), _null, _null);
      if (part > 255)
        error.call$2(_s37_, partStart);
      result[partIndex] = part;
      return result;
    },
    Uri_parseIPv6Address: function(host, start, end) {
      var error, parseHex, parts, i, partStart, wildcardSeen, seenDot, char, atEnd, t1, last, bytes, wildCardLength, index, value, j;
      if (end == null)
        end = host.length;
      error = new P.Uri_parseIPv6Address_error(host);
      parseHex = new P.Uri_parseIPv6Address_parseHex(error, host);
      if (host.length < 2)
        error.call$1("address is too short");
      parts = H.setRuntimeTypeInfo([], [P.int]);
      for (i = start, partStart = i, wildcardSeen = false, seenDot = false; i < end; ++i) {
        char = C.JSString_methods.codeUnitAt$1(host, i);
        if (char === 58) {
          if (i === start) {
            ++i;
            if (C.JSString_methods.codeUnitAt$1(host, i) !== 58)
              error.call$2("invalid start colon.", i);
            partStart = i;
          }
          if (i === partStart) {
            if (wildcardSeen)
              error.call$2("only one wildcard `::` is allowed", i);
            parts.push(-1);
            wildcardSeen = true;
          } else
            parts.push(parseHex.call$2(partStart, i));
          partStart = i + 1;
        } else if (char === 46)
          seenDot = true;
      }
      if (parts.length === 0)
        error.call$1("too few parts");
      atEnd = partStart === end;
      t1 = C.JSArray_methods.get$last(parts);
      if (atEnd && t1 !== -1)
        error.call$2("expected a part after last `:`", end);
      if (!atEnd)
        if (!seenDot)
          parts.push(parseHex.call$2(partStart, end));
        else {
          last = P.Uri__parseIPv4Address(host, partStart, end);
          parts.push((last[0] << 8 | last[1]) >>> 0);
          parts.push((last[2] << 8 | last[3]) >>> 0);
        }
      if (wildcardSeen) {
        if (parts.length > 7)
          error.call$1("an address with a wildcard must have less than 7 parts");
      } else if (parts.length !== 8)
        error.call$1("an address without a wildcard must contain exactly 8 parts");
      bytes = new Uint8Array(16);
      for (t1 = parts.length, wildCardLength = 9 - t1, i = 0, index = 0; i < t1; ++i) {
        value = parts[i];
        if (value === -1)
          for (j = 0; j < wildCardLength; ++j) {
            bytes[index] = 0;
            bytes[index + 1] = 0;
            index += 2;
          }
        else {
          bytes[index] = C.JSInt_methods._shrOtherPositive$1(value, 8);
          bytes[index + 1] = value & 255;
          index += 2;
        }
      }
      return bytes;
    },
    _Uri__Uri$notSimple: function(uri, start, end, schemeEnd, hostStart, portStart, pathStart, queryStart, fragmentStart, scheme) {
      var userInfoStart, userInfo, host, t1, port, path, query, _null = null;
      if (scheme == null)
        if (schemeEnd > start)
          scheme = P._Uri__makeScheme(uri, start, schemeEnd);
        else {
          if (schemeEnd === start)
            P._Uri__fail(uri, start, "Invalid empty scheme");
          scheme = "";
        }
      if (hostStart > start) {
        userInfoStart = schemeEnd + 3;
        userInfo = userInfoStart < hostStart ? P._Uri__makeUserInfo(uri, userInfoStart, hostStart - 1) : "";
        host = P._Uri__makeHost(uri, hostStart, portStart, false);
        t1 = portStart + 1;
        port = t1 < pathStart ? P._Uri__makePort(P.int_parse(J.substring$2$s(uri, t1, pathStart), new P._Uri__Uri$notSimple_closure(uri, portStart), _null), scheme) : _null;
      } else {
        port = _null;
        host = port;
        userInfo = "";
      }
      path = P._Uri__makePath(uri, pathStart, queryStart, _null, scheme, host != null);
      query = queryStart < fragmentStart ? P._Uri__makeQuery(uri, queryStart + 1, fragmentStart, _null) : _null;
      return new P._Uri(scheme, userInfo, host, port, path, query, fragmentStart < end ? P._Uri__makeFragment(uri, fragmentStart + 1, end) : _null);
    },
    _Uri__Uri: function(host, path, pathSegments, scheme) {
      var userInfo, query, fragment, port, isFile, t1, hasAuthority, t2, _null = null;
      scheme = P._Uri__makeScheme(scheme, 0, scheme == null ? 0 : scheme.length);
      userInfo = P._Uri__makeUserInfo(_null, 0, 0);
      host = P._Uri__makeHost(host, 0, host == null ? 0 : host.length, false);
      query = P._Uri__makeQuery(_null, 0, 0, _null);
      fragment = P._Uri__makeFragment(_null, 0, 0);
      port = P._Uri__makePort(_null, scheme);
      isFile = scheme === "file";
      if (host == null)
        t1 = userInfo.length !== 0 || port != null || isFile;
      else
        t1 = false;
      if (t1)
        host = "";
      t1 = host == null;
      hasAuthority = !t1;
      path = P._Uri__makePath(path, 0, path == null ? 0 : path.length, pathSegments, scheme, hasAuthority);
      t2 = scheme.length === 0;
      if (t2 && t1 && !C.JSString_methods.startsWith$1(path, "/"))
        path = P._Uri__normalizeRelativePath(path, !t2 || hasAuthority);
      else
        path = P._Uri__removeDotSegments(path);
      return new P._Uri(scheme, userInfo, t1 && C.JSString_methods.startsWith$1(path, "//") ? "" : host, port, path, query, fragment);
    },
    _Uri__defaultPort: function(scheme) {
      if (scheme === "http")
        return 80;
      if (scheme === "https")
        return 443;
      return 0;
    },
    _Uri__fail: function(uri, index, message) {
      throw H.wrapException(P.FormatException$(message, uri, index));
    },
    _Uri__Uri$file: function(path, windows) {
      return windows ? P._Uri__makeWindowsFileUrl(path, false) : P._Uri__makeFileUri(path, false);
    },
    _Uri__checkNonWindowsPathReservedCharacters: function(segments, argumentError) {
      C.JSArray_methods.forEach$1(segments, new P._Uri__checkNonWindowsPathReservedCharacters_closure(false));
    },
    _Uri__checkWindowsPathReservedCharacters: function(segments, argumentError, firstSegment) {
      var t1, t2, t3;
      for (t1 = H.SubListIterable$(segments, firstSegment, null, H.getTypeArgumentByIndex(segments, 0)), t1 = new H.ListIterator(t1, t1.get$length(t1)); t1.moveNext$0();) {
        t2 = t1.__internal$_current;
        t3 = P.RegExp_RegExp('["*/:<>?\\\\|]', false);
        t2.length;
        if (H.stringContainsUnchecked(t2, t3, 0))
          if (argumentError)
            throw H.wrapException(P.ArgumentError$("Illegal character in path"));
          else
            throw H.wrapException(P.UnsupportedError$("Illegal character in path: " + H.S(t2)));
      }
    },
    _Uri__checkWindowsDriveLetter: function(charCode, argumentError) {
      var t1,
        _s21_ = "Illegal drive letter ";
      if (!(65 <= charCode && charCode <= 90))
        t1 = 97 <= charCode && charCode <= 122;
      else
        t1 = true;
      if (t1)
        return;
      if (argumentError)
        throw H.wrapException(P.ArgumentError$(_s21_ + P.String_String$fromCharCode(charCode)));
      else
        throw H.wrapException(P.UnsupportedError$(_s21_ + P.String_String$fromCharCode(charCode)));
    },
    _Uri__makeFileUri: function(path, slashTerminated) {
      var _null = null,
        segments = H.setRuntimeTypeInfo(path.split("/"), [P.String]);
      if (C.JSString_methods.startsWith$1(path, "/"))
        return P._Uri__Uri(_null, _null, segments, "file");
      else
        return P._Uri__Uri(_null, _null, segments, _null);
    },
    _Uri__makeWindowsFileUrl: function(path, slashTerminated) {
      var t1, pathSegments, pathStart, hostPart, _s1_ = "\\", _null = null, _s4_ = "file";
      if (C.JSString_methods.startsWith$1(path, "\\\\?\\"))
        if (C.JSString_methods.startsWith$2(path, "UNC\\", 4))
          path = C.JSString_methods.replaceRange$3(path, 0, 7, _s1_);
        else {
          path = C.JSString_methods.substring$1(path, 4);
          if (path.length < 3 || C.JSString_methods._codeUnitAt$1(path, 1) !== 58 || C.JSString_methods._codeUnitAt$1(path, 2) !== 92)
            throw H.wrapException(P.ArgumentError$("Windows paths with \\\\?\\ prefix must be absolute"));
        }
      else
        path = H.stringReplaceAllUnchecked(path, "/", _s1_);
      t1 = path.length;
      if (t1 > 1 && C.JSString_methods._codeUnitAt$1(path, 1) === 58) {
        P._Uri__checkWindowsDriveLetter(C.JSString_methods._codeUnitAt$1(path, 0), true);
        if (t1 === 2 || C.JSString_methods._codeUnitAt$1(path, 2) !== 92)
          throw H.wrapException(P.ArgumentError$("Windows paths with drive letter must be absolute"));
        pathSegments = H.setRuntimeTypeInfo(path.split(_s1_), [P.String]);
        P._Uri__checkWindowsPathReservedCharacters(pathSegments, true, 1);
        return P._Uri__Uri(_null, _null, pathSegments, _s4_);
      }
      if (C.JSString_methods.startsWith$1(path, _s1_))
        if (C.JSString_methods.startsWith$2(path, _s1_, 1)) {
          pathStart = C.JSString_methods.indexOf$2(path, _s1_, 2);
          t1 = pathStart < 0;
          hostPart = t1 ? C.JSString_methods.substring$1(path, 2) : C.JSString_methods.substring$2(path, 2, pathStart);
          pathSegments = H.setRuntimeTypeInfo((t1 ? "" : C.JSString_methods.substring$1(path, pathStart + 1)).split(_s1_), [P.String]);
          P._Uri__checkWindowsPathReservedCharacters(pathSegments, true, 0);
          return P._Uri__Uri(hostPart, _null, pathSegments, _s4_);
        } else {
          pathSegments = H.setRuntimeTypeInfo(path.split(_s1_), [P.String]);
          P._Uri__checkWindowsPathReservedCharacters(pathSegments, true, 0);
          return P._Uri__Uri(_null, _null, pathSegments, _s4_);
        }
      else {
        pathSegments = H.setRuntimeTypeInfo(path.split(_s1_), [P.String]);
        P._Uri__checkWindowsPathReservedCharacters(pathSegments, true, 0);
        return P._Uri__Uri(_null, _null, pathSegments, _null);
      }
    },
    _Uri__makePort: function(port, scheme) {
      if (port != null && port === P._Uri__defaultPort(scheme))
        return;
      return port;
    },
    _Uri__makeHost: function(host, start, end, strictIPv6) {
      var t1, i;
      if (host == null)
        return;
      if (start === end)
        return "";
      if (C.JSString_methods.codeUnitAt$1(host, start) === 91) {
        t1 = end - 1;
        if (C.JSString_methods.codeUnitAt$1(host, t1) !== 93)
          P._Uri__fail(host, start, "Missing end `]` to match `[` in host");
        P.Uri_parseIPv6Address(host, start + 1, t1);
        return C.JSString_methods.substring$2(host, start, end).toLowerCase();
      }
      for (i = start; i < end; ++i)
        if (C.JSString_methods.codeUnitAt$1(host, i) === 58) {
          P.Uri_parseIPv6Address(host, start, end);
          return "[" + host + "]";
        }
      return P._Uri__normalizeRegName(host, start, end);
    },
    _Uri__normalizeRegName: function(host, start, end) {
      var index, sectionStart, buffer, isNormalized, char, replacement, t1, slice, t2, sourceLength, tail;
      for (index = start, sectionStart = index, buffer = null, isNormalized = true; index < end;) {
        char = C.JSString_methods.codeUnitAt$1(host, index);
        if (char === 37) {
          replacement = P._Uri__normalizeEscape(host, index, true);
          t1 = replacement == null;
          if (t1 && isNormalized) {
            index += 3;
            continue;
          }
          if (buffer == null)
            buffer = new P.StringBuffer("");
          slice = C.JSString_methods.substring$2(host, sectionStart, index);
          t2 = buffer._contents += !isNormalized ? slice.toLowerCase() : slice;
          if (t1) {
            replacement = C.JSString_methods.substring$2(host, index, index + 3);
            sourceLength = 3;
          } else if (replacement === "%") {
            replacement = "%25";
            sourceLength = 1;
          } else
            sourceLength = 3;
          buffer._contents = t2 + replacement;
          index += sourceLength;
          sectionStart = index;
          isNormalized = true;
        } else if (char < 127 && (C.List_qNA[char >>> 4] & 1 << (char & 15)) !== 0) {
          if (isNormalized && 65 <= char && 90 >= char) {
            if (buffer == null)
              buffer = new P.StringBuffer("");
            if (sectionStart < index) {
              buffer._contents += C.JSString_methods.substring$2(host, sectionStart, index);
              sectionStart = index;
            }
            isNormalized = false;
          }
          ++index;
        } else if (char <= 93 && (C.List_2Vk[char >>> 4] & 1 << (char & 15)) !== 0)
          P._Uri__fail(host, index, "Invalid character");
        else {
          if ((char & 64512) === 55296 && index + 1 < end) {
            tail = C.JSString_methods.codeUnitAt$1(host, index + 1);
            if ((tail & 64512) === 56320) {
              char = 65536 | (char & 1023) << 10 | tail & 1023;
              sourceLength = 2;
            } else
              sourceLength = 1;
          } else
            sourceLength = 1;
          if (buffer == null)
            buffer = new P.StringBuffer("");
          slice = C.JSString_methods.substring$2(host, sectionStart, index);
          buffer._contents += !isNormalized ? slice.toLowerCase() : slice;
          buffer._contents += P._Uri__escapeChar(char);
          index += sourceLength;
          sectionStart = index;
        }
      }
      if (buffer == null)
        return C.JSString_methods.substring$2(host, start, end);
      if (sectionStart < end) {
        slice = C.JSString_methods.substring$2(host, sectionStart, end);
        buffer._contents += !isNormalized ? slice.toLowerCase() : slice;
      }
      t1 = buffer._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    _Uri__makeScheme: function(scheme, start, end) {
      var i, containsUpperCase, codeUnit;
      if (start === end)
        return "";
      if (!P._Uri__isAlphabeticCharacter(J.getInterceptor$s(scheme)._codeUnitAt$1(scheme, start)))
        P._Uri__fail(scheme, start, "Scheme not starting with alphabetic character");
      for (i = start, containsUpperCase = false; i < end; ++i) {
        codeUnit = C.JSString_methods._codeUnitAt$1(scheme, i);
        if (!(codeUnit < 128 && (C.List_JYB[codeUnit >>> 4] & 1 << (codeUnit & 15)) !== 0))
          P._Uri__fail(scheme, i, "Illegal scheme character");
        if (65 <= codeUnit && codeUnit <= 90)
          containsUpperCase = true;
      }
      scheme = C.JSString_methods.substring$2(scheme, start, end);
      return P._Uri__canonicalizeScheme(containsUpperCase ? scheme.toLowerCase() : scheme);
    },
    _Uri__canonicalizeScheme: function(scheme) {
      if (scheme === "http")
        return "http";
      if (scheme === "file")
        return "file";
      if (scheme === "https")
        return "https";
      if (scheme === "package")
        return "package";
      return scheme;
    },
    _Uri__makeUserInfo: function(userInfo, start, end) {
      if (userInfo == null)
        return "";
      return P._Uri__normalizeOrSubstring(userInfo, start, end, C.List_gRj, false);
    },
    _Uri__makePath: function(path, start, end, pathSegments, scheme, hasAuthority) {
      var result,
        isFile = scheme === "file",
        ensureLeadingSlash = isFile || hasAuthority,
        t1 = path == null;
      if (t1 && pathSegments == null)
        return isFile ? "/" : "";
      t1 = !t1;
      if (t1 && pathSegments != null)
        throw H.wrapException(P.ArgumentError$("Both path and pathSegments specified"));
      if (t1)
        result = P._Uri__normalizeOrSubstring(path, start, end, C.List_qg4, true);
      else {
        pathSegments.toString;
        result = new H.MappedListIterable(pathSegments, new P._Uri__makePath_closure(), [H.getTypeArgumentByIndex(pathSegments, 0), P.String]).join$1(0, "/");
      }
      if (result.length === 0) {
        if (isFile)
          return "/";
      } else if (ensureLeadingSlash && !C.JSString_methods.startsWith$1(result, "/"))
        result = "/" + result;
      return P._Uri__normalizePath(result, scheme, hasAuthority);
    },
    _Uri__normalizePath: function(path, scheme, hasAuthority) {
      var t1 = scheme.length === 0;
      if (t1 && !hasAuthority && !C.JSString_methods.startsWith$1(path, "/"))
        return P._Uri__normalizeRelativePath(path, !t1 || hasAuthority);
      return P._Uri__removeDotSegments(path);
    },
    _Uri__makeQuery: function(query, start, end, queryParameters) {
      if (query != null)
        return P._Uri__normalizeOrSubstring(query, start, end, C.List_CVk, true);
      return;
    },
    _Uri__makeFragment: function(fragment, start, end) {
      if (fragment == null)
        return;
      return P._Uri__normalizeOrSubstring(fragment, start, end, C.List_CVk, true);
    },
    _Uri__normalizeEscape: function(source, index, lowerCase) {
      var firstDigit, secondDigit, firstDigitValue, secondDigitValue, value,
        t1 = index + 2;
      if (t1 >= source.length)
        return "%";
      firstDigit = C.JSString_methods.codeUnitAt$1(source, index + 1);
      secondDigit = C.JSString_methods.codeUnitAt$1(source, t1);
      firstDigitValue = H.hexDigitValue(firstDigit);
      secondDigitValue = H.hexDigitValue(secondDigit);
      if (firstDigitValue < 0 || secondDigitValue < 0)
        return "%";
      value = firstDigitValue * 16 + secondDigitValue;
      if (value < 127 && (C.List_nxB[C.JSInt_methods._shrOtherPositive$1(value, 4)] & 1 << (value & 15)) !== 0)
        return H.Primitives_stringFromCharCode(lowerCase && 65 <= value && 90 >= value ? (value | 32) >>> 0 : value);
      if (firstDigit >= 97 || secondDigit >= 97)
        return C.JSString_methods.substring$2(source, index, index + 3).toUpperCase();
      return;
    },
    _Uri__escapeChar: function(char) {
      var t1, codeUnits, flag, encodedBytes, index, byte,
        _s16_ = "0123456789ABCDEF";
      if (char < 128) {
        t1 = new Array(3);
        t1.fixed$length = Array;
        codeUnits = H.setRuntimeTypeInfo(t1, [P.int]);
        codeUnits[0] = 37;
        codeUnits[1] = C.JSString_methods._codeUnitAt$1(_s16_, char >>> 4);
        codeUnits[2] = C.JSString_methods._codeUnitAt$1(_s16_, char & 15);
      } else {
        if (char > 2047)
          if (char > 65535) {
            flag = 240;
            encodedBytes = 4;
          } else {
            flag = 224;
            encodedBytes = 3;
          }
        else {
          flag = 192;
          encodedBytes = 2;
        }
        t1 = new Array(3 * encodedBytes);
        t1.fixed$length = Array;
        codeUnits = H.setRuntimeTypeInfo(t1, [P.int]);
        for (index = 0; --encodedBytes, encodedBytes >= 0; flag = 128) {
          byte = C.JSInt_methods._shrReceiverPositive$1(char, 6 * encodedBytes) & 63 | flag;
          codeUnits[index] = 37;
          codeUnits[index + 1] = C.JSString_methods._codeUnitAt$1(_s16_, byte >>> 4);
          codeUnits[index + 2] = C.JSString_methods._codeUnitAt$1(_s16_, byte & 15);
          index += 3;
        }
      }
      return P.String_String$fromCharCodes(codeUnits, 0, null);
    },
    _Uri__normalizeOrSubstring: function(component, start, end, charTable, escapeDelimiters) {
      var t1 = P._Uri__normalize(component, start, end, charTable, escapeDelimiters);
      return t1 == null ? C.JSString_methods.substring$2(component, start, end) : t1;
    },
    _Uri__normalize: function(component, start, end, charTable, escapeDelimiters) {
      var t1, index, sectionStart, buffer, char, replacement, sourceLength, t2, tail;
      for (t1 = !escapeDelimiters, index = start, sectionStart = index, buffer = null; index < end;) {
        char = C.JSString_methods.codeUnitAt$1(component, index);
        if (char < 127 && (charTable[char >>> 4] & 1 << (char & 15)) !== 0)
          ++index;
        else {
          if (char === 37) {
            replacement = P._Uri__normalizeEscape(component, index, false);
            if (replacement == null) {
              index += 3;
              continue;
            }
            if ("%" === replacement) {
              replacement = "%25";
              sourceLength = 1;
            } else
              sourceLength = 3;
          } else if (t1 && char <= 93 && (C.List_2Vk[char >>> 4] & 1 << (char & 15)) !== 0) {
            P._Uri__fail(component, index, "Invalid character");
            replacement = null;
            sourceLength = null;
          } else {
            if ((char & 64512) === 55296) {
              t2 = index + 1;
              if (t2 < end) {
                tail = C.JSString_methods.codeUnitAt$1(component, t2);
                if ((tail & 64512) === 56320) {
                  char = 65536 | (char & 1023) << 10 | tail & 1023;
                  sourceLength = 2;
                } else
                  sourceLength = 1;
              } else
                sourceLength = 1;
            } else
              sourceLength = 1;
            replacement = P._Uri__escapeChar(char);
          }
          if (buffer == null)
            buffer = new P.StringBuffer("");
          buffer._contents += C.JSString_methods.substring$2(component, sectionStart, index);
          buffer._contents += H.S(replacement);
          index += sourceLength;
          sectionStart = index;
        }
      }
      if (buffer == null)
        return;
      if (sectionStart < end)
        buffer._contents += C.JSString_methods.substring$2(component, sectionStart, end);
      t1 = buffer._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    _Uri__mayContainDotSegments: function(path) {
      if (C.JSString_methods.startsWith$1(path, "."))
        return true;
      return C.JSString_methods.indexOf$1(path, "/.") !== -1;
    },
    _Uri__removeDotSegments: function(path) {
      var output, t1, t2, appendSlash, _i, segment;
      if (!P._Uri__mayContainDotSegments(path))
        return path;
      output = H.setRuntimeTypeInfo([], [P.String]);
      for (t1 = path.split("/"), t2 = t1.length, appendSlash = false, _i = 0; _i < t2; ++_i) {
        segment = t1[_i];
        if (J.$eq$(segment, "..")) {
          if (output.length !== 0) {
            output.pop();
            if (output.length === 0)
              output.push("");
          }
          appendSlash = true;
        } else if ("." === segment)
          appendSlash = true;
        else {
          output.push(segment);
          appendSlash = false;
        }
      }
      if (appendSlash)
        output.push("");
      return C.JSArray_methods.join$1(output, "/");
    },
    _Uri__normalizeRelativePath: function(path, allowScheme) {
      var output, t1, t2, appendSlash, _i, segment;
      if (!P._Uri__mayContainDotSegments(path))
        return !allowScheme ? P._Uri__escapeScheme(path) : path;
      output = H.setRuntimeTypeInfo([], [P.String]);
      for (t1 = path.split("/"), t2 = t1.length, appendSlash = false, _i = 0; _i < t2; ++_i) {
        segment = t1[_i];
        if (".." === segment)
          if (output.length !== 0 && C.JSArray_methods.get$last(output) !== "..") {
            output.pop();
            appendSlash = true;
          } else {
            output.push("..");
            appendSlash = false;
          }
        else if ("." === segment)
          appendSlash = true;
        else {
          output.push(segment);
          appendSlash = false;
        }
      }
      t1 = output.length;
      if (t1 !== 0)
        t1 = t1 === 1 && output[0].length === 0;
      else
        t1 = true;
      if (t1)
        return "./";
      if (appendSlash || C.JSArray_methods.get$last(output) === "..")
        output.push("");
      if (!allowScheme)
        output[0] = P._Uri__escapeScheme(output[0]);
      return C.JSArray_methods.join$1(output, "/");
    },
    _Uri__escapeScheme: function(path) {
      var i, char,
        t1 = path.length;
      if (t1 >= 2 && P._Uri__isAlphabeticCharacter(J._codeUnitAt$1$s(path, 0)))
        for (i = 1; i < t1; ++i) {
          char = C.JSString_methods._codeUnitAt$1(path, i);
          if (char === 58)
            return C.JSString_methods.substring$2(path, 0, i) + "%3A" + C.JSString_methods.substring$1(path, i + 1);
          if (char > 127 || (C.List_JYB[char >>> 4] & 1 << (char & 15)) === 0)
            break;
        }
      return path;
    },
    _Uri__toWindowsFilePath: function(uri) {
      var hasDriveLetter, t2, host,
        segments = uri.get$pathSegments(),
        t1 = segments.length;
      if (t1 > 0 && J.get$length$asx(segments[0]) === 2 && J.codeUnitAt$1$s(segments[0], 1) === 58) {
        P._Uri__checkWindowsDriveLetter(J.codeUnitAt$1$s(segments[0], 0), false);
        P._Uri__checkWindowsPathReservedCharacters(segments, false, 1);
        hasDriveLetter = true;
      } else {
        P._Uri__checkWindowsPathReservedCharacters(segments, false, 0);
        hasDriveLetter = false;
      }
      t2 = uri.get$hasAbsolutePath() && !hasDriveLetter ? "\\" : "";
      if (uri.get$hasAuthority()) {
        host = uri.get$host();
        if (host.length !== 0)
          t2 = t2 + "\\" + H.S(host) + "\\";
      }
      t2 = P.StringBuffer__writeAll(t2, segments, "\\");
      t1 = hasDriveLetter && t1 === 1 ? t2 + "\\" : t2;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    _Uri__hexCharPairToByte: function(s, pos) {
      var byte, i, charCode;
      for (byte = 0, i = 0; i < 2; ++i) {
        charCode = C.JSString_methods._codeUnitAt$1(s, pos + i);
        if (48 <= charCode && charCode <= 57)
          byte = byte * 16 + charCode - 48;
        else {
          charCode |= 32;
          if (97 <= charCode && charCode <= 102)
            byte = byte * 16 + charCode - 87;
          else
            throw H.wrapException(P.ArgumentError$("Invalid URL encoding"));
        }
      }
      return byte;
    },
    _Uri__uriDecode: function(text, start, end, encoding, plusToSpace) {
      var simple, codeUnit, t2, bytes,
        t1 = J.getInterceptor$s(text),
        i = start;
      while (true) {
        if (!(i < end)) {
          simple = true;
          break;
        }
        codeUnit = t1._codeUnitAt$1(text, i);
        if (codeUnit <= 127)
          if (codeUnit !== 37)
            t2 = false;
          else
            t2 = true;
        else
          t2 = true;
        if (t2) {
          simple = false;
          break;
        }
        ++i;
      }
      if (simple) {
        if (C.C_Utf8Codec !== encoding)
          t2 = false;
        else
          t2 = true;
        if (t2)
          return t1.substring$2(text, start, end);
        else
          bytes = new H.CodeUnits(t1.substring$2(text, start, end));
      } else {
        bytes = H.setRuntimeTypeInfo([], [P.int]);
        for (i = start; i < end; ++i) {
          codeUnit = t1._codeUnitAt$1(text, i);
          if (codeUnit > 127)
            throw H.wrapException(P.ArgumentError$("Illegal percent encoding in URI"));
          if (codeUnit === 37) {
            if (i + 3 > text.length)
              throw H.wrapException(P.ArgumentError$("Truncated URI"));
            bytes.push(P._Uri__hexCharPairToByte(text, i + 1));
            i += 2;
          } else
            bytes.push(codeUnit);
        }
      }
      return new P.Utf8Decoder(false).convert$1(bytes);
    },
    _Uri__isAlphabeticCharacter: function(codeUnit) {
      var lowerCase = codeUnit | 32;
      return 97 <= lowerCase && lowerCase <= 122;
    },
    UriData__writeUri: function(mimeType, charsetName, parameters, buffer, indices) {
      var t1, slashIndex;
      if (mimeType == null || mimeType === "text/plain")
        mimeType = "";
      if (mimeType.length === 0 || mimeType === "application/octet-stream")
        t1 = buffer._contents += mimeType;
      else {
        slashIndex = P.UriData__validateMimeType(mimeType);
        if (slashIndex < 0)
          throw H.wrapException(P.ArgumentError$value(mimeType, "mimeType", "Invalid MIME type"));
        t1 = buffer._contents += H.S(P._Uri__uriEncode(C.List_qFt, C.JSString_methods.substring$2(mimeType, 0, slashIndex), C.C_Utf8Codec, false));
        buffer._contents = t1 + "/";
        t1 = buffer._contents += H.S(P._Uri__uriEncode(C.List_qFt, C.JSString_methods.substring$1(mimeType, slashIndex + 1), C.C_Utf8Codec, false));
      }
      if (charsetName != null) {
        indices.push(t1.length);
        indices.push(buffer._contents.length + 8);
        buffer._contents += ";charset=";
        buffer._contents += H.S(P._Uri__uriEncode(C.List_qFt, charsetName, C.C_Utf8Codec, false));
      }
    },
    UriData__validateMimeType: function(mimeType) {
      var t1, slashIndex, i;
      for (t1 = mimeType.length, slashIndex = -1, i = 0; i < t1; ++i) {
        if (C.JSString_methods._codeUnitAt$1(mimeType, i) !== 47)
          continue;
        if (slashIndex < 0) {
          slashIndex = i;
          continue;
        }
        return -1;
      }
      return slashIndex;
    },
    UriData__parse: function(text, start, sourceUri) {
      var t1, i, slashIndex, char, equalsIndex, lastSeparator, t2, data,
        _s17_ = "Invalid MIME type",
        indices = H.setRuntimeTypeInfo([start - 1], [P.int]);
      for (t1 = text.length, i = start, slashIndex = -1, char = null; i < t1; ++i) {
        char = C.JSString_methods._codeUnitAt$1(text, i);
        if (char === 44 || char === 59)
          break;
        if (char === 47) {
          if (slashIndex < 0) {
            slashIndex = i;
            continue;
          }
          throw H.wrapException(P.FormatException$(_s17_, text, i));
        }
      }
      if (slashIndex < 0 && i > start)
        throw H.wrapException(P.FormatException$(_s17_, text, i));
      for (; char !== 44;) {
        indices.push(i);
        ++i;
        for (equalsIndex = -1; i < t1; ++i) {
          char = C.JSString_methods._codeUnitAt$1(text, i);
          if (char === 61) {
            if (equalsIndex < 0)
              equalsIndex = i;
          } else if (char === 59 || char === 44)
            break;
        }
        if (equalsIndex >= 0)
          indices.push(equalsIndex);
        else {
          lastSeparator = C.JSArray_methods.get$last(indices);
          if (char !== 44 || i !== lastSeparator + 7 || !C.JSString_methods.startsWith$2(text, "base64", lastSeparator + 1))
            throw H.wrapException(P.FormatException$("Expecting '='", text, i));
          break;
        }
      }
      indices.push(i);
      t2 = i + 1;
      if ((indices.length & 1) === 1)
        text = C.C_Base64Codec.normalize$3(text, t2, t1);
      else {
        data = P._Uri__normalize(text, t2, t1, C.List_CVk, true);
        if (data != null)
          text = C.JSString_methods.replaceRange$3(text, t2, t1, data);
      }
      return new P.UriData(text, indices, sourceUri);
    },
    UriData__uriEncodeBytes: function(canonicalTable, bytes, buffer) {
      var t1, byteOr, i, byte,
        _s16_ = "0123456789ABCDEF";
      for (t1 = J.getInterceptor$asx(bytes), byteOr = 0, i = 0; i < t1.get$length(bytes); ++i) {
        byte = t1.$index(bytes, i);
        byteOr |= byte;
        if (byte < 128 && (canonicalTable[C.JSInt_methods._shrOtherPositive$1(byte, 4)] & 1 << (byte & 15)) !== 0)
          buffer._contents += H.Primitives_stringFromCharCode(byte);
        else {
          buffer._contents += H.Primitives_stringFromCharCode(37);
          buffer._contents += H.Primitives_stringFromCharCode(C.JSString_methods._codeUnitAt$1(_s16_, C.JSInt_methods._shrOtherPositive$1(byte, 4)));
          buffer._contents += H.Primitives_stringFromCharCode(C.JSString_methods._codeUnitAt$1(_s16_, byte & 15));
        }
      }
      if ((byteOr & 4294967040) >>> 0 !== 0)
        for (i = 0; i < t1.get$length(bytes); ++i) {
          byte = t1.$index(bytes, i);
          if (byte < 0 || byte > 255)
            throw H.wrapException(P.ArgumentError$value(byte, "non-byte value", null));
        }
    },
    _createTables: function() {
      var _s77_ = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=",
        _s1_ = ".", _s1_0 = ":", _s1_1 = "/", _s1_2 = "?", _s1_3 = "#",
        tables = P.List_List$generate(22, new P._createTables_closure(), true, P.Uint8List),
        t1 = new P._createTables_build(tables),
        t2 = new P._createTables_setChars(),
        t3 = new P._createTables_setRange(),
        b = t1.call$2(0, 225);
      t2.call$3(b, _s77_, 1);
      t2.call$3(b, _s1_, 14);
      t2.call$3(b, _s1_0, 34);
      t2.call$3(b, _s1_1, 3);
      t2.call$3(b, _s1_2, 172);
      t2.call$3(b, _s1_3, 205);
      b = t1.call$2(14, 225);
      t2.call$3(b, _s77_, 1);
      t2.call$3(b, _s1_, 15);
      t2.call$3(b, _s1_0, 34);
      t2.call$3(b, _s1_1, 234);
      t2.call$3(b, _s1_2, 172);
      t2.call$3(b, _s1_3, 205);
      b = t1.call$2(15, 225);
      t2.call$3(b, _s77_, 1);
      t2.call$3(b, "%", 225);
      t2.call$3(b, _s1_0, 34);
      t2.call$3(b, _s1_1, 9);
      t2.call$3(b, _s1_2, 172);
      t2.call$3(b, _s1_3, 205);
      b = t1.call$2(1, 225);
      t2.call$3(b, _s77_, 1);
      t2.call$3(b, _s1_0, 34);
      t2.call$3(b, _s1_1, 10);
      t2.call$3(b, _s1_2, 172);
      t2.call$3(b, _s1_3, 205);
      b = t1.call$2(2, 235);
      t2.call$3(b, _s77_, 139);
      t2.call$3(b, _s1_1, 131);
      t2.call$3(b, _s1_, 146);
      t2.call$3(b, _s1_2, 172);
      t2.call$3(b, _s1_3, 205);
      b = t1.call$2(3, 235);
      t2.call$3(b, _s77_, 11);
      t2.call$3(b, _s1_1, 68);
      t2.call$3(b, _s1_, 18);
      t2.call$3(b, _s1_2, 172);
      t2.call$3(b, _s1_3, 205);
      b = t1.call$2(4, 229);
      t2.call$3(b, _s77_, 5);
      t3.call$3(b, "AZ", 229);
      t2.call$3(b, _s1_0, 102);
      t2.call$3(b, "@", 68);
      t2.call$3(b, "[", 232);
      t2.call$3(b, _s1_1, 138);
      t2.call$3(b, _s1_2, 172);
      t2.call$3(b, _s1_3, 205);
      b = t1.call$2(5, 229);
      t2.call$3(b, _s77_, 5);
      t3.call$3(b, "AZ", 229);
      t2.call$3(b, _s1_0, 102);
      t2.call$3(b, "@", 68);
      t2.call$3(b, _s1_1, 138);
      t2.call$3(b, _s1_2, 172);
      t2.call$3(b, _s1_3, 205);
      b = t1.call$2(6, 231);
      t3.call$3(b, "19", 7);
      t2.call$3(b, "@", 68);
      t2.call$3(b, _s1_1, 138);
      t2.call$3(b, _s1_2, 172);
      t2.call$3(b, _s1_3, 205);
      b = t1.call$2(7, 231);
      t3.call$3(b, "09", 7);
      t2.call$3(b, "@", 68);
      t2.call$3(b, _s1_1, 138);
      t2.call$3(b, _s1_2, 172);
      t2.call$3(b, _s1_3, 205);
      t2.call$3(t1.call$2(8, 8), "]", 5);
      b = t1.call$2(9, 235);
      t2.call$3(b, _s77_, 11);
      t2.call$3(b, _s1_, 16);
      t2.call$3(b, _s1_1, 234);
      t2.call$3(b, _s1_2, 172);
      t2.call$3(b, _s1_3, 205);
      b = t1.call$2(16, 235);
      t2.call$3(b, _s77_, 11);
      t2.call$3(b, _s1_, 17);
      t2.call$3(b, _s1_1, 234);
      t2.call$3(b, _s1_2, 172);
      t2.call$3(b, _s1_3, 205);
      b = t1.call$2(17, 235);
      t2.call$3(b, _s77_, 11);
      t2.call$3(b, _s1_1, 9);
      t2.call$3(b, _s1_2, 172);
      t2.call$3(b, _s1_3, 205);
      b = t1.call$2(10, 235);
      t2.call$3(b, _s77_, 11);
      t2.call$3(b, _s1_, 18);
      t2.call$3(b, _s1_1, 234);
      t2.call$3(b, _s1_2, 172);
      t2.call$3(b, _s1_3, 205);
      b = t1.call$2(18, 235);
      t2.call$3(b, _s77_, 11);
      t2.call$3(b, _s1_, 19);
      t2.call$3(b, _s1_1, 234);
      t2.call$3(b, _s1_2, 172);
      t2.call$3(b, _s1_3, 205);
      b = t1.call$2(19, 235);
      t2.call$3(b, _s77_, 11);
      t2.call$3(b, _s1_1, 234);
      t2.call$3(b, _s1_2, 172);
      t2.call$3(b, _s1_3, 205);
      b = t1.call$2(11, 235);
      t2.call$3(b, _s77_, 11);
      t2.call$3(b, _s1_1, 10);
      t2.call$3(b, _s1_2, 172);
      t2.call$3(b, _s1_3, 205);
      b = t1.call$2(12, 236);
      t2.call$3(b, _s77_, 12);
      t2.call$3(b, _s1_2, 12);
      t2.call$3(b, _s1_3, 205);
      b = t1.call$2(13, 237);
      t2.call$3(b, _s77_, 13);
      t2.call$3(b, _s1_2, 13);
      t3.call$3(t1.call$2(20, 245), "az", 21);
      b = t1.call$2(21, 245);
      t3.call$3(b, "az", 21);
      t3.call$3(b, "09", 21);
      t2.call$3(b, "+-.", 21);
      return tables;
    },
    _scan: function(uri, start, end, state, indices) {
      var t1, i, table, char, transition,
        tables = $.$get$_scannerTables();
      for (t1 = J.getInterceptor$s(uri), i = start; i < end; ++i) {
        table = tables[state];
        char = t1._codeUnitAt$1(uri, i) ^ 96;
        transition = table[char > 95 ? 31 : char];
        state = transition & 31;
        indices[transition >>> 5] = i;
      }
      return state;
    },
    NoSuchMethodError_toString_closure: function NoSuchMethodError_toString_closure(t0, t1) {
      this._box_0 = t0;
      this.sb = t1;
    },
    bool: function bool() {
    },
    DateTime: function DateTime(t0, t1) {
      this._value = t0;
      this.isUtc = t1;
    },
    double: function double() {
    },
    Duration: function Duration(t0) {
      this._duration = t0;
    },
    Duration_toString_sixDigits: function Duration_toString_sixDigits() {
    },
    Duration_toString_twoDigits: function Duration_toString_twoDigits() {
    },
    Error: function Error() {
    },
    NullThrownError: function NullThrownError() {
    },
    ArgumentError: function ArgumentError(t0, t1, t2, t3) {
      var _ = this;
      _._hasValue = t0;
      _.invalidValue = t1;
      _.name = t2;
      _.message = t3;
    },
    RangeError: function RangeError(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _.start = t0;
      _.end = t1;
      _._hasValue = t2;
      _.invalidValue = t3;
      _.name = t4;
      _.message = t5;
    },
    IndexError: function IndexError(t0, t1, t2, t3, t4) {
      var _ = this;
      _.length = t0;
      _._hasValue = t1;
      _.invalidValue = t2;
      _.name = t3;
      _.message = t4;
    },
    NoSuchMethodError: function NoSuchMethodError(t0, t1, t2, t3) {
      var _ = this;
      _._receiver = t0;
      _._memberName = t1;
      _._arguments = t2;
      _._namedArguments = t3;
    },
    UnsupportedError: function UnsupportedError(t0) {
      this.message = t0;
    },
    UnimplementedError: function UnimplementedError(t0) {
      this.message = t0;
    },
    StateError: function StateError(t0) {
      this.message = t0;
    },
    ConcurrentModificationError: function ConcurrentModificationError(t0) {
      this.modifiedObject = t0;
    },
    OutOfMemoryError: function OutOfMemoryError() {
    },
    StackOverflowError: function StackOverflowError() {
    },
    CyclicInitializationError: function CyclicInitializationError(t0) {
      this.variableName = t0;
    },
    _Exception: function _Exception(t0) {
      this.message = t0;
    },
    FormatException: function FormatException(t0, t1, t2) {
      this.message = t0;
      this.source = t1;
      this.offset = t2;
    },
    Function: function Function() {
    },
    int: function int() {
    },
    Iterable: function Iterable() {
    },
    _GeneratorIterable: function _GeneratorIterable(t0, t1, t2) {
      this.length = t0;
      this._generator = t1;
      this.$ti = t2;
    },
    Iterator: function Iterator() {
    },
    List: function List() {
    },
    Map: function Map() {
    },
    MapEntry: function MapEntry(t0, t1, t2) {
      this.key = t0;
      this.value = t1;
      this.$ti = t2;
    },
    Null: function Null() {
    },
    num: function num() {
    },
    Object: function Object() {
    },
    Match: function Match() {
    },
    RegExpMatch: function RegExpMatch() {
    },
    Set: function Set() {
    },
    StackTrace: function StackTrace() {
    },
    _StringStackTrace: function _StringStackTrace(t0) {
      this._core$_stackTrace = t0;
    },
    String: function String() {
    },
    Runes: function Runes(t0) {
      this.string = t0;
    },
    RuneIterator: function RuneIterator(t0) {
      var _ = this;
      _.string = t0;
      _._nextPosition = _._core$_position = 0;
      _._currentCodePoint = null;
    },
    StringBuffer: function StringBuffer(t0) {
      this._contents = t0;
    },
    StringSink: function StringSink() {
    },
    Symbol: function Symbol() {
    },
    Uri: function Uri() {
    },
    Uri__parseIPv4Address_error: function Uri__parseIPv4Address_error(t0) {
      this.host = t0;
    },
    Uri_parseIPv6Address_error: function Uri_parseIPv6Address_error(t0) {
      this.host = t0;
    },
    Uri_parseIPv6Address_parseHex: function Uri_parseIPv6Address_parseHex(t0, t1) {
      this.error = t0;
      this.host = t1;
    },
    _Uri: function _Uri(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _.scheme = t0;
      _._userInfo = t1;
      _._host = t2;
      _._port = t3;
      _.path = t4;
      _._query = t5;
      _._fragment = t6;
      _._hashCodeCache = _._text = _._pathSegments = null;
    },
    _Uri__Uri$notSimple_closure: function _Uri__Uri$notSimple_closure(t0, t1) {
      this.uri = t0;
      this.portStart = t1;
    },
    _Uri__checkNonWindowsPathReservedCharacters_closure: function _Uri__checkNonWindowsPathReservedCharacters_closure(t0) {
      this.argumentError = t0;
    },
    _Uri__makePath_closure: function _Uri__makePath_closure() {
    },
    UriData: function UriData(t0, t1, t2) {
      this._text = t0;
      this._separatorIndices = t1;
      this._uriCache = t2;
    },
    _createTables_closure: function _createTables_closure() {
    },
    _createTables_build: function _createTables_build(t0) {
      this.tables = t0;
    },
    _createTables_setChars: function _createTables_setChars() {
    },
    _createTables_setRange: function _createTables_setRange() {
    },
    _SimpleUri: function _SimpleUri(t0, t1, t2, t3, t4, t5, t6, t7) {
      var _ = this;
      _._uri = t0;
      _._schemeEnd = t1;
      _._hostStart = t2;
      _._portStart = t3;
      _._pathStart = t4;
      _._queryStart = t5;
      _._fragmentStart = t6;
      _._schemeCache = t7;
      _._hashCodeCache = null;
    },
    _DataUri: function _DataUri(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _.scheme = t0;
      _._userInfo = t1;
      _._host = t2;
      _._port = t3;
      _.path = t4;
      _._query = t5;
      _._fragment = t6;
      _._hashCodeCache = _._text = _._pathSegments = null;
    },
    max: function(a, b) {
      return Math.max(H.checkNum(a), H.checkNum(b));
    },
    pow: function(x, exponent) {
      return Math.pow(x, exponent);
    },
    Random_Random: function() {
      return C.C__JSRandom;
    },
    _JSRandom: function _JSRandom() {
    },
    Uint8List: function Uint8List() {
    },
    _convertDartFunctionFast: function(f) {
      var ret,
        existing = f.$dart_jsFunction;
      if (existing != null)
        return existing;
      ret = function(_call, f) {
        return function() {
          return _call(f, Array.prototype.slice.apply(arguments));
        };
      }(P._callDartFunctionFast, f);
      ret[$.$get$DART_CLOSURE_PROPERTY_NAME()] = f;
      f.$dart_jsFunction = ret;
      return ret;
    },
    _convertDartFunctionFastCaptureThis: function(f) {
      var ret,
        existing = f._$dart_jsFunctionCaptureThis;
      if (existing != null)
        return existing;
      ret = function(_call, f) {
        return function() {
          return _call(f, this, Array.prototype.slice.apply(arguments));
        };
      }(P._callDartFunctionFastCaptureThis, f);
      ret[$.$get$DART_CLOSURE_PROPERTY_NAME()] = f;
      f._$dart_jsFunctionCaptureThis = ret;
      return ret;
    },
    _callDartFunctionFast: function(callback, $arguments) {
      return P.Function_apply(callback, $arguments);
    },
    _callDartFunctionFastCaptureThis: function(callback, $self, $arguments) {
      var t1 = [$self];
      C.JSArray_methods.addAll$1(t1, $arguments);
      return P.Function_apply(callback, t1);
    },
    allowInterop: function(f) {
      if (typeof f == "function")
        return f;
      else
        return P._convertDartFunctionFast(f);
    },
    allowInteropCaptureThis: function(f) {
      if (typeof f == "function")
        throw H.wrapException(P.ArgumentError$("Function is already a JS function so cannot capture this."));
      else
        return P._convertDartFunctionFastCaptureThis(f);
    },
    callConstructor: function(constr, $arguments) {
      var args, factoryFunction;
      if ($arguments instanceof Array)
        switch ($arguments.length) {
          case 0:
            return new constr();
          case 1:
            return new constr($arguments[0]);
          case 2:
            return new constr($arguments[0], $arguments[1]);
          case 3:
            return new constr($arguments[0], $arguments[1], $arguments[2]);
          case 4:
            return new constr($arguments[0], $arguments[1], $arguments[2], $arguments[3]);
        }
      args = [null];
      C.JSArray_methods.addAll$1(args, $arguments);
      factoryFunction = constr.bind.apply(constr, args);
      String(factoryFunction);
      return new factoryFunction();
    }
  },
  N = {ArgParser: function ArgParser(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _._arg_parser$_options = t0;
      _.options = t1;
      _.commands = t2;
      _._optionsAndSeparators = t3;
      _.allowTrailingOptions = t4;
      _.usageLineLength = t5;
    }, ArgParser_findByAbbreviation_closure: function ArgParser_findByAbbreviation_closure(t0) {
      this.abbr = t0;
    }, ArgParser_findByAbbreviation_closure0: function ArgParser_findByAbbreviation_closure0() {
    }, SupportsCondition: function SupportsCondition() {
    }, AttributeSelector: function AttributeSelector(t0, t1, t2, t3) {
      var _ = this;
      _.name = t0;
      _.op = t1;
      _.value = t2;
      _.modifier = t3;
    }, AttributeOperator: function AttributeOperator(t0) {
      this._attribute$_text = t0;
    }, IDSelector: function IDSelector(t0) {
      this.name = t0;
    }, IDSelector_unify_closure: function IDSelector_unify_closure(t0) {
      this.$this = t0;
    }, PlaceholderSelector: function PlaceholderSelector(t0) {
      this.name = t0;
    }, UniversalSelector: function UniversalSelector(t0) {
      this.namespace = t0;
    }, NoSourceMapBuffer: function NoSourceMapBuffer(t0) {
      this._no_source_map_buffer$_buffer = t0;
    },
    serialize: function(node, charset, indentWidth, inspect, lineFeed, sourceMap, style, useSpaces) {
      var t1, css, t2, prefix, t3,
        visitor = N._SerializeVisitor$(indentWidth == null ? 2 : indentWidth, inspect, lineFeed, true, sourceMap, style, useSpaces);
      node.accept$1(visitor);
      t1 = visitor._buffer;
      css = t1.toString$0(0);
      if (charset) {
        t2 = new H.CodeUnits(css);
        t2 = t2.any$1(t2, new N.serialize_closure());
      } else
        t2 = false;
      if (t2)
        prefix = style === C.OutputStyle_compressed ? "\ufeff" : '@charset "UTF-8";\n';
      else
        prefix = "";
      t2 = prefix + css;
      t3 = sourceMap ? t1.buildSourceMap$1$prefix(prefix) : null;
      if (sourceMap)
        t1.get$sourceFiles();
      return new N.SerializeResult(t2, t3);
    },
    serializeValue: function(value, inspect, quote) {
      var visitor = N._SerializeVisitor$(null, inspect, null, quote, false, null, true);
      value.accept$1(visitor);
      return visitor._buffer.toString$0(0);
    },
    _SerializeVisitor$: function(indentWidth, inspect, lineFeed, quote, sourceMap, style, useSpaces) {
      var t1 = sourceMap ? new D.SourceMapBuffer(new P.StringBuffer(""), H.setRuntimeTypeInfo([], [L.Entry]), P.LinkedHashMap_LinkedHashMap$_empty(P.Uri, Y.SourceFile)) : new N.NoSourceMapBuffer(new P.StringBuffer("")),
        t2 = style == null ? C.OutputStyle_expanded : style,
        t3 = useSpaces ? 32 : 9,
        t4 = indentWidth == null ? 2 : indentWidth,
        t5 = lineFeed == null ? C.LineFeed_D6m : lineFeed;
      P.RangeError_checkValueInInterval(t4, 0, 10, "indentWidth");
      return new N._SerializeVisitor(t1, t2, inspect, quote, t3, t4, t5);
    },
    serialize_closure: function serialize_closure() {
    },
    _SerializeVisitor: function _SerializeVisitor(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _._buffer = t0;
      _._indentation = 0;
      _._style = t1;
      _._inspect = t2;
      _._quote = t3;
      _._indentCharacter = t4;
      _._indentWidth = t5;
      _._lineFeed = t6;
    },
    _SerializeVisitor_visitCssComment_closure: function _SerializeVisitor_visitCssComment_closure(t0, t1) {
      this.$this = t0;
      this.node = t1;
    },
    _SerializeVisitor_visitCssAtRule_closure: function _SerializeVisitor_visitCssAtRule_closure(t0, t1) {
      this.$this = t0;
      this.node = t1;
    },
    _SerializeVisitor_visitCssMediaRule_closure: function _SerializeVisitor_visitCssMediaRule_closure(t0, t1) {
      this.$this = t0;
      this.node = t1;
    },
    _SerializeVisitor_visitCssImport_closure: function _SerializeVisitor_visitCssImport_closure(t0, t1) {
      this.$this = t0;
      this.node = t1;
    },
    _SerializeVisitor_visitCssImport__closure: function _SerializeVisitor_visitCssImport__closure(t0, t1) {
      this.$this = t0;
      this.node = t1;
    },
    _SerializeVisitor_visitCssKeyframeBlock_closure: function _SerializeVisitor_visitCssKeyframeBlock_closure(t0, t1) {
      this.$this = t0;
      this.node = t1;
    },
    _SerializeVisitor_visitCssStyleRule_closure: function _SerializeVisitor_visitCssStyleRule_closure(t0, t1) {
      this.$this = t0;
      this.node = t1;
    },
    _SerializeVisitor_visitCssSupportsRule_closure: function _SerializeVisitor_visitCssSupportsRule_closure(t0, t1) {
      this.$this = t0;
      this.node = t1;
    },
    _SerializeVisitor_visitCssDeclaration_closure: function _SerializeVisitor_visitCssDeclaration_closure(t0, t1) {
      this.$this = t0;
      this.node = t1;
    },
    _SerializeVisitor_visitCssDeclaration_closure0: function _SerializeVisitor_visitCssDeclaration_closure0(t0, t1) {
      this.$this = t0;
      this.node = t1;
    },
    _SerializeVisitor_visitList_closure: function _SerializeVisitor_visitList_closure() {
    },
    _SerializeVisitor_visitList_closure0: function _SerializeVisitor_visitList_closure0(t0, t1) {
      this.$this = t0;
      this.value = t1;
    },
    _SerializeVisitor_visitList_closure1: function _SerializeVisitor_visitList_closure1(t0) {
      this.$this = t0;
    },
    _SerializeVisitor_visitMap_closure: function _SerializeVisitor_visitMap_closure(t0, t1) {
      this.$this = t0;
      this.map = t1;
    },
    _SerializeVisitor_visitSelectorList_closure: function _SerializeVisitor_visitSelectorList_closure() {
    },
    _SerializeVisitor__write_closure: function _SerializeVisitor__write_closure(t0, t1) {
      this.$this = t0;
      this.value = t1;
    },
    _SerializeVisitor__visitChildren_closure: function _SerializeVisitor__visitChildren_closure(t0, t1, t2) {
      this._box_0 = t0;
      this.$this = t1;
      this.children = t2;
    },
    OutputStyle: function OutputStyle(t0) {
      this._serialize$_name = t0;
    },
    LineFeed: function LineFeed(t0, t1) {
      this.name = t0;
      this.text = t1;
    },
    SerializeResult: function SerializeResult(t0, t1) {
      this.css = t0;
      this.sourceMap = t1;
    },
    warn: function(message, deprecation) {
      var warnDefinition = $.Zone__current.$index(0, C.Symbol__warn);
      if (warnDefinition == null)
        throw H.wrapException(P.ArgumentError$("warn() may only be called within a custom function or importer callback."));
      warnDefinition.call$2(message, deprecation);
    },
    withWarnCallback: function(warn, callback) {
      return P.runZoned(new N.withWarnCallback_closure(callback), P.LinkedHashMap__makeLiteral([C.Symbol__warn, warn]));
    },
    withWarnCallback_closure: function withWarnCallback_closure(t0) {
      this.callback = t0;
    },
    UnparsedFrame: function UnparsedFrame(t0, t1) {
      this.uri = t0;
      this.member = t1;
    }
  },
  Z = {
    ArgParserException$: function(message, commands) {
      return new Z.ArgParserException(commands == null ? C.List_empty0 : P.List_List$unmodifiable(commands, P.String), message, null, null);
    },
    ArgParserException: function ArgParserException(t0, t1, t2, t3) {
      var _ = this;
      _.commands = t0;
      _.message = t1;
      _.source = t2;
      _.offset = t3;
    },
    Argument: function Argument(t0, t1, t2) {
      this.name = t0;
      this.defaultValue = t1;
      this.span = t2;
    },
    BooleanExpression: function BooleanExpression(t0, t1) {
      this.value = t0;
      this.span = t1;
    },
    VariableDeclaration$: function($name, expression, span, comment, global, guarded, namespace) {
      if (namespace != null && global)
        H.throwExpression(P.ArgumentError$("Other modules' members can't be defined with !global."));
      return new Z.VariableDeclaration(namespace, $name, expression, guarded, global, span);
    },
    VariableDeclaration: function VariableDeclaration(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _.namespace = t0;
      _.name = t1;
      _.expression = t2;
      _.isGuarded = t3;
      _.isGlobal = t4;
      _.span = t5;
    },
    InterpolationBuffer: function InterpolationBuffer(t0, t1) {
      this._interpolation_buffer$_text = t0;
      this._interpolation_buffer$_contents = t1;
    },
    RenderContext: function RenderContext() {
    },
    closure36: function closure36() {
    },
    _closure4: function _closure4() {
    },
    _closure5: function _closure5() {
    },
    MergedMapView$: function(maps, $K, $V) {
      var t1 = new Z.MergedMapView(P.LinkedHashMap_LinkedHashMap$_empty($K, [P.Map, $K, $V]), [$K, $V]);
      t1.MergedMapView$1(maps, $K, $V);
      return t1;
    },
    MergedMapView: function MergedMapView(t0, t1) {
      this._mapsByKey = t0;
      this.$ti = t1;
    },
    SassBoolean: function SassBoolean(t0) {
      this.value = t0;
    },
    LineScanner: function LineScanner(t0, t1) {
      var _ = this;
      _._line_scanner$_column = _._line_scanner$_line = 0;
      _.sourceUrl = t0;
      _.string = t1;
      _._string_scanner$_position = 0;
      _._lastMatchPosition = _._lastMatch = null;
    }
  },
  V = {
    ArgResults$_: function(_parser, _parsed, $name, command, rest, $arguments) {
      return new V.ArgResults(_parser, _parsed, $name, new P.UnmodifiableListView(rest, [P.String]));
    },
    ArgResults: function ArgResults(t0, t1, t2, t3) {
      var _ = this;
      _._parser = t0;
      _._parsed = t1;
      _.name = t2;
      _.rest = t3;
    },
    ErrorResult: function ErrorResult(t0, t1) {
      this.error = t0;
      this.stackTrace = t1;
    },
    ModifiableCssStylesheet: function ModifiableCssStylesheet(t0, t1, t2) {
      var _ = this;
      _.span = t0;
      _.children = t1;
      _._children = t2;
      _._indexInParent = _._parent = null;
      _.isGroupEnd = false;
    },
    CssStylesheet: function CssStylesheet(t0, t1) {
      this.children = t0;
      this.span = t1;
    },
    AtRootQuery: function AtRootQuery(t0, t1, t2, t3) {
      var _ = this;
      _.include = t0;
      _.names = t1;
      _._all = t2;
      _._at_root_query$_rule = t3;
    },
    BinaryOperationExpression: function BinaryOperationExpression(t0, t1, t2, t3) {
      var _ = this;
      _.operator = t0;
      _.left = t1;
      _.right = t2;
      _.allowsSlash = t3;
    },
    BinaryOperator: function BinaryOperator(t0, t1, t2) {
      this.name = t0;
      this.operator = t1;
      this.precedence = t2;
    },
    AtRootRule: function AtRootRule(t0, t1, t2, t3) {
      var _ = this;
      _.query = t0;
      _.span = t1;
      _.children = t2;
      _.hasDeclarations = t3;
    },
    EachRule: function EachRule(t0, t1, t2, t3, t4) {
      var _ = this;
      _.variables = t0;
      _.list = t1;
      _.span = t2;
      _.children = t3;
      _.hasDeclarations = t4;
    },
    EachRule_toString_closure: function EachRule_toString_closure() {
    },
    IfRule: function IfRule(t0, t1, t2) {
      this.clauses = t0;
      this.lastClause = t1;
      this.span = t2;
    },
    IfRule_toString_closure: function IfRule_toString_closure(t0) {
      this._box_0 = t0;
    },
    IfClause: function IfClause(t0, t1, t2) {
      this.expression = t0;
      this.children = t1;
      this.hasDeclarations = t2;
    },
    IfClause$__closure: function IfClause$__closure() {
    },
    Stylesheet$: function(children, span, plainCss) {
      var t1 = H.setRuntimeTypeInfo([], [T.UseRule]),
        t2 = H.setRuntimeTypeInfo([], [L.ForwardRule]),
        t3 = P.List_List$unmodifiable(children, O.Statement),
        t4 = C.JSArray_methods.any$1(t3, new M.ParentStatement_closure());
      t1 = new V.Stylesheet(span, plainCss, t1, t2, t3, t4);
      t1.Stylesheet$3$plainCss(children, span, plainCss);
      return t1;
    },
    Stylesheet_Stylesheet$parse: function(contents, syntax, logger, url) {
      var t1, t2, t3, t4;
      switch (syntax) {
        case C.Syntax_Sass:
          contents.toString;
          t1 = new H.CodeUnits(contents);
          t2 = H.setRuntimeTypeInfo([0], [P.int]);
          t3 = typeof url === "string";
          t4 = t3 ? P.Uri_parse(url) : url;
          t2 = new Y.SourceFile(t4, t2, new Uint32Array(H._ensureNativeList(t1.toList$0(t1))));
          t2.SourceFile$decoded$2$url(t1, url);
          t1 = t3 ? P.Uri_parse(url) : H.interceptedTypeCast(url, "$isUri");
          t3 = logger == null ? C.StderrLogger_false : logger;
          return new U.SassParser(P.LinkedHashMap_LinkedHashMap$_empty(P.String, Z.VariableDeclaration), new S.SpanScanner(t2, t1, contents), t3).parse$0();
        case C.Syntax_SCSS:
          t1 = S.SpanScanner$(contents, url);
          t2 = logger == null ? C.StderrLogger_false : logger;
          return new L.ScssParser(P.LinkedHashMap_LinkedHashMap$_empty(P.String, Z.VariableDeclaration), t1, t2).parse$0();
        case C.Syntax_CSS:
          contents.toString;
          t1 = new H.CodeUnits(contents);
          t2 = H.setRuntimeTypeInfo([0], [P.int]);
          t3 = typeof url === "string";
          t4 = t3 ? P.Uri_parse(url) : url;
          t2 = new Y.SourceFile(t4, t2, new Uint32Array(H._ensureNativeList(t1.toList$0(t1))));
          t2.SourceFile$decoded$2$url(t1, url);
          t1 = t3 ? P.Uri_parse(url) : H.interceptedTypeCast(url, "$isUri");
          t3 = logger == null ? C.StderrLogger_false : logger;
          return new Q.CssParser(P.LinkedHashMap_LinkedHashMap$_empty(P.String, Z.VariableDeclaration), new S.SpanScanner(t2, t1, contents), t3).parse$0();
        default:
          throw H.wrapException(P.ArgumentError$("Unknown syntax " + syntax.toString$0(0) + "."));
      }
    },
    Stylesheet: function Stylesheet(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _.span = t0;
      _.plainCss = t1;
      _._uses = t2;
      _._forwards = t3;
      _.children = t4;
      _.hasDeclarations = t5;
    },
    JSError: function JSError() {
    },
    AtRootQueryParser: function AtRootQueryParser(t0, t1) {
      this.scanner = t0;
      this.logger = t1;
    },
    AtRootQueryParser_parse_closure: function AtRootQueryParser_parse_closure(t0) {
      this.$this = t0;
    },
    StylesheetParser: function StylesheetParser() {
    },
    StylesheetParser_parse_closure: function StylesheetParser_parse_closure(t0) {
      this.$this = t0;
    },
    StylesheetParser_parse__closure: function StylesheetParser_parse__closure(t0) {
      this.$this = t0;
    },
    StylesheetParser_parse__closure0: function StylesheetParser_parse__closure0() {
    },
    StylesheetParser_parseArgumentDeclaration_closure: function StylesheetParser_parseArgumentDeclaration_closure(t0) {
      this.$this = t0;
    },
    StylesheetParser_parseExpression_closure: function StylesheetParser_parseExpression_closure(t0) {
      this.$this = t0;
    },
    StylesheetParser_parseVariableDeclaration_closure: function StylesheetParser_parseVariableDeclaration_closure(t0) {
      this.$this = t0;
    },
    StylesheetParser_parseSignature_closure: function StylesheetParser_parseSignature_closure(t0) {
      this.$this = t0;
    },
    StylesheetParser__statement_closure: function StylesheetParser__statement_closure(t0) {
      this.$this = t0;
    },
    StylesheetParser_variableDeclaration_closure: function StylesheetParser_variableDeclaration_closure(t0) {
      this.declaration = t0;
    },
    StylesheetParser__styleRule_closure: function StylesheetParser__styleRule_closure(t0) {
      this.selector = t0;
    },
    StylesheetParser__declarationOrStyleRule_closure: function StylesheetParser__declarationOrStyleRule_closure(t0, t1, t2, t3, t4) {
      var _ = this;
      _.$this = t0;
      _.selectorSpan = t1;
      _.wasInStyleRule = t2;
      _.buffer = t3;
      _.start = t4;
    },
    StylesheetParser__declarationOrBuffer_closure: function StylesheetParser__declarationOrBuffer_closure(t0) {
      this.name = t0;
    },
    StylesheetParser__declarationOrBuffer_closure0: function StylesheetParser__declarationOrBuffer_closure0(t0, t1) {
      this._box_0 = t0;
      this.name = t1;
    },
    StylesheetParser__declaration_closure: function StylesheetParser__declaration_closure(t0) {
      this._box_0 = t0;
    },
    StylesheetParser__declaration_closure0: function StylesheetParser__declaration_closure0(t0, t1) {
      this._box_0 = t0;
      this.value = t1;
    },
    StylesheetParser__atRootRule_closure: function StylesheetParser__atRootRule_closure(t0) {
      this.query = t0;
    },
    StylesheetParser__atRootRule_closure0: function StylesheetParser__atRootRule_closure0() {
    },
    StylesheetParser__eachRule_closure: function StylesheetParser__eachRule_closure(t0, t1, t2, t3) {
      var _ = this;
      _.$this = t0;
      _.wasInControlDirective = t1;
      _.variables = t2;
      _.list = t3;
    },
    StylesheetParser__functionRule_closure: function StylesheetParser__functionRule_closure(t0, t1, t2) {
      this.name = t0;
      this.$arguments = t1;
      this.precedingComment = t2;
    },
    StylesheetParser__forRule_closure: function StylesheetParser__forRule_closure(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    StylesheetParser__forRule_closure0: function StylesheetParser__forRule_closure0(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _._box_0 = t0;
      _.$this = t1;
      _.wasInControlDirective = t2;
      _.variable = t3;
      _.from = t4;
      _.to = t5;
    },
    StylesheetParser__memberList_closure: function StylesheetParser__memberList_closure(t0, t1, t2) {
      this.$this = t0;
      this.variables = t1;
      this.identifiers = t2;
    },
    StylesheetParser__includeRule_closure: function StylesheetParser__includeRule_closure(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    StylesheetParser_mediaRule_closure: function StylesheetParser_mediaRule_closure(t0) {
      this.query = t0;
    },
    StylesheetParser__mixinRule_closure: function StylesheetParser__mixinRule_closure(t0, t1, t2, t3) {
      var _ = this;
      _.$this = t0;
      _.name = t1;
      _.$arguments = t2;
      _.precedingComment = t3;
    },
    StylesheetParser_mozDocumentRule_closure: function StylesheetParser_mozDocumentRule_closure(t0, t1, t2, t3) {
      var _ = this;
      _._box_0 = t0;
      _.$this = t1;
      _.name = t2;
      _.value = t3;
    },
    StylesheetParser_supportsRule_closure: function StylesheetParser_supportsRule_closure(t0) {
      this.condition = t0;
    },
    StylesheetParser__whileRule_closure: function StylesheetParser__whileRule_closure(t0, t1, t2) {
      this.$this = t0;
      this.wasInControlDirective = t1;
      this.condition = t2;
    },
    StylesheetParser_unknownAtRule_closure: function StylesheetParser_unknownAtRule_closure(t0, t1) {
      this._box_0 = t0;
      this.name = t1;
    },
    StylesheetParser_expression_resetState: function StylesheetParser_expression_resetState(t0, t1, t2) {
      this._box_0 = t0;
      this.$this = t1;
      this.start = t2;
    },
    StylesheetParser_expression_resolveOneOperation: function StylesheetParser_expression_resolveOneOperation(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    StylesheetParser_expression_resolveOperations: function StylesheetParser_expression_resolveOperations(t0, t1) {
      this._box_0 = t0;
      this.resolveOneOperation = t1;
    },
    StylesheetParser_expression_addSingleExpression: function StylesheetParser_expression_addSingleExpression(t0, t1, t2, t3) {
      var _ = this;
      _._box_0 = t0;
      _.$this = t1;
      _.resetState = t2;
      _.resolveOperations = t3;
    },
    StylesheetParser_expression_addOperator: function StylesheetParser_expression_addOperator(t0, t1, t2) {
      this._box_0 = t0;
      this.$this = t1;
      this.resolveOneOperation = t2;
    },
    StylesheetParser_expression_resolveSpaceExpressions: function StylesheetParser_expression_resolveSpaceExpressions(t0, t1) {
      this._box_0 = t0;
      this.resolveOperations = t1;
    },
    StylesheetParser__expressionUntilComma_closure: function StylesheetParser__expressionUntilComma_closure(t0) {
      this.$this = t0;
    },
    StylesheetParser__unicodeRange_closure: function StylesheetParser__unicodeRange_closure() {
    },
    StylesheetParser__unicodeRange_closure0: function StylesheetParser__unicodeRange_closure0() {
    },
    StylesheetParser__expressionUntilComparison_closure: function StylesheetParser__expressionUntilComparison_closure(t0) {
      this.$this = t0;
    },
    cloneCssStylesheet: function(stylesheet, extender) {
      var result = extender.clone$0(),
        t1 = stylesheet.get$span(),
        t2 = B.ModifiableCssNode,
        t3 = H.setRuntimeTypeInfo([], [t2]);
      return new S.Tuple2(new V._CloneCssVisitor(result.item2)._visitChildren$2(new V.ModifiableCssStylesheet(t1, new P.UnmodifiableListView(t3, [t2]), t3), stylesheet), result.item1, [V.ModifiableCssStylesheet, F.Extender]);
    },
    _CloneCssVisitor: function _CloneCssVisitor(t0) {
      this._oldToNewRules = t0;
    },
    SourceLocation$: function(offset, column, line, sourceUrl) {
      var t1 = line == null,
        t2 = t1 ? 0 : line,
        t3 = column == null,
        t4 = t3 ? offset : column;
      if (offset < 0)
        H.throwExpression(P.RangeError$("Offset may not be negative, was " + H.S(offset) + "."));
      else if (!t1 && line < 0)
        H.throwExpression(P.RangeError$("Line may not be negative, was " + H.S(line) + "."));
      else if (!t3 && column < 0)
        H.throwExpression(P.RangeError$("Column may not be negative, was " + H.S(column) + "."));
      return new V.SourceLocation(sourceUrl, offset, t2, t4);
    },
    SourceLocation: function SourceLocation(t0, t1, t2, t3) {
      var _ = this;
      _.sourceUrl = t0;
      _.offset = t1;
      _.line = t2;
      _.column = t3;
    },
    SourceSpan: function SourceSpan() {
    },
    SourceSpanBase: function SourceSpanBase() {
    }
  },
  G = {Option: function Option(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11) {
      var _ = this;
      _.name = t0;
      _.abbr = t1;
      _.help = t2;
      _.valueHelp = t3;
      _.allowed = t4;
      _.allowedHelp = t5;
      _.defaultsTo = t6;
      _.negatable = t7;
      _.callback = t8;
      _.type = t9;
      _.splitCommas = t10;
      _.hide = t11;
    }, OptionType: function OptionType(t0) {
      this.name = t0;
    },
    Parser$0: function(commandName, grammar, args, $parent, rest) {
      var t1 = P.String,
        t2 = H.setRuntimeTypeInfo([], [t1]);
      if (rest != null)
        C.JSArray_methods.addAll$1(t2, rest);
      return new G.Parser0(commandName, $parent, grammar, args, t2, P.LinkedHashMap_LinkedHashMap$_empty(t1, null));
    },
    Parser0: function Parser0(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _.commandName = t0;
      _.parent = t1;
      _.grammar = t2;
      _.args = t3;
      _.rest = t4;
      _.results = t5;
    },
    Parser_parse_closure: function Parser_parse_closure(t0) {
      this.$this = t0;
    },
    Parser_setOption_closure: function Parser_setOption_closure() {
    },
    Usage: function Usage(t0, t1) {
      var _ = this;
      _.optionsAndSeparators = t0;
      _.buffer = null;
      _.currentColumn = 0;
      _.columnWidths = null;
      _.newlinesNeeded = _.numHelpLines = 0;
      _.lineLength = t1;
    },
    Usage_generate_closure: function Usage_generate_closure() {
    },
    Usage_buildAllowedList_closure: function Usage_buildAllowedList_closure(t0) {
      this.option = t0;
    },
    StreamQueue: function StreamQueue(t0, t1, t2, t3) {
      var _ = this;
      _._stream_queue$_source = t0;
      _._stream_queue$_subscription = null;
      _._isDone = false;
      _._eventsReceived = 0;
      _._eventQueue = t1;
      _._requestQueue = t2;
      _.$ti = t3;
    },
    StreamQueue__ensureListening_closure: function StreamQueue__ensureListening_closure(t0) {
      this.$this = t0;
    },
    StreamQueue__ensureListening_closure1: function StreamQueue__ensureListening_closure1(t0) {
      this.$this = t0;
    },
    StreamQueue__ensureListening_closure0: function StreamQueue__ensureListening_closure0(t0) {
      this.$this = t0;
    },
    _EventRequest: function _EventRequest() {
    },
    _NextRequest: function _NextRequest(t0, t1) {
      this._stream_queue$_completer = t0;
      this.$ti = t1;
    },
    ModifiableCssMediaRule$: function(queries, span) {
      var t1 = P.List_List$unmodifiable(queries, F.CssMediaQuery),
        t2 = B.ModifiableCssNode,
        t3 = H.setRuntimeTypeInfo([], [t2]);
      if (J.get$isEmpty$asx(queries))
        H.throwExpression(P.ArgumentError$value(queries, "queries", "may not be empty."));
      return new G.ModifiableCssMediaRule(t1, span, new P.UnmodifiableListView(t3, [t2]), t3);
    },
    ModifiableCssMediaRule: function ModifiableCssMediaRule(t0, t1, t2, t3) {
      var _ = this;
      _.queries = t0;
      _.span = t1;
      _.children = t2;
      _._children = t3;
      _._indexInParent = _._parent = null;
      _.isGroupEnd = false;
    },
    MediaRule: function MediaRule(t0, t1, t2, t3) {
      var _ = this;
      _.query = t0;
      _.span = t1;
      _.children = t2;
      _.hasDeclarations = t3;
    },
    WhileRule: function WhileRule(t0, t1, t2, t3) {
      var _ = this;
      _.condition = t0;
      _.span = t1;
      _.children = t2;
      _.hasDeclarations = t3;
    },
    Module: function Module() {
    },
    Types: function Types() {
    },
    Parser_isIdentifier: function(text) {
      var exception, logger = null;
      try {
        G.Parser$(text, logger, null)._parseIdentifier$0();
        return true;
      } catch (exception) {
        if (H.unwrapException(exception) instanceof E.SassFormatException)
          return false;
        else
          throw exception;
      }
    },
    Parser$: function(contents, logger, url) {
      var t1, t2, t3, t4;
      contents.toString;
      t1 = new H.CodeUnits(contents);
      t2 = H.setRuntimeTypeInfo([0], [P.int]);
      t3 = typeof url === "string";
      t4 = t3 ? P.Uri_parse(url) : url;
      t2 = new Y.SourceFile(t4, t2, new Uint32Array(H._ensureNativeList(t1.toList$0(t1))));
      t2.SourceFile$decoded$2$url(t1, url);
      t1 = t3 ? P.Uri_parse(url) : H.interceptedTypeCast(url, "$isUri");
      t3 = logger == null ? C.StderrLogger_false : logger;
      return new G.Parser(new S.SpanScanner(t2, t1, contents), t3);
    },
    Parser: function Parser(t0, t1) {
      this.scanner = t0;
      this.logger = t1;
    },
    Parser__parseIdentifier_closure: function Parser__parseIdentifier_closure(t0) {
      this.$this = t0;
    },
    FixedLengthListBuilder: function FixedLengthListBuilder(t0, t1) {
      this._list = t0;
      this._fixed_length_list_builder$_index = 0;
      this.$ti = t1;
    },
    SourceSpanFormatException$: function(message, span, _source) {
      return new G.SourceSpanFormatException(_source, message, span);
    },
    SourceSpanException: function SourceSpanException() {
    },
    SourceSpanFormatException: function SourceSpanFormatException(t0, t1, t2) {
      this._span_exception$_source = t0;
      this._span_exception$_message = t1;
      this._span = t2;
    }
  },
  E = {Result: function Result() {
    }, PosixStyle: function PosixStyle(t0, t1, t2) {
      this.separatorPattern = t0;
      this.needsSeparatorPattern = t1;
      this.rootPattern = t2;
    }, UserDefinedCallable: function UserDefinedCallable(t0, t1, t2) {
      this.declaration = t0;
      this.environment = t1;
      this.$ti = t2;
    },
    SassException$: function(message, span) {
      return new E.SassException(message, span);
    },
    SassFormatException$: function(message, span) {
      return new E.SassFormatException(message, span);
    },
    SassScriptException$: function(message) {
      return new E.SassScriptException(message);
    },
    SassException: function SassException(t0, t1) {
      this._span_exception$_message = t0;
      this._span = t1;
    },
    SassRuntimeException: function SassRuntimeException(t0, t1, t2) {
      this.trace = t0;
      this._span_exception$_message = t1;
      this._span = t2;
    },
    SassFormatException: function SassFormatException(t0, t1) {
      this._span_exception$_message = t0;
      this._span = t1;
    },
    SassScriptException: function SassScriptException(t0) {
      this.message = t0;
    },
    ImporterResult: function ImporterResult(t0, t1, t2) {
      this.contents = t0;
      this._sourceMapUrl = t1;
      this.syntax = t2;
    },
    FiberClass: function FiberClass() {
    },
    Fiber: function Fiber() {
    },
    KeyframeSelectorParser: function KeyframeSelectorParser(t0, t1) {
      this.scanner = t0;
      this.logger = t1;
    },
    KeyframeSelectorParser_parse_closure: function KeyframeSelectorParser_parse_closure(t0) {
      this.$this = t0;
    },
    _EvaluateVisitor$0: function(functions, importCache, logger, nodeImporter, sourceMap) {
      var t7, t8,
        t1 = P.String,
        t2 = P.Uri,
        t3 = [G.Module, B.AsyncCallable],
        t4 = P.LinkedHashSet_LinkedHashSet(t1),
        t5 = P.LinkedHashSet_LinkedHashSet(t2),
        t6 = H.setRuntimeTypeInfo([], [[S.Tuple2, P.String, B.AstNode]]);
      if (nodeImporter == null)
        t7 = importCache == null ? O.AsyncImportCache$none(logger) : importCache;
      else
        t7 = null;
      t8 = logger == null ? C.StderrLogger_false : logger;
      t6 = new E._EvaluateVisitor0(t7, nodeImporter, P.LinkedHashMap_LinkedHashMap$_empty(t1, B.AsyncCallable), P.LinkedHashMap_LinkedHashMap$_empty(t2, t3), P.LinkedHashMap_LinkedHashMap$_empty(t2, t3), t8, sourceMap, t4, t5, t6);
      t6._EvaluateVisitor$5$functions$importCache$logger$nodeImporter$sourceMap0(functions, importCache, logger, nodeImporter, sourceMap);
      return t6;
    },
    _ArgumentResults$0: function(positional, named, separator, namedNodes, positionalNodes) {
      return new E._ArgumentResults0(positional, positionalNodes, named, namedNodes, separator);
    },
    _EvaluateVisitor0: function _EvaluateVisitor0(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9) {
      var _ = this;
      _._async_evaluate$_importCache = t0;
      _._async_evaluate$_nodeImporter = t1;
      _._async_evaluate$_builtInFunctions = t2;
      _._async_evaluate$_builtInModules = t3;
      _._async_evaluate$_modules = t4;
      _._async_evaluate$_logger = t5;
      _._async_evaluate$_sourceMap = t6;
      _._async_evaluate$_declarationName = _._async_evaluate$_parent = _._async_evaluate$_mediaQueries = _._async_evaluate$_styleRule = _._async_evaluate$_environment = null;
      _._async_evaluate$_member = "root stylesheet";
      _._async_evaluate$_importSpan = _._async_evaluate$_callableNode = null;
      _._async_evaluate$_inKeyframes = _._async_evaluate$_atRootExcludingStyleRule = _._async_evaluate$_inUnknownAtRule = _._async_evaluate$_inFunction = false;
      _._async_evaluate$_includedFiles = t7;
      _._async_evaluate$_activeModules = t8;
      _._async_evaluate$_stack = t9;
      _._async_evaluate$_extender = _._async_evaluate$_outOfOrderImports = _._async_evaluate$_endOfImports = _._async_evaluate$_root = _._async_evaluate$_stylesheet = _._async_evaluate$_importer = null;
    },
    _EvaluateVisitor_closure8: function _EvaluateVisitor_closure8(t0) {
      this.$this = t0;
    },
    _EvaluateVisitor_closure9: function _EvaluateVisitor_closure9(t0) {
      this.$this = t0;
    },
    _EvaluateVisitor_closure10: function _EvaluateVisitor_closure10(t0) {
      this.$this = t0;
    },
    _EvaluateVisitor_closure11: function _EvaluateVisitor_closure11(t0) {
      this.$this = t0;
    },
    _EvaluateVisitor_closure12: function _EvaluateVisitor_closure12(t0) {
      this.$this = t0;
    },
    _EvaluateVisitor_closure13: function _EvaluateVisitor_closure13(t0) {
      this.$this = t0;
    },
    _EvaluateVisitor_closure14: function _EvaluateVisitor_closure14(t0) {
      this.$this = t0;
    },
    _EvaluateVisitor_closure15: function _EvaluateVisitor_closure15(t0) {
      this.$this = t0;
    },
    _EvaluateVisitor__closure4: function _EvaluateVisitor__closure4(t0, t1, t2) {
      this.$this = t0;
      this.name = t1;
      this.module = t2;
    },
    _EvaluateVisitor_closure16: function _EvaluateVisitor_closure16(t0) {
      this.$this = t0;
    },
    _EvaluateVisitor__closure2: function _EvaluateVisitor__closure2() {
    },
    _EvaluateVisitor__closure3: function _EvaluateVisitor__closure3() {
    },
    _EvaluateVisitor_run_closure0: function _EvaluateVisitor_run_closure0(t0, t1, t2) {
      this.$this = t0;
      this.node = t1;
      this.importer = t2;
    },
    _EvaluateVisitor__withWarnCallback_closure0: function _EvaluateVisitor__withWarnCallback_closure0(t0) {
      this.$this = t0;
    },
    _EvaluateVisitor__loadModule_closure0: function _EvaluateVisitor__loadModule_closure0(t0, t1, t2, t3) {
      var _ = this;
      _.$this = t0;
      _.url = t1;
      _.nodeForSpan = t2;
      _.callback = t3;
    },
    _EvaluateVisitor__loadModule__closure0: function _EvaluateVisitor__loadModule__closure0(t0, t1, t2) {
      this.$this = t0;
      this.url = t1;
      this.nodeForSpan = t2;
    },
    _EvaluateVisitor__execute_closure0: function _EvaluateVisitor__execute_closure0(t0, t1, t2) {
      this.$this = t0;
      this.importer = t1;
      this.stylesheet = t2;
    },
    _EvaluateVisitor__execute__closure0: function _EvaluateVisitor__execute__closure0(t0, t1, t2, t3, t4) {
      var _ = this;
      _._box_0 = t0;
      _.$this = t1;
      _.importer = t2;
      _.stylesheet = t3;
      _.extender = t4;
    },
    _EvaluateVisitor__combineCss_closure2: function _EvaluateVisitor__combineCss_closure2() {
    },
    _EvaluateVisitor__combineCss_closure3: function _EvaluateVisitor__combineCss_closure3(t0) {
      this.selectors = t0;
    },
    _EvaluateVisitor__combineCss_closure4: function _EvaluateVisitor__combineCss_closure4() {
    },
    _EvaluateVisitor__extendModules_closure1: function _EvaluateVisitor__extendModules_closure1(t0) {
      this.originalSelectors = t0;
    },
    _EvaluateVisitor__extendModules_closure2: function _EvaluateVisitor__extendModules_closure2() {
    },
    _EvaluateVisitor__topologicalModules_visitModule0: function _EvaluateVisitor__topologicalModules_visitModule0(t0, t1) {
      this.seen = t0;
      this.sorted = t1;
    },
    _EvaluateVisitor_visitAtRootRule_closure2: function _EvaluateVisitor_visitAtRootRule_closure2(t0, t1) {
      this.$this = t0;
      this.resolved = t1;
    },
    _EvaluateVisitor_visitAtRootRule_closure3: function _EvaluateVisitor_visitAtRootRule_closure3(t0, t1) {
      this.$this = t0;
      this.node = t1;
    },
    _EvaluateVisitor_visitAtRootRule_closure4: function _EvaluateVisitor_visitAtRootRule_closure4(t0, t1) {
      this.$this = t0;
      this.node = t1;
    },
    _EvaluateVisitor__scopeForAtRoot_closure5: function _EvaluateVisitor__scopeForAtRoot_closure5(t0, t1, t2) {
      this.$this = t0;
      this.newParent = t1;
      this.node = t2;
    },
    _EvaluateVisitor__scopeForAtRoot_closure6: function _EvaluateVisitor__scopeForAtRoot_closure6(t0, t1) {
      this.$this = t0;
      this.innerScope = t1;
    },
    _EvaluateVisitor__scopeForAtRoot_closure7: function _EvaluateVisitor__scopeForAtRoot_closure7(t0, t1) {
      this.$this = t0;
      this.innerScope = t1;
    },
    _EvaluateVisitor__scopeForAtRoot__closure0: function _EvaluateVisitor__scopeForAtRoot__closure0(t0, t1) {
      this.innerScope = t0;
      this.callback = t1;
    },
    _EvaluateVisitor__scopeForAtRoot_closure8: function _EvaluateVisitor__scopeForAtRoot_closure8(t0, t1) {
      this.$this = t0;
      this.innerScope = t1;
    },
    _EvaluateVisitor__scopeForAtRoot_closure9: function _EvaluateVisitor__scopeForAtRoot_closure9() {
    },
    _EvaluateVisitor__scopeForAtRoot_closure10: function _EvaluateVisitor__scopeForAtRoot_closure10(t0, t1) {
      this.$this = t0;
      this.innerScope = t1;
    },
    _EvaluateVisitor_visitContentRule_closure0: function _EvaluateVisitor_visitContentRule_closure0(t0, t1) {
      this.$this = t0;
      this.content = t1;
    },
    _EvaluateVisitor_visitDeclaration_closure0: function _EvaluateVisitor_visitDeclaration_closure0(t0, t1) {
      this.$this = t0;
      this.node = t1;
    },
    _EvaluateVisitor_visitEachRule_closure2: function _EvaluateVisitor_visitEachRule_closure2(t0, t1, t2) {
      this.$this = t0;
      this.node = t1;
      this.nodeForSpan = t2;
    },
    _EvaluateVisitor_visitEachRule_closure3: function _EvaluateVisitor_visitEachRule_closure3(t0, t1, t2) {
      this.$this = t0;
      this.node = t1;
      this.nodeForSpan = t2;
    },
    _EvaluateVisitor_visitEachRule_closure4: function _EvaluateVisitor_visitEachRule_closure4(t0, t1, t2, t3) {
      var _ = this;
      _.$this = t0;
      _.list = t1;
      _.setVariables = t2;
      _.node = t3;
    },
    _EvaluateVisitor_visitEachRule__closure0: function _EvaluateVisitor_visitEachRule__closure0(t0, t1, t2) {
      this.$this = t0;
      this.setVariables = t1;
      this.node = t2;
    },
    _EvaluateVisitor_visitEachRule___closure0: function _EvaluateVisitor_visitEachRule___closure0(t0) {
      this.$this = t0;
    },
    _EvaluateVisitor_visitExtendRule_closure0: function _EvaluateVisitor_visitExtendRule_closure0(t0, t1) {
      this.$this = t0;
      this.targetText = t1;
    },
    _EvaluateVisitor_visitAtRule_closure1: function _EvaluateVisitor_visitAtRule_closure1(t0, t1) {
      this.$this = t0;
      this.node = t1;
    },
    _EvaluateVisitor_visitAtRule__closure0: function _EvaluateVisitor_visitAtRule__closure0(t0, t1) {
      this.$this = t0;
      this.node = t1;
    },
    _EvaluateVisitor_visitAtRule_closure2: function _EvaluateVisitor_visitAtRule_closure2() {
    },
    _EvaluateVisitor_visitForRule_closure4: function _EvaluateVisitor_visitForRule_closure4(t0, t1) {
      this.$this = t0;
      this.node = t1;
    },
    _EvaluateVisitor_visitForRule_closure5: function _EvaluateVisitor_visitForRule_closure5(t0, t1) {
      this.$this = t0;
      this.node = t1;
    },
    _EvaluateVisitor_visitForRule_closure6: function _EvaluateVisitor_visitForRule_closure6(t0, t1) {
      this.fromNumber = t0;
      this.toNumber = t1;
    },
    _EvaluateVisitor_visitForRule_closure7: function _EvaluateVisitor_visitForRule_closure7(t0) {
      this.toNumber = t0;
    },
    _EvaluateVisitor_visitForRule_closure8: function _EvaluateVisitor_visitForRule_closure8(t0, t1, t2, t3, t4) {
      var _ = this;
      _._box_0 = t0;
      _.$this = t1;
      _.node = t2;
      _.from = t3;
      _.direction = t4;
    },
    _EvaluateVisitor_visitForRule__closure0: function _EvaluateVisitor_visitForRule__closure0(t0) {
      this.$this = t0;
    },
    _EvaluateVisitor_visitForwardRule_closure0: function _EvaluateVisitor_visitForwardRule_closure0(t0, t1) {
      this.$this = t0;
      this.node = t1;
    },
    _EvaluateVisitor_visitIfRule_closure0: function _EvaluateVisitor_visitIfRule_closure0(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    _EvaluateVisitor_visitIfRule__closure0: function _EvaluateVisitor_visitIfRule__closure0(t0) {
      this.$this = t0;
    },
    _EvaluateVisitor__visitDynamicImport_closure0: function _EvaluateVisitor__visitDynamicImport_closure0(t0, t1) {
      this.$this = t0;
      this.$import = t1;
    },
    _EvaluateVisitor__visitDynamicImport__closure1: function _EvaluateVisitor__visitDynamicImport__closure1(t0, t1, t2) {
      this.$this = t0;
      this.importer = t1;
      this.stylesheet = t2;
    },
    _EvaluateVisitor__visitDynamicImport__closure2: function _EvaluateVisitor__visitDynamicImport__closure2(t0, t1, t2, t3) {
      var _ = this;
      _._box_0 = t0;
      _.$this = t1;
      _.importer = t2;
      _.stylesheet = t3;
    },
    _EvaluateVisitor_visitIncludeRule_closure1: function _EvaluateVisitor_visitIncludeRule_closure1(t0, t1) {
      this.$this = t0;
      this.node = t1;
    },
    _EvaluateVisitor_visitIncludeRule_closure2: function _EvaluateVisitor_visitIncludeRule_closure2(t0, t1, t2) {
      this.$this = t0;
      this.contentCallable = t1;
      this.mixin = t2;
    },
    _EvaluateVisitor_visitIncludeRule__closure0: function _EvaluateVisitor_visitIncludeRule__closure0(t0, t1) {
      this.$this = t0;
      this.mixin = t1;
    },
    _EvaluateVisitor_visitIncludeRule___closure0: function _EvaluateVisitor_visitIncludeRule___closure0(t0, t1) {
      this.$this = t0;
      this.mixin = t1;
    },
    _EvaluateVisitor_visitMediaRule_closure1: function _EvaluateVisitor_visitMediaRule_closure1(t0, t1, t2, t3) {
      var _ = this;
      _.$this = t0;
      _.mergedQueries = t1;
      _.queries = t2;
      _.node = t3;
    },
    _EvaluateVisitor_visitMediaRule__closure0: function _EvaluateVisitor_visitMediaRule__closure0(t0, t1) {
      this.$this = t0;
      this.node = t1;
    },
    _EvaluateVisitor_visitMediaRule___closure0: function _EvaluateVisitor_visitMediaRule___closure0(t0, t1) {
      this.$this = t0;
      this.node = t1;
    },
    _EvaluateVisitor_visitMediaRule_closure2: function _EvaluateVisitor_visitMediaRule_closure2(t0) {
      this.mergedQueries = t0;
    },
    _EvaluateVisitor__visitMediaQueries_closure0: function _EvaluateVisitor__visitMediaQueries_closure0(t0, t1) {
      this.$this = t0;
      this.resolved = t1;
    },
    _EvaluateVisitor_visitStyleRule_closure6: function _EvaluateVisitor_visitStyleRule_closure6(t0, t1) {
      this.$this = t0;
      this.selectorText = t1;
    },
    _EvaluateVisitor_visitStyleRule_closure7: function _EvaluateVisitor_visitStyleRule_closure7(t0, t1) {
      this.$this = t0;
      this.node = t1;
    },
    _EvaluateVisitor_visitStyleRule_closure8: function _EvaluateVisitor_visitStyleRule_closure8() {
    },
    _EvaluateVisitor_visitStyleRule_closure9: function _EvaluateVisitor_visitStyleRule_closure9(t0, t1) {
      this.$this = t0;
      this.selectorText = t1;
    },
    _EvaluateVisitor_visitStyleRule_closure10: function _EvaluateVisitor_visitStyleRule_closure10(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    _EvaluateVisitor_visitStyleRule_closure11: function _EvaluateVisitor_visitStyleRule_closure11(t0, t1, t2) {
      this.$this = t0;
      this.rule = t1;
      this.node = t2;
    },
    _EvaluateVisitor_visitStyleRule__closure0: function _EvaluateVisitor_visitStyleRule__closure0(t0, t1) {
      this.$this = t0;
      this.node = t1;
    },
    _EvaluateVisitor_visitStyleRule_closure12: function _EvaluateVisitor_visitStyleRule_closure12() {
    },
    _EvaluateVisitor_visitSupportsRule_closure1: function _EvaluateVisitor_visitSupportsRule_closure1(t0, t1) {
      this.$this = t0;
      this.node = t1;
    },
    _EvaluateVisitor_visitSupportsRule__closure0: function _EvaluateVisitor_visitSupportsRule__closure0(t0, t1) {
      this.$this = t0;
      this.node = t1;
    },
    _EvaluateVisitor_visitSupportsRule_closure2: function _EvaluateVisitor_visitSupportsRule_closure2() {
    },
    _EvaluateVisitor_visitVariableDeclaration_closure1: function _EvaluateVisitor_visitVariableDeclaration_closure1(t0, t1) {
      this.$this = t0;
      this.node = t1;
    },
    _EvaluateVisitor_visitVariableDeclaration_closure2: function _EvaluateVisitor_visitVariableDeclaration_closure2(t0, t1, t2) {
      this.$this = t0;
      this.node = t1;
      this.value = t2;
    },
    _EvaluateVisitor_visitUseRule_closure0: function _EvaluateVisitor_visitUseRule_closure0(t0, t1) {
      this.$this = t0;
      this.node = t1;
    },
    _EvaluateVisitor_visitWarnRule_closure0: function _EvaluateVisitor_visitWarnRule_closure0(t0, t1) {
      this.$this = t0;
      this.node = t1;
    },
    _EvaluateVisitor_visitWhileRule_closure0: function _EvaluateVisitor_visitWhileRule_closure0(t0, t1) {
      this.$this = t0;
      this.node = t1;
    },
    _EvaluateVisitor_visitWhileRule__closure0: function _EvaluateVisitor_visitWhileRule__closure0(t0) {
      this.$this = t0;
    },
    _EvaluateVisitor_visitBinaryOperationExpression_closure0: function _EvaluateVisitor_visitBinaryOperationExpression_closure0(t0, t1) {
      this.$this = t0;
      this.node = t1;
    },
    _EvaluateVisitor_visitVariableExpression_closure0: function _EvaluateVisitor_visitVariableExpression_closure0(t0, t1) {
      this.$this = t0;
      this.node = t1;
    },
    _EvaluateVisitor_visitListExpression_closure0: function _EvaluateVisitor_visitListExpression_closure0(t0) {
      this.$this = t0;
    },
    _EvaluateVisitor_visitFunctionExpression_closure0: function _EvaluateVisitor_visitFunctionExpression_closure0(t0, t1, t2) {
      this.$this = t0;
      this.node = t1;
      this.plainName = t2;
    },
    _EvaluateVisitor__runUserDefinedCallable_closure0: function _EvaluateVisitor__runUserDefinedCallable_closure0(t0, t1, t2, t3, t4) {
      var _ = this;
      _.$this = t0;
      _.callable = t1;
      _.evaluated = t2;
      _.nodeWithSpan = t3;
      _.run = t4;
    },
    _EvaluateVisitor__runUserDefinedCallable__closure0: function _EvaluateVisitor__runUserDefinedCallable__closure0(t0, t1, t2, t3, t4) {
      var _ = this;
      _.$this = t0;
      _.evaluated = t1;
      _.callable = t2;
      _.nodeWithSpan = t3;
      _.run = t4;
    },
    _EvaluateVisitor__runUserDefinedCallable___closure0: function _EvaluateVisitor__runUserDefinedCallable___closure0(t0, t1, t2, t3, t4) {
      var _ = this;
      _.$this = t0;
      _.evaluated = t1;
      _.callable = t2;
      _.nodeWithSpan = t3;
      _.run = t4;
    },
    _EvaluateVisitor__runUserDefinedCallable____closure0: function _EvaluateVisitor__runUserDefinedCallable____closure0() {
    },
    _EvaluateVisitor__runFunctionCallable_closure0: function _EvaluateVisitor__runFunctionCallable_closure0(t0, t1) {
      this.$this = t0;
      this.callable = t1;
    },
    _EvaluateVisitor__runBuiltInCallable_closure1: function _EvaluateVisitor__runBuiltInCallable_closure1(t0, t1, t2) {
      this.overload = t0;
      this.evaluated = t1;
      this.namedSet = t2;
    },
    _EvaluateVisitor__runBuiltInCallable_closure2: function _EvaluateVisitor__runBuiltInCallable_closure2() {
    },
    _EvaluateVisitor__evaluateArguments_closure6: function _EvaluateVisitor__evaluateArguments_closure6(t0) {
      this.$this = t0;
    },
    _EvaluateVisitor__evaluateArguments_closure7: function _EvaluateVisitor__evaluateArguments_closure7(t0) {
      this.$this = t0;
    },
    _EvaluateVisitor__evaluateArguments_closure8: function _EvaluateVisitor__evaluateArguments_closure8() {
    },
    _EvaluateVisitor__evaluateArguments_closure9: function _EvaluateVisitor__evaluateArguments_closure9(t0) {
      this.restNodeForSpan = t0;
    },
    _EvaluateVisitor__evaluateArguments_closure10: function _EvaluateVisitor__evaluateArguments_closure10(t0, t1, t2) {
      this.named = t0;
      this.namedNodes = t1;
      this.restNodeForSpan = t2;
    },
    _EvaluateVisitor__evaluateArguments_closure11: function _EvaluateVisitor__evaluateArguments_closure11() {
    },
    _EvaluateVisitor__evaluateArguments_closure12: function _EvaluateVisitor__evaluateArguments_closure12(t0) {
      this.keywordRestNodeForSpan = t0;
    },
    _EvaluateVisitor__evaluateMacroArguments_closure3: function _EvaluateVisitor__evaluateMacroArguments_closure3() {
    },
    _EvaluateVisitor__evaluateMacroArguments_closure4: function _EvaluateVisitor__evaluateMacroArguments_closure4() {
    },
    _EvaluateVisitor__evaluateMacroArguments_closure5: function _EvaluateVisitor__evaluateMacroArguments_closure5(t0) {
      this.named = t0;
    },
    _EvaluateVisitor__evaluateMacroArguments_closure6: function _EvaluateVisitor__evaluateMacroArguments_closure6() {
    },
    _EvaluateVisitor__addRestMap_closure1: function _EvaluateVisitor__addRestMap_closure1(t0) {
      this.T = t0;
    },
    _EvaluateVisitor__addRestMap_closure2: function _EvaluateVisitor__addRestMap_closure2(t0, t1, t2, t3, t4) {
      var _ = this;
      _._box_0 = t0;
      _.$this = t1;
      _.values = t2;
      _.map = t3;
      _.nodeForSpan = t4;
    },
    _EvaluateVisitor__verifyArguments_closure0: function _EvaluateVisitor__verifyArguments_closure0(t0, t1, t2) {
      this.$arguments = t0;
      this.positional = t1;
      this.named = t2;
    },
    _EvaluateVisitor_visitStringExpression_closure0: function _EvaluateVisitor_visitStringExpression_closure0(t0) {
      this.$this = t0;
    },
    _EvaluateVisitor_visitCssAtRule_closure1: function _EvaluateVisitor_visitCssAtRule_closure1(t0, t1) {
      this.$this = t0;
      this.node = t1;
    },
    _EvaluateVisitor_visitCssAtRule_closure2: function _EvaluateVisitor_visitCssAtRule_closure2() {
    },
    _EvaluateVisitor_visitCssKeyframeBlock_closure1: function _EvaluateVisitor_visitCssKeyframeBlock_closure1(t0, t1) {
      this.$this = t0;
      this.node = t1;
    },
    _EvaluateVisitor_visitCssKeyframeBlock_closure2: function _EvaluateVisitor_visitCssKeyframeBlock_closure2() {
    },
    _EvaluateVisitor_visitCssMediaRule_closure1: function _EvaluateVisitor_visitCssMediaRule_closure1(t0, t1, t2) {
      this.$this = t0;
      this.mergedQueries = t1;
      this.node = t2;
    },
    _EvaluateVisitor_visitCssMediaRule__closure0: function _EvaluateVisitor_visitCssMediaRule__closure0(t0, t1) {
      this.$this = t0;
      this.node = t1;
    },
    _EvaluateVisitor_visitCssMediaRule___closure0: function _EvaluateVisitor_visitCssMediaRule___closure0(t0, t1) {
      this.$this = t0;
      this.node = t1;
    },
    _EvaluateVisitor_visitCssMediaRule_closure2: function _EvaluateVisitor_visitCssMediaRule_closure2(t0) {
      this.mergedQueries = t0;
    },
    _EvaluateVisitor_visitCssStyleRule_closure1: function _EvaluateVisitor_visitCssStyleRule_closure1(t0, t1, t2) {
      this.$this = t0;
      this.rule = t1;
      this.node = t2;
    },
    _EvaluateVisitor_visitCssStyleRule__closure0: function _EvaluateVisitor_visitCssStyleRule__closure0(t0, t1) {
      this.$this = t0;
      this.node = t1;
    },
    _EvaluateVisitor_visitCssStyleRule_closure2: function _EvaluateVisitor_visitCssStyleRule_closure2() {
    },
    _EvaluateVisitor_visitCssSupportsRule_closure1: function _EvaluateVisitor_visitCssSupportsRule_closure1(t0, t1) {
      this.$this = t0;
      this.node = t1;
    },
    _EvaluateVisitor_visitCssSupportsRule__closure0: function _EvaluateVisitor_visitCssSupportsRule__closure0(t0, t1) {
      this.$this = t0;
      this.node = t1;
    },
    _EvaluateVisitor_visitCssSupportsRule_closure2: function _EvaluateVisitor_visitCssSupportsRule_closure2() {
    },
    _EvaluateVisitor__performInterpolation_closure0: function _EvaluateVisitor__performInterpolation_closure0(t0, t1) {
      this.$this = t0;
      this.warnForColor = t1;
    },
    _EvaluateVisitor__serialize_closure0: function _EvaluateVisitor__serialize_closure0(t0, t1) {
      this.value = t0;
      this.quote = t1;
    },
    _EvaluateVisitor__stackTrace_closure0: function _EvaluateVisitor__stackTrace_closure0(t0) {
      this.$this = t0;
    },
    _ImportedCssVisitor0: function _ImportedCssVisitor0(t0) {
      this._async_evaluate$_visitor = t0;
    },
    _ImportedCssVisitor_visitCssAtRule_closure0: function _ImportedCssVisitor_visitCssAtRule_closure0() {
    },
    _ImportedCssVisitor_visitCssMediaRule_closure0: function _ImportedCssVisitor_visitCssMediaRule_closure0(t0) {
      this.hasBeenMerged = t0;
    },
    _ImportedCssVisitor_visitCssStyleRule_closure0: function _ImportedCssVisitor_visitCssStyleRule_closure0() {
    },
    _ImportedCssVisitor_visitCssSupportsRule_closure0: function _ImportedCssVisitor_visitCssSupportsRule_closure0() {
    },
    EvaluateResult: function EvaluateResult(t0, t1) {
      this.stylesheet = t0;
      this.includedFiles = t1;
    },
    _ArgumentResults0: function _ArgumentResults0(t0, t1, t2, t3, t4) {
      var _ = this;
      _.positional = t0;
      _.positionalNodes = t1;
      _.named = t2;
      _.namedNodes = t3;
      _.separator = t4;
    },
    StringScannerException$: function(message, span, source) {
      return new E.StringScannerException(source, message, span);
    },
    StringScannerException: function StringScannerException(t0, t1, t2) {
      this._span_exception$_source = t0;
      this._span_exception$_message = t1;
      this._span = t2;
    },
    WatchEvent: function WatchEvent(t0, t1) {
      this.type = t0;
      this.path = t1;
    },
    ChangeType: function ChangeType(t0) {
      this._watch_event$_name = t0;
    }
  },
  F = {ValueResult: function ValueResult(t0, t1) {
      this.value = t0;
      this.$ti = t1;
    }, UrlStyle: function UrlStyle(t0, t1, t2, t3) {
      var _ = this;
      _.separatorPattern = t0;
      _.needsSeparatorPattern = t1;
      _.rootPattern = t2;
      _.relativeRootPattern = t3;
    },
    CssMediaQuery$: function(type, features, modifier) {
      return new F.CssMediaQuery(modifier, type, features == null ? C.List_empty0 : P.List_List$unmodifiable(features, P.String));
    },
    CssMediaQuery: function CssMediaQuery(t0, t1, t2) {
      this.modifier = t0;
      this.type = t1;
      this.features = t2;
    },
    _SingletonCssMediaQueryMergeResult: function _SingletonCssMediaQueryMergeResult(t0) {
      this._media_query$_name = t0;
    },
    MediaQuerySuccessfulMergeResult: function MediaQuerySuccessfulMergeResult(t0) {
      this.query = t0;
    },
    ModifiableCssImport$: function(url, span, media, supports) {
      return new F.ModifiableCssImport(url, supports, media == null ? null : P.List_List$unmodifiable(media, F.CssMediaQuery), span);
    },
    ModifiableCssImport: function ModifiableCssImport(t0, t1, t2, t3) {
      var _ = this;
      _.url = t0;
      _.supports = t1;
      _.media = t2;
      _.span = t3;
      _._indexInParent = _._parent = null;
      _.isGroupEnd = false;
    },
    ModifiableCssValue: function ModifiableCssValue(t0, t1, t2) {
      this.value = t0;
      this.span = t1;
      this.$ti = t2;
    },
    CssValue: function CssValue(t0, t1, t2) {
      this.value = t0;
      this.span = t1;
      this.$ti = t2;
    },
    FunctionExpression: function FunctionExpression(t0, t1, t2, t3) {
      var _ = this;
      _.namespace = t0;
      _.name = t1;
      _.$arguments = t2;
      _.span = t3;
    },
    ValueExpression: function ValueExpression(t0, t1) {
      this.value = t0;
      this.span = t1;
    },
    Import: function Import() {
    },
    TypeSelector: function TypeSelector(t0) {
      this.name = t0;
    },
    main: function(args) {
      return F.main$body(args);
    },
    main$body: function(args) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(null),
        $async$returnValue, $async$handler = 2, $async$currentError, $async$next = [], printError, graph, source, destination, error, stackTrace, error0, stackTrace0, error1, error2, stackTrace1, buffer, options, t1, t2, t3, exception, _box_0, $async$exception, $async$exception1, $async$temp1;
      var $async$main = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$currentError = $async$result;
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              _box_0 = {};
              _box_0.printedError = false;
              printError = new F.main_printError(_box_0);
              _box_0.options = null;
              $async$handler = 4;
              options = B.ExecutableOptions_ExecutableOptions$parse(args);
              _box_0.options = options;
              t1 = options._options;
              $._glyphs = !(t1.wasParsed$1("unicode") ? H.boolTypeCast(t1.$index(0, "unicode")) : $._glyphs !== C.C_AsciiGlyphSet) ? C.C_AsciiGlyphSet : C.C_UnicodeGlyphSet;
              $async$goto = H.boolTypeCast(_box_0.options._options.$index(0, "version")) ? 7 : 8;
              break;
            case 7:
              // then
              $async$temp1 = P;
              $async$goto = 9;
              return P._asyncAwait(F._loadVersion(), $async$main);
            case 9:
              // returning from await.
              $async$temp1.print($async$result);
              self.process.exitCode = 0;
              // goto return
              $async$goto = 1;
              break;
            case 8:
              // join
              $async$goto = _box_0.options.get$interactive() ? 10 : 11;
              break;
            case 10:
              // then
              $async$goto = 12;
              return P._asyncAwait(Y.repl(_box_0.options), $async$main);
            case 12:
              // returning from await.
              // goto return
              $async$goto = 1;
              break;
            case 11:
              // join
              t1 = H.setRuntimeTypeInfo([], [M.Importer]);
              t2 = H.subtypeCast(_box_0.options._options.$index(0, "load-path"), "$isList", [P.String], "$asList");
              t3 = _box_0.options;
              t3 = H.boolTypeCast(t3._options.$index(0, "quiet")) ? $.$get$Logger_quiet() : new S.StderrLogger(t3.get$color());
              t2 = R.ImportCache__toImporters(t1, t2, null);
              t1 = t3 == null ? C.StderrLogger_false : t3;
              t3 = P.Uri;
              graph = new M.StylesheetGraph(P.LinkedHashMap_LinkedHashMap$_empty(t3, M.StylesheetNode), new R.ImportCache(t2, t1, P.LinkedHashMap_LinkedHashMap$_empty(t3, [S.Tuple3, M.Importer, P.Uri, P.Uri]), P.LinkedHashMap_LinkedHashMap$_empty(t3, V.Stylesheet), P.LinkedHashMap_LinkedHashMap$_empty(t3, E.ImporterResult)), P.LinkedHashMap_LinkedHashMap$_empty(t3, P.DateTime));
              $async$goto = H.boolTypeCast(_box_0.options._options.$index(0, "watch")) ? 13 : 14;
              break;
            case 13:
              // then
              $async$goto = 15;
              return P._asyncAwait(A.watch(_box_0.options, graph), $async$main);
            case 15:
              // returning from await.
              // goto return
              $async$goto = 1;
              break;
            case 14:
              // join
              t1 = _box_0.options, t1._ensureSources$0(), t1 = t1._sourcesToDestinations.get$keys(), t1 = t1.get$iterator(t1);
            case 16:
              // for condition
              if (!t1.moveNext$0()) {
                // goto after for
                $async$goto = 17;
                break;
              }
              source = t1.get$current(t1);
              t2 = _box_0.options;
              t2._ensureSources$0();
              destination = t2._sourcesToDestinations.$index(0, source);
              $async$handler = 19;
              t2 = _box_0.options;
              $async$goto = 22;
              return P._asyncAwait(D.compileStylesheet(t2, graph, source, destination, H.boolTypeCast(t2._options.$index(0, "update"))), $async$main);
            case 22:
              // returning from await.
              $async$handler = 4;
              // goto after finally
              $async$goto = 21;
              break;
            case 19:
              // catch
              $async$handler = 18;
              $async$exception = $async$currentError;
              t2 = H.unwrapException($async$exception);
              t3 = J.getInterceptor$(t2);
              if (!!t3.$isSassException) {
                error = t2;
                stackTrace = H.getTraceFromException($async$exception);
                new F.main_closure0(_box_0, destination).call$0();
                t2 = _box_0.options._options;
                if (t2._parser.options._collection$_map.$index(0, "color") == null)
                  H.throwExpression(P.ArgumentError$('Could not find an option named "color".'));
                if (t2._parsed.containsKey$1("color"))
                  t2 = H.boolTypeCast(t2.$index(0, "color"));
                else {
                  t2 = self.process.stdout.isTTY;
                  if (t2 == null)
                    t2 = false;
                }
                t2 = J.toString$1$color$(error, t2);
                t3 = H.boolTypeCast(_box_0.options._options.$index(0, "trace")) ? stackTrace : null;
                printError.call$2(t2, t3);
                if (!J.$eq$(self.process.exitCode, 66))
                  self.process.exitCode = 65;
                if (H.boolTypeCast(_box_0.options._options.$index(0, "stop-on-error"))) {
                  // goto return
                  $async$goto = 1;
                  break;
                }
              } else if (!!t3.$isFileSystemException) {
                error0 = t2;
                stackTrace0 = H.getTraceFromException($async$exception);
                t2 = error0.path;
                t2 = "Error reading " + H.S($.$get$context().relative$2$from(t2, null)) + ": " + error0.message + ".";
                t3 = H.boolTypeCast(_box_0.options._options.$index(0, "trace")) ? stackTrace0 : null;
                printError.call$2(t2, t3);
                self.process.exitCode = 66;
                if (H.boolTypeCast(_box_0.options._options.$index(0, "stop-on-error"))) {
                  // goto return
                  $async$goto = 1;
                  break;
                }
              } else
                throw $async$exception;
              // goto after finally
              $async$goto = 21;
              break;
            case 18:
              // uncaught
              // goto catch
              $async$goto = 4;
              break;
            case 21:
              // after finally
              // goto for condition
              $async$goto = 16;
              break;
            case 17:
              // after for
              $async$handler = 2;
              // goto after finally
              $async$goto = 6;
              break;
            case 4:
              // catch
              $async$handler = 3;
              $async$exception1 = $async$currentError;
              t1 = H.unwrapException($async$exception1);
              if (t1 instanceof B.UsageException) {
                error1 = t1;
                P.print(H.S(error1.message) + "\n");
                P.print("Usage: sass <input.scss> [output.css]\n       sass <input.scss>:<output.css> <input/>:<output/> <dir/>\n");
                t1 = $.$get$ExecutableOptions__parser();
                P.print(new G.Usage(t1._optionsAndSeparators, t1.usageLineLength).generate$0());
                self.process.exitCode = 64;
              } else {
                error2 = t1;
                stackTrace1 = H.getTraceFromException($async$exception1);
                buffer = new P.StringBuffer("");
                t1 = _box_0.options;
                if (t1 != null && t1.get$color())
                  buffer._contents += "\x1b[31m\x1b[1m";
                buffer._contents += "Unexpected exception:";
                t1 = _box_0.options;
                if (t1 != null && t1.get$color())
                  buffer._contents += "\x1b[0m";
                buffer._contents += "\n";
                buffer._contents += H.S(error2) + "\n";
                t1 = buffer._contents;
                printError.call$2(t1.charCodeAt(0) == 0 ? t1 : t1, stackTrace1);
                self.process.exitCode = 255;
              }
              // goto after finally
              $async$goto = 6;
              break;
            case 3:
              // uncaught
              // goto rethrow
              $async$goto = 2;
              break;
            case 6:
              // after finally
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return P._asyncRethrow($async$currentError, $async$completer);
          }
      });
      return P._asyncStartSync($async$main, $async$completer);
    },
    _loadVersion: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.String),
        $async$returnValue;
      var $async$_loadVersion = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$returnValue = "1.22.10 compiled with dart2js 2.4.1";
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$_loadVersion, $async$completer);
    },
    main_printError: function main_printError(t0) {
      this._box_0 = t0;
    },
    main_closure0: function main_closure0(t0, t1) {
      this._box_0 = t0;
      this.destination = t1;
    },
    Extender__extendOrReplace: function(selector, source, targets, mode) {
      var t3, t4, t5, t6, t7, t8, t9, t10, _i, complex, t11, t12, t13, _i0, _null = null,
        t1 = source.components,
        t2 = S.ComplexSelector,
        map = P.LinkedHashMap_LinkedHashMap(_null, _null, _null, t2, S.Extension);
      P.MapBase__fillMapWithMappedIterable(map, t1, _null, new F.Extender__extendOrReplace_closure());
      for (t1 = targets.components, t3 = t1.length, t2 = [t2], t4 = M.SimpleSelector, t5 = [P.Set, X.ModifiableCssStyleRule], t6 = [P.Map, S.ComplexSelector, S.Extension], t7 = [P.List, S.Extension], t8 = X.CssStyleRule, t9 = [P.List, F.CssMediaQuery], t10 = [t4, P.int], _i = 0; _i < t3; ++_i) {
        complex = t1[_i];
        t11 = complex.components;
        if (t11.length !== 1)
          throw H.wrapException(E.SassScriptException$("Can't extend complex selector " + H.S(complex) + "."));
        t12 = P.LinkedHashMap_LinkedHashMap$_empty(t4, t6);
        for (t11 = H.interceptedTypeCast(C.JSArray_methods.get$first(t11), "$isCompoundSelector").components, t13 = t11.length, _i0 = 0; _i0 < t13; ++_i0)
          t12.$indexSet(0, t11[_i0], map);
        t11 = new P._LinkedIdentityHashSet(t2);
        if (!selector.get$isInvisible())
          t11.addAll$1(0, selector.components);
        selector = new F.Extender(P.LinkedHashMap_LinkedHashMap$_empty(t4, t5), P.LinkedHashMap_LinkedHashMap$_empty(t4, t6), P.LinkedHashMap_LinkedHashMap$_empty(t4, t7), P.LinkedHashMap_LinkedHashMap$_empty(t8, t9), new P._LinkedIdentityHashMap(t10), t11, mode)._extendList$3(selector, t12, _null);
      }
      return selector;
    },
    Extender: function Extender(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _._selectors = t0;
      _._extensions = t1;
      _._extensionsByExtender = t2;
      _._mediaContexts = t3;
      _._sourceSpecificity = t4;
      _._originals = t5;
      _._mode = t6;
    },
    Extender__extendOrReplace_closure: function Extender__extendOrReplace_closure() {
    },
    Extender_extensionsWhereTarget_closure: function Extender_extensionsWhereTarget_closure() {
    },
    Extender__registerSelector_closure: function Extender__registerSelector_closure() {
    },
    Extender_addExtension_closure: function Extender_addExtension_closure() {
    },
    Extender_addExtension_closure0: function Extender_addExtension_closure0() {
    },
    Extender_addExtension_closure1: function Extender_addExtension_closure1(t0) {
      this.complex = t0;
    },
    Extender__extendExistingExtensions_closure: function Extender__extendExistingExtensions_closure() {
    },
    Extender__extendExistingExtensions_closure0: function Extender__extendExistingExtensions_closure0() {
    },
    Extender_addExtensions_closure: function Extender_addExtensions_closure(t0, t1, t2) {
      this._box_0 = t0;
      this.$this = t1;
      this.extender = t2;
    },
    Extender_addExtensions__closure: function Extender_addExtensions__closure(t0, t1, t2, t3, t4) {
      var _ = this;
      _._box_0 = t0;
      _.existingSources = t1;
      _.extensionsForTarget = t2;
      _.rulesForTarget = t3;
      _.target = t4;
    },
    Extender_addExtensions___closure: function Extender_addExtensions___closure() {
    },
    Extender_addExtensions___closure0: function Extender_addExtensions___closure0(t0) {
      this.extension = t0;
    },
    Extender__extendList_closure: function Extender__extendList_closure() {
    },
    Extender__extendComplex_closure: function Extender__extendComplex_closure(t0) {
      this.complex = t0;
    },
    Extender__extendComplex_closure0: function Extender__extendComplex_closure0(t0, t1, t2) {
      this._box_0 = t0;
      this.$this = t1;
      this.complex = t2;
    },
    Extender__extendComplex__closure: function Extender__extendComplex__closure() {
    },
    Extender__extendComplex__closure0: function Extender__extendComplex__closure0(t0, t1, t2, t3) {
      var _ = this;
      _._box_0 = t0;
      _.$this = t1;
      _.complex = t2;
      _.path = t3;
    },
    Extender__extendComplex___closure: function Extender__extendComplex___closure() {
    },
    Extender__extendCompound_closure: function Extender__extendCompound_closure(t0) {
      this.mediaQueryContext = t0;
    },
    Extender__extendCompound_closure0: function Extender__extendCompound_closure0(t0, t1, t2, t3) {
      var _ = this;
      _._box_1 = t0;
      _.$this = t1;
      _.compound = t2;
      _.mediaQueryContext = t3;
    },
    Extender__extendCompound__closure: function Extender__extendCompound__closure() {
    },
    Extender__extendCompound__closure0: function Extender__extendCompound__closure0(t0) {
      this._box_0 = t0;
    },
    Extender__extendCompound_closure1: function Extender__extendCompound_closure1() {
    },
    Extender__extendCompound_closure2: function Extender__extendCompound_closure2() {
    },
    Extender__extendSimple_withoutPseudo: function Extender__extendSimple_withoutPseudo(t0, t1, t2) {
      this.$this = t0;
      this.extensions = t1;
      this.targetsUsed = t2;
    },
    Extender__extendSimple_closure: function Extender__extendSimple_closure(t0, t1) {
      this.$this = t0;
      this.withoutPseudo = t1;
    },
    Extender__extendPseudo_closure: function Extender__extendPseudo_closure() {
    },
    Extender__extendPseudo_closure0: function Extender__extendPseudo_closure0() {
    },
    Extender__extendPseudo_closure1: function Extender__extendPseudo_closure1() {
    },
    Extender__extendPseudo_closure2: function Extender__extendPseudo_closure2(t0) {
      this.pseudo = t0;
    },
    Extender__extendPseudo_closure3: function Extender__extendPseudo_closure3(t0) {
      this.pseudo = t0;
    },
    Extender__trim_closure: function Extender__trim_closure(t0, t1) {
      this._box_0 = t0;
      this.complex1 = t1;
    },
    Extender__trim_closure0: function Extender__trim_closure0(t0, t1) {
      this._box_0 = t0;
      this.complex1 = t1;
    },
    Extender_clone_closure: function Extender_clone_closure(t0, t1, t2, t3) {
      var _ = this;
      _.$this = t0;
      _.newSelectors = t1;
      _.oldToNewRules = t2;
      _.newMediaContexts = t3;
    },
    FilesystemImporter: function FilesystemImporter(t0) {
      this._loadPath = t0;
    },
    NodeImporter__addSassPath: function(includePaths) {
      return F.NodeImporter__addSassPath$body(includePaths);
    },
    NodeImporter__addSassPath$body: function($async$includePaths) {
      return P._makeSyncStarIterable(function() {
        var includePaths = $async$includePaths;
        var $async$goto = 0, $async$handler = 2, $async$currentError, sassPath;
        return function $async$NodeImporter__addSassPath($async$errorCode, $async$result) {
          if ($async$errorCode === 1) {
            $async$currentError = $async$result;
            $async$goto = $async$handler;
          }
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$goto = 3;
                return P._IterationMarker_yieldStar(includePaths);
              case 3:
                // after yield
                sassPath = H.stringTypeCast(J.get$env$x(self.process).SASS_PATH);
                if (sassPath == null) {
                  // goto return
                  $async$goto = 1;
                  break;
                }
                $async$goto = 4;
                return P._IterationMarker_yieldStar(H.setRuntimeTypeInfo(sassPath.split(J.$eq$(J.get$platform$x(self.process), "win32") ? ";" : ":"), [P.String]));
              case 4:
                // after yield
              case 1:
                // return
                return P._IterationMarker_endOfIteration();
              case 2:
                // rethrow
                return P._IterationMarker_uncaughtError($async$currentError);
            }
        };
      }, P.String);
    },
    NodeImporter: function NodeImporter(t0, t1, t2) {
      this._implementation$_context = t0;
      this._includePaths = t1;
      this._implementation$_importers = t2;
    },
    realCasePath: function(path) {
      var t1, basename, matches;
      if (!(J.$eq$(J.get$platform$x(self.process), "win32") || J.$eq$(J.get$platform$x(self.process), "darwin")))
        return path;
      t1 = $.$get$context();
      basename = X.ParsedPath_ParsedPath$parse(path, t1.style).get$basename();
      matches = J.where$1$ax(B.listDir(t1.dirname$1(path), false), new F.realCasePath_closure(basename)).toList$0(0);
      if (matches.length !== 1)
        return path;
      return C.JSArray_methods.get$first(matches);
    },
    realCasePath_closure: function realCasePath_closure(t0) {
      this.basename = t0;
    },
    _QuietLogger: function _QuietLogger() {
    },
    JSFunction: function JSFunction() {
    },
    NodeImporterResult: function NodeImporterResult() {
    },
    MediaQueryParser: function MediaQueryParser(t0, t1) {
      this.scanner = t0;
      this.logger = t1;
    },
    MediaQueryParser_parse_closure: function MediaQueryParser_parse_closure(t0) {
      this.$this = t0;
    },
    PrefixedMapView: function PrefixedMapView(t0, t1, t2) {
      this._prefixed_map_view$_map = t0;
      this._prefix = t1;
      this.$ti = t2;
    },
    _PrefixedKeys: function _PrefixedKeys(t0) {
      this._view = t0;
    },
    _PrefixedKeys_iterator_closure: function _PrefixedKeys_iterator_closure(t0) {
      this.$this = t0;
    },
    Value: function Value() {
    },
    SassFunction: function SassFunction(t0) {
      this.callable = t0;
    },
    unwrapValue: function(object) {
      var value;
      if (object != null) {
        if (object instanceof F.Value)
          return object;
        value = object.dartValue;
        if (value != null && value instanceof F.Value)
          return value;
        if (object instanceof self.Error)
          throw H.wrapException(object);
      }
      throw H.wrapException(H.S(object) + " must be a Sass value type.");
    },
    wrapValue: function(value) {
      var t1 = J.getInterceptor$(value);
      if (!!t1.$isSassColor)
        return P.callConstructor($.$get$colorConstructor(), [null, null, null, null, value]);
      if (!!t1.$isSassList)
        return P.callConstructor($.$get$listConstructor(), [null, null, value]);
      if (!!t1.$isSassMap)
        return P.callConstructor($.$get$mapConstructor(), [null, value]);
      if (!!t1.$isSassNumber)
        return P.callConstructor($.$get$numberConstructor(), [null, null, value]);
      if (!!t1.$isSassString)
        return P.callConstructor($.$get$stringConstructor(), [null, value]);
      return value;
    }
  },
  Y = {StreamCompleter: function StreamCompleter(t0, t1) {
      this._stream_completer$_stream = t0;
      this.$ti = t1;
    }, _CompleterStream: function _CompleterStream(t0) {
      this._sourceStream = this._stream_completer$_controller = null;
      this.$ti = t0;
    },
    mapMap: function(map, key, value, K1, V1, K2, V2) {
      var result, t1 = {};
      t1.key = key;
      t1.value = value;
      if (key == null)
        t1.key = new Y.mapMap_closure(K2, K1, V1);
      if (value == null)
        t1.value = new Y.mapMap_closure0(V2, K1, V1);
      result = P.LinkedHashMap_LinkedHashMap$_empty(K2, V2);
      map.forEach$1(0, new Y.mapMap_closure1(t1, result, K1, V1));
      return result;
    },
    minBy: function(values, orderBy, $S, $T) {
      var t1, minValue, minOrderBy, element, elementOrderBy,
        compare = B.defaultCompare($T);
      for (t1 = new H.MappedIterator(J.get$iterator$ax(values.__internal$_iterable), values._f), minValue = null, minOrderBy = null; t1.moveNext$0();) {
        element = t1.__internal$_current;
        elementOrderBy = orderBy.call$1(element);
        if (minOrderBy == null || compare.call$2(elementOrderBy, minOrderBy) < 0) {
          minOrderBy = elementOrderBy;
          minValue = element;
        }
      }
      return minValue;
    },
    mapMap_closure: function mapMap_closure(t0, t1, t2) {
      this.K2 = t0;
      this.K1 = t1;
      this.V1 = t2;
    },
    mapMap_closure0: function mapMap_closure0(t0, t1, t2) {
      this.V2 = t0;
      this.K1 = t1;
      this.V1 = t2;
    },
    mapMap_closure1: function mapMap_closure1(t0, t1, t2, t3) {
      var _ = this;
      _._box_0 = t0;
      _.result = t1;
      _.K1 = t2;
      _.V1 = t3;
    },
    ContentBlock: function ContentBlock(t0, t1, t2, t3, t4) {
      var _ = this;
      _.name = t0;
      _.$arguments = t1;
      _.span = t2;
      _.children = t3;
      _.hasDeclarations = t4;
    },
    WarnRule: function WarnRule(t0, t1) {
      this.expression = t0;
      this.span = t1;
    },
    unifyComplex: function(complexes) {
      var t2, unifiedBase, base, t3, t4, _i, complexesWithoutBases,
        t1 = J.getInterceptor$asx(complexes);
      if (t1.get$length(complexes) === 1)
        return complexes;
      for (t2 = t1.get$iterator(complexes), unifiedBase = null; t2.moveNext$0();) {
        base = J.get$last$ax(t2.get$current(t2));
        if (base instanceof X.CompoundSelector)
          if (unifiedBase == null)
            unifiedBase = base.components;
          else
            for (t3 = base.components, t4 = t3.length, _i = 0; _i < t4; ++_i) {
              unifiedBase = t3[_i].unify$1(unifiedBase);
              if (unifiedBase == null)
                return;
            }
        else
          return;
      }
      complexesWithoutBases = t1.map$1$1(complexes, new Y.unifyComplex_closure(), [P.List, S.ComplexSelectorComponent]).toList$0(0);
      J.add$1$ax(C.JSArray_methods.get$last(complexesWithoutBases), X.CompoundSelector$(unifiedBase));
      return Y.weave(complexesWithoutBases);
    },
    unifyCompound: function(compound1, compound2) {
      var t1, result, _i;
      for (t1 = compound1.length, result = compound2, _i = 0; _i < t1; ++_i) {
        result = compound1[_i].unify$1(result);
        if (result == null)
          return;
      }
      return X.CompoundSelector$(result);
    },
    unifyUniversalAndElement: function(selector1, selector2) {
      var namespace1, name1, t1, namespace2, name2, namespace, $name,
        _s45_ = "must be a UniversalSelector or a TypeSelector";
      if (!!selector1.$isUniversalSelector) {
        namespace1 = selector1.namespace;
        name1 = null;
      } else if (!!selector1.$isTypeSelector) {
        t1 = selector1.name;
        namespace1 = t1.namespace;
        name1 = t1.name;
      } else
        throw H.wrapException(P.ArgumentError$value(selector1, "selector1", _s45_));
      t1 = J.getInterceptor$(selector2);
      if (!!t1.$isUniversalSelector) {
        namespace2 = selector2.namespace;
        name2 = null;
      } else if (!!t1.$isTypeSelector) {
        t1 = selector2.name;
        namespace2 = t1.namespace;
        name2 = t1.name;
      } else
        throw H.wrapException(P.ArgumentError$value(selector2, "selector2", _s45_));
      if (namespace1 == namespace2 || namespace2 === "*")
        namespace = namespace1;
      else {
        if (namespace1 !== "*")
          return;
        namespace = namespace2;
      }
      if (name1 == name2 || name2 == null)
        $name = name1;
      else {
        if (!(name1 == null || name1 === "*"))
          return;
        $name = name2;
      }
      return $name == null ? new N.UniversalSelector(namespace) : new F.TypeSelector(new D.QualifiedName($name, namespace));
    },
    weave: function(complexes) {
      var t2, t3, t4, target, _i, parents, newPrefixes, parentPrefixes, t5,
        t1 = [[P.List, S.ComplexSelectorComponent]],
        prefixes = H.setRuntimeTypeInfo([J.toList$0$ax(C.JSArray_methods.get$first(complexes))], t1);
      for (t2 = H.SubListIterable$(complexes, 1, null, H.getTypeArgumentByIndex(complexes, 0)), t2 = new H.ListIterator(t2, t2.get$length(t2)); t2.moveNext$0();) {
        t3 = t2.__internal$_current;
        t4 = J.getInterceptor$asx(t3);
        if (t4.get$isEmpty(t3))
          continue;
        target = t4.get$last(t3);
        if (t4.get$length(t3) === 1) {
          for (t3 = prefixes.length, _i = 0; _i < prefixes.length; prefixes.length === t3 || (0, H.throwConcurrentModificationError)(prefixes), ++_i)
            J.add$1$ax(prefixes[_i], target);
          continue;
        }
        parents = t4.take$1(t3, t4.get$length(t3) - 1).toList$0(0);
        newPrefixes = H.setRuntimeTypeInfo([], t1);
        for (t3 = prefixes.length, _i = 0; _i < prefixes.length; prefixes.length === t3 || (0, H.throwConcurrentModificationError)(prefixes), ++_i) {
          parentPrefixes = Y._weaveParents(prefixes[_i], parents);
          if (parentPrefixes == null)
            continue;
          for (t4 = parentPrefixes.get$iterator(parentPrefixes); t4.moveNext$0();) {
            t5 = t4.get$current(t4);
            J.add$1$ax(t5, target);
            newPrefixes.push(t5);
          }
        }
        prefixes = newPrefixes;
      }
      return prefixes;
    },
    _weaveParents: function(parents1, parents2) {
      var finalCombinators, root1, root2, root, groups1, groups2, lcs, t2, t3, choices, t4, _i, group, t5,
        t1 = S.ComplexSelectorComponent,
        queue1 = P.ListQueue_ListQueue$of(parents1, t1),
        queue2 = P.ListQueue_ListQueue$of(parents2, t1),
        initialCombinators = Y._mergeInitialCombinators(queue1, queue2);
      if (initialCombinators == null)
        return;
      finalCombinators = Y._mergeFinalCombinators(queue1, queue2, null);
      if (finalCombinators == null)
        return;
      root1 = Y._firstIfRoot(queue1);
      root2 = Y._firstIfRoot(queue2);
      t1 = root1 != null;
      if (t1 && root2 != null) {
        root = Y.unifyCompound(root1.components, root2.components);
        if (root == null)
          return;
        queue1.addFirst$1(root);
        queue2.addFirst$1(root);
      } else if (t1)
        queue2.addFirst$1(root1);
      else if (root2 != null)
        queue1.addFirst$1(root2);
      groups1 = Y._groupSelectors(queue1);
      groups2 = Y._groupSelectors(queue2);
      t1 = [P.List, S.ComplexSelectorComponent];
      lcs = B.longestCommonSubsequence(groups2, groups1, new Y._weaveParents_closure(), t1);
      t2 = [P.Iterable, S.ComplexSelectorComponent];
      t3 = [t2];
      choices = H.setRuntimeTypeInfo([H.setRuntimeTypeInfo([initialCombinators], t3)], [[P.List, [P.Iterable, S.ComplexSelectorComponent]]]);
      for (t4 = lcs.length, _i = 0; _i < lcs.length; lcs.length === t4 || (0, H.throwConcurrentModificationError)(lcs), ++_i) {
        group = lcs[_i];
        t5 = Y._chunks(groups1, groups2, new Y._weaveParents_closure0(group), t1);
        choices.push(new H.MappedListIterable(t5, new Y._weaveParents_closure1(), [H.getTypeArgumentByIndex(t5, 0), t2]).toList$0(0));
        choices.push(H.setRuntimeTypeInfo([group], t3));
        groups1.removeFirst$0();
        groups2.removeFirst$0();
      }
      t3 = Y._chunks(groups1, groups2, new Y._weaveParents_closure2(), t1);
      choices.push(new H.MappedListIterable(t3, new Y._weaveParents_closure3(), [H.getTypeArgumentByIndex(t3, 0), t2]).toList$0(0));
      C.JSArray_methods.addAll$1(choices, finalCombinators);
      return J.map$1$1$ax(Y.paths(new H.WhereIterable(choices, new Y._weaveParents_closure4(), [H.getTypeArgumentByIndex(choices, 0)]), t2), new Y._weaveParents_closure5(), t1);
    },
    _firstIfRoot: function(queue) {
      var first;
      if (queue._collection$_head === queue._collection$_tail)
        return;
      first = queue.get$first(queue);
      if (first instanceof X.CompoundSelector) {
        if (!Y._hasRoot(first))
          return;
        queue.removeFirst$0();
        return first;
      } else
        return;
    },
    _mergeInitialCombinators: function(components1, components2) {
      var t3, combinators2, lcs,
        t1 = S.Combinator,
        t2 = [t1],
        combinators1 = H.setRuntimeTypeInfo([], t2);
      while (true) {
        if (!components1.get$isEmpty(components1)) {
          t3 = components1._collection$_head;
          if (t3 === components1._collection$_tail)
            H.throwExpression(H.IterableElementError_noElement());
          t3 = components1._collection$_table[t3] instanceof S.Combinator;
        } else
          t3 = false;
        if (!t3)
          break;
        combinators1.push(H.interceptedTypeCast(components1.removeFirst$0(), "$isCombinator"));
      }
      combinators2 = H.setRuntimeTypeInfo([], t2);
      while (true) {
        if (!components2.get$isEmpty(components2)) {
          t2 = components2._collection$_head;
          if (t2 === components2._collection$_tail)
            H.throwExpression(H.IterableElementError_noElement());
          t2 = components2._collection$_table[t2] instanceof S.Combinator;
        } else
          t2 = false;
        if (!t2)
          break;
        combinators2.push(H.interceptedTypeCast(components2.removeFirst$0(), "$isCombinator"));
      }
      lcs = B.longestCommonSubsequence(combinators1, combinators2, null, t1);
      if (C.C_ListEquality.equals$2(lcs, combinators1))
        return combinators2;
      if (C.C_ListEquality.equals$2(lcs, combinators2))
        return combinators1;
      return;
    },
    _mergeFinalCombinators: function(components1, components2, result) {
      var t1, t2, combinators1, combinators2, lcs, combinator1, combinator2, compound1, compound2, choices, unified, followingSiblingSelector, nextSiblingSelector, _null = null;
      if (result == null)
        result = Q.QueueList$(_null, [P.List, [P.List, S.ComplexSelectorComponent]]);
      if (components1._collection$_head === components1._collection$_tail || !(components1.get$last(components1) instanceof S.Combinator))
        t1 = components2._collection$_head === components2._collection$_tail || !(components2.get$last(components2) instanceof S.Combinator);
      else
        t1 = false;
      if (t1)
        return result;
      t1 = S.Combinator;
      t2 = [t1];
      combinators1 = H.setRuntimeTypeInfo([], t2);
      while (true) {
        if (!(!components1.get$isEmpty(components1) && components1.get$last(components1) instanceof S.Combinator))
          break;
        combinators1.push(H.interceptedTypeCast(components1.removeLast$0(0), "$isCombinator"));
      }
      combinators2 = H.setRuntimeTypeInfo([], t2);
      while (true) {
        if (!(!components2.get$isEmpty(components2) && components2.get$last(components2) instanceof S.Combinator))
          break;
        combinators2.push(H.interceptedTypeCast(components2.removeLast$0(0), "$isCombinator"));
      }
      t2 = combinators1.length;
      if (t2 > 1 || combinators2.length > 1) {
        lcs = B.longestCommonSubsequence(combinators1, combinators2, _null, t1);
        if (C.C_ListEquality.equals$2(lcs, combinators1))
          result.addFirst$1(H.setRuntimeTypeInfo([P.List_List$from(new H.ReversedListIterable(combinators2, [H.getTypeArgumentByIndex(combinators2, 0)]), true, S.ComplexSelectorComponent)], [[P.List, S.ComplexSelectorComponent]]));
        else if (C.C_ListEquality.equals$2(lcs, combinators2))
          result.addFirst$1(H.setRuntimeTypeInfo([P.List_List$from(new H.ReversedListIterable(combinators1, [H.getTypeArgumentByIndex(combinators1, 0)]), true, S.ComplexSelectorComponent)], [[P.List, S.ComplexSelectorComponent]]));
        else
          return;
        return result;
      }
      combinator1 = t2 === 0 ? _null : C.JSArray_methods.get$first(combinators1);
      combinator2 = combinators2.length === 0 ? _null : C.JSArray_methods.get$first(combinators2);
      t1 = combinator1 != null;
      if (t1 && combinator2 != null) {
        compound1 = H.interceptedTypeCast(components1.removeLast$0(0), "$isCompoundSelector");
        compound2 = H.interceptedTypeCast(components2.removeLast$0(0), "$isCompoundSelector");
        t1 = combinator1 === C.Combinator_CzM;
        if (t1 && combinator2 === C.Combinator_CzM) {
          compound1.toString;
          if (Y.compoundIsSuperselector(compound1, compound2, _null))
            result.addFirst$1(H.setRuntimeTypeInfo([H.setRuntimeTypeInfo([compound2, C.Combinator_CzM], [S.ComplexSelectorComponent])], [[P.List, S.ComplexSelectorComponent]]));
          else {
            compound2.toString;
            t1 = [S.ComplexSelectorComponent];
            t2 = [[P.List, S.ComplexSelectorComponent]];
            if (Y.compoundIsSuperselector(compound2, compound1, _null))
              result.addFirst$1(H.setRuntimeTypeInfo([H.setRuntimeTypeInfo([compound1, C.Combinator_CzM], t1)], t2));
            else {
              choices = H.setRuntimeTypeInfo([H.setRuntimeTypeInfo([compound1, C.Combinator_CzM, compound2, C.Combinator_CzM], t1), H.setRuntimeTypeInfo([compound2, C.Combinator_CzM, compound1, C.Combinator_CzM], t1)], t2);
              unified = Y.unifyCompound(compound1.components, compound2.components);
              if (unified != null)
                choices.push(H.setRuntimeTypeInfo([unified, C.Combinator_CzM], t1));
              result.addFirst$1(choices);
            }
          }
        } else {
          if (!(t1 && combinator2 === C.Combinator_uzg))
            t2 = combinator1 === C.Combinator_uzg && combinator2 === C.Combinator_CzM;
          else
            t2 = true;
          if (t2) {
            followingSiblingSelector = t1 ? compound1 : compound2;
            nextSiblingSelector = t1 ? compound2 : compound1;
            followingSiblingSelector.toString;
            t1 = [S.ComplexSelectorComponent];
            t2 = [[P.List, S.ComplexSelectorComponent]];
            if (Y.compoundIsSuperselector(followingSiblingSelector, nextSiblingSelector, _null))
              result.addFirst$1(H.setRuntimeTypeInfo([H.setRuntimeTypeInfo([nextSiblingSelector, C.Combinator_uzg], t1)], t2));
            else {
              unified = Y.unifyCompound(compound1.components, compound2.components);
              t2 = H.setRuntimeTypeInfo([], t2);
              t2.push(H.setRuntimeTypeInfo([followingSiblingSelector, C.Combinator_CzM, nextSiblingSelector, C.Combinator_uzg], t1));
              if (unified != null)
                t2.push(H.setRuntimeTypeInfo([unified, C.Combinator_uzg], t1));
              result.addFirst$1(t2);
            }
          } else {
            if (combinator1 === C.Combinator_sgq)
              t2 = combinator2 === C.Combinator_uzg || combinator2 === C.Combinator_CzM;
            else
              t2 = false;
            if (t2) {
              result.addFirst$1(H.setRuntimeTypeInfo([H.setRuntimeTypeInfo([compound2, combinator2], [S.ComplexSelectorComponent])], [[P.List, S.ComplexSelectorComponent]]));
              components1._collection$_add$1(compound1);
              components1._collection$_add$1(C.Combinator_sgq);
            } else {
              if (combinator2 === C.Combinator_sgq)
                t1 = combinator1 === C.Combinator_uzg || t1;
              else
                t1 = false;
              if (t1) {
                result.addFirst$1(H.setRuntimeTypeInfo([H.setRuntimeTypeInfo([compound1, combinator1], [S.ComplexSelectorComponent])], [[P.List, S.ComplexSelectorComponent]]));
                components2._collection$_add$1(compound2);
                components2._collection$_add$1(C.Combinator_sgq);
              } else if (combinator1 === combinator2) {
                unified = Y.unifyCompound(compound1.components, compound2.components);
                if (unified == null)
                  return;
                result.addFirst$1(H.setRuntimeTypeInfo([H.setRuntimeTypeInfo([unified, combinator1], [S.ComplexSelectorComponent])], [[P.List, S.ComplexSelectorComponent]]));
              } else
                return;
            }
          }
        }
        return Y._mergeFinalCombinators(components1, components2, result);
      } else if (t1) {
        if (combinator1 === C.Combinator_sgq)
          if (!components2.get$isEmpty(components2)) {
            t1 = H.interceptedTypeCast(components2.get$last(components2), "$isCompoundSelector");
            t2 = H.interceptedTypeCast(components1.get$last(components1), "$isCompoundSelector");
            t1.toString;
            t2 = Y.compoundIsSuperselector(t1, t2, _null);
            t1 = t2;
          } else
            t1 = false;
        else
          t1 = false;
        if (t1)
          components2.removeLast$0(0);
        result.addFirst$1(H.setRuntimeTypeInfo([H.setRuntimeTypeInfo([components1.removeLast$0(0), combinator1], [S.ComplexSelectorComponent])], [[P.List, S.ComplexSelectorComponent]]));
        return Y._mergeFinalCombinators(components1, components2, result);
      } else {
        if (combinator2 === C.Combinator_sgq)
          if (!components1.get$isEmpty(components1)) {
            t1 = H.interceptedTypeCast(components1.get$last(components1), "$isCompoundSelector");
            t2 = H.interceptedTypeCast(components2.get$last(components2), "$isCompoundSelector");
            t1.toString;
            t2 = Y.compoundIsSuperselector(t1, t2, _null);
            t1 = t2;
          } else
            t1 = false;
        else
          t1 = false;
        if (t1)
          components1.removeLast$0(0);
        result.addFirst$1(H.setRuntimeTypeInfo([H.setRuntimeTypeInfo([components2.removeLast$0(0), combinator2], [S.ComplexSelectorComponent])], [[P.List, S.ComplexSelectorComponent]]));
        return Y._mergeFinalCombinators(components1, components2, result);
      }
    },
    _mustUnify: function(complex1, complex2) {
      var t2, t3, t4,
        t1 = P.LinkedHashSet_LinkedHashSet(M.SimpleSelector);
      for (t2 = J.get$iterator$ax(complex1); t2.moveNext$0();) {
        t3 = t2.get$current(t2);
        if (t3 instanceof X.CompoundSelector)
          for (t3 = C.JSArray_methods.get$iterator(t3.components), t4 = new H.WhereIterator(t3, Y.functions___isUnique$closure()); t4.moveNext$0();)
            t1.add$1(0, t3.get$current(t3));
      }
      if (t1._collection$_length === 0)
        return false;
      return J.any$1$ax(complex2, new Y._mustUnify_closure(t1));
    },
    _isUnique: function(simple) {
      var t1 = J.getInterceptor$(simple);
      if (!t1.$isIDSelector)
        t1 = !!t1.$isPseudoSelector && !simple.isClass;
      else
        t1 = true;
      return t1;
    },
    _chunks: function(queue1, queue2, done, $T) {
      var chunk2, t2, t3, _i,
        t1 = [$T],
        chunk1 = H.setRuntimeTypeInfo([], t1);
      for (; !done.call$1(queue1);)
        chunk1.push(queue1.removeFirst$0());
      chunk2 = H.setRuntimeTypeInfo([], t1);
      for (; !done.call$1(queue2);)
        chunk2.push(queue2.removeFirst$0());
      t2 = chunk1.length === 0;
      if (t2 && chunk2.length === 0)
        return H.setRuntimeTypeInfo([], [[P.List, $T]]);
      if (t2)
        return H.setRuntimeTypeInfo([chunk2], [[P.List, $T]]);
      if (chunk2.length === 0)
        return H.setRuntimeTypeInfo([chunk1], [[P.List, $T]]);
      t2 = H.setRuntimeTypeInfo([], t1);
      for (t3 = chunk1.length, _i = 0; _i < chunk1.length; chunk1.length === t3 || (0, H.throwConcurrentModificationError)(chunk1), ++_i)
        t2.push(chunk1[_i]);
      for (t3 = chunk2.length, _i = 0; _i < chunk2.length; chunk2.length === t3 || (0, H.throwConcurrentModificationError)(chunk2), ++_i)
        t2.push(chunk2[_i]);
      t1 = H.setRuntimeTypeInfo([], t1);
      for (t3 = chunk2.length, _i = 0; _i < chunk2.length; chunk2.length === t3 || (0, H.throwConcurrentModificationError)(chunk2), ++_i)
        t1.push(chunk2[_i]);
      for (t3 = chunk1.length, _i = 0; _i < chunk1.length; chunk1.length === t3 || (0, H.throwConcurrentModificationError)(chunk1), ++_i)
        t1.push(chunk1[_i]);
      return H.setRuntimeTypeInfo([t2, t1], [[P.List, $T]]);
    },
    paths: function(choices, $T) {
      return J.fold$2$ax(choices, H.setRuntimeTypeInfo([H.setRuntimeTypeInfo([], [$T])], [[P.List, $T]]), new Y.paths_closure($T));
    },
    _groupSelectors: function(complex) {
      var t1, group, t2,
        groups = Q.QueueList$(null, [P.List, S.ComplexSelectorComponent]),
        iterator = P._ListQueueIterator$(complex);
      iterator.moveNext$0();
      for (t1 = [S.ComplexSelectorComponent]; iterator._collection$_current != null;) {
        group = H.setRuntimeTypeInfo([], t1);
        do {
          group.push(iterator._collection$_current);
          if (iterator.moveNext$0())
            t2 = iterator._collection$_current instanceof S.Combinator || C.JSArray_methods.get$last(group) instanceof S.Combinator;
          else
            t2 = false;
        } while (t2);
        groups._queue_list$_add$1(group);
      }
      return groups;
    },
    _hasRoot: function(compound) {
      return C.JSArray_methods.any$1(compound.components, new Y._hasRoot_closure());
    },
    listIsSuperslector: function(list1, list2) {
      return C.JSArray_methods.every$1(list2, new Y.listIsSuperslector_closure(list1));
    },
    complexIsParentSuperselector: function(complex1, complex2) {
      var t2, base, t3, t4,
        t1 = J.getInterceptor$ax(complex1);
      if (t1.get$first(complex1) instanceof S.Combinator)
        return false;
      t2 = J.getInterceptor$ax(complex2);
      if (t2.get$first(complex2) instanceof S.Combinator)
        return false;
      if (t1.get$length(complex1) > t2.get$length(complex2))
        return false;
      base = X.CompoundSelector$(H.setRuntimeTypeInfo([new N.PlaceholderSelector("<temp>")], [M.SimpleSelector]));
      t3 = [S.ComplexSelectorComponent];
      t4 = H.setRuntimeTypeInfo([], t3);
      for (t1 = t1.get$iterator(complex1); t1.moveNext$0();)
        t4.push(t1.get$current(t1));
      t4.push(base);
      t1 = H.setRuntimeTypeInfo([], t3);
      for (t2 = t2.get$iterator(complex2); t2.moveNext$0();)
        t1.push(t2.get$current(t2));
      t1.push(base);
      return Y.complexIsSuperselector(t4, t1);
    },
    complexIsSuperselector: function(complex1, complex2) {
      var t1, i1, i2, remaining1, remaining2, t2, afterSuperselector, afterSuperselector0, t3, compound2, i10, combinator1, combinator2;
      if (C.JSArray_methods.get$last(complex1) instanceof S.Combinator)
        return false;
      if (C.JSArray_methods.get$last(complex2) instanceof S.Combinator)
        return false;
      for (t1 = H.getTypeArgumentByIndex(complex2, 0), i1 = 0, i2 = 0; true;) {
        remaining1 = complex1.length - i1;
        remaining2 = complex2.length - i2;
        if (remaining1 === 0 || remaining2 === 0)
          return false;
        if (remaining1 > remaining2)
          return false;
        t2 = complex1[i1];
        if (t2 instanceof S.Combinator)
          return false;
        if (complex2[i2] instanceof S.Combinator)
          return false;
        H.interceptedTypeCast(t2, "$isCompoundSelector");
        if (remaining1 === 1)
          return Y.compoundIsSuperselector(t2, H.interceptedTypeCast(C.JSArray_methods.get$last(complex2), "$isCompoundSelector"), H.SubListIterable$(complex2, i2 + 1, null, t1));
        afterSuperselector = i2 + 1;
        for (afterSuperselector0 = afterSuperselector; afterSuperselector0 < complex2.length; ++afterSuperselector0) {
          t3 = afterSuperselector0 - 1;
          compound2 = complex2[t3];
          if (compound2 instanceof X.CompoundSelector)
            if (Y.compoundIsSuperselector(t2, compound2, H.SubListIterable$(complex2, 0, t3, t1).skip$1(0, afterSuperselector)))
              break;
        }
        if (afterSuperselector0 === complex2.length)
          return false;
        i10 = i1 + 1;
        combinator1 = complex1[i10];
        combinator2 = complex2[afterSuperselector0];
        if (combinator1 instanceof S.Combinator) {
          if (!(combinator2 instanceof S.Combinator))
            return false;
          if (combinator1 === C.Combinator_CzM) {
            if (combinator2 === C.Combinator_sgq)
              return false;
          } else if (combinator2 !== combinator1)
            return false;
          if (remaining1 === 3 && remaining2 > 3)
            return false;
          i1 += 2;
          i2 = afterSuperselector0 + 1;
        } else {
          if (combinator2 instanceof S.Combinator) {
            if (combinator2 !== C.Combinator_sgq)
              return false;
            i2 = afterSuperselector0 + 1;
          } else
            i2 = afterSuperselector0;
          i1 = i10;
        }
      }
    },
    compoundIsSuperselector: function(compound1, compound2, parents) {
      var t1, t2, _i, simple1, simple2;
      for (t1 = compound1.components, t2 = t1.length, _i = 0; _i < t2; ++_i) {
        simple1 = t1[_i];
        if (simple1 instanceof D.PseudoSelector && simple1.selector != null) {
          if (!Y._selectorPseudoIsSuperselector(simple1, compound2, parents))
            return false;
        } else if (!Y._simpleIsSuperselectorOfCompound(simple1, compound2))
          return false;
      }
      for (t1 = compound2.components, t2 = t1.length, _i = 0; _i < t2; ++_i) {
        simple2 = t1[_i];
        if (simple2 instanceof D.PseudoSelector && !simple2.isClass && !Y._simpleIsSuperselectorOfCompound(simple2, compound1))
          return false;
      }
      return true;
    },
    _simpleIsSuperselectorOfCompound: function(simple, compound) {
      return C.JSArray_methods.any$1(compound.components, new Y._simpleIsSuperselectorOfCompound_closure(simple));
    },
    _selectorPseudoIsSuperselector: function(pseudo1, compound2, parents) {
      switch (pseudo1.normalizedName) {
        case "matches":
        case "any":
          return Y._selectorPseudosNamed(compound2, pseudo1.name).any$1(0, new Y._selectorPseudoIsSuperselector_closure(pseudo1)) || C.JSArray_methods.any$1(pseudo1.selector.components, new Y._selectorPseudoIsSuperselector_closure0(parents, compound2));
        case "has":
        case "host":
        case "host-context":
        case "slotted":
          return Y._selectorPseudosNamed(compound2, pseudo1.name).any$1(0, new Y._selectorPseudoIsSuperselector_closure1(pseudo1));
        case "not":
          return C.JSArray_methods.every$1(pseudo1.selector.components, new Y._selectorPseudoIsSuperselector_closure2(compound2, pseudo1));
        case "current":
          return Y._selectorPseudosNamed(compound2, "current").any$1(0, new Y._selectorPseudoIsSuperselector_closure3(pseudo1));
        case "nth-child":
        case "nth-last-child":
          return C.JSArray_methods.any$1(compound2.components, new Y._selectorPseudoIsSuperselector_closure4(pseudo1));
        default:
          throw H.wrapException("unreachable");
      }
    },
    _selectorPseudosNamed: function(compound, $name) {
      var t1 = D.PseudoSelector;
      return new H.WhereIterable(new H.WhereTypeIterable(compound.components, [t1]), new Y._selectorPseudosNamed_closure($name), [t1]);
    },
    unifyComplex_closure: function unifyComplex_closure() {
    },
    _weaveParents_closure: function _weaveParents_closure() {
    },
    _weaveParents_closure0: function _weaveParents_closure0(t0) {
      this.group = t0;
    },
    _weaveParents_closure1: function _weaveParents_closure1() {
    },
    _weaveParents__closure1: function _weaveParents__closure1() {
    },
    _weaveParents_closure2: function _weaveParents_closure2() {
    },
    _weaveParents_closure3: function _weaveParents_closure3() {
    },
    _weaveParents__closure0: function _weaveParents__closure0() {
    },
    _weaveParents_closure4: function _weaveParents_closure4() {
    },
    _weaveParents_closure5: function _weaveParents_closure5() {
    },
    _weaveParents__closure: function _weaveParents__closure() {
    },
    _mustUnify_closure: function _mustUnify_closure(t0) {
      this.uniqueSelectors = t0;
    },
    _mustUnify__closure: function _mustUnify__closure(t0) {
      this.uniqueSelectors = t0;
    },
    paths_closure: function paths_closure(t0) {
      this.T = t0;
    },
    paths__closure: function paths__closure(t0, t1) {
      this.paths = t0;
      this.T = t1;
    },
    paths___closure: function paths___closure(t0, t1) {
      this.option = t0;
      this.T = t1;
    },
    _hasRoot_closure: function _hasRoot_closure() {
    },
    listIsSuperslector_closure: function listIsSuperslector_closure(t0) {
      this.list1 = t0;
    },
    listIsSuperslector__closure: function listIsSuperslector__closure(t0) {
      this.complex1 = t0;
    },
    _simpleIsSuperselectorOfCompound_closure: function _simpleIsSuperselectorOfCompound_closure(t0) {
      this.simple = t0;
    },
    _simpleIsSuperselectorOfCompound__closure: function _simpleIsSuperselectorOfCompound__closure(t0) {
      this.simple = t0;
    },
    _selectorPseudoIsSuperselector_closure: function _selectorPseudoIsSuperselector_closure(t0) {
      this.pseudo1 = t0;
    },
    _selectorPseudoIsSuperselector_closure0: function _selectorPseudoIsSuperselector_closure0(t0, t1) {
      this.parents = t0;
      this.compound2 = t1;
    },
    _selectorPseudoIsSuperselector_closure1: function _selectorPseudoIsSuperselector_closure1(t0) {
      this.pseudo1 = t0;
    },
    _selectorPseudoIsSuperselector_closure2: function _selectorPseudoIsSuperselector_closure2(t0, t1) {
      this.compound2 = t0;
      this.pseudo1 = t1;
    },
    _selectorPseudoIsSuperselector__closure: function _selectorPseudoIsSuperselector__closure(t0, t1) {
      this.complex = t0;
      this.pseudo1 = t1;
    },
    _selectorPseudoIsSuperselector___closure: function _selectorPseudoIsSuperselector___closure(t0) {
      this.simple2 = t0;
    },
    _selectorPseudoIsSuperselector___closure0: function _selectorPseudoIsSuperselector___closure0(t0) {
      this.simple2 = t0;
    },
    _selectorPseudoIsSuperselector_closure3: function _selectorPseudoIsSuperselector_closure3(t0) {
      this.pseudo1 = t0;
    },
    _selectorPseudoIsSuperselector_closure4: function _selectorPseudoIsSuperselector_closure4(t0) {
      this.pseudo1 = t0;
    },
    _selectorPseudosNamed_closure: function _selectorPseudosNamed_closure(t0) {
      this.name = t0;
    },
    closure37: function closure37() {
    },
    Chokidar: function Chokidar() {
    },
    ChokidarOptions: function ChokidarOptions() {
    },
    ChokidarWatcher: function ChokidarWatcher() {
    },
    SourceFile$decoded: function(decodedChars, url) {
      var t1 = H.setRuntimeTypeInfo([0], [P.int]),
        t2 = typeof url === "string" ? P.Uri_parse(url) : url;
      t1 = new Y.SourceFile(t2, t1, new Uint32Array(H._ensureNativeList(J.toList$0$ax(decodedChars))));
      t1.SourceFile$decoded$2$url(decodedChars, url);
      return t1;
    },
    FileLocation$_: function(file, offset) {
      if (offset < 0)
        H.throwExpression(P.RangeError$("Offset may not be negative, was " + H.S(offset) + "."));
      else if (offset > file._decodedChars.length)
        H.throwExpression(P.RangeError$("Offset " + H.S(offset) + " must not be greater than the number of characters in the file, " + file.get$length(file) + "."));
      return new Y.FileLocation(file, offset);
    },
    _FileSpan$: function(file, _start, _end) {
      if (_end < _start)
        H.throwExpression(P.ArgumentError$("End " + H.S(_end) + " must come after start " + H.S(_start) + "."));
      else if (_end > file._decodedChars.length)
        H.throwExpression(P.RangeError$("End " + H.S(_end) + " must not be greater than the number of characters in the file, " + file.get$length(file) + "."));
      else if (_start < 0)
        H.throwExpression(P.RangeError$("Start may not be negative, was " + H.S(_start) + "."));
      return new Y._FileSpan(file, _start, _end);
    },
    SourceFile: function SourceFile(t0, t1, t2) {
      var _ = this;
      _.url = t0;
      _._lineStarts = t1;
      _._decodedChars = t2;
      _._cachedLine = null;
    },
    FileLocation: function FileLocation(t0, t1) {
      this.file = t0;
      this.offset = t1;
    },
    FileSpan: function FileSpan() {
    },
    _FileSpan: function _FileSpan(t0, t1, t2) {
      this.file = t0;
      this._start = t1;
      this._end = t2;
    },
    SourceSpanMixin: function SourceSpanMixin() {
    },
    Trace_Trace$from: function(trace) {
      if (trace == null)
        throw H.wrapException(P.ArgumentError$("Cannot create a Trace from null."));
      if (!!trace.$isTrace)
        return trace;
      if (!!trace.$isChain)
        return trace.toTrace$0();
      return new T.LazyTrace(new Y.Trace_Trace$from_closure(trace));
    },
    Trace_Trace$parse: function(trace) {
      var error, t1, exception;
      try {
        if (trace.length === 0) {
          t1 = A.Frame;
          t1 = P.List_List$unmodifiable(H.setRuntimeTypeInfo([], [t1]), t1);
          return new Y.Trace(t1, new P._StringStackTrace(null));
        }
        if (J.getInterceptor$asx(trace).contains$1(trace, $.$get$_v8Trace())) {
          t1 = Y.Trace$parseV8(trace);
          return t1;
        }
        if (C.JSString_methods.contains$1(trace, "\tat ")) {
          t1 = Y.Trace$parseJSCore(trace);
          return t1;
        }
        if (C.JSString_methods.contains$1(trace, $.$get$_firefoxSafariTrace())) {
          t1 = Y.Trace$parseFirefox(trace);
          return t1;
        }
        if (C.JSString_methods.contains$1(trace, "===== asynchronous gap ===========================\n")) {
          t1 = U.Chain_Chain$parse(trace).toTrace$0();
          return t1;
        }
        if (C.JSString_methods.contains$1(trace, $.$get$_friendlyTrace())) {
          t1 = Y.Trace$parseFriendly(trace);
          return t1;
        }
        t1 = P.List_List$unmodifiable(Y.Trace__parseVM(trace), A.Frame);
        return new Y.Trace(t1, new P._StringStackTrace(trace));
      } catch (exception) {
        t1 = H.unwrapException(exception);
        if (!!J.getInterceptor$(t1).$isFormatException) {
          error = t1;
          throw H.wrapException(P.FormatException$(H.S(J.get$message$x(error)) + "\nStack trace:\n" + H.S(trace), null, null));
        } else
          throw exception;
      }
    },
    Trace__parseVM: function(trace) {
      var $frames,
        t1 = J.trim$0$s(trace),
        lines = H.setRuntimeTypeInfo(H.stringReplaceAllUnchecked(t1, "<asynchronous suspension>\n", "").split("\n"), [P.String]);
      t1 = H.SubListIterable$(lines, 0, lines.length - 1, H.getTypeArgumentByIndex(lines, 0));
      $frames = new H.MappedListIterable(t1, new Y.Trace__parseVM_closure(), [H.getTypeArgumentByIndex(t1, 0), A.Frame]).toList$0(0);
      if (!J.endsWith$1$s(C.JSArray_methods.get$last(lines), ".da"))
        C.JSArray_methods.add$1($frames, A.Frame_Frame$parseVM(C.JSArray_methods.get$last(lines)));
      return $frames;
    },
    Trace$parseV8: function(trace) {
      var t2,
        t1 = H.setRuntimeTypeInfo(trace.split("\n"), [P.String]);
      t1 = H.SubListIterable$(t1, 1, null, H.getTypeArgumentByIndex(t1, 0)).super$Iterable$skipWhile(0, new Y.Trace$parseV8_closure());
      t2 = A.Frame;
      return new Y.Trace(P.List_List$unmodifiable(H.MappedIterable_MappedIterable(t1, new Y.Trace$parseV8_closure0(), H.getTypeArgumentByIndex(t1, 0), t2), t2), new P._StringStackTrace(trace));
    },
    Trace$parseJSCore: function(trace) {
      var t1 = H.setRuntimeTypeInfo(trace.split("\n"), [P.String]),
        t2 = H.getTypeArgumentByIndex(t1, 0),
        t3 = A.Frame;
      return new Y.Trace(P.List_List$unmodifiable(new H.MappedIterable(new H.WhereIterable(t1, new Y.Trace$parseJSCore_closure(), [t2]), new Y.Trace$parseJSCore_closure0(), [t2, t3]), t3), new P._StringStackTrace(trace));
    },
    Trace$parseFirefox: function(trace) {
      var t1 = H.setRuntimeTypeInfo(C.JSString_methods.trim$0(trace).split("\n"), [P.String]),
        t2 = H.getTypeArgumentByIndex(t1, 0),
        t3 = A.Frame;
      return new Y.Trace(P.List_List$unmodifiable(new H.MappedIterable(new H.WhereIterable(t1, new Y.Trace$parseFirefox_closure(), [t2]), new Y.Trace$parseFirefox_closure0(), [t2, t3]), t3), new P._StringStackTrace(trace));
    },
    Trace$parseFriendly: function(trace) {
      var t2, t3,
        t1 = A.Frame;
      if (trace.length === 0)
        t2 = H.setRuntimeTypeInfo([], [t1]);
      else {
        t2 = H.setRuntimeTypeInfo(J.trim$0$s(trace).split("\n"), [P.String]);
        t3 = H.getTypeArgumentByIndex(t2, 0);
        t3 = new H.MappedIterable(new H.WhereIterable(t2, new Y.Trace$parseFriendly_closure(), [t3]), new Y.Trace$parseFriendly_closure0(), [t3, t1]);
        t2 = t3;
      }
      return new Y.Trace(P.List_List$unmodifiable(t2, t1), new P._StringStackTrace(trace));
    },
    Trace: function Trace(t0, t1) {
      this.frames = t0;
      this.original = t1;
    },
    Trace_Trace$from_closure: function Trace_Trace$from_closure(t0) {
      this.trace = t0;
    },
    Trace__parseVM_closure: function Trace__parseVM_closure() {
    },
    Trace$parseV8_closure: function Trace$parseV8_closure() {
    },
    Trace$parseV8_closure0: function Trace$parseV8_closure0() {
    },
    Trace$parseJSCore_closure: function Trace$parseJSCore_closure() {
    },
    Trace$parseJSCore_closure0: function Trace$parseJSCore_closure0() {
    },
    Trace$parseFirefox_closure: function Trace$parseFirefox_closure() {
    },
    Trace$parseFirefox_closure0: function Trace$parseFirefox_closure0() {
    },
    Trace$parseFriendly_closure: function Trace$parseFriendly_closure() {
    },
    Trace$parseFriendly_closure0: function Trace$parseFriendly_closure0() {
    },
    Trace_terse_closure: function Trace_terse_closure() {
    },
    Trace_foldFrames_closure: function Trace_foldFrames_closure(t0) {
      this.oldPredicate = t0;
    },
    Trace_foldFrames_closure0: function Trace_foldFrames_closure0(t0) {
      this._box_0 = t0;
    },
    Trace_toString_closure0: function Trace_toString_closure0() {
    },
    Trace_toString_closure: function Trace_toString_closure(t0) {
      this.longest = t0;
    },
    repl: function(options) {
      return Y.repl$body(options);
    },
    repl$body: function(options) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$handler = 1, $async$currentError, $async$next = [], repl, variables, line, logger, declaration, expression, result, error, stackTrace, t5, t6, t7, t8, line0, exception, t1, t2, t3, t4, repl0;
      var $async$repl = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$currentError = $async$result;
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = P.String;
              t2 = H.setRuntimeTypeInfo([], [t1]);
              t3 = C.JSString_methods.$mul(" ", 3);
              t4 = $.$get$alwaysValid();
              repl0 = new Q.Repl(">> ", t3, t4, t2);
              repl0._adapter = new B.ReplAdapter(repl0);
              repl = repl0;
              variables = P.LinkedHashMap_LinkedHashMap$_empty(t1, F.Value);
              t2 = P._StreamIterator$(repl._adapter.runAsync$0());
              $async$handler = 2;
              t3 = Z.VariableDeclaration, t4 = [P.int];
            case 5:
              // for condition
              $async$goto = 7;
              return P._asyncAwait(t2.moveNext$0(), $async$repl);
            case 7:
              // returning from await.
              if (!$async$result) {
                // goto after for
                $async$goto = 6;
                break;
              }
              line = t2.get$current(t2);
              if (J.trim$0$s(line).length === 0) {
                // goto for condition
                $async$goto = 5;
                break;
              }
              t5 = options._options;
              if (H.boolTypeCast(t5.$index(0, "quiet")))
                t5 = $.$get$Logger_quiet();
              else {
                if (t5._parser.options._collection$_map.$index(0, "color") == null)
                  H.throwExpression(P.ArgumentError$('Could not find an option named "color".'));
                if (t5._parsed.containsKey$1("color"))
                  t5 = H.boolTypeCast(t5.$index(0, "color"));
                else {
                  t5 = self.process.stdout.isTTY;
                  if (t5 == null)
                    t5 = false;
                }
                t5 = new S.StderrLogger(t5);
              }
              logger = new T.TrackingLogger(t5);
              try {
                declaration = null;
                expression = null;
                t5 = line;
                t5.toString;
                t6 = new H.CodeUnits(t5);
                t7 = H.setRuntimeTypeInfo([0], t4);
                t7 = new Y.SourceFile(null, t7, new Uint32Array(H._ensureNativeList(t6.toList$0(t6))));
                t7.SourceFile$decoded$2$url(t6, null);
                if (new G.Parser(new S.SpanScanner(t7, null, t5), C.StderrLogger_false)._isVariableDeclarationLike$0()) {
                  t5 = line;
                  t6 = logger;
                  t5.toString;
                  t7 = new H.CodeUnits(t5);
                  t8 = H.setRuntimeTypeInfo([0], t4);
                  t8 = new Y.SourceFile(null, t8, new Uint32Array(H._ensureNativeList(t7.toList$0(t7))));
                  t8.SourceFile$decoded$2$url(t7, null);
                  if (t6 == null)
                    t6 = C.StderrLogger_false;
                  declaration = new L.ScssParser(P.LinkedHashMap_LinkedHashMap$_empty(t1, t3), new S.SpanScanner(t8, null, t5), t6).parseVariableDeclaration$0();
                  expression = declaration.expression;
                } else {
                  t5 = line;
                  t6 = logger;
                  t5.toString;
                  t7 = new H.CodeUnits(t5);
                  t8 = H.setRuntimeTypeInfo([0], t4);
                  t8 = new Y.SourceFile(null, t8, new Uint32Array(H._ensureNativeList(t7.toList$0(t7))));
                  t8.SourceFile$decoded$2$url(t7, null);
                  if (t6 == null)
                    t6 = C.StderrLogger_false;
                  expression = new L.ScssParser(P.LinkedHashMap_LinkedHashMap$_empty(t1, t3), new S.SpanScanner(t8, null, t5), t6).parseExpression$0();
                }
                t5 = expression;
                result = R._EvaluateVisitor$(null, null, logger, null, false).runExpression$2$variables(t5, variables);
                if (declaration != null)
                  J.$indexSet$ax(variables, declaration.name, result);
                line0 = H.S(result);
                t5 = $.printToZone;
                if (t5 == null)
                  H.printString(line0);
                else
                  t5.call$1(line0);
              } catch (exception) {
                t5 = H.unwrapException(exception);
                if (t5 instanceof E.SassException) {
                  error = t5;
                  stackTrace = H.getTraceFromException(exception);
                  Y._logError(error, stackTrace, line, repl, options, logger);
                } else
                  throw exception;
              }
              // goto for condition
              $async$goto = 5;
              break;
            case 6:
              // after for
              $async$next.push(4);
              // goto finally
              $async$goto = 3;
              break;
            case 2:
              // uncaught
              $async$next = [1];
            case 3:
              // finally
              $async$handler = 1;
              $async$goto = 8;
              return P._asyncAwait(t2.cancel$0(), $async$repl);
            case 8:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 4:
              // after finally
              // implicit return
              return P._asyncReturn(null, $async$completer);
            case 1:
              // rethrow
              return P._asyncRethrow($async$currentError, $async$completer);
          }
      });
      return P._asyncStartSync($async$repl, $async$completer);
    },
    _logError: function(error, stackTrace, line, repl, options, logger) {
      var t2, t3, spacesBeforeError,
        t1 = options._options;
      if (!H.boolTypeCast(t1.$index(0, "quiet")))
        t2 = logger._emittedDebug || logger._emittedWarning;
      else
        t2 = false;
      if (t2) {
        P.print("Error: " + H.S(error._span_exception$_message));
        P.print(G.SourceSpanException.prototype.get$span.call(error).highlight$1$color(options.get$color()));
        return;
      }
      t2 = options.get$color() ? "\x1b[31m" : "";
      t3 = G.SourceSpanException.prototype.get$span.call(error);
      t3 = Y.FileLocation$_(t3.file, t3._start);
      spacesBeforeError = repl.prompt.length + t3.file.getColumn$1(t3.offset);
      if (options.get$color()) {
        t3 = G.SourceSpanException.prototype.get$span.call(error);
        t3 = Y.FileLocation$_(t3.file, t3._start);
        t3 = t3.file.getColumn$1(t3.offset) < line.length;
      } else
        t3 = false;
      if (t3) {
        t2 += "\x1b[1F\x1b[" + spacesBeforeError + "C";
        t3 = G.SourceSpanException.prototype.get$span.call(error);
        t3 = t2 + (P.String_String$fromCharCodes(C.NativeUint32List_methods.sublist$2(t3.file._decodedChars, t3._start, t3._end), 0, null) + "\n");
        t2 = t3;
      }
      t2 += C.JSString_methods.$mul(" ", spacesBeforeError);
      t3 = G.SourceSpanException.prototype.get$span.call(error);
      t3 = t2 + (C.JSString_methods.$mul("^", Math.max(1, t3._end - t3._start)) + "\n");
      t2 = options.get$color() ? t3 + "\x1b[0m" : t3;
      t2 += "Error: " + H.S(error._span_exception$_message) + "\n";
      t1 = H.boolTypeCast(t1.$index(0, "trace")) ? t2 + Y.Trace_Trace$from(stackTrace).get$terse().toString$0(0) : t2;
      P.print(C.JSString_methods.trimRight$0(t1.charCodeAt(0) == 0 ? t1 : t1));
    }
  },
  L = {StreamGroup: function StreamGroup(t0, t1, t2) {
      var _ = this;
      _._controller = null;
      _._closed = false;
      _._stream_group$_state = t0;
      _._subscriptions = t1;
      _.$ti = t2;
    }, StreamGroup_add_closure: function StreamGroup_add_closure() {
    }, StreamGroup_add_closure0: function StreamGroup_add_closure0(t0, t1) {
      this.$this = t0;
      this.stream = t1;
    }, StreamGroup__onListen_closure: function StreamGroup__onListen_closure(t0) {
      this.$this = t0;
    }, StreamGroup__onCancel_closure: function StreamGroup__onCancel_closure() {
    }, StreamGroup__onCancel_closure0: function StreamGroup__onCancel_closure0() {
    }, StreamGroup__listenToStream_closure: function StreamGroup__listenToStream_closure(t0, t1) {
      this.$this = t0;
      this.stream = t1;
    }, _StreamGroupState: function _StreamGroupState(t0) {
      this.name = t0;
    },
    UnmodifiableSetMixin__throw: function() {
      throw H.wrapException(P.UnsupportedError$("Cannot modify an unmodifiable Set"));
    },
    UnmodifiableSetView: function UnmodifiableSetView(t0, t1) {
      this._base = t0;
      this.$ti = t1;
    },
    UnmodifiableSetMixin: function UnmodifiableSetMixin() {
    },
    _UnmodifiableSetView_DelegatingSet_UnmodifiableSetMixin: function _UnmodifiableSetView_DelegatingSet_UnmodifiableSetMixin() {
    },
    WindowsStyle: function WindowsStyle(t0, t1, t2, t3) {
      var _ = this;
      _.separatorPattern = t0;
      _.needsSeparatorPattern = t1;
      _.rootPattern = t2;
      _.relativeRootPattern = t3;
    },
    WindowsStyle_absolutePathToUri_closure: function WindowsStyle_absolutePathToUri_closure() {
    },
    ModifiableCssDeclaration$: function($name, value, span, valueSpanForMap) {
      return new L.ModifiableCssDeclaration($name, value, valueSpanForMap == null ? span : valueSpanForMap, span);
    },
    ModifiableCssDeclaration: function ModifiableCssDeclaration(t0, t1, t2, t3) {
      var _ = this;
      _.name = t0;
      _.value = t1;
      _.valueSpanForMap = t2;
      _.span = t3;
      _._indexInParent = _._parent = null;
      _.isGroupEnd = false;
    },
    IfExpression: function IfExpression(t0, t1) {
      this.$arguments = t0;
      this.span = t1;
    },
    Declaration$: function($name, span, children, value) {
      var t1;
      children = children == null ? null : P.List_List$unmodifiable(children, O.Statement);
      t1 = children == null ? null : C.JSArray_methods.any$1(children, new M.ParentStatement_closure());
      return new L.Declaration($name, value, span, children, t1 === true);
    },
    Declaration: function Declaration(t0, t1, t2, t3, t4) {
      var _ = this;
      _.name = t0;
      _.value = t1;
      _.span = t2;
      _.children = t3;
      _.hasDeclarations = t4;
    },
    ForwardRule: function ForwardRule(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _.url = t0;
      _.shownMixinsAndFunctions = t1;
      _.shownVariables = t2;
      _.hiddenMixinsAndFunctions = t3;
      _.hiddenVariables = t4;
      _.prefix = t5;
      _.span = t6;
    },
    ForwardRule__memberList_closure: function ForwardRule__memberList_closure() {
    },
    LoudComment: function LoudComment(t0) {
      this.text = t0;
    },
    SupportsDeclaration: function SupportsDeclaration(t0, t1, t2) {
      this.name = t0;
      this.value = t1;
      this.span = t2;
    },
    PlainCssCallable: function PlainCssCallable(t0) {
      this.name = t0;
    },
    ExtendMode: function ExtendMode(t0) {
      this.name = t0;
    },
    RenderContextOptions: function RenderContextOptions() {
    },
    ScssParser: function ScssParser(t0, t1, t2) {
      var _ = this;
      _._isUseAllowed = true;
      _._stylesheet$_inMixin = false;
      _._mixinHasContent = null;
      _._inParentheses = _._inStyleRule = _._stylesheet$_inUnknownAtRule = _._inControlDirective = _._inContentBlock = false;
      _._globalVariables = t0;
      _.lastSilentComment = null;
      _.scanner = t1;
      _.logger = t2;
    },
    _FindImportsVisitor: function _FindImportsVisitor(t0) {
      this._imports = t0;
    },
    Entry: function Entry(t0, t1, t2) {
      this.source = t0;
      this.target = t1;
      this.identifierName = t2;
    },
    _StreamTransformer__defaultHandleError: function(error, stackTrace, sink) {
      sink.addError$2(error, stackTrace);
    },
    _StreamTransformer: function _StreamTransformer(t0, t1, t2, t3) {
      var _ = this;
      _._from_handlers$_handleData = t0;
      _._from_handlers$_handleDone = t1;
      _._from_handlers$_handleError = t2;
      _.$ti = t3;
    },
    _StreamTransformer_bind_closure: function _StreamTransformer_bind_closure(t0, t1, t2, t3) {
      var _ = this;
      _._box_1 = t0;
      _.$this = t1;
      _.values = t2;
      _.controller = t3;
    },
    _StreamTransformer_bind__closure: function _StreamTransformer_bind__closure(t0, t1) {
      this.$this = t0;
      this.controller = t1;
    },
    _StreamTransformer_bind__closure1: function _StreamTransformer_bind__closure1(t0, t1) {
      this.$this = t0;
      this.controller = t1;
    },
    _StreamTransformer_bind__closure0: function _StreamTransformer_bind__closure0(t0, t1, t2) {
      this._box_0 = t0;
      this.$this = t1;
      this.controller = t2;
    },
    _StreamTransformer_bind__closure2: function _StreamTransformer_bind__closure2(t0, t1) {
      this._box_1 = t0;
      this._box_0 = t1;
    },
    encodeVlq: function(value) {
      var res, signBit, digit, t1;
      if (value < $.$get$MIN_INT32() || value > $.$get$MAX_INT32())
        throw H.wrapException(P.ArgumentError$("expected 32 bit int, got: " + value));
      res = H.setRuntimeTypeInfo([], [P.String]);
      if (value < 0) {
        value = -value;
        signBit = 1;
      } else
        signBit = 0;
      value = value << 1 | signBit;
      do {
        digit = value & 31;
        value = value >>> 5;
        t1 = value > 0;
        res.push("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[t1 ? digit | 32 : digit]);
      } while (t1);
      return res;
    }
  },
  Q = {Repl: function Repl(t0, t1, t2, t3) {
      var _ = this;
      _.prompt = t0;
      _.continuation = t1;
      _.validator = t2;
      _._adapter = null;
      _.history = t3;
    }, closure130: function closure130() {
    },
    QueueList$: function(initialCapacity, $E) {
      var t1 = new Q.QueueList(0, 0, [$E]);
      t1.QueueList$1(initialCapacity, $E);
      return t1;
    },
    QueueList_QueueList$from: function(source, $E) {
      var $length, queue,
        t1 = J.getInterceptor$(source);
      if (!!t1.$isList) {
        $length = t1.get$length(source);
        queue = Q.QueueList$($length + 1, $E);
        J.setRange$4$ax(queue._table, 0, $length, source, 0);
        queue._tail = $length;
        return queue;
      } else {
        t1 = Q.QueueList$(null, $E);
        t1.addAll$1(0, source);
        return t1;
      }
    },
    QueueList__nextPowerOf2: function(number) {
      var nextNumber;
      number = (number << 1 >>> 0) - 1;
      for (; true; number = nextNumber) {
        nextNumber = (number & number - 1) >>> 0;
        if (nextNumber === 0)
          return number;
      }
    },
    QueueList: function QueueList(t0, t1, t2) {
      var _ = this;
      _._table = null;
      _._head = t0;
      _._tail = t1;
      _.$ti = t2;
    },
    _CastQueueList: function _CastQueueList(t0, t1, t2, t3) {
      var _ = this;
      _._queue_list$_delegate = t0;
      _._table = null;
      _._head = t1;
      _._tail = t2;
      _.$ti = t3;
    },
    _QueueList_Object_ListMixin: function _QueueList_Object_ListMixin() {
    },
    StaticImport: function StaticImport(t0, t1, t2, t3) {
      var _ = this;
      _.url = t0;
      _.supports = t1;
      _.media = t2;
      _.span = t3;
    },
    ContentRule: function ContentRule(t0, t1) {
      this.span = t0;
      this.$arguments = t1;
    },
    DebugRule: function DebugRule(t0, t1) {
      this.expression = t0;
      this.span = t1;
    },
    AsyncEnvironment$_: function(_modules, _globalModules, _forwardedModules, _allModules, _variables, _variableNodes, _functions, _mixins, _content) {
      var t1 = P.String,
        t2 = P.int;
      return new Q.AsyncEnvironment(_modules, _globalModules, _forwardedModules, _allModules, _variables, _variableNodes, P.LinkedHashMap_LinkedHashMap$_empty(t1, t2), _functions, P.LinkedHashMap_LinkedHashMap$_empty(t1, t2), _mixins, P.LinkedHashMap_LinkedHashMap$_empty(t1, t2), _content);
    },
    _EnvironmentModule__EnvironmentModule0: function(environment, css, extender, forwarded) {
      var t1, t2, t3, t4, t5, t6;
      if (forwarded == null)
        forwarded = C.List_empty12;
      t1 = Q._EnvironmentModule__makeModulesByVariable0(forwarded);
      t2 = H.getTypeArgumentByIndex(forwarded, 0);
      t3 = Q._EnvironmentModule__memberMap0(C.JSArray_methods.get$first(environment._async_environment$_variables), new H.MappedListIterable(forwarded, new Q._EnvironmentModule__EnvironmentModule_closure5(), [t2, [P.Map, P.String, F.Value]]), F.Value);
      t4 = environment._async_environment$_variableNodes;
      t4 = t4 == null ? null : Q._EnvironmentModule__memberMap0(C.JSArray_methods.get$first(t4), new H.MappedListIterable(forwarded, new Q._EnvironmentModule__EnvironmentModule_closure6(), [t2, [P.Map, P.String, B.AstNode]]), B.AstNode);
      t2 = [t2, [P.Map, P.String, B.AsyncCallable]];
      t5 = B.AsyncCallable;
      t6 = Q._EnvironmentModule__memberMap0(C.JSArray_methods.get$first(environment._async_environment$_functions), new H.MappedListIterable(forwarded, new Q._EnvironmentModule__EnvironmentModule_closure7(), t2), t5);
      t5 = Q._EnvironmentModule__memberMap0(C.JSArray_methods.get$first(environment._async_environment$_mixins), new H.MappedListIterable(forwarded, new Q._EnvironmentModule__EnvironmentModule_closure8(), t2), t5);
      t2 = J.get$isNotEmpty$asx(css.get$children()) || C.JSArray_methods.any$1(environment._async_environment$_allModules, new Q._EnvironmentModule__EnvironmentModule_closure9());
      return Q._EnvironmentModule$_0(environment, css, extender, t1, t3, t4, t6, t5, t2, !extender.get$isEmpty(extender) || C.JSArray_methods.any$1(environment._async_environment$_allModules, new Q._EnvironmentModule__EnvironmentModule_closure10()));
    },
    _EnvironmentModule__makeModulesByVariable0: function(forwarded) {
      var modulesByVariable, _i, module,
        t1 = forwarded.length;
      if (t1 === 0)
        return C.Map_empty6;
      modulesByVariable = P.LinkedHashMap_LinkedHashMap$_empty(P.String, [G.Module, B.AsyncCallable]);
      for (_i = 0; _i < forwarded.length; forwarded.length === t1 || (0, H.throwConcurrentModificationError)(forwarded), ++_i) {
        module = forwarded[_i];
        B.setAll(modulesByVariable, module.variables.get$keys(), module);
      }
      return modulesByVariable;
    },
    _EnvironmentModule__memberMap0: function(localMap, otherMaps, $V) {
      var t1, t2, t3;
      localMap = new U.PublicMemberMapView(localMap, [$V]);
      if (otherMaps.get$length(otherMaps) === 0)
        return localMap;
      t1 = H.setRuntimeTypeInfo([], [[P.Map, P.String, $V]]);
      for (t2 = new H.ListIterator(otherMaps, otherMaps.get$length(otherMaps)); t2.moveNext$0();) {
        t3 = t2.__internal$_current;
        if (t3.get$isNotEmpty(t3))
          t1.push(t3);
      }
      t1.push(localMap);
      if (t1.length === 1)
        return localMap;
      return Z.MergedMapView$(t1, P.String, $V);
    },
    _EnvironmentModule$_0: function(_environment, css, extender, _modulesByVariable, variables, variableNodes, functions, mixins, transitivelyContainsCss, transitivelyContainsExtensions) {
      return new Q._EnvironmentModule0(_environment._async_environment$_allModules, variables, variableNodes, functions, mixins, extender, css, transitivelyContainsCss, transitivelyContainsExtensions, _environment, _modulesByVariable);
    },
    AsyncEnvironment: function AsyncEnvironment(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11) {
      var _ = this;
      _._async_environment$_modules = t0;
      _._async_environment$_globalModules = t1;
      _._async_environment$_forwardedModules = t2;
      _._async_environment$_allModules = t3;
      _._async_environment$_variables = t4;
      _._async_environment$_variableNodes = t5;
      _._async_environment$_variableIndices = t6;
      _._async_environment$_functions = t7;
      _._async_environment$_functionIndices = t8;
      _._async_environment$_mixins = t9;
      _._async_environment$_mixinIndices = t10;
      _._async_environment$_content = t11;
      _._async_environment$_inMixin = false;
      _._async_environment$_inSemiGlobalScope = true;
      _._async_environment$_lastVariableIndex = _._async_environment$_lastVariableName = null;
    },
    AsyncEnvironment__getVariableFromGlobalModule_closure: function AsyncEnvironment__getVariableFromGlobalModule_closure(t0) {
      this.name = t0;
    },
    AsyncEnvironment_setVariable_closure: function AsyncEnvironment_setVariable_closure(t0, t1) {
      this.$this = t0;
      this.name = t1;
    },
    AsyncEnvironment_setVariable_closure0: function AsyncEnvironment_setVariable_closure0(t0) {
      this.name = t0;
    },
    AsyncEnvironment_setVariable_closure1: function AsyncEnvironment_setVariable_closure1(t0, t1) {
      this.$this = t0;
      this.name = t1;
    },
    AsyncEnvironment__getFunctionFromGlobalModule_closure: function AsyncEnvironment__getFunctionFromGlobalModule_closure(t0) {
      this.name = t0;
    },
    AsyncEnvironment__getMixinFromGlobalModule_closure: function AsyncEnvironment__getMixinFromGlobalModule_closure(t0) {
      this.name = t0;
    },
    _EnvironmentModule0: function _EnvironmentModule0(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10) {
      var _ = this;
      _.upstream = t0;
      _.variables = t1;
      _.variableNodes = t2;
      _.functions = t3;
      _.mixins = t4;
      _.extender = t5;
      _.css = t6;
      _.transitivelyContainsCss = t7;
      _.transitivelyContainsExtensions = t8;
      _._async_environment$_environment = t9;
      _._async_environment$_modulesByVariable = t10;
    },
    _EnvironmentModule__EnvironmentModule_closure5: function _EnvironmentModule__EnvironmentModule_closure5() {
    },
    _EnvironmentModule__EnvironmentModule_closure6: function _EnvironmentModule__EnvironmentModule_closure6() {
    },
    _EnvironmentModule__EnvironmentModule_closure7: function _EnvironmentModule__EnvironmentModule_closure7() {
    },
    _EnvironmentModule__EnvironmentModule_closure8: function _EnvironmentModule__EnvironmentModule_closure8() {
    },
    _EnvironmentModule__EnvironmentModule_closure9: function _EnvironmentModule__EnvironmentModule_closure9() {
    },
    _EnvironmentModule__EnvironmentModule_closure10: function _EnvironmentModule__EnvironmentModule_closure10() {
    },
    BuiltInCallable$: function($name, $arguments, callback) {
      return new Q.BuiltInCallable($name, H.setRuntimeTypeInfo([new S.Tuple2(B.ArgumentDeclaration_ArgumentDeclaration$parse($arguments), callback, [B.ArgumentDeclaration, {func: 1, ret: F.Value, args: [[P.List, F.Value]]}])], [[S.Tuple2, B.ArgumentDeclaration, {func: 1, ret: F.Value, args: [[P.List, F.Value]]}]]));
    },
    BuiltInCallable$parsed: function($name, $arguments, callback) {
      return new Q.BuiltInCallable($name, H.setRuntimeTypeInfo([new S.Tuple2($arguments, callback, [B.ArgumentDeclaration, {func: 1, ret: F.Value, args: [[P.List, F.Value]]}])], [[S.Tuple2, B.ArgumentDeclaration, {func: 1, ret: F.Value, args: [[P.List, F.Value]]}]]));
    },
    BuiltInCallable$overloaded: function($name, overloads) {
      var t2, t3, t4, t5, t6, t7, t8, t9, t10,
        t1 = H.setRuntimeTypeInfo([], [[S.Tuple2, B.ArgumentDeclaration, {func: 1, ret: F.Value, args: [[P.List, F.Value]]}]]);
      for (t2 = overloads.get$entries(), t2 = t2.get$iterator(t2), t3 = [B.ArgumentDeclaration, {func: 1, ret: F.Value, args: [[P.List, F.Value]]}], t4 = P.String, t5 = Z.VariableDeclaration, t6 = [P.int]; t2.moveNext$0();) {
        t7 = t2.get$current(t2);
        t8 = "(" + H.S(t7.key) + ")";
        t9 = new H.CodeUnits(t8);
        t10 = H.setRuntimeTypeInfo([0], t6);
        t10 = new Y.SourceFile(null, t10, new Uint32Array(H._ensureNativeList(t9.toList$0(t9))));
        t10.SourceFile$decoded$2$url(t9, null);
        t1.push(new S.Tuple2(new L.ScssParser(P.LinkedHashMap_LinkedHashMap$_empty(t4, t5), new S.SpanScanner(t10, null, t8), C.StderrLogger_false).parseArgumentDeclaration$0(), t7.value, t3));
      }
      return new Q.BuiltInCallable($name, t1);
    },
    BuiltInCallable: function BuiltInCallable(t0, t1) {
      this.name = t0;
      this._overloads = t1;
    },
    BuiltInCallable_callbackFor_closure: function BuiltInCallable_callbackFor_closure(t0, t1) {
      this.positional = t0;
      this.names = t1;
    },
    BuiltInCallable_callbackFor_closure0: function BuiltInCallable_callbackFor_closure0(t0) {
      this.$this = t0;
    },
    closure125: function closure125() {
    },
    closure126: function closure126() {
    },
    closure127: function closure127() {
    },
    closure128: function closure128() {
    },
    _closure19: function _closure19() {
    },
    BuiltInModule$: function($name, functions, $T) {
      var t4, _i, $function,
        t1 = P._Uri__Uri(null, $name, null, "sass"),
        t2 = P.String,
        t3 = P.LinkedHashMap_LinkedHashMap$_empty(t2, $T);
      for (t4 = functions.length, _i = 0; _i < functions.length; functions.length === t4 || (0, H.throwConcurrentModificationError)(functions), ++_i) {
        $function = functions[_i];
        t3.$indexSet(0, $function.get$name(), $function);
      }
      return new Q.BuiltInModule(t1, new P.UnmodifiableMapView(t3, [t2, $T]), [$T]);
    },
    BuiltInModule: function BuiltInModule(t0, t1, t2) {
      this.url = t0;
      this.functions = t1;
      this.$ti = t2;
    },
    closure129: function closure129() {
    },
    CssParser: function CssParser(t0, t1, t2) {
      var _ = this;
      _._isUseAllowed = true;
      _._stylesheet$_inMixin = false;
      _._mixinHasContent = null;
      _._inParentheses = _._inStyleRule = _._stylesheet$_inUnknownAtRule = _._inControlDirective = _._inContentBlock = false;
      _._globalVariables = t0;
      _.lastSilentComment = null;
      _.scanner = t1;
      _.logger = t2;
    }
  },
  B = {ReplAdapter: function ReplAdapter(t0) {
      this.repl = t0;
      this.rl = null;
    }, ReplAdapter_runAsync_closure: function ReplAdapter_runAsync_closure(t0) {
      this.controller = t0;
    }, Stdin: function Stdin() {
    }, Stdout: function Stdout() {
    }, ReadlineModule: function ReadlineModule() {
    }, ReadlineOptions: function ReadlineOptions() {
    }, ReadlineInterface: function ReadlineInterface() {
    },
    defaultCompare: function($T) {
      return new B.defaultCompare_closure($T);
    },
    defaultCompare_closure: function defaultCompare_closure(t0) {
      this.T = t0;
    },
    InternalStyle: function InternalStyle() {
    },
    ModifiableCssNode: function ModifiableCssNode() {
    },
    ModifiableCssParentNode: function ModifiableCssParentNode() {
    },
    ModifiableCssSupportsRule: function ModifiableCssSupportsRule(t0, t1, t2, t3) {
      var _ = this;
      _.condition = t0;
      _.span = t1;
      _.children = t2;
      _._children = t3;
      _._indexInParent = _._parent = null;
      _.isGroupEnd = false;
    },
    CssNode: function CssNode() {
    },
    CssParentNode: function CssParentNode() {
    },
    AstNode: function AstNode() {
    },
    ArgumentDeclaration_ArgumentDeclaration$parse: function(contents) {
      var t1 = S.SpanScanner$("(" + H.S(contents) + ")", null);
      return new L.ScssParser(P.LinkedHashMap_LinkedHashMap$_empty(P.String, Z.VariableDeclaration), t1, C.StderrLogger_false).parseArgumentDeclaration$0();
    },
    ArgumentDeclaration: function ArgumentDeclaration(t0, t1, t2) {
      this.$arguments = t0;
      this.restArgument = t1;
      this.span = t2;
    },
    ArgumentDeclaration_verify_closure: function ArgumentDeclaration_verify_closure() {
    },
    ArgumentDeclaration_verify_closure0: function ArgumentDeclaration_verify_closure0() {
    },
    DynamicImport: function DynamicImport(t0, t1) {
      this.url = t0;
      this.span = t1;
    },
    SassNode: function SassNode() {
    },
    ForRule: function ForRule(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _.variable = t0;
      _.from = t1;
      _.to = t2;
      _.isExclusive = t3;
      _.span = t4;
      _.children = t5;
      _.hasDeclarations = t6;
    },
    ImportRule: function ImportRule(t0, t1) {
      this.imports = t0;
      this.span = t1;
    },
    ReturnRule: function ReturnRule(t0, t1) {
      this.expression = t0;
      this.span = t1;
    },
    SilentComment: function SilentComment(t0, t1) {
      this.text = t0;
      this.span = t1;
    },
    SupportsRule: function SupportsRule(t0, t1, t2, t3) {
      var _ = this;
      _.condition = t0;
      _.span = t1;
      _.children = t2;
      _.hasDeclarations = t3;
    },
    AsyncCallable: function AsyncCallable() {
    },
    ExecutableOptions__separator: function(text) {
      var t1 = $.$get$ExecutableOptions__separatorBar(),
        t2 = C.JSString_methods.$mul(t1, 3) + " ",
        t3 = self.process.stdout.isTTY;
      t2 = t2 + ((t3 == null ? false : t3) ? "\x1b[1m" : "") + text;
      t3 = self.process.stdout.isTTY;
      return t2 + ((t3 == null ? false : t3) ? "\x1b[0m" : "") + " " + C.JSString_methods.$mul(t1, 35 - text.length);
    },
    ExecutableOptions__fail: function(message) {
      return H.throwExpression(B.UsageException$(message));
    },
    ExecutableOptions_ExecutableOptions$parse: function(args) {
      var options, error, t1, t2, exception;
      try {
        t1 = $.$get$ExecutableOptions__parser();
        t1.toString;
        t2 = H.setRuntimeTypeInfo(args.slice(0), [H.getTypeArgumentByIndex(args, 0)]);
        t1 = G.Parser$0(null, t1, t2, null, null).parse$0();
        if (t1.wasParsed$1("poll") && !H.boolTypeCast(t1.$index(0, "watch")))
          B.ExecutableOptions__fail("--poll may not be passed without --watch.");
        options = new B.ExecutableOptions(t1);
        if (H.boolTypeCast(options._options.$index(0, "help")))
          B.ExecutableOptions__fail("Compile Sass to CSS.");
        return options;
      } catch (exception) {
        t1 = H.unwrapException(exception);
        if (!!J.getInterceptor$(t1).$isFormatException) {
          error = t1;
          B.ExecutableOptions__fail(J.get$message$x(error));
        } else
          throw exception;
      }
    },
    UsageException$: function(message) {
      return new B.UsageException(message);
    },
    ExecutableOptions: function ExecutableOptions(t0) {
      var _ = this;
      _._options = t0;
      _._sourceDirectoriesToDestinations = _._sourcesToDestinations = _._interactive = null;
    },
    ExecutableOptions_closure: function ExecutableOptions_closure() {
    },
    ExecutableOptions_emitErrorCss_closure: function ExecutableOptions_emitErrorCss_closure() {
    },
    UsageException: function UsageException(t0) {
      this.message = t0;
    },
    AsyncImporter: function AsyncImporter() {
    },
    inUseRule: function(callback) {
      var t1,
        wasInUseRule = $._inUseRule;
      $._inUseRule = true;
      try {
        t1 = callback.call$0();
        return t1;
      } finally {
        $._inUseRule = wasInUseRule;
      }
    },
    inUseRuleAsync: function(callback, $T) {
      return B.inUseRuleAsync$body(callback, $T, $T);
    },
    inUseRuleAsync$body: function(callback, $T, $async$type) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter($async$type),
        $async$returnValue, $async$handler = 2, $async$currentError, $async$next = [], t1, wasInUseRule;
      var $async$inUseRuleAsync = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$currentError = $async$result;
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              wasInUseRule = $._inUseRule;
              $._inUseRule = true;
              $async$handler = 3;
              $async$goto = 6;
              return P._asyncAwait(callback.call$0(), $async$inUseRuleAsync);
            case 6:
              // returning from await.
              t1 = $async$result;
              $async$returnValue = t1;
              $async$next = [1];
              // goto finally
              $async$goto = 4;
              break;
              $async$next.push(5);
              // goto finally
              $async$goto = 4;
              break;
            case 3:
              // uncaught
              $async$next = [2];
            case 4:
              // finally
              $async$handler = 2;
              $._inUseRule = wasInUseRule;
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 5:
              // after finally
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return P._asyncRethrow($async$currentError, $async$completer);
          }
      });
      return P._asyncStartSync($async$inUseRuleAsync, $async$completer);
    },
    resolveImportPath: function(path) {
      var t1,
        extension = X.ParsedPath_ParsedPath$parse(path, $.$get$context().style)._splitExtension$0()[1];
      if (extension === ".sass" || extension === ".scss" || extension === ".css") {
        t1 = $._inUseRule ? null : new B.resolveImportPath_closure(path, extension).call$0();
        return t1 == null ? B._exactlyOne(B._tryPath(path)) : t1;
      }
      t1 = $._inUseRule ? null : new B.resolveImportPath_closure0(path).call$0();
      if (t1 == null)
        t1 = B._exactlyOne(B._tryPathWithExtensions(path));
      return t1 == null ? B._tryPathAsDirectory(path) : t1;
    },
    _tryPathWithExtensions: function(path) {
      var result = B._tryPath(J.$add$ansx(path, ".sass"));
      C.JSArray_methods.addAll$1(result, B._tryPath(path + ".scss"));
      return result.length !== 0 ? result : B._tryPath(path + ".css");
    },
    _tryPath: function(path) {
      var t1 = $.$get$context(),
        partial = D.join(t1.dirname$1(path), "_" + H.S(X.ParsedPath_ParsedPath$parse(path, t1.style).get$basename()), null);
      t1 = H.setRuntimeTypeInfo([], [P.String]);
      if (B.fileExists(partial))
        t1.push(partial);
      if (B.fileExists(path))
        t1.push(path);
      return t1;
    },
    _tryPathAsDirectory: function(path) {
      var t1;
      if (!B.dirExists(path))
        return;
      t1 = $._inUseRule ? null : new B._tryPathAsDirectory_closure(path).call$0();
      return t1 == null ? B._exactlyOne(B._tryPathWithExtensions(D.join(path, "index", null))) : t1;
    },
    _exactlyOne: function(paths) {
      var t1 = paths.length;
      if (t1 === 0)
        return;
      if (t1 === 1)
        return C.JSArray_methods.get$first(paths);
      throw H.wrapException("It's not clear which file to import. Found:\n" + C.JSArray_methods.map$1$1(paths, new B._exactlyOne_closure(), P.String).join$1(0, "\n"));
    },
    resolveImportPath_closure: function resolveImportPath_closure(t0, t1) {
      this.path = t0;
      this.extension = t1;
    },
    resolveImportPath_closure0: function resolveImportPath_closure0(t0) {
      this.path = t0;
    },
    _tryPathAsDirectory_closure: function _tryPathAsDirectory_closure(t0) {
      this.path = t0;
    },
    _exactlyOne_closure: function _exactlyOne_closure() {
    },
    readFile: function(path) {
      var t1, t2, t3, sourceFile, i,
        contents = H.stringTypeCast(B._readFile(path, "utf8"));
      if (!J.getInterceptor$asx(contents).contains$1(contents, "\ufffd"))
        return contents;
      t1 = $.$get$context().toUri$1(path);
      t2 = new H.CodeUnits(contents);
      t3 = H.setRuntimeTypeInfo([0], [P.int]);
      sourceFile = new Y.SourceFile(t1, t3, new Uint32Array(H._ensureNativeList(t2.toList$0(t2))));
      sourceFile.SourceFile$decoded$2$url(t2, t1);
      for (t1 = contents.length, i = 0; i < t1; ++i) {
        if (C.JSString_methods._codeUnitAt$1(contents, i) !== 65533)
          continue;
        throw H.wrapException(E.SassException$("Invalid UTF-8.", Y.FileLocation$_(sourceFile, i).pointSpan$0()));
      }
      return contents;
    },
    _readFile: function(path, encoding) {
      return B._systemErrorToFileSystemException(new B._readFile_closure(path, encoding));
    },
    writeFile: function(path, contents) {
      return B._systemErrorToFileSystemException(new B.writeFile_closure(path, contents));
    },
    deleteFile: function(path) {
      return B._systemErrorToFileSystemException(new B.deleteFile_closure(path));
    },
    readStdin: function() {
      return B.readStdin$body();
    },
    readStdin$body: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.String),
        $async$returnValue, sink, t1, t2, t3, completer;
      var $async$readStdin = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = {};
              t2 = P.String;
              t3 = new P._Future($.Zone__current, [t2]);
              completer = new P._AsyncCompleter(t3, [t2]);
              t1.contents = null;
              sink = new P.Utf8Decoder(false).startChunkedConversion$1(new P._StringCallbackSink(new B.readStdin_closure(t1, completer), new P.StringBuffer("")));
              J.on$2$x(self.process.stdin, "data", P.allowInterop(new B.readStdin_closure0(sink)));
              J.on$2$x(self.process.stdin, "end", P.allowInterop(new B.readStdin_closure1(sink)));
              J.on$2$x(self.process.stdin, "error", P.allowInterop(new B.readStdin_closure2(completer)));
              $async$returnValue = t3;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$readStdin, $async$completer);
    },
    fileExists: function(path) {
      var error, systemError, t1, exception;
      try {
        t1 = J.isFile$0$x(J.statSync$1$x(self.fs, path));
        return t1;
      } catch (exception) {
        error = H.unwrapException(exception);
        systemError = H.interceptedTypeCast(error, "$is_SystemError");
        if (J.$eq$(J.get$code$x(systemError), "ENOENT"))
          return false;
        throw exception;
      }
    },
    dirExists: function(path) {
      var error, systemError, t1, exception;
      try {
        t1 = J.isDirectory$0$x(J.statSync$1$x(self.fs, path));
        return t1;
      } catch (exception) {
        error = H.unwrapException(exception);
        systemError = H.interceptedTypeCast(error, "$is_SystemError");
        if (J.$eq$(J.get$code$x(systemError), "ENOENT"))
          return false;
        throw exception;
      }
    },
    ensureDir: function(path) {
      return B._systemErrorToFileSystemException(new B.ensureDir_closure(path));
    },
    listDir: function(path, recursive) {
      return B._systemErrorToFileSystemException(new B.listDir_closure(recursive, path));
    },
    modificationTime: function(path) {
      return B._systemErrorToFileSystemException(new B.modificationTime_closure(path));
    },
    _systemErrorToFileSystemException: function(callback) {
      var error, systemError, t1, exception, t2;
      try {
        t1 = callback.call$0();
        return t1;
      } catch (exception) {
        error = H.unwrapException(exception);
        systemError = H.interceptedTypeCast(error, "$is_SystemError");
        t1 = systemError;
        t2 = J.getInterceptor$x(t1);
        throw H.wrapException(new B.FileSystemException(J.substring$2$s(t2.get$message(t1), (H.S(t2.get$code(t1)) + ": ").length, J.get$length$asx(t2.get$message(t1)) - (", " + H.S(t2.get$syscall(t1)) + " '" + H.S(t2.get$path(t1)) + "'").length), J.get$path$x(systemError)));
      }
    },
    isWindows: function() {
      return J.$eq$(J.get$platform$x(self.process), "win32");
    },
    watchDir: function(path, poll) {
      var t2, t3, t4, t1 = {},
        watcher = J.watch$2$x(self.chokidar, path, {disableGlobbing: true, usePolling: poll});
      t1.controller = null;
      t2 = J.getInterceptor$x(watcher);
      t2.on$2(watcher, "add", P.allowInterop(new B.watchDir_closure(t1)));
      t2.on$2(watcher, "change", P.allowInterop(new B.watchDir_closure0(t1)));
      t2.on$2(watcher, "unlink", P.allowInterop(new B.watchDir_closure1(t1)));
      t2.on$2(watcher, "error", P.allowInterop(new B.watchDir_closure2(t1)));
      t3 = [P.Stream, E.WatchEvent];
      t4 = new P._Future($.Zone__current, [t3]);
      t2.on$2(watcher, "ready", P.allowInterop(new B.watchDir_closure3(t1, watcher, new P._AsyncCompleter(t4, [t3]))));
      return t4;
    },
    _FS: function _FS() {
    },
    _Stat: function _Stat() {
    },
    _Date: function _Date() {
    },
    _Stderr: function _Stderr() {
    },
    _Stdin: function _Stdin() {
    },
    _SystemError: function _SystemError() {
    },
    _Process: function _Process() {
    },
    FileSystemException: function FileSystemException(t0, t1) {
      this.message = t0;
      this.path = t1;
    },
    Stderr: function Stderr(t0) {
      this._stderr = t0;
    },
    _readFile_closure: function _readFile_closure(t0, t1) {
      this.path = t0;
      this.encoding = t1;
    },
    writeFile_closure: function writeFile_closure(t0, t1) {
      this.path = t0;
      this.contents = t1;
    },
    deleteFile_closure: function deleteFile_closure(t0) {
      this.path = t0;
    },
    readStdin_closure: function readStdin_closure(t0, t1) {
      this._box_0 = t0;
      this.completer = t1;
    },
    readStdin_closure0: function readStdin_closure0(t0) {
      this.sink = t0;
    },
    readStdin_closure1: function readStdin_closure1(t0) {
      this.sink = t0;
    },
    readStdin_closure2: function readStdin_closure2(t0) {
      this.completer = t0;
    },
    ensureDir_closure: function ensureDir_closure(t0) {
      this.path = t0;
    },
    listDir_closure: function listDir_closure(t0, t1) {
      this.recursive = t0;
      this.path = t1;
    },
    listDir__closure: function listDir__closure(t0) {
      this.path = t0;
    },
    listDir__closure0: function listDir__closure0() {
    },
    listDir_closure_list: function listDir_closure_list() {
    },
    listDir__list_closure: function listDir__list_closure(t0, t1) {
      this.parent = t0;
      this.list = t1;
    },
    modificationTime_closure: function modificationTime_closure(t0) {
      this.path = t0;
    },
    watchDir_closure: function watchDir_closure(t0) {
      this._box_0 = t0;
    },
    watchDir_closure0: function watchDir_closure0(t0) {
      this._box_0 = t0;
    },
    watchDir_closure1: function watchDir_closure1(t0) {
      this._box_0 = t0;
    },
    watchDir_closure2: function watchDir_closure2(t0) {
      this._box_0 = t0;
    },
    watchDir_closure3: function watchDir_closure3(t0, t1, t2) {
      this._box_0 = t0;
      this.watcher = t1;
      this.completer = t2;
    },
    watchDir__closure: function watchDir__closure(t0) {
      this.watcher = t0;
    },
    main0: function() {
      J.set$run_$x(self.exports, P.allowInterop(new B.main_closure()));
      J.set$render$x(self.exports, P.allowInterop(B.node___render$closure()));
      J.set$renderSync$x(self.exports, P.allowInterop(B.node___renderSync$closure()));
      J.set$info$x(self.exports, "dart-sass\t1.22.10\t(Sass Compiler)\t[Dart]\ndart2js\t2.4.1\t(Dart Compiler)\t[Dart]");
      J.set$types$x(self.exports, {Boolean: $.$get$booleanConstructor(), Color: $.$get$colorConstructor(), List: $.$get$listConstructor(), Map: $.$get$mapConstructor(), Null: $.$get$nullConstructor(), Number: $.$get$numberConstructor(), String: $.$get$stringConstructor(), Error: self.Error});
    },
    _render: function(options, callback) {
      var t1 = J.getInterceptor$x(options);
      if (t1.get$fiber(options) != null)
        J.run$0$x(t1.get$fiber(options).call$1(P.allowInterop(new B._render_closure(callback, options))));
      else
        B._renderAsync(options).then$1$2$onError(new B._render_closure0(callback), new B._render_closure1(callback), null);
    },
    _renderAsync: function(options) {
      return B._renderAsync$body(options);
    },
    _renderAsync$body: function(options) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(U.RenderResult),
        $async$returnValue, t2, t3, t4, t5, t6, t7, t8, t9, result, start, t1, file;
      var $async$_renderAsync = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              start = new P.DateTime(Date.now(), false);
              t1 = J.getInterceptor$x(options);
              file = t1.get$file(options) == null ? null : D.absolute(t1.get$file(options));
              $async$goto = t1.get$data(options) != null ? 3 : 5;
              break;
            case 3:
              // then
              t2 = t1.get$data(options);
              t3 = B._parseImporter(options, start);
              t4 = B._parseFunctions(options, true);
              t5 = t1.get$indentedSyntax(options);
              t5 = !J.$eq$(t5, false) && t5 != null ? C.Syntax_Sass : null;
              t6 = B._parseOutputStyle(t1.get$outputStyle(options));
              t7 = J.$eq$(t1.get$indentType(options), "tab");
              t8 = B._parseIndentWidth(t1.get$indentWidth(options));
              t9 = B._parseLineFeed(t1.get$linefeed(options));
              t1 = t1.get$file(options) == null ? "stdin" : J.toString$0$($.$get$context().toUri$1(file));
              $async$goto = 6;
              return P._asyncAwait(X.compileStringAsync(t2, true, t4, null, null, t8, t9, null, t3, B._enableSourceMaps(options), t6, t5, t1, !t7), $async$_renderAsync);
            case 6:
              // returning from await.
              result = $async$result;
              // goto join
              $async$goto = 4;
              break;
            case 5:
              // else
              $async$goto = t1.get$file(options) != null ? 7 : 9;
              break;
            case 7:
              // then
              t2 = B._parseImporter(options, start);
              t3 = B._parseFunctions(options, true);
              t4 = t1.get$indentedSyntax(options);
              t4 = !J.$eq$(t4, false) && t4 != null ? C.Syntax_Sass : null;
              t5 = B._parseOutputStyle(t1.get$outputStyle(options));
              t6 = J.$eq$(t1.get$indentType(options), "tab");
              $async$goto = 10;
              return P._asyncAwait(X.compileAsync(file, true, t3, null, B._parseIndentWidth(t1.get$indentWidth(options)), B._parseLineFeed(t1.get$linefeed(options)), null, t2, B._enableSourceMaps(options), t5, t4, !t6), $async$_renderAsync);
            case 10:
              // returning from await.
              result = $async$result;
              // goto join
              $async$goto = 8;
              break;
            case 9:
              // else
              throw H.wrapException(P.ArgumentError$("Either options.data or options.file must be set."));
            case 8:
              // join
            case 4:
              // join
              $async$returnValue = B._newRenderResult(options, result, start);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$_renderAsync, $async$completer);
    },
    _renderSync: function(options) {
      var start, file, result, error, error0, t1, t2, t3, t4, t5, t6, t7, t8, t9, exception, _null = null;
      try {
        start = new P.DateTime(Date.now(), false);
        t1 = J.getInterceptor$x(options);
        file = t1.get$file(options) == null ? _null : D.absolute(t1.get$file(options));
        result = null;
        if (t1.get$data(options) != null) {
          t2 = t1.get$data(options);
          t3 = B._parseImporter(options, start);
          t4 = B._parseFunctions(options, false);
          t5 = t1.get$indentedSyntax(options);
          t5 = !J.$eq$(t5, false) && t5 != null ? C.Syntax_Sass : _null;
          t6 = B._parseOutputStyle(t1.get$outputStyle(options));
          t7 = J.$eq$(t1.get$indentType(options), "tab");
          t8 = B._parseIndentWidth(t1.get$indentWidth(options));
          t9 = B._parseLineFeed(t1.get$linefeed(options));
          t1 = t1.get$file(options) == null ? "stdin" : J.toString$0$($.$get$context().toUri$1(file));
          result = U.compileString(t2, true, new H.CastList(t4, [H.getTypeArgumentByIndex(t4, 0), D.Callable]), _null, _null, t8, t9, _null, t3, B._enableSourceMaps(options), t6, t5, t1, !t7);
        } else if (t1.get$file(options) != null) {
          t2 = B._parseImporter(options, start);
          t3 = B._parseFunctions(options, false);
          t4 = t1.get$indentedSyntax(options);
          t4 = !J.$eq$(t4, false) && t4 != null ? C.Syntax_Sass : _null;
          t5 = B._parseOutputStyle(t1.get$outputStyle(options));
          t6 = J.$eq$(t1.get$indentType(options), "tab");
          result = U.compile(file, true, new H.CastList(t3, [H.getTypeArgumentByIndex(t3, 0), D.Callable]), _null, B._parseIndentWidth(t1.get$indentWidth(options)), B._parseLineFeed(t1.get$linefeed(options)), _null, t2, B._enableSourceMaps(options), t5, t4, !t6);
        } else {
          t1 = P.ArgumentError$("Either options.data or options.file must be set.");
          throw H.wrapException(t1);
        }
        t1 = B._newRenderResult(options, result, start);
        return t1;
      } catch (exception) {
        t1 = H.unwrapException(exception);
        if (t1 instanceof E.SassException) {
          error = t1;
          t1 = B._wrapException(error);
          $.$get$_jsThrow().call$1(t1);
        } else {
          error0 = t1;
          t1 = B._newRenderError(J.toString$0$(error0), _null, _null, _null, 3);
          $.$get$_jsThrow().call$1(t1);
        }
      }
      throw H.wrapException("unreachable");
    },
    _wrapException: function(exception) {
      var t3, t4,
        t1 = C.JSString_methods.replaceFirst$2(exception.toString$0(0), "Error: ", ""),
        t2 = G.SourceSpanException.prototype.get$span.call(exception);
      t2 = Y.FileLocation$_(t2.file, t2._start);
      t2 = t2.file.getLine$1(t2.offset);
      t3 = G.SourceSpanException.prototype.get$span.call(exception);
      t3 = Y.FileLocation$_(t3.file, t3._start);
      t3 = t3.file.getColumn$1(t3.offset);
      if (G.SourceSpanException.prototype.get$span.call(exception).file.url == null)
        t4 = "stdin";
      else {
        t4 = G.SourceSpanException.prototype.get$span.call(exception).file;
        t4 = $.$get$context().style.pathFromUri$1(M._parseUri(t4.url));
      }
      return B._newRenderError(t1, t3 + 1, t4, t2 + 1, 1);
    },
    _parseFunctions: function(options, asynch) {
      var result,
        t1 = J.getInterceptor$x(options);
      if (t1.get$functions(options) == null)
        return C.List_empty11;
      result = H.setRuntimeTypeInfo([], [B.AsyncCallable]);
      B.jsForEach(t1.get$functions(options), new B._parseFunctions_closure(options, result, asynch));
      return result;
    },
    _parseImporter: function(options, start) {
      var importers, t2, t3, includePaths, t4, t5, t6, t7, _i, t8, t9, t10, context,
        t1 = J.getInterceptor$x(options);
      if (t1.get$importer(options) == null)
        importers = H.setRuntimeTypeInfo([], [F.JSFunction]);
      else {
        t2 = F.JSFunction;
        importers = !!J.getInterceptor$(t1.get$importer(options)).$isList ? J.cast$1$0$ax(H.subtypeCast(t1.get$importer(options), "$isList", [P.Object], "$asList"), t2) : H.setRuntimeTypeInfo([H.interceptedTypeCast(t1.get$importer(options), "$isJSFunction")], [t2]);
      }
      t2 = t1.get$includePaths(options);
      if (t2 == null)
        t2 = [];
      t3 = P.String;
      includePaths = P.List_List$from(t2, true, t3);
      t2 = J.getInterceptor$asx(importers);
      if (t2.get$isNotEmpty(importers)) {
        t4 = t1.get$file(options);
        t5 = t1.get$data(options);
        t6 = H.setRuntimeTypeInfo([], [t3]);
        t6.push(D.current());
        for (t7 = includePaths.length, _i = 0; _i < includePaths.length; includePaths.length === t7 || (0, H.throwConcurrentModificationError)(includePaths), ++_i)
          t6.push(includePaths[_i]);
        t6 = C.JSArray_methods.join$1(t6, J.$eq$(J.get$platform$x(self.process), "win32") ? ";" : ":");
        t7 = J.$eq$(t1.get$indentType(options), "tab") ? 1 : 0;
        t8 = B._parseIndentWidth(t1.get$indentWidth(options));
        if (t8 == null)
          t8 = 2;
        t9 = B._parseLineFeed(t1.get$linefeed(options));
        t10 = t1.get$file(options);
        if (t10 == null)
          t10 = "data";
        context = {options: {file: t4, data: t5, includePaths: t6, precision: 10, style: 1, indentType: t7, indentWidth: t8, linefeed: t9.text, result: {stats: {entry: t10, start: start._value}}}};
        J.set$context$x(J.get$options$x(context), context);
      } else
        context = null;
      if (t1.get$fiber(options) != null)
        importers = t2.map$1$1(importers, new B._parseImporter_closure(options), F.JSFunction).toList$0(0);
      return new F.NodeImporter(context, P.List_List$unmodifiable(F.NodeImporter__addSassPath(includePaths), t3), P.List_List$unmodifiable(J.cast$1$0$ax(importers, null), F.JSFunction));
    },
    _parseOutputStyle: function(style) {
      if (style == null || style === "expanded")
        return C.OutputStyle_expanded;
      if (style === "compressed")
        return C.OutputStyle_compressed;
      throw H.wrapException(P.ArgumentError$('Unsupported output style "' + H.S(style) + '".'));
    },
    _parseIndentWidth: function(width) {
      if (width == null)
        return;
      return typeof width === "number" && Math.floor(width) === width ? width : P.int_parse(J.toString$0$(width), null, null);
    },
    _parseLineFeed: function(str) {
      switch (str) {
        case "cr":
          return C.LineFeed_kMT;
        case "crlf":
          return C.LineFeed_Mss;
        case "lfcr":
          return C.LineFeed_a1Y;
        default:
          return C.LineFeed_D6m;
      }
    },
    _newRenderResult: function(options, result, start) {
      var t3, t4, sourceMapPath, sourceMapDir, sourceMapDirUrl, i, source, sourceMapBytes, buffer, indices, url, _null = null,
        t1 = Date.now(),
        t2 = result._serialize,
        css = t2.css;
      if (B._enableSourceMaps(options)) {
        t3 = J.getInterceptor$x(options);
        t4 = t3.get$sourceMap(options);
        sourceMapPath = typeof t4 === "string" ? H.stringTypeCast(t3.get$sourceMap(options)) : J.$add$ansx(t3.get$outFile(options), ".map");
        t4 = $.$get$context();
        sourceMapDir = t4.dirname$1(sourceMapPath);
        t2 = t2.sourceMap;
        t2.sourceRoot = t3.get$sourceMapRoot(options);
        if (t3.get$outFile(options) == null)
          if (t3.get$file(options) == null)
            t2.targetUrl = "stdin.css";
          else
            t2.targetUrl = J.toString$0$(t4.toUri$1(t4.withoutExtension$1(t3.get$file(options)) + ".css"));
        else
          t2.targetUrl = J.toString$0$(t4.toUri$1(t4.relative$2$from(t3.get$outFile(options), sourceMapDir)));
        sourceMapDirUrl = J.toString$0$(t4.toUri$1(sourceMapDir));
        for (t4 = t2.urls, i = 0; i < t4.length; ++i) {
          source = t4[i];
          if (source === "stdin")
            continue;
          t4[i] = $.$get$url().relative$2$from(source, sourceMapDirUrl);
        }
        t4 = t3.get$sourceMapContents(options);
        t2 = C.C_JsonCodec.encode$2$toEncodable(t2.toJson$1$includeSourceContents(!J.$eq$(t4, false) && t4 != null), _null);
        sourceMapBytes = self.Buffer.from(t2, "utf8");
        t2 = t3.get$omitSourceMapUrl(options);
        if (!(!J.$eq$(t2, false) && t2 != null)) {
          t2 = t3.get$sourceMapEmbed(options);
          if (!J.$eq$(t2, false) && t2 != null) {
            buffer = new P.StringBuffer("");
            indices = H.setRuntimeTypeInfo([-1], [P.int]);
            P.UriData__writeUri("application/json", _null, _null, buffer, indices);
            indices.push(buffer._contents.length);
            t2 = buffer._contents += ";base64,";
            indices.push(t2.length - 1);
            C.C_Base64Encoder.startChunkedConversion$1(new P._StringSinkConversionSink(buffer)).addSlice$4(sourceMapBytes, 0, sourceMapBytes.length, true);
            t2 = buffer._contents;
            url = new P.UriData(t2.charCodeAt(0) == 0 ? t2 : t2, indices, _null).get$uri();
          } else {
            if (t3.get$outFile(options) == null)
              t2 = sourceMapPath;
            else {
              t2 = t3.get$outFile(options);
              t3 = $.$get$context();
              t2 = t3.relative$2$from(sourceMapPath, t3.dirname$1(t2));
            }
            url = $.$get$context().toUri$1(t2);
          }
          css += "\n\n/*# sourceMappingURL=" + H.S(url) + " */";
        }
      } else
        sourceMapBytes = _null;
      t2 = self.Buffer.from(css, "utf8");
      t3 = J.get$file$x(options);
      if (t3 == null)
        t3 = "data";
      t4 = start._value;
      t1 = new P.DateTime(t1, false)._value;
      return {css: t2, map: sourceMapBytes, stats: {entry: t3, start: t4, end: t1, duration: C.JSInt_methods._tdivFast$1(P.Duration$(t1 - t4, 0)._duration, 1000), includedFiles: result._evaluate.includedFiles.toList$0(0)}};
    },
    _enableSourceMaps: function(options) {
      var t1 = J.getInterceptor$x(options),
        t2 = t1.get$sourceMap(options);
      if (typeof t2 !== "string") {
        t2 = t1.get$sourceMap(options);
        t1 = !J.$eq$(t2, false) && t2 != null && t1.get$outFile(options) != null;
      } else
        t1 = true;
      return t1;
    },
    _newRenderError: function(message, column, file, line, $status) {
      var error = new self.Error(message);
      error.formatted = "Error: " + H.S(message);
      if (line != null)
        error.line = line;
      if (column != null)
        error.column = column;
      if (file != null)
        error.file = file;
      error.status = $status;
      return error;
    },
    main_closure: function main_closure() {
    },
    _render_closure: function _render_closure(t0, t1) {
      this.callback = t0;
      this.options = t1;
    },
    _render_closure0: function _render_closure0(t0) {
      this.callback = t0;
    },
    _render_closure1: function _render_closure1(t0) {
      this.callback = t0;
    },
    _parseFunctions_closure: function _parseFunctions_closure(t0, t1, t2) {
      this.options = t0;
      this.result = t1;
      this.asynch = t2;
    },
    _parseFunctions__closure: function _parseFunctions__closure(t0, t1) {
      this.options = t0;
      this.callback = t1;
    },
    _parseFunctions___closure0: function _parseFunctions___closure0(t0) {
      this.fiber = t0;
    },
    _parseFunctions____closure: function _parseFunctions____closure(t0, t1) {
      this.fiber = t0;
      this.result = t1;
    },
    _parseFunctions__closure0: function _parseFunctions__closure0(t0) {
      this.callback = t0;
    },
    _parseFunctions__closure1: function _parseFunctions__closure1(t0) {
      this.callback = t0;
    },
    _parseFunctions___closure: function _parseFunctions___closure(t0) {
      this.completer = t0;
    },
    _parseImporter_closure: function _parseImporter_closure(t0) {
      this.options = t0;
    },
    _parseImporter__closure: function _parseImporter__closure(t0, t1) {
      this.options = t0;
      this.importer = t1;
    },
    _parseImporter___closure: function _parseImporter___closure(t0) {
      this.fiber = t0;
    },
    _parseImporter____closure: function _parseImporter____closure(t0, t1) {
      this.fiber = t0;
      this.result = t1;
    },
    forwardToString: function(klass) {
      klass.prototype.toString = P.allowInteropCaptureThis(new B.forwardToString_closure());
    },
    jsForEach: function(object, callback) {
      var t1, t2;
      for (t1 = J.get$iterator$ax(self.Object.keys(object)); t1.moveNext$0();) {
        t2 = t1.get$current(t1);
        callback.call$2(t2, object[t2]);
      }
    },
    createClass: function($constructor, methods) {
      var klass = P.allowInteropCaptureThis($constructor);
      methods.forEach$1(0, new B.createClass_closure(klass.prototype));
      return klass;
    },
    injectSuperclass: function(object, $constructor) {
      var t1,
        $prototype = self.Object.getPrototypeOf(object),
        $parent = self.Object.getPrototypeOf($prototype);
      if ($parent != null) {
        t1 = $constructor.prototype;
        self.Object.setPrototypeOf(t1, $parent);
      }
      t1 = $constructor.prototype;
      t1 = self.Object.create(t1);
      self.Object.setPrototypeOf($prototype, t1);
    },
    forwardToString_closure: function forwardToString_closure() {
    },
    createClass_closure: function createClass_closure(t0) {
      this.$prototype = t0;
    },
    toSentence: function(iter, conjunction) {
      if (iter.get$length(iter) === 1)
        return J.toString$0$(iter.get$first(iter));
      return iter.take$1(0, iter.get$length(iter) - 1).join$1(0, ", ") + (" " + conjunction + " " + H.S(iter.get$last(iter)));
    },
    indent: function(string, indentation) {
      var t1 = P.String,
        t2 = H.setRuntimeTypeInfo(string.split("\n"), [t1]);
      return new H.MappedListIterable(t2, new B.indent_closure(indentation), [H.getTypeArgumentByIndex(t2, 0), t1]).join$1(0, "\n");
    },
    pluralize: function($name, number, plural) {
      if (number === 1)
        return $name;
      if (plural != null)
        return plural;
      return $name + "s";
    },
    trimAscii: function(string, excludeEscape) {
      var start = B._firstNonWhitespace(string);
      return start == null ? "" : J.substring$2$s(string, start, B._lastNonWhitespace(string, true) + 1);
    },
    trimAsciiRight: function(string, excludeEscape) {
      var end = B._lastNonWhitespace(string, excludeEscape);
      return end == null ? "" : J.substring$2$s(string, 0, end + 1);
    },
    _firstNonWhitespace: function(string) {
      var t1, i, t2;
      for (t1 = string.length, i = 0; i < t1; ++i) {
        t2 = C.JSString_methods._codeUnitAt$1(string, i);
        if (!(t2 === 32 || t2 === 9 || t2 === 10 || t2 === 13 || t2 === 12))
          return i;
      }
      return;
    },
    _lastNonWhitespace: function(string, excludeEscape) {
      var t1, i, t2, codeUnit;
      for (t1 = string.length, i = t1 - 1, t2 = J.getInterceptor$s(string); i >= 0; --i) {
        codeUnit = t2.codeUnitAt$1(string, i);
        if (!(codeUnit === 32 || codeUnit === 9 || codeUnit === 10 || codeUnit === 13 || codeUnit === 12))
          if (excludeEscape && i !== 0 && i !== t1 && codeUnit === 92)
            return i + 1;
          else
            return i;
      }
      return;
    },
    isPublic: function(member) {
      var start = J._codeUnitAt$1$s(member, 0);
      return start !== 45 && start !== 95;
    },
    flattenVertically: function(iterable, $T) {
      var result, t1,
        queues = new H.MappedListIterable(iterable, new B.flattenVertically_closure($T), [H.getRuntimeTypeArgument(iterable, "ListIterable", 0), [Q.QueueList, $T]]).toList$0(0);
      if (queues.length === 1)
        return C.JSArray_methods.get$first(queues);
      result = H.setRuntimeTypeInfo([], [$T]);
      for (t1 = !!queues.fixed$length; queues.length !== 0;) {
        if (t1)
          H.throwExpression(P.UnsupportedError$("removeWhere"));
        C.JSArray_methods._removeWhere$2(queues, new B.flattenVertically_closure0(result), true);
      }
      return result;
    },
    firstOrNull: function(iterable) {
      var iterator = J.get$iterator$ax(iterable);
      return iterator.moveNext$0() ? iterator.get$current(iterator) : null;
    },
    codepointIndexToCodeUnitIndex: function(string, codepointIndex) {
      var t1, codeUnitIndex, i, codeUnitIndex0, t2;
      for (t1 = J.getInterceptor$s(string), codeUnitIndex = 0, i = 0; i < codepointIndex; ++i) {
        codeUnitIndex0 = codeUnitIndex + 1;
        t2 = t1._codeUnitAt$1(string, codeUnitIndex);
        codeUnitIndex = t2 >= 55296 && t2 <= 56319 ? codeUnitIndex0 + 1 : codeUnitIndex0;
      }
      return codeUnitIndex;
    },
    codeUnitIndexToCodepointIndex: function(string, codeUnitIndex) {
      var t1, codepointIndex, i, t2;
      for (t1 = J.getInterceptor$s(string), codepointIndex = 0, i = 0; i < codeUnitIndex; i = (t2 >= 55296 && t2 <= 56319 ? i + 1 : i) + 1) {
        ++codepointIndex;
        t2 = t1._codeUnitAt$1(string, i);
      }
      return codepointIndex;
    },
    frameForSpan: function(span, member, url) {
      var t2, t3, t4,
        t1 = url == null ? span.file.url : url;
      if (t1 == null)
        t1 = $.$get$_noSourceUrl();
      t2 = span.file;
      t3 = span._start;
      t4 = Y.FileLocation$_(t2, t3);
      t4 = t4.file.getLine$1(t4.offset);
      t3 = Y.FileLocation$_(t2, t3);
      return new A.Frame(t1, t4 + 1, t3.file.getColumn$1(t3.offset) + 1, member);
    },
    spanForList: function(nodes) {
      var left, right;
      if (nodes.length === 0)
        return;
      left = C.JSArray_methods.get$first(nodes).get$span();
      if (left == null)
        return;
      right = C.JSArray_methods.get$last(nodes).get$span();
      if (right == null)
        return;
      return left.expand$1(0, right);
    },
    declarationName: function(span) {
      var text = P.String_String$fromCharCodes(C.NativeUint32List_methods.sublist$2(span.file._decodedChars, span._start, span._end), 0, null);
      return B.trimAsciiRight(C.JSString_methods.substring$2(text, 0, C.JSString_methods.indexOf$1(text, ":")), false);
    },
    unvendor: function($name) {
      var i,
        t1 = $name.length;
      if (t1 < 2)
        return $name;
      if (J.getInterceptor$s($name)._codeUnitAt$1($name, 0) !== 45)
        return $name;
      if (C.JSString_methods._codeUnitAt$1($name, 1) === 45)
        return $name;
      for (i = 2; i < t1; ++i)
        if (C.JSString_methods._codeUnitAt$1($name, i) === 45)
          return C.JSString_methods.substring$1($name, i + 1);
      return $name;
    },
    equalsIgnoreCase: function(string1, string2) {
      var t1, i;
      if (string1 == string2)
        return true;
      if (string1 == null || string2 == null)
        return false;
      t1 = string1.length;
      if (t1 !== string2.length)
        return false;
      for (i = 0; i < t1; ++i)
        if (!T.characterEqualsIgnoreCase(C.JSString_methods._codeUnitAt$1(string1, i), C.JSString_methods._codeUnitAt$1(string2, i)))
          return false;
      return true;
    },
    startsWithIgnoreCase: function(string, prefix) {
      var t2, i,
        t1 = prefix.length;
      if (string.length < t1)
        return false;
      for (t2 = J.getInterceptor$s(string), i = 0; i < t1; ++i)
        if (!T.characterEqualsIgnoreCase(t2._codeUnitAt$1(string, i), C.JSString_methods._codeUnitAt$1(prefix, i)))
          return false;
      return true;
    },
    startsWithIgnoreSeparator: function(string, prefix) {
      var i, stringCodeUnit, prefixCodeUnit,
        t1 = string.length,
        t2 = prefix.length;
      if (t1 < t2)
        return false;
      for (t1 = J.getInterceptor$s(string), i = 0; i < t2; ++i) {
        stringCodeUnit = t1._codeUnitAt$1(string, i);
        prefixCodeUnit = C.JSString_methods._codeUnitAt$1(prefix, i);
        if (stringCodeUnit === prefixCodeUnit)
          continue;
        if (stringCodeUnit === 45) {
          if (prefixCodeUnit !== 95)
            return false;
        } else if (stringCodeUnit === 95) {
          if (prefixCodeUnit !== 45)
            return false;
        } else
          return false;
      }
      return true;
    },
    mapInPlace: function(list, $function) {
      var i;
      for (i = 0; i < list.length; ++i)
        list[i] = $function.call$1(list[i]);
    },
    longestCommonSubsequence: function(list1, list2, select, $T) {
      var t1, lengths, selections, t2, i, i0, j, selection, t3, j0, t4, t5;
      if (select == null)
        select = new B.longestCommonSubsequence_closure($T);
      t1 = J.getInterceptor$asx(list1);
      lengths = P.List_List$generate(t1.get$length(list1) + 1, new B.longestCommonSubsequence_closure0(list2), false, [P.List, P.int]);
      selections = P.List_List$generate(t1.get$length(list1), new B.longestCommonSubsequence_closure1(list2, $T), false, [P.List, $T]);
      for (t2 = J.getInterceptor$asx(list2), i = 0; i < t1.get$length(list1); i = i0)
        for (i0 = i + 1, j = 0; j < t2.get$length(list2); j = j0) {
          selection = select.call$2(t1.$index(list1, i), t2.$index(list2, j));
          J.$indexSet$ax(selections[i], j, selection);
          t3 = lengths[i0];
          j0 = j + 1;
          if (selection == null) {
            t4 = J.$index$asx(t3, j);
            t5 = J.$index$asx(lengths[i], j0);
            t5 = Math.max(H.checkNum(t4), H.checkNum(t5));
            t4 = t5;
          } else
            t4 = J.$index$asx(lengths[i], j) + 1;
          J.$indexSet$ax(t3, j0, t4);
        }
      return new B.longestCommonSubsequence_backtrack(selections, lengths, $T).call$2(t1.get$length(list1) - 1, t2.get$length(list2) - 1);
    },
    removeFirstWhere: function(list, test, orElse) {
      var toRemove, element,
        t1 = list.length,
        _i = 0;
      while (true) {
        if (!(_i < list.length)) {
          toRemove = null;
          break;
        }
        c$0: {
          element = list[_i];
          if (!test.call$1(element))
            break c$0;
          toRemove = element;
          break;
        }
        list.length === t1 || (0, H.throwConcurrentModificationError)(list);
        ++_i;
      }
      if (toRemove == null)
        return orElse.call$0();
      else {
        C.JSArray_methods.remove$1(list, toRemove);
        return toRemove;
      }
    },
    mapAddAll2: function(destination, source) {
      source.forEach$1(0, new B.mapAddAll2_closure(destination));
    },
    setAll: function(map, keys, value) {
      var t1;
      for (t1 = J.get$iterator$ax(keys); t1.moveNext$0();)
        map.$indexSet(0, t1.get$current(t1), value);
    },
    rotateSlice: function(list, start, end) {
      var i, next,
        element = list.$index(0, end - 1);
      for (i = start; i < end; ++i, element = next) {
        next = list.$index(0, i);
        list.$indexSet(0, i, element);
      }
    },
    mapAsync: function(iterable, callback, $E, $F) {
      return B.mapAsync$body(iterable, callback, $E, $F, [P.Iterable, $F]);
    },
    mapAsync$body: function(iterable, callback, $E, $F, $async$type) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter($async$type),
        $async$returnValue, t2, _i, t1, $async$temp1;
      var $async$mapAsync = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = H.setRuntimeTypeInfo([], [$F]);
              t2 = iterable.length, _i = 0;
            case 3:
              // for condition
              if (!(_i < t2)) {
                // goto after for
                $async$goto = 5;
                break;
              }
              $async$temp1 = t1;
              $async$goto = 6;
              return P._asyncAwait(callback.call$1(iterable[_i]), $async$mapAsync);
            case 6:
              // returning from await.
              $async$temp1.push($async$result);
            case 4:
              // for update
              ++_i;
              // goto for condition
              $async$goto = 3;
              break;
            case 5:
              // after for
              $async$returnValue = t1;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$mapAsync, $async$completer);
    },
    putIfAbsentAsync: function(map, key, ifAbsent, $K, $V) {
      return B.putIfAbsentAsync$body(map, key, ifAbsent, $K, $V, $V);
    },
    putIfAbsentAsync$body: function(map, key, ifAbsent, $K, $V, $async$type) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter($async$type),
        $async$returnValue, value;
      var $async$putIfAbsentAsync = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              if (map.containsKey$1(key)) {
                $async$returnValue = map.$index(0, key);
                // goto return
                $async$goto = 1;
                break;
              }
              $async$goto = 3;
              return P._asyncAwait(ifAbsent.call$0(), $async$putIfAbsentAsync);
            case 3:
              // returning from await.
              value = $async$result;
              map.$indexSet(0, key, value);
              $async$returnValue = value;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$putIfAbsentAsync, $async$completer);
    },
    mapMapAsync: function(map, value, K1, V1, K2, V2) {
      return B.mapMapAsync$body(map, value, K1, V1, K2, V2, [P.Map, K2, V2]);
    },
    mapMapAsync$body: function(map, value, K1, V1, K2, V2, $async$type) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter($async$type),
        $async$returnValue, t1, mapKey, mapValue, key, result, $async$temp1, $async$temp2;
      var $async$mapMapAsync = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              key = new B.mapMapAsync_closure(K2, K1, V1);
              result = P.LinkedHashMap_LinkedHashMap$_empty(K2, V2);
              t1 = map.get$keys(), t1 = t1.get$iterator(t1);
            case 3:
              // for condition
              if (!t1.moveNext$0()) {
                // goto after for
                $async$goto = 4;
                break;
              }
              mapKey = t1.get$current(t1);
              mapValue = map.$index(0, mapKey);
              $async$temp1 = result;
              $async$goto = 5;
              return P._asyncAwait(key.call$2(mapKey, mapValue), $async$mapMapAsync);
            case 5:
              // returning from await.
              $async$temp2 = $async$result;
              $async$goto = 6;
              return P._asyncAwait(value.call$2(mapKey, mapValue), $async$mapMapAsync);
            case 6:
              // returning from await.
              $async$temp1.$indexSet(0, $async$temp2, $async$result);
              // goto for condition
              $async$goto = 3;
              break;
            case 4:
              // after for
              $async$returnValue = result;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$mapMapAsync, $async$completer);
    },
    copyMapOfMap: function(map, K1, K2, $V) {
      var t1 = [P.Map, K2, $V];
      return Y.mapMap(map, null, new B.copyMapOfMap_closure(K2, $V), K1, t1, K1, t1);
    },
    copyMapOfList: function(map, $K, $E) {
      var t1 = [P.List, $E];
      return Y.mapMap(map, null, new B.copyMapOfList_closure(), $K, t1, $K, t1);
    },
    indent_closure: function indent_closure(t0) {
      this.indentation = t0;
    },
    flattenVertically_closure: function flattenVertically_closure(t0) {
      this.T = t0;
    },
    flattenVertically_closure0: function flattenVertically_closure0(t0) {
      this.result = t0;
    },
    longestCommonSubsequence_closure: function longestCommonSubsequence_closure(t0) {
      this.T = t0;
    },
    longestCommonSubsequence_closure0: function longestCommonSubsequence_closure0(t0) {
      this.list2 = t0;
    },
    longestCommonSubsequence_closure1: function longestCommonSubsequence_closure1(t0, t1) {
      this.list2 = t0;
      this.T = t1;
    },
    longestCommonSubsequence_backtrack: function longestCommonSubsequence_backtrack(t0, t1, t2) {
      this.selections = t0;
      this.lengths = t1;
      this.T = t2;
    },
    mapAddAll2_closure: function mapAddAll2_closure(t0) {
      this.destination = t0;
    },
    mapMapAsync_closure: function mapMapAsync_closure(t0, t1, t2) {
      this.K2 = t0;
      this.K1 = t1;
      this.V1 = t2;
    },
    copyMapOfMap_closure: function copyMapOfMap_closure(t0, t1) {
      this.K2 = t0;
      this.V = t1;
    },
    copyMapOfList_closure: function copyMapOfList_closure() {
    },
    isAlphabetic: function(char) {
      var t1;
      if (!(char >= 65 && char <= 90))
        t1 = char >= 97 && char <= 122;
      else
        t1 = true;
      return t1;
    },
    isDriveLetter: function(path, index) {
      var t1 = path.length,
        t2 = index + 2;
      if (t1 < t2)
        return false;
      if (!B.isAlphabetic(C.JSString_methods.codeUnitAt$1(path, index)))
        return false;
      if (C.JSString_methods.codeUnitAt$1(path, index + 1) !== 58)
        return false;
      if (t1 === t2)
        return true;
      return C.JSString_methods.codeUnitAt$1(path, t2) === 47;
    },
    countCodeUnits: function(string, codeUnit) {
      var t1, count;
      for (t1 = new H.CodeUnits(string), t1 = new H.ListIterator(t1, t1.get$length(t1)), count = 0; t1.moveNext$0();)
        if (t1.__internal$_current === codeUnit)
          ++count;
      return count;
    },
    findLineStart: function(context, text, column) {
      var beginningOfLine, index, lineStart;
      if (text.length === 0)
        for (beginningOfLine = 0; true;) {
          index = C.JSString_methods.indexOf$2(context, "\n", beginningOfLine);
          if (index === -1)
            return context.length - beginningOfLine >= column ? beginningOfLine : null;
          if (index - beginningOfLine >= column)
            return beginningOfLine;
          beginningOfLine = index + 1;
        }
      index = C.JSString_methods.indexOf$1(context, text);
      for (; index !== -1;) {
        lineStart = index === 0 ? 0 : C.JSString_methods.lastIndexOf$2(context, "\n", index - 1) + 1;
        if (column === index - lineStart)
          return lineStart;
        index = C.JSString_methods.indexOf$2(context, text, index + 1);
      }
      return;
    },
    validateErrorArgs: function(string, match, position, $length) {
      var t2,
        t1 = position != null;
      if (t1)
        if (position < 0)
          throw H.wrapException(P.RangeError$("position must be greater than or equal to 0."));
        else if (position > string.length)
          throw H.wrapException(P.RangeError$("position must be less than or equal to the string length."));
      t2 = $length != null;
      if (t2 && $length < 0)
        throw H.wrapException(P.RangeError$("length must be greater than or equal to 0."));
      if (t1 && t2 && position + $length > string.length)
        throw H.wrapException(P.RangeError$("position plus length must not go beyond the end of the string."));
    }
  },
  O = {
    EmptyUnmodifiableSet__throw: function() {
      throw H.wrapException(P.UnsupportedError$("Cannot modify an unmodifiable Set"));
    },
    EmptyUnmodifiableSet: function EmptyUnmodifiableSet(t0) {
      this.$ti = t0;
    },
    Style__getPlatformStyle: function() {
      if (P.Uri_base().get$scheme() !== "file")
        return $.$get$Style_url();
      var t1 = P.Uri_base();
      if (!C.JSString_methods.endsWith$1(t1.get$path(t1), "/"))
        return $.$get$Style_url();
      if (P._Uri__Uri(null, "a/b", null, null).toFilePath$0() === "a\\b")
        return $.$get$Style_windows();
      return $.$get$Style_posix();
    },
    Style: function Style() {
    },
    NullExpression: function NullExpression(t0) {
      this.span = t0;
    },
    Statement: function Statement() {
    },
    AsyncImportCache$none: function(logger) {
      var t1 = logger == null ? C.StderrLogger_false : logger,
        t2 = P.Uri;
      return new O.AsyncImportCache(C.List_empty13, t1, P.LinkedHashMap_LinkedHashMap$_empty(t2, [S.Tuple3, B.AsyncImporter, P.Uri, P.Uri]), P.LinkedHashMap_LinkedHashMap$_empty(t2, V.Stylesheet), P.LinkedHashMap_LinkedHashMap$_empty(t2, E.ImporterResult));
    },
    AsyncImportCache__toImporters: function(importers, loadPaths, packageResolver) {
      var _i, t2, t3, path, _null = null,
        sassPath = H.stringTypeCast(J.get$env$x(self.process).SASS_PATH),
        t1 = H.setRuntimeTypeInfo([], [B.AsyncImporter]);
      for (_i = 0; false; ++_i)
        t1.push(importers[_i]);
      if (loadPaths != null)
        for (t2 = J.get$iterator$ax(loadPaths); t2.moveNext$0();) {
          t3 = t2.get$current(t2);
          t1.push(new F.FilesystemImporter($.$get$context().absolute$7(t3, _null, _null, _null, _null, _null, _null)));
        }
      if (sassPath != null) {
        t2 = sassPath.split(J.$eq$(J.get$platform$x(self.process), "win32") ? ";" : ":");
        t3 = t2.length;
        _i = 0;
        for (; _i < t3; ++_i) {
          path = t2[_i];
          t1.push(new F.FilesystemImporter($.$get$context().absolute$7(path, _null, _null, _null, _null, _null, _null)));
        }
      }
      return t1;
    },
    AsyncImportCache: function AsyncImportCache(t0, t1, t2, t3, t4) {
      var _ = this;
      _._async_import_cache$_importers = t0;
      _._async_import_cache$_logger = t1;
      _._async_import_cache$_canonicalizeCache = t2;
      _._async_import_cache$_importCache = t3;
      _._async_import_cache$_resultsCache = t4;
    },
    AsyncImportCache_canonicalize_closure: function AsyncImportCache_canonicalize_closure(t0, t1) {
      this.$this = t0;
      this.url = t1;
    },
    AsyncImportCache_importCanonical_closure: function AsyncImportCache_importCanonical_closure(t0, t1, t2, t3) {
      var _ = this;
      _.$this = t0;
      _.importer = t1;
      _.canonicalUrl = t2;
      _.originalUrl = t3;
    },
    AsyncImportCache_humanize_closure: function AsyncImportCache_humanize_closure(t0) {
      this.canonicalUrl = t0;
    },
    AsyncImportCache_humanize_closure0: function AsyncImportCache_humanize_closure0() {
    },
    AsyncImportCache_humanize_closure1: function AsyncImportCache_humanize_closure1() {
    },
    Environment$: function(sourceMap) {
      var _null = null,
        t1 = P.String,
        t2 = [G.Module, D.Callable],
        t3 = H.setRuntimeTypeInfo([], [t2]),
        t4 = H.setRuntimeTypeInfo([P.LinkedHashMap_LinkedHashMap$_empty(t1, F.Value)], [[P.Map, P.String, F.Value]]),
        t5 = sourceMap ? H.setRuntimeTypeInfo([P.LinkedHashMap_LinkedHashMap$_empty(t1, B.AstNode)], [[P.Map, P.String, B.AstNode]]) : _null,
        t6 = P.int,
        t7 = D.Callable,
        t8 = [[P.Map, P.String, D.Callable]];
      return new O.Environment(P.LinkedHashMap_LinkedHashMap$_empty(t1, t2), _null, _null, t3, t4, t5, P.LinkedHashMap_LinkedHashMap$_empty(t1, t6), H.setRuntimeTypeInfo([P.LinkedHashMap_LinkedHashMap$_empty(t1, t7)], t8), P.LinkedHashMap_LinkedHashMap$_empty(t1, t6), H.setRuntimeTypeInfo([P.LinkedHashMap_LinkedHashMap$_empty(t1, t7)], t8), P.LinkedHashMap_LinkedHashMap$_empty(t1, t6), _null);
    },
    Environment$_: function(_modules, _globalModules, _forwardedModules, _allModules, _variables, _variableNodes, _functions, _mixins, _content) {
      var t1 = P.String,
        t2 = P.int;
      return new O.Environment(_modules, _globalModules, _forwardedModules, _allModules, _variables, _variableNodes, P.LinkedHashMap_LinkedHashMap$_empty(t1, t2), _functions, P.LinkedHashMap_LinkedHashMap$_empty(t1, t2), _mixins, P.LinkedHashMap_LinkedHashMap$_empty(t1, t2), _content);
    },
    _EnvironmentModule__EnvironmentModule: function(environment, css, extender, forwarded) {
      var t1, t2, t3, t4, t5, t6;
      if (forwarded == null)
        forwarded = C.List_empty2;
      t1 = O._EnvironmentModule__makeModulesByVariable(forwarded);
      t2 = H.getTypeArgumentByIndex(forwarded, 0);
      t3 = O._EnvironmentModule__memberMap(C.JSArray_methods.get$first(environment._variables), new H.MappedListIterable(forwarded, new O._EnvironmentModule__EnvironmentModule_closure(), [t2, [P.Map, P.String, F.Value]]), F.Value);
      t4 = environment._variableNodes;
      t4 = t4 == null ? null : O._EnvironmentModule__memberMap(C.JSArray_methods.get$first(t4), new H.MappedListIterable(forwarded, new O._EnvironmentModule__EnvironmentModule_closure0(), [t2, [P.Map, P.String, B.AstNode]]), B.AstNode);
      t2 = [t2, [P.Map, P.String, D.Callable]];
      t5 = D.Callable;
      t6 = O._EnvironmentModule__memberMap(C.JSArray_methods.get$first(environment._functions), new H.MappedListIterable(forwarded, new O._EnvironmentModule__EnvironmentModule_closure1(), t2), t5);
      t5 = O._EnvironmentModule__memberMap(C.JSArray_methods.get$first(environment._mixins), new H.MappedListIterable(forwarded, new O._EnvironmentModule__EnvironmentModule_closure2(), t2), t5);
      t2 = J.get$isNotEmpty$asx(css.get$children()) || C.JSArray_methods.any$1(environment._allModules, new O._EnvironmentModule__EnvironmentModule_closure3());
      return O._EnvironmentModule$_(environment, css, extender, t1, t3, t4, t6, t5, t2, !extender.get$isEmpty(extender) || C.JSArray_methods.any$1(environment._allModules, new O._EnvironmentModule__EnvironmentModule_closure4()));
    },
    _EnvironmentModule__makeModulesByVariable: function(forwarded) {
      var modulesByVariable, _i, module,
        t1 = forwarded.length;
      if (t1 === 0)
        return C.Map_empty1;
      modulesByVariable = P.LinkedHashMap_LinkedHashMap$_empty(P.String, [G.Module, D.Callable]);
      for (_i = 0; _i < forwarded.length; forwarded.length === t1 || (0, H.throwConcurrentModificationError)(forwarded), ++_i) {
        module = forwarded[_i];
        B.setAll(modulesByVariable, module.variables.get$keys(), module);
      }
      return modulesByVariable;
    },
    _EnvironmentModule__memberMap: function(localMap, otherMaps, $V) {
      var t1, t2, t3;
      localMap = new U.PublicMemberMapView(localMap, [$V]);
      if (otherMaps.get$length(otherMaps) === 0)
        return localMap;
      t1 = H.setRuntimeTypeInfo([], [[P.Map, P.String, $V]]);
      for (t2 = new H.ListIterator(otherMaps, otherMaps.get$length(otherMaps)); t2.moveNext$0();) {
        t3 = t2.__internal$_current;
        if (t3.get$isNotEmpty(t3))
          t1.push(t3);
      }
      t1.push(localMap);
      if (t1.length === 1)
        return localMap;
      return Z.MergedMapView$(t1, P.String, $V);
    },
    _EnvironmentModule$_: function(_environment, css, extender, _modulesByVariable, variables, variableNodes, functions, mixins, transitivelyContainsCss, transitivelyContainsExtensions) {
      return new O._EnvironmentModule(_environment._allModules, variables, variableNodes, functions, mixins, extender, css, transitivelyContainsCss, transitivelyContainsExtensions, _environment, _modulesByVariable);
    },
    Environment: function Environment(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11) {
      var _ = this;
      _._environment$_modules = t0;
      _._globalModules = t1;
      _._forwardedModules = t2;
      _._allModules = t3;
      _._variables = t4;
      _._variableNodes = t5;
      _._variableIndices = t6;
      _._functions = t7;
      _._functionIndices = t8;
      _._mixins = t9;
      _._mixinIndices = t10;
      _._content = t11;
      _._inMixin = false;
      _._inSemiGlobalScope = true;
      _._lastVariableIndex = _._lastVariableName = null;
    },
    Environment__getVariableFromGlobalModule_closure: function Environment__getVariableFromGlobalModule_closure(t0) {
      this.name = t0;
    },
    Environment_setVariable_closure: function Environment_setVariable_closure(t0, t1) {
      this.$this = t0;
      this.name = t1;
    },
    Environment_setVariable_closure0: function Environment_setVariable_closure0(t0) {
      this.name = t0;
    },
    Environment_setVariable_closure1: function Environment_setVariable_closure1(t0, t1) {
      this.$this = t0;
      this.name = t1;
    },
    Environment__getFunctionFromGlobalModule_closure: function Environment__getFunctionFromGlobalModule_closure(t0) {
      this.name = t0;
    },
    Environment__getMixinFromGlobalModule_closure: function Environment__getMixinFromGlobalModule_closure(t0) {
      this.name = t0;
    },
    _EnvironmentModule: function _EnvironmentModule(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10) {
      var _ = this;
      _.upstream = t0;
      _.variables = t1;
      _.variableNodes = t2;
      _.functions = t3;
      _.mixins = t4;
      _.extender = t5;
      _.css = t6;
      _.transitivelyContainsCss = t7;
      _.transitivelyContainsExtensions = t8;
      _._environment = t9;
      _._modulesByVariable = t10;
    },
    _EnvironmentModule__EnvironmentModule_closure: function _EnvironmentModule__EnvironmentModule_closure() {
    },
    _EnvironmentModule__EnvironmentModule_closure0: function _EnvironmentModule__EnvironmentModule_closure0() {
    },
    _EnvironmentModule__EnvironmentModule_closure1: function _EnvironmentModule__EnvironmentModule_closure1() {
    },
    _EnvironmentModule__EnvironmentModule_closure2: function _EnvironmentModule__EnvironmentModule_closure2() {
    },
    _EnvironmentModule__EnvironmentModule_closure3: function _EnvironmentModule__EnvironmentModule_closure3() {
    },
    _EnvironmentModule__EnvironmentModule_closure4: function _EnvironmentModule__EnvironmentModule_closure4() {
    },
    closure9: function closure9() {
    },
    _closure: function _closure() {
    },
    _closure0: function _closure0() {
    },
    SassNull: function SassNull() {
    }
  },
  U = {DefaultEquality: function DefaultEquality() {
    }, ListEquality: function ListEquality() {
    }, _MapEntry: function _MapEntry(t0, t1, t2) {
      this.equality = t0;
      this.key = t1;
      this.value = t2;
    }, MapEquality: function MapEquality() {
    }, ModifiableCssAtRule: function ModifiableCssAtRule(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _.name = t0;
      _.value = t1;
      _.isChildless = t2;
      _.span = t3;
      _.children = t4;
      _._children = t5;
      _._indexInParent = _._parent = null;
      _.isGroupEnd = false;
    }, ModifiableCssKeyframeBlock: function ModifiableCssKeyframeBlock(t0, t1, t2, t3) {
      var _ = this;
      _.selector = t0;
      _.span = t1;
      _.children = t2;
      _._children = t3;
      _._indexInParent = _._parent = null;
      _.isGroupEnd = false;
    },
    AtRule$: function($name, span, children, value) {
      var t1 = children == null ? null : P.List_List$unmodifiable(children, O.Statement),
        t2 = t1 == null ? null : C.JSArray_methods.any$1(t1, new M.ParentStatement_closure());
      return new U.AtRule($name, value, span, t1, t2 === true);
    },
    AtRule: function AtRule(t0, t1, t2, t3, t4) {
      var _ = this;
      _.name = t0;
      _.value = t1;
      _.span = t2;
      _.children = t3;
      _.hasDeclarations = t4;
    },
    SupportsOperation: function SupportsOperation(t0, t1, t2, t3) {
      var _ = this;
      _.left = t0;
      _.right = t1;
      _.operator = t2;
      _.span = t3;
    },
    compile: function(path, charset, functions, importCache, indentWidth, lineFeed, logger, nodeImporter, sourceMap, style, syntax, useSpaces) {
      var t1, t2, stylesheet;
      if (nodeImporter == null)
        t1 = syntax == null || syntax === M.Syntax_forPath(path);
      else
        t1 = false;
      if (t1) {
        if (importCache == null)
          importCache = R.ImportCache$none(logger);
        t1 = D.absolute(".");
        t2 = $.$get$context();
        stylesheet = importCache.importCanonical$3(new F.FilesystemImporter(t1), t2.toUri$1(t2.canonicalize$1(path)), t2.toUri$1(path));
      } else {
        t1 = B.readFile(path);
        t2 = syntax == null ? M.Syntax_forPath(path) : syntax;
        stylesheet = V.Stylesheet_Stylesheet$parse(t1, t2, logger, $.$get$context().toUri$1(path));
      }
      return U._compileStylesheet(stylesheet, logger, importCache, nodeImporter, new F.FilesystemImporter(D.absolute(".")), functions, style, useSpaces, indentWidth, lineFeed, sourceMap, charset);
    },
    compileString: function(source, charset, functions, importCache, importer, indentWidth, lineFeed, logger, nodeImporter, sourceMap, style, syntax, url, useSpaces) {
      var stylesheet = V.Stylesheet_Stylesheet$parse(source, syntax == null ? C.Syntax_SCSS : syntax, logger, url);
      return U._compileStylesheet(stylesheet, logger, importCache, nodeImporter, importer == null ? new F.FilesystemImporter(D.absolute(".")) : importer, functions, style, useSpaces, indentWidth, lineFeed, sourceMap, charset);
    },
    _compileStylesheet: function(stylesheet, logger, importCache, nodeImporter, importer, functions, style, useSpaces, indentWidth, lineFeed, sourceMap, charset) {
      var evaluateResult = R._EvaluateVisitor$(functions, importCache, logger, nodeImporter, sourceMap).run$2(0, importer, stylesheet),
        serializeResult = N.serialize(evaluateResult.stylesheet, charset, indentWidth, false, lineFeed, sourceMap, style, useSpaces),
        t1 = serializeResult.sourceMap;
      if (t1 != null && importCache != null)
        B.mapInPlace(t1.urls, new U._compileStylesheet_closure(stylesheet, importCache));
      return new X.CompileResult(evaluateResult, serializeResult);
    },
    _compileStylesheet_closure: function _compileStylesheet_closure(t0, t1) {
      this.stylesheet = t0;
      this.importCache = t1;
    },
    RenderResult: function RenderResult() {
    },
    RenderResultStats: function RenderResultStats() {
    },
    SassParser: function SassParser(t0, t1, t2) {
      var _ = this;
      _._currentIndentation = 0;
      _._spaces = _._nextIndentationEnd = _._nextIndentation = null;
      _._isUseAllowed = true;
      _._stylesheet$_inMixin = false;
      _._mixinHasContent = null;
      _._inParentheses = _._inStyleRule = _._stylesheet$_inUnknownAtRule = _._inControlDirective = _._inContentBlock = false;
      _._globalVariables = t0;
      _.lastSilentComment = null;
      _.scanner = t1;
      _.logger = t2;
    },
    SassParser_children_closure: function SassParser_children_closure(t0, t1, t2) {
      this.$this = t0;
      this.children = t1;
      this.child = t2;
    },
    MultiDirWatcher: function MultiDirWatcher(t0, t1, t2) {
      this._watchers = t0;
      this._group = t1;
      this._poll = t2;
    },
    PublicMemberMapView: function PublicMemberMapView(t0, t1) {
      this._inner = t0;
      this.$ti = t1;
    },
    Highlighter__normalizeNewlines: function(span) {
      var endOffset, t1, i, t2, t3, t4,
        text = span.get$text();
      if (!C.JSString_methods.contains$1(text, "\r\n"))
        return span;
      endOffset = span.get$end(span).get$offset();
      for (t1 = text.length - 1, i = 0; i < t1; ++i)
        if (C.JSString_methods._codeUnitAt$1(text, i) === 13 && C.JSString_methods._codeUnitAt$1(text, i + 1) === 10)
          --endOffset;
      t1 = span.get$start(span);
      t2 = span.get$sourceUrl();
      t3 = span.get$end(span).get$line();
      t2 = V.SourceLocation$(endOffset, span.get$end(span).get$column(), t3, t2);
      t3 = H.stringReplaceAllUnchecked(text, "\r\n", "\n");
      t4 = span.get$context(span);
      return X.SourceSpanWithContext$(t1, t2, t3, H.stringReplaceAllUnchecked(t4, "\r\n", "\n"));
    },
    Highlighter__normalizeTrailingNewline: function(span) {
      var context, text, start, end, t1, t2, t3;
      if (!C.JSString_methods.endsWith$1(span.get$context(span), "\n"))
        return span;
      if (C.JSString_methods.endsWith$1(span.get$text(), "\n\n"))
        return span;
      context = C.JSString_methods.substring$2(span.get$context(span), 0, span.get$context(span).length - 1);
      text = span.get$text();
      start = span.get$start(span);
      end = span.get$end(span);
      if (C.JSString_methods.endsWith$1(span.get$text(), "\n") && B.findLineStart(span.get$context(span), span.get$text(), span.get$start(span).get$column()) + span.get$start(span).get$column() + span.get$length(span) === span.get$context(span).length) {
        text = C.JSString_methods.substring$2(span.get$text(), 0, span.get$text().length - 1);
        t1 = span.get$end(span).get$offset();
        t2 = span.get$sourceUrl();
        t3 = span.get$end(span).get$line();
        end = V.SourceLocation$(t1 - 1, U.Highlighter__lastLineLength(text), t3 - 1, t2);
        start = span.get$start(span).get$offset() == span.get$end(span).get$offset() ? end : span.get$start(span);
      }
      return X.SourceSpanWithContext$(start, end, text, context);
    },
    Highlighter__normalizeEndOfLine: function(span) {
      var text, t1, t2, t3, t4;
      if (span.get$end(span).get$column() !== 0)
        return span;
      if (span.get$end(span).get$line() == span.get$start(span).get$line())
        return span;
      text = C.JSString_methods.substring$2(span.get$text(), 0, span.get$text().length - 1);
      t1 = span.get$start(span);
      t2 = span.get$end(span).get$offset();
      t3 = span.get$sourceUrl();
      t4 = span.get$end(span).get$line();
      return X.SourceSpanWithContext$(t1, V.SourceLocation$(t2 - 1, U.Highlighter__lastLineLength(text), t4 - 1, t3), text, span.get$context(span));
    },
    Highlighter__lastLineLength: function(text) {
      var t1 = text.length;
      if (t1 === 0)
        return 0;
      if (C.JSString_methods.codeUnitAt$1(text, t1 - 1) === 10)
        return t1 === 1 ? 0 : t1 - C.JSString_methods.lastIndexOf$2(text, "\n", t1 - 2) - 1;
      else
        return t1 - C.JSString_methods.lastIndexOf$1(text, "\n") - 1;
    },
    Highlighter: function Highlighter(t0, t1, t2, t3, t4) {
      var _ = this;
      _._highlighter$_span = t0;
      _._color = t1;
      _._multiline = t2;
      _._paddingBeforeSidebar = t3;
      _._highlighter$_buffer = t4;
    },
    Highlighter__writeFirstLine_closure: function Highlighter__writeFirstLine_closure(t0, t1) {
      this.$this = t0;
      this.line = t1;
    },
    Highlighter__writeFirstLine_closure0: function Highlighter__writeFirstLine_closure0(t0, t1) {
      this.$this = t0;
      this.textInside = t1;
    },
    Highlighter__writeFirstLine_closure1: function Highlighter__writeFirstLine_closure1(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    Highlighter__writeFirstLine_closure2: function Highlighter__writeFirstLine_closure2(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    Highlighter__writeIntermediateLines_closure: function Highlighter__writeIntermediateLines_closure(t0, t1) {
      this.$this = t0;
      this.line = t1;
    },
    Highlighter__writeLastLine_closure: function Highlighter__writeLastLine_closure(t0, t1) {
      this.$this = t0;
      this.line = t1;
    },
    Highlighter__writeLastLine_closure0: function Highlighter__writeLastLine_closure0(t0, t1) {
      this.$this = t0;
      this.textInside = t1;
    },
    Highlighter__writeLastLine_closure1: function Highlighter__writeLastLine_closure1(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    Highlighter__writeSidebar_closure: function Highlighter__writeSidebar_closure(t0, t1, t2) {
      this.$this = t0;
      this.line = t1;
      this.end = t2;
    },
    Chain_Chain$parse: function(chain) {
      var t1, t2,
        _s26_ = "<asynchronous suspension>\n",
        _s51_ = "===== asynchronous gap ===========================\n";
      if (chain.length === 0) {
        t1 = Y.Trace;
        return new U.Chain(P.List_List$unmodifiable(H.setRuntimeTypeInfo([], [t1]), t1));
      }
      if (C.JSString_methods.contains$1(chain, _s26_)) {
        t1 = H.setRuntimeTypeInfo(chain.split(_s26_), [P.String]);
        t2 = Y.Trace;
        return new U.Chain(P.List_List$unmodifiable(new H.MappedListIterable(t1, new U.Chain_Chain$parse_closure(), [H.getTypeArgumentByIndex(t1, 0), t2]), t2));
      }
      if (!C.JSString_methods.contains$1(chain, _s51_)) {
        t1 = Y.Trace;
        return new U.Chain(P.List_List$unmodifiable(H.setRuntimeTypeInfo([Y.Trace_Trace$parse(chain)], [t1]), t1));
      }
      t1 = H.setRuntimeTypeInfo(chain.split(_s51_), [P.String]);
      t2 = Y.Trace;
      return new U.Chain(P.List_List$unmodifiable(new H.MappedListIterable(t1, new U.Chain_Chain$parse_closure0(), [H.getTypeArgumentByIndex(t1, 0), t2]), t2));
    },
    Chain: function Chain(t0) {
      this.traces = t0;
    },
    Chain_Chain$parse_closure: function Chain_Chain$parse_closure() {
    },
    Chain_Chain$parse_closure0: function Chain_Chain$parse_closure0() {
    },
    Chain_toTrace_closure: function Chain_toTrace_closure() {
    },
    Chain_toString_closure0: function Chain_toString_closure0() {
    },
    Chain_toString__closure0: function Chain_toString__closure0() {
    },
    Chain_toString_closure: function Chain_toString_closure(t0) {
      this.longest = t0;
    },
    Chain_toString__closure: function Chain_toString__closure(t0) {
      this.longest = t0;
    }
  },
  M = {_DelegatingIterableBase: function _DelegatingIterableBase() {
    }, DelegatingIterable: function DelegatingIterable() {
    }, DelegatingSet: function DelegatingSet(t0, t1) {
      this._base = t0;
      this.$ti = t1;
    }, MapKeySet: function MapKeySet(t0, t1) {
      this._baseMap = t0;
      this.$ti = t1;
    }, _MapKeySet__DelegatingIterableBase_UnmodifiableSetMixin: function _MapKeySet__DelegatingIterableBase_UnmodifiableSetMixin() {
    },
    Context_Context: function(style) {
      var current = style == null ? D.current() : ".";
      if (style == null)
        style = $.$get$Style_platform();
      return new M.Context(style, current);
    },
    _parseUri: function(uri) {
      if (typeof uri === "string")
        return P.Uri_parse(uri);
      if (!!J.getInterceptor$(uri).$isUri)
        return uri;
      throw H.wrapException(P.ArgumentError$value(uri, "uri", "Value must be a String or a Uri"));
    },
    _validateArgList: function(method, args) {
      var numArgs, i, numArgs0, message, t1, t2;
      for (numArgs = args.length, i = 1; i < numArgs; ++i) {
        if (args[i] == null || args[i - 1] != null)
          continue;
        for (; numArgs >= 1; numArgs = numArgs0) {
          numArgs0 = numArgs - 1;
          if (args[numArgs0] != null)
            break;
        }
        message = new P.StringBuffer("");
        t1 = method + "(";
        message._contents = t1;
        t2 = H.SubListIterable$(args, 0, numArgs, H.getTypeArgumentByIndex(args, 0));
        t2 = t1 + new H.MappedListIterable(t2, new M._validateArgList_closure(), [H.getTypeArgumentByIndex(t2, 0), P.String]).join$1(0, ", ");
        message._contents = t2;
        message._contents = t2 + ("): part " + (i - 1) + " was null, but part " + i + " was not.");
        throw H.wrapException(P.ArgumentError$(message.toString$0(0)));
      }
    },
    Context: function Context(t0, t1) {
      this.style = t0;
      this._context$_current = t1;
    },
    Context_join_closure: function Context_join_closure() {
    },
    Context_joinAll_closure: function Context_joinAll_closure() {
    },
    Context_split_closure: function Context_split_closure() {
    },
    _validateArgList_closure: function _validateArgList_closure() {
    },
    _PathDirection: function _PathDirection(t0) {
      this.name = t0;
    },
    _PathRelation: function _PathRelation(t0) {
      this.name = t0;
    },
    CallableDeclaration: function CallableDeclaration() {
    },
    FunctionRule: function FunctionRule(t0, t1, t2, t3, t4) {
      var _ = this;
      _.name = t0;
      _.$arguments = t1;
      _.span = t2;
      _.children = t3;
      _.hasDeclarations = t4;
    },
    ParentStatement: function ParentStatement() {
    },
    ParentStatement_closure: function ParentStatement_closure() {
    },
    SupportsNegation: function SupportsNegation(t0, t1) {
      this.condition = t0;
      this.span = t1;
    },
    ParentSelector: function ParentSelector(t0) {
      this.suffix = t0;
    },
    SimpleSelector: function SimpleSelector() {
    },
    Importer: function Importer() {
    },
    StylesheetNode$_: function(_stylesheet, importer, canonicalUrl, _upstream) {
      var t1 = new M.StylesheetNode(importer, canonicalUrl, _upstream, P.LinkedHashSet_LinkedHashSet(M.StylesheetNode));
      t1.StylesheetNode$_$4(_stylesheet, importer, canonicalUrl, _upstream);
      return t1;
    },
    StylesheetGraph: function StylesheetGraph(t0, t1, t2) {
      this._nodes = t0;
      this.importCache = t1;
      this._transitiveModificationTimes = t2;
    },
    StylesheetGraph_modifiedSince_transitiveModificationTime: function StylesheetGraph_modifiedSince_transitiveModificationTime(t0) {
      this.$this = t0;
    },
    StylesheetGraph_modifiedSince_transitiveModificationTime_closure: function StylesheetGraph_modifiedSince_transitiveModificationTime_closure(t0, t1) {
      this.node = t0;
      this.transitiveModificationTime = t1;
    },
    StylesheetGraph__add_closure: function StylesheetGraph__add_closure(t0, t1, t2, t3) {
      var _ = this;
      _.$this = t0;
      _.url = t1;
      _.baseImporter = t2;
      _.baseUrl = t3;
    },
    StylesheetGraph_addCanonical_closure: function StylesheetGraph_addCanonical_closure(t0, t1, t2, t3) {
      var _ = this;
      _.$this = t0;
      _.importer = t1;
      _.canonicalUrl = t2;
      _.originalUrl = t3;
    },
    StylesheetGraph_addCanonical_closure0: function StylesheetGraph_addCanonical_closure0(t0, t1, t2, t3) {
      var _ = this;
      _.$this = t0;
      _.stylesheet = t1;
      _.importer = t2;
      _.canonicalUrl = t3;
    },
    StylesheetGraph__upstreamNodes_closure: function StylesheetGraph__upstreamNodes_closure() {
    },
    StylesheetGraph_reload_closure: function StylesheetGraph_reload_closure(t0, t1, t2) {
      this.$this = t0;
      this.node = t1;
      this.canonicalUrl = t2;
    },
    StylesheetGraph__nodeFor_closure: function StylesheetGraph__nodeFor_closure(t0, t1, t2, t3) {
      var _ = this;
      _.$this = t0;
      _.url = t1;
      _.baseImporter = t2;
      _.baseUrl = t3;
    },
    StylesheetGraph__nodeFor_closure0: function StylesheetGraph__nodeFor_closure0(t0, t1, t2, t3) {
      var _ = this;
      _.$this = t0;
      _.importer = t1;
      _.canonicalUrl = t2;
      _.resolvedUrl = t3;
    },
    StylesheetNode: function StylesheetNode(t0, t1, t2, t3) {
      var _ = this;
      _.importer = t0;
      _.canonicalUrl = t1;
      _._upstream = t2;
      _._downstream = t3;
    },
    Syntax_forPath: function(path) {
      switch (X.ParsedPath_ParsedPath$parse(path, $.$get$context().style)._splitExtension$0()[1]) {
        case ".sass":
          return C.Syntax_Sass;
        case ".css":
          return C.Syntax_CSS;
        default:
          return C.Syntax_SCSS;
      }
    },
    Syntax: function Syntax(t0) {
      this._syntax$_name = t0;
    }
  },
  X = {
    ParsedPath_ParsedPath$parse: function(path, style) {
      var t1, parts, separators, start, i,
        root = style.getRoot$1(path),
        isRootRelative = style.isRootRelative$1(path);
      if (root != null)
        path = J.substring$1$s(path, root.length);
      t1 = [P.String];
      parts = H.setRuntimeTypeInfo([], t1);
      separators = H.setRuntimeTypeInfo([], t1);
      t1 = path.length;
      if (t1 !== 0 && style.isSeparator$1(C.JSString_methods._codeUnitAt$1(path, 0))) {
        separators.push(path[0]);
        start = 1;
      } else {
        separators.push("");
        start = 0;
      }
      for (i = start; i < t1; ++i)
        if (style.isSeparator$1(C.JSString_methods._codeUnitAt$1(path, i))) {
          parts.push(C.JSString_methods.substring$2(path, start, i));
          separators.push(path[i]);
          start = i + 1;
        }
      if (start < t1) {
        parts.push(C.JSString_methods.substring$1(path, start));
        separators.push("");
      }
      return new X.ParsedPath(style, root, isRootRelative, parts, separators);
    },
    ParsedPath: function ParsedPath(t0, t1, t2, t3, t4) {
      var _ = this;
      _.style = t0;
      _.root = t1;
      _.isRootRelative = t2;
      _.parts = t3;
      _.separators = t4;
    },
    ParsedPath_normalize_closure: function ParsedPath_normalize_closure(t0) {
      this.$this = t0;
    },
    ParsedPath__splitExtension_closure: function ParsedPath__splitExtension_closure() {
    },
    ParsedPath__splitExtension_closure0: function ParsedPath__splitExtension_closure0() {
    },
    PathException$: function(message) {
      return new X.PathException(message);
    },
    PathException: function PathException(t0) {
      this.message = t0;
    },
    ModifiableCssStyleRule$: function(selector, span, originalSelector) {
      var t1 = originalSelector == null ? selector.value : originalSelector,
        t2 = B.ModifiableCssNode,
        t3 = H.setRuntimeTypeInfo([], [t2]);
      return new X.ModifiableCssStyleRule(selector, t1, span, new P.UnmodifiableListView(t3, [t2]), t3);
    },
    ModifiableCssStyleRule: function ModifiableCssStyleRule(t0, t1, t2, t3, t4) {
      var _ = this;
      _.selector = t0;
      _.originalSelector = t1;
      _.span = t2;
      _.children = t3;
      _._children = t4;
      _._indexInParent = _._parent = null;
      _.isGroupEnd = false;
    },
    CssStyleRule: function CssStyleRule() {
    },
    ArgumentInvocation$: function(positional, named, span, keywordRest, rest) {
      var t1 = T.Expression;
      return new X.ArgumentInvocation(P.List_List$unmodifiable(positional, t1), H.ConstantMap_ConstantMap$from(named, P.String, t1), rest, keywordRest, span);
    },
    ArgumentInvocation: function ArgumentInvocation(t0, t1, t2, t3, t4) {
      var _ = this;
      _.positional = t0;
      _.named = t1;
      _.rest = t2;
      _.keywordRest = t3;
      _.span = t4;
    },
    UnaryOperationExpression: function UnaryOperationExpression(t0, t1, t2) {
      this.operator = t0;
      this.operand = t1;
      this.span = t2;
    },
    UnaryOperator: function UnaryOperator(t0, t1) {
      this.name = t0;
      this.operator = t1;
    },
    Interpolation$: function(contents, span) {
      var t1 = new X.Interpolation(P.List_List$unmodifiable(contents, P.Object), span);
      t1.Interpolation$2(contents, span);
      return t1;
    },
    Interpolation: function Interpolation(t0, t1) {
      this.contents = t0;
      this.span = t1;
    },
    Interpolation_toString_closure: function Interpolation_toString_closure() {
    },
    ExtendRule: function ExtendRule(t0, t1, t2) {
      this.selector = t0;
      this.isOptional = t1;
      this.span = t2;
    },
    StyleRule: function StyleRule(t0, t1, t2, t3) {
      var _ = this;
      _.selector = t0;
      _.span = t1;
      _.children = t2;
      _.hasDeclarations = t3;
    },
    SupportsInterpolation: function SupportsInterpolation(t0, t1) {
      this.expression = t0;
      this.span = t1;
    },
    ClassSelector: function ClassSelector(t0) {
      this.name = t0;
    },
    CompoundSelector$: function(components) {
      var t1 = P.List_List$unmodifiable(components, M.SimpleSelector);
      if (t1.length === 0)
        H.throwExpression(P.ArgumentError$("components may not be empty."));
      return new X.CompoundSelector(t1);
    },
    CompoundSelector: function CompoundSelector(t0) {
      this.components = t0;
      this._compound$_maxSpecificity = this._compound$_minSpecificity = null;
    },
    CompoundSelector_isInvisible_closure: function CompoundSelector_isInvisible_closure() {
    },
    compileAsync: function(path, charset, functions, importCache, indentWidth, lineFeed, logger, nodeImporter, sourceMap, style, syntax, useSpaces) {
      return X.compileAsync$body(path, charset, functions, importCache, indentWidth, lineFeed, logger, nodeImporter, sourceMap, style, syntax, useSpaces);
    },
    compileAsync$body: function(path, charset, functions, importCache, indentWidth, lineFeed, logger, nodeImporter, sourceMap, style, syntax, useSpaces) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(X.CompileResult),
        $async$returnValue, t1, t2, stylesheet;
      var $async$compileAsync = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              if (nodeImporter == null)
                t1 = syntax == null || syntax === M.Syntax_forPath(path);
              else
                t1 = false;
              $async$goto = t1 ? 3 : 5;
              break;
            case 3:
              // then
              if (importCache == null)
                importCache = O.AsyncImportCache$none(logger);
              t1 = D.absolute(".");
              t2 = $.$get$context();
              $async$goto = 6;
              return P._asyncAwait(importCache.importCanonical$3(new F.FilesystemImporter(t1), t2.toUri$1(t2.canonicalize$1(path)), t2.toUri$1(path)), $async$compileAsync);
            case 6:
              // returning from await.
              stylesheet = $async$result;
              // goto join
              $async$goto = 4;
              break;
            case 5:
              // else
              t1 = B.readFile(path);
              t2 = syntax == null ? M.Syntax_forPath(path) : syntax;
              stylesheet = V.Stylesheet_Stylesheet$parse(t1, t2, logger, $.$get$context().toUri$1(path));
            case 4:
              // join
              $async$goto = 7;
              return P._asyncAwait(X._compileStylesheet0(stylesheet, logger, importCache, nodeImporter, new F.FilesystemImporter(D.absolute(".")), functions, style, useSpaces, indentWidth, lineFeed, sourceMap, charset), $async$compileAsync);
            case 7:
              // returning from await.
              $async$returnValue = $async$result;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$compileAsync, $async$completer);
    },
    compileStringAsync: function(source, charset, functions, importCache, importer, indentWidth, lineFeed, logger, nodeImporter, sourceMap, style, syntax, url, useSpaces) {
      return X.compileStringAsync$body(source, charset, functions, importCache, importer, indentWidth, lineFeed, logger, nodeImporter, sourceMap, style, syntax, url, useSpaces);
    },
    compileStringAsync$body: function(source, charset, functions, importCache, importer, indentWidth, lineFeed, logger, nodeImporter, sourceMap, style, syntax, url, useSpaces) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(X.CompileResult),
        $async$returnValue, stylesheet;
      var $async$compileStringAsync = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              stylesheet = V.Stylesheet_Stylesheet$parse(source, syntax == null ? C.Syntax_SCSS : syntax, logger, url);
              $async$returnValue = X._compileStylesheet0(stylesheet, logger, importCache, nodeImporter, importer == null ? new F.FilesystemImporter(D.absolute(".")) : importer, functions, style, useSpaces, indentWidth, lineFeed, sourceMap, charset);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$compileStringAsync, $async$completer);
    },
    _compileStylesheet0: function(stylesheet, logger, importCache, nodeImporter, importer, functions, style, useSpaces, indentWidth, lineFeed, sourceMap, charset) {
      return X._compileStylesheet$body(stylesheet, logger, importCache, nodeImporter, importer, functions, style, useSpaces, indentWidth, lineFeed, sourceMap, charset);
    },
    _compileStylesheet$body: function(stylesheet, logger, importCache, nodeImporter, importer, functions, style, useSpaces, indentWidth, lineFeed, sourceMap, charset) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(X.CompileResult),
        $async$returnValue, evaluateResult, serializeResult, t1;
      var $async$_compileStylesheet0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              return P._asyncAwait(E._EvaluateVisitor$0(functions, importCache, logger, nodeImporter, sourceMap).run$2(0, importer, stylesheet), $async$_compileStylesheet0);
            case 3:
              // returning from await.
              evaluateResult = $async$result;
              serializeResult = N.serialize(evaluateResult.stylesheet, charset, indentWidth, false, lineFeed, sourceMap, style, useSpaces);
              t1 = serializeResult.sourceMap;
              if (t1 != null && importCache != null)
                B.mapInPlace(t1.urls, new X._compileStylesheet_closure0(stylesheet, importCache));
              $async$returnValue = new X.CompileResult(evaluateResult, serializeResult);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$_compileStylesheet0, $async$completer);
    },
    _compileStylesheet_closure0: function _compileStylesheet_closure0(t0, t1) {
      this.stylesheet = t0;
      this.importCache = t1;
    },
    CompileResult: function CompileResult(t0, t1) {
      this._evaluate = t0;
      this._serialize = t1;
    },
    closure34: function closure34() {
    },
    closure35: function closure35() {
    },
    SourceSpanWithContext$: function(start, end, text, _context) {
      var t1 = new X.SourceSpanWithContext(_context, start, end, text);
      t1.SourceSpanBase$3(start, end, text);
      if (!C.JSString_methods.contains$1(_context, text))
        H.throwExpression(P.ArgumentError$('The context line "' + _context + '" must contain "' + text + '".'));
      if (B.findLineStart(_context, text, start.get$column()) == null)
        H.throwExpression(P.ArgumentError$('The span text "' + text + '" must start at column ' + (start.get$column() + 1) + ' in a line within "' + _context + '".'));
      return t1;
    },
    SourceSpanWithContext: function SourceSpanWithContext(t0, t1, t2, t3) {
      var _ = this;
      _._context = t0;
      _.start = t1;
      _.end = t2;
      _.text = t3;
    },
    StringScanner$: function(string, position, sourceUrl) {
      var t1 = typeof sourceUrl === "string" ? P.Uri_parse(sourceUrl) : H.interceptedTypeCast(sourceUrl, "$isUri");
      return new X.StringScanner(t1, string);
    },
    StringScanner: function StringScanner(t0, t1) {
      var _ = this;
      _.sourceUrl = t0;
      _.string = t1;
      _._string_scanner$_position = 0;
      _._lastMatchPosition = _._lastMatch = null;
    },
    _combine: function(hash, value) {
      hash = 536870911 & hash + value;
      hash = 536870911 & hash + ((524287 & hash) << 10);
      return hash ^ hash >>> 6;
    },
    _finish: function(hash) {
      hash = 536870911 & hash + ((67108863 & hash) << 3);
      hash ^= hash >>> 11;
      return 536870911 & hash + ((16383 & hash) << 15);
    }
  },
  K = {
    PathMap__create: function(context, $V) {
      var t1 = {};
      t1.context = context;
      t1.context = $.$get$context();
      return P.LinkedHashMap_LinkedHashMap(new K.PathMap__create_closure(t1), new K.PathMap__create_closure0(t1), new K.PathMap__create_closure1(), P.String, $V);
    },
    PathMap: function PathMap(t0, t1) {
      this._collection$_map = t0;
      this.$ti = t1;
    },
    PathMap__create_closure: function PathMap__create_closure(t0) {
      this._box_0 = t0;
    },
    PathMap__create_closure0: function PathMap__create_closure0(t0) {
      this._box_0 = t0;
    },
    PathMap__create_closure1: function PathMap__create_closure1() {
    },
    ColorExpression: function ColorExpression(t0) {
      this.value = t0;
    },
    _functionString: function($name, $arguments) {
      return new D.SassString($name + "(" + J.map$1$1$ax($arguments, new K._functionString_closure(), P.String).join$1(0, ", ") + ")", false);
    },
    _removedColorFunction: function($name, argument, negative) {
      return new Q.BuiltInCallable($name, H.setRuntimeTypeInfo([new S.Tuple2(B.ArgumentDeclaration_ArgumentDeclaration$parse("$color, $amount"), new K._removedColorFunction_closure($name, argument, negative), [B.ArgumentDeclaration, {func: 1, ret: F.Value, args: [[P.List, F.Value]]}])], [[S.Tuple2, B.ArgumentDeclaration, {func: 1, ret: F.Value, args: [[P.List, F.Value]]}]]));
    },
    _rgb: function($name, $arguments) {
      var t2, red, green, blue, t3, _null = null,
        t1 = J.getInterceptor$asx($arguments),
        alpha = t1.get$length($arguments) > 3 ? t1.$index($arguments, 3) : _null;
      if (!t1.$index($arguments, 0).get$isSpecialNumber())
        if (!t1.$index($arguments, 1).get$isSpecialNumber())
          if (!t1.$index($arguments, 2).get$isSpecialNumber()) {
            t2 = alpha == null ? _null : alpha.get$isSpecialNumber();
            t2 = t2 === true;
          } else
            t2 = true;
        else
          t2 = true;
      else
        t2 = true;
      if (t2)
        return K._functionString($name, $arguments);
      red = t1.$index($arguments, 0).assertNumber$1("red");
      green = t1.$index($arguments, 1).assertNumber$1("green");
      blue = t1.$index($arguments, 2).assertNumber$1("blue");
      t1 = T.fuzzyRound(K._percentageOrUnitless(red, 255, "red"));
      t2 = T.fuzzyRound(K._percentageOrUnitless(green, 255, "green"));
      t3 = T.fuzzyRound(K._percentageOrUnitless(blue, 255, "blue"));
      return K.SassColor$rgb(t1, t2, t3, alpha == null ? _null : K._percentageOrUnitless(alpha.assertNumber$1("alpha"), 1, "alpha"), _null);
    },
    _rgbTwoArg: function($name, $arguments) {
      var first, t2, color,
        t1 = J.getInterceptor$asx($arguments);
      if (t1.$index($arguments, 0).get$isVar())
        return K._functionString($name, $arguments);
      else if (t1.$index($arguments, 1).get$isVar()) {
        first = t1.$index($arguments, 0);
        if (first instanceof K.SassColor) {
          t2 = $name + "(" + H.S(first.get$red()) + ", " + H.S(first.get$green()) + ", " + H.S(first.get$blue()) + ", ";
          t1 = t1.$index($arguments, 1);
          t1.toString;
          return new D.SassString(t2 + N.serializeValue(t1, false, true) + ")", false);
        } else
          return K._functionString($name, $arguments);
      } else if (t1.$index($arguments, 1).get$isSpecialNumber()) {
        color = t1.$index($arguments, 0).assertColor$1("color");
        t2 = $name + "(" + H.S(color.get$red()) + ", " + H.S(color.get$green()) + ", " + H.S(color.get$blue()) + ", ";
        t1 = t1.$index($arguments, 1);
        t1.toString;
        return new D.SassString(t2 + N.serializeValue(t1, false, true) + ")", false);
      }
      return t1.$index($arguments, 0).assertColor$1("color").changeAlpha$1(K._percentageOrUnitless(t1.$index($arguments, 1).assertNumber$1("alpha"), 1, "alpha"));
    },
    _hsl: function($name, $arguments) {
      var t2, hue, saturation, lightness, t3,
        t1 = J.getInterceptor$asx($arguments),
        alpha = t1.get$length($arguments) > 3 ? t1.$index($arguments, 3) : null;
      if (!t1.$index($arguments, 0).get$isSpecialNumber())
        if (!t1.$index($arguments, 1).get$isSpecialNumber())
          if (!t1.$index($arguments, 2).get$isSpecialNumber()) {
            t2 = alpha == null ? null : alpha.get$isSpecialNumber();
            t2 = t2 === true;
          } else
            t2 = true;
        else
          t2 = true;
      else
        t2 = true;
      if (t2)
        return K._functionString($name, $arguments);
      hue = t1.$index($arguments, 0).assertNumber$1("hue");
      saturation = t1.$index($arguments, 1).assertNumber$1("saturation");
      lightness = t1.$index($arguments, 2).assertNumber$1("lightness");
      t1 = J.clamp$2$n(saturation.value, 0, 100);
      t2 = J.clamp$2$n(lightness.value, 0, 100);
      t3 = alpha == null ? null : K._percentageOrUnitless(alpha.assertNumber$1("alpha"), 1, "alpha");
      return K.SassColor$hsl(hue.value, t1, t2, t3);
    },
    _parseChannels: function($name, argumentNames, channels) {
      var isCommaSeparated, isBracketed, buffer, t1, list, maybeSlashSeparated, t2, t3,
        _s17_ = "$channels must be",
        _s32_ = "$channels must be an unbracketed";
      if (channels.get$isVar())
        return K._functionString($name, H.setRuntimeTypeInfo([channels], [F.Value]));
      isCommaSeparated = channels.get$separator() === C.ListSeparator_comma;
      isBracketed = channels.get$hasBrackets();
      if (isCommaSeparated || isBracketed) {
        buffer = new P.StringBuffer(_s17_);
        if (isBracketed) {
          buffer._contents = _s32_;
          t1 = _s32_;
        } else
          t1 = _s17_;
        if (isCommaSeparated) {
          t1 += isBracketed ? "," : " a";
          buffer._contents = t1;
          t1 = buffer._contents = t1 + " space-separated";
        }
        buffer._contents = t1 + " list.";
        throw H.wrapException(E.SassScriptException$(buffer.toString$0(0)));
      }
      list = channels.get$asList();
      t1 = list.length;
      if (t1 > 3)
        throw H.wrapException(E.SassScriptException$("Only 3 elements allowed, but " + t1 + " were passed."));
      else if (t1 < 3) {
        if (!C.JSArray_methods.any$1(list, new K._parseChannels_closure()))
          if (list.length !== 0) {
            t1 = C.JSArray_methods.get$last(list);
            if (t1 instanceof D.SassString)
              if (t1.hasQuotes) {
                t1 = t1.text;
                t1 = B.startsWithIgnoreCase(t1, "var(") && J.contains$1$asx(t1, "/");
              } else
                t1 = false;
            else
              t1 = false;
          } else
            t1 = false;
        else
          t1 = true;
        if (t1)
          return K._functionString($name, H.setRuntimeTypeInfo([channels], [F.Value]));
        else
          throw H.wrapException(E.SassScriptException$("Missing element " + argumentNames[list.length] + "."));
      }
      maybeSlashSeparated = list[2];
      t1 = J.getInterceptor$(maybeSlashSeparated);
      if (!!t1.$isSassNumber && maybeSlashSeparated.asSlash != null) {
        t1 = list[0];
        t2 = list[1];
        t3 = maybeSlashSeparated.asSlash;
        return H.setRuntimeTypeInfo([t1, t2, t3.item1, t3.item2], [F.Value]);
      } else if (!!t1.$isSassString && !maybeSlashSeparated.hasQuotes && J.contains$1$asx(maybeSlashSeparated.text, "/"))
        return K._functionString($name, H.setRuntimeTypeInfo([channels], [F.Value]));
      else
        return list;
    },
    _percentageOrUnitless: function(number, max, $name) {
      var value;
      if (!(number.numeratorUnits.length !== 0 || number.denominatorUnits.length !== 0))
        value = number.value;
      else if (number.hasUnit$1("%"))
        value = max * number.value / 100;
      else
        throw H.wrapException(E.SassScriptException$("$" + $name + ": Expected " + number.toString$0(0) + ' to have no units or "%".'));
      return J.clamp$2$n(value, 0, max);
    },
    _mixColors: function(color1, color2, weight) {
      var weightScale = weight.valueInRange$3(0, 100, "weight") / 100,
        normalizedWeight = weightScale * 2 - 1,
        t1 = color1.alpha,
        t2 = color2.alpha,
        alphaDistance = t1 - t2,
        t3 = normalizedWeight * alphaDistance,
        weight1 = ((t3 === -1 ? normalizedWeight : (normalizedWeight + alphaDistance) / (1 + t3)) + 1) / 2,
        weight2 = 1 - weight1;
      return K.SassColor$rgb(T.fuzzyRound(color1.get$red() * weight1 + color2.get$red() * weight2), T.fuzzyRound(color1.get$green() * weight1 + color2.get$green() * weight2), T.fuzzyRound(color1.get$blue() * weight1 + color2.get$blue() * weight2), t1 * weightScale + t2 * (1 - weightScale), null);
    },
    _opacify: function($arguments) {
      var t1 = J.getInterceptor$asx($arguments),
        color = t1.$index($arguments, 0).assertColor$1("color");
      return color.changeAlpha$1(C.JSNumber_methods.clamp$2(color.alpha + t1.$index($arguments, 1).assertNumber$1("amount").valueInRange$3(0, 1, "amount"), 0, 1));
    },
    _transparentize: function($arguments) {
      var t1 = J.getInterceptor$asx($arguments),
        color = t1.$index($arguments, 0).assertColor$1("color");
      return color.changeAlpha$1(C.JSNumber_methods.clamp$2(color.alpha - t1.$index($arguments, 1).assertNumber$1("amount").valueInRange$3(0, 1, "amount"), 0, 1));
    },
    closure81: function closure81() {
    },
    closure82: function closure82() {
    },
    closure83: function closure83() {
    },
    closure84: function closure84() {
    },
    closure85: function closure85() {
    },
    closure86: function closure86() {
    },
    closure87: function closure87() {
    },
    closure88: function closure88() {
    },
    closure89: function closure89() {
    },
    closure90: function closure90() {
    },
    closure91: function closure91() {
    },
    closure92: function closure92() {
    },
    closure93: function closure93() {
    },
    closure94: function closure94() {
    },
    closure95: function closure95() {
    },
    closure96: function closure96() {
    },
    closure97: function closure97() {
    },
    closure98: function closure98() {
    },
    closure99: function closure99() {
    },
    closure100: function closure100() {
    },
    closure101: function closure101() {
    },
    closure102: function closure102() {
    },
    closure103: function closure103() {
    },
    closure104: function closure104() {
    },
    closure105: function closure105() {
    },
    _closure17: function _closure17() {
    },
    closure106: function closure106() {
    },
    closure120: function closure120() {
    },
    closure121: function closure121() {
    },
    closure122: function closure122() {
    },
    closure123: function closure123() {
    },
    _closure18: function _closure18() {
    },
    closure124: function closure124() {
    },
    closure119: function closure119() {
    },
    closure118: function closure118() {
    },
    closure117: function closure117() {
    },
    closure116: function closure116() {
    },
    closure115: function closure115() {
    },
    closure114: function closure114() {
    },
    closure113: function closure113() {
    },
    closure112: function closure112() {
    },
    closure111: function closure111() {
    },
    closure109: function closure109() {
    },
    closure_getInRange0: function closure_getInRange0(t0) {
      this.keywords = t0;
    },
    _closure16: function _closure16() {
    },
    closure108: function closure108() {
    },
    closure_getScale: function closure_getScale(t0) {
      this.keywords = t0;
    },
    closure_scaleValue: function closure_scaleValue() {
    },
    _closure15: function _closure15() {
    },
    closure107: function closure107() {
    },
    closure_getInRange: function closure_getInRange(t0) {
      this.keywords = t0;
    },
    _closure14: function _closure14() {
    },
    closure110: function closure110() {
    },
    closure_hexString: function closure_hexString() {
    },
    _functionString_closure: function _functionString_closure() {
    },
    _removedColorFunction_closure: function _removedColorFunction_closure(t0, t1, t2) {
      this.name = t0;
      this.argument = t1;
      this.negative = t2;
    },
    _parseChannels_closure: function _parseChannels_closure() {
    },
    _numberFunction: function($name, transform) {
      return new Q.BuiltInCallable($name, H.setRuntimeTypeInfo([new S.Tuple2(B.ArgumentDeclaration_ArgumentDeclaration$parse("$number"), new K._numberFunction_closure(transform), [B.ArgumentDeclaration, {func: 1, ret: F.Value, args: [[P.List, F.Value]]}])], [[S.Tuple2, B.ArgumentDeclaration, {func: 1, ret: F.Value, args: [[P.List, F.Value]]}]]));
    },
    closure57: function closure57() {
    },
    closure64: function closure64() {
    },
    closure63: function closure63() {
    },
    closure62: function closure62() {
    },
    closure61: function closure61() {
    },
    closure60: function closure60() {
    },
    closure59: function closure59() {
    },
    closure58: function closure58() {
    },
    closure56: function closure56() {
    },
    closure55: function closure55() {
    },
    _numberFunction_closure: function _numberFunction_closure(t0) {
      this.transform = t0;
    },
    _NodeSassColor: function _NodeSassColor() {
    },
    closure24: function closure24() {
    },
    closure25: function closure25() {
    },
    closure26: function closure26() {
    },
    closure27: function closure27() {
    },
    closure28: function closure28() {
    },
    closure29: function closure29() {
    },
    closure30: function closure30() {
    },
    closure31: function closure31() {
    },
    closure32: function closure32() {
    },
    closure33: function closure33() {
    },
    LimitedMapView$blacklist: function(_map, blacklist, $K, $V) {
      var t2, t3, key,
        t1 = P.LinkedHashSet_LinkedHashSet($K);
      for (t2 = J.get$iterator$ax(_map.get$keys()), t3 = blacklist._base; t2.moveNext$0();) {
        key = t2.get$current(t2);
        if (!t3.contains$1(0, key))
          t1.add$1(0, key);
      }
      return new K.LimitedMapView(_map, t1, [$K, $V]);
    },
    LimitedMapView: function LimitedMapView(t0, t1, t2) {
      this._limited_map_view$_map = t0;
      this._limited_map_view$_keys = t1;
      this.$ti = t2;
    },
    SassColor$rgb: function(_red, _green, _blue, alpha, originalSpan) {
      var t1 = new K.SassColor(_red, _green, _blue, null, null, null, alpha == null ? 1 : T.fuzzyAssertRange(alpha, 0, 1, "alpha"), originalSpan);
      P.RangeError_checkValueInInterval(t1.get$red(), 0, 255, "red");
      P.RangeError_checkValueInInterval(t1.get$green(), 0, 255, "green");
      P.RangeError_checkValueInInterval(t1.get$blue(), 0, 255, "blue");
      return t1;
    },
    SassColor$hsl: function(hue, saturation, lightness, alpha) {
      var _null = null,
        t1 = C.JSNumber_methods.$mod(hue, 360),
        t2 = T.fuzzyAssertRange(saturation, 0, 100, "saturation"),
        t3 = T.fuzzyAssertRange(lightness, 0, 100, "lightness");
      return new K.SassColor(_null, _null, _null, t1, t2, t3, alpha == null ? 1 : T.fuzzyAssertRange(alpha, 0, 1, "alpha"), _null);
    },
    SassColor: function SassColor(t0, t1, t2, t3, t4, t5, t6, t7) {
      var _ = this;
      _._red = t0;
      _._green = t1;
      _._blue = t2;
      _._hue = t3;
      _._saturation = t4;
      _._lightness = t5;
      _.alpha = t6;
      _.originalSpan = t7;
    },
    UnicodeGlyphSet: function UnicodeGlyphSet() {
    }
  },
  R = {ModifiableCssComment: function ModifiableCssComment(t0, t1) {
      var _ = this;
      _.text = t0;
      _.span = t1;
      _._indexInParent = _._parent = null;
      _.isGroupEnd = false;
    },
    ImportCache$none: function(logger) {
      var t1 = logger == null ? C.StderrLogger_false : logger,
        t2 = P.Uri;
      return new R.ImportCache(C.List_empty10, t1, P.LinkedHashMap_LinkedHashMap$_empty(t2, [S.Tuple3, M.Importer, P.Uri, P.Uri]), P.LinkedHashMap_LinkedHashMap$_empty(t2, V.Stylesheet), P.LinkedHashMap_LinkedHashMap$_empty(t2, E.ImporterResult));
    },
    ImportCache__toImporters: function(importers, loadPaths, packageResolver) {
      var _i, t2, t3, path, _null = null,
        sassPath = H.stringTypeCast(J.get$env$x(self.process).SASS_PATH),
        t1 = H.setRuntimeTypeInfo([], [M.Importer]);
      for (_i = 0; false; ++_i)
        t1.push(importers[_i]);
      if (loadPaths != null)
        for (t2 = J.get$iterator$ax(loadPaths); t2.moveNext$0();) {
          t3 = t2.get$current(t2);
          t1.push(new F.FilesystemImporter($.$get$context().absolute$7(t3, _null, _null, _null, _null, _null, _null)));
        }
      if (sassPath != null) {
        t2 = sassPath.split(J.$eq$(J.get$platform$x(self.process), "win32") ? ";" : ":");
        t3 = t2.length;
        _i = 0;
        for (; _i < t3; ++_i) {
          path = t2[_i];
          t1.push(new F.FilesystemImporter($.$get$context().absolute$7(path, _null, _null, _null, _null, _null, _null)));
        }
      }
      return t1;
    },
    ImportCache: function ImportCache(t0, t1, t2, t3, t4) {
      var _ = this;
      _._importers = t0;
      _._import_cache$_logger = t1;
      _._canonicalizeCache = t2;
      _._import_cache$_importCache = t3;
      _._resultsCache = t4;
    },
    ImportCache_canonicalize_closure: function ImportCache_canonicalize_closure(t0, t1) {
      this.$this = t0;
      this.url = t1;
    },
    ImportCache_importCanonical_closure: function ImportCache_importCanonical_closure(t0, t1, t2, t3) {
      var _ = this;
      _.$this = t0;
      _.importer = t1;
      _.canonicalUrl = t2;
      _.originalUrl = t3;
    },
    ImportCache_humanize_closure: function ImportCache_humanize_closure(t0) {
      this.canonicalUrl = t0;
    },
    ImportCache_humanize_closure0: function ImportCache_humanize_closure0() {
    },
    ImportCache_humanize_closure1: function ImportCache_humanize_closure1() {
    },
    ForwardedModuleView$: function(_inner, _rule, $T) {
      var t5,
        t1 = _rule.prefix,
        t2 = _rule.shownVariables,
        t3 = _rule.hiddenVariables,
        t4 = R.ForwardedModuleView__forwardedMap(_inner.get$variables(), t1, t2, t3, F.Value);
      t2 = _inner.get$variableNodes() == null ? null : R.ForwardedModuleView__forwardedMap(_inner.get$variableNodes(), t1, t2, t3, B.AstNode);
      t3 = _rule.shownMixinsAndFunctions;
      t5 = _rule.hiddenMixinsAndFunctions;
      return new R.ForwardedModuleView(_inner, _rule, t4, t2, R.ForwardedModuleView__forwardedMap(_inner.get$functions(_inner), t1, t3, t5, $T), R.ForwardedModuleView__forwardedMap(_inner.get$mixins(), t1, t3, t5, $T), [$T]);
    },
    ForwardedModuleView__forwardedMap: function(map, prefix, whitelist, blacklist, $V) {
      var t2,
        t1 = prefix == null;
      if (t1)
        if (whitelist == null)
          if (blacklist != null) {
            t2 = blacklist._base;
            t2 = t2.get$isEmpty(t2);
          } else
            t2 = true;
        else
          t2 = false;
      else
        t2 = false;
      if (t2)
        return map;
      if (!t1)
        map = new F.PrefixedMapView(map, prefix, [$V]);
      if (whitelist != null)
        map = new K.LimitedMapView(map, whitelist._base.intersection$1(new M.MapKeySet(map, [P.Object])), [P.String, $V]);
      else {
        if (blacklist != null) {
          t1 = blacklist._base;
          t1 = t1.get$isNotEmpty(t1);
        } else
          t1 = false;
        if (t1)
          map = K.LimitedMapView$blacklist(map, blacklist, P.String, $V);
      }
      return map;
    },
    ForwardedModuleView: function ForwardedModuleView(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _._forwarded_view$_inner = t0;
      _._rule = t1;
      _.variables = t2;
      _.variableNodes = t3;
      _.functions = t4;
      _.mixins = t5;
      _.$ti = t6;
    },
    RenderOptions: function RenderOptions() {
    },
    _EvaluateVisitor$: function(functions, importCache, logger, nodeImporter, sourceMap) {
      var t7, t8,
        t1 = P.String,
        t2 = P.Uri,
        t3 = [G.Module, D.Callable],
        t4 = P.LinkedHashSet_LinkedHashSet(t1),
        t5 = P.LinkedHashSet_LinkedHashSet(t2),
        t6 = H.setRuntimeTypeInfo([], [[S.Tuple2, P.String, B.AstNode]]);
      if (nodeImporter == null)
        t7 = importCache == null ? R.ImportCache$none(logger) : importCache;
      else
        t7 = null;
      t8 = logger == null ? C.StderrLogger_false : logger;
      t6 = new R._EvaluateVisitor(t7, nodeImporter, P.LinkedHashMap_LinkedHashMap$_empty(t1, D.Callable), P.LinkedHashMap_LinkedHashMap$_empty(t2, t3), P.LinkedHashMap_LinkedHashMap$_empty(t2, t3), t8, sourceMap, t4, t5, t6);
      t6._EvaluateVisitor$5$functions$importCache$logger$nodeImporter$sourceMap(functions, importCache, logger, nodeImporter, sourceMap);
      return t6;
    },
    _ArgumentResults$: function(positional, named, separator, namedNodes, positionalNodes) {
      return new R._ArgumentResults(positional, positionalNodes, named, namedNodes, separator);
    },
    _EvaluateVisitor: function _EvaluateVisitor(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9) {
      var _ = this;
      _._importCache = t0;
      _._nodeImporter = t1;
      _._builtInFunctions = t2;
      _._builtInModules = t3;
      _._modules = t4;
      _._logger = t5;
      _._sourceMap = t6;
      _._declarationName = _._evaluate$_parent = _._mediaQueries = _._styleRule = _._evaluate$_environment = null;
      _._member = "root stylesheet";
      _._importSpan = _._callableNode = null;
      _._inKeyframes = _._atRootExcludingStyleRule = _._inUnknownAtRule = _._inFunction = false;
      _._includedFiles = t7;
      _._activeModules = t8;
      _._stack = t9;
      _._extender = _._outOfOrderImports = _._endOfImports = _._root = _._stylesheet = _._importer = null;
    },
    _EvaluateVisitor_closure: function _EvaluateVisitor_closure(t0) {
      this.$this = t0;
    },
    _EvaluateVisitor_closure0: function _EvaluateVisitor_closure0(t0) {
      this.$this = t0;
    },
    _EvaluateVisitor_closure1: function _EvaluateVisitor_closure1(t0) {
      this.$this = t0;
    },
    _EvaluateVisitor_closure2: function _EvaluateVisitor_closure2(t0) {
      this.$this = t0;
    },
    _EvaluateVisitor_closure3: function _EvaluateVisitor_closure3(t0) {
      this.$this = t0;
    },
    _EvaluateVisitor_closure4: function _EvaluateVisitor_closure4(t0) {
      this.$this = t0;
    },
    _EvaluateVisitor_closure5: function _EvaluateVisitor_closure5(t0) {
      this.$this = t0;
    },
    _EvaluateVisitor_closure6: function _EvaluateVisitor_closure6(t0) {
      this.$this = t0;
    },
    _EvaluateVisitor__closure1: function _EvaluateVisitor__closure1(t0, t1, t2) {
      this.$this = t0;
      this.name = t1;
      this.module = t2;
    },
    _EvaluateVisitor_closure7: function _EvaluateVisitor_closure7(t0) {
      this.$this = t0;
    },
    _EvaluateVisitor__closure: function _EvaluateVisitor__closure() {
    },
    _EvaluateVisitor__closure0: function _EvaluateVisitor__closure0() {
    },
    _EvaluateVisitor_run_closure: function _EvaluateVisitor_run_closure(t0, t1, t2) {
      this.$this = t0;
      this.node = t1;
      this.importer = t2;
    },
    _EvaluateVisitor_runExpression_closure: function _EvaluateVisitor_runExpression_closure(t0, t1, t2) {
      this.$this = t0;
      this.variables = t1;
      this.expression = t2;
    },
    _EvaluateVisitor__withWarnCallback_closure: function _EvaluateVisitor__withWarnCallback_closure(t0) {
      this.$this = t0;
    },
    _EvaluateVisitor__loadModule_closure: function _EvaluateVisitor__loadModule_closure(t0, t1, t2, t3) {
      var _ = this;
      _.$this = t0;
      _.url = t1;
      _.nodeForSpan = t2;
      _.callback = t3;
    },
    _EvaluateVisitor__loadModule__closure: function _EvaluateVisitor__loadModule__closure(t0, t1, t2) {
      this.$this = t0;
      this.url = t1;
      this.nodeForSpan = t2;
    },
    _EvaluateVisitor__execute_closure: function _EvaluateVisitor__execute_closure(t0, t1, t2) {
      this.$this = t0;
      this.importer = t1;
      this.stylesheet = t2;
    },
    _EvaluateVisitor__execute__closure: function _EvaluateVisitor__execute__closure(t0, t1, t2, t3, t4) {
      var _ = this;
      _._box_0 = t0;
      _.$this = t1;
      _.importer = t2;
      _.stylesheet = t3;
      _.extender = t4;
    },
    _EvaluateVisitor__combineCss_closure: function _EvaluateVisitor__combineCss_closure() {
    },
    _EvaluateVisitor__combineCss_closure0: function _EvaluateVisitor__combineCss_closure0(t0) {
      this.selectors = t0;
    },
    _EvaluateVisitor__combineCss_closure1: function _EvaluateVisitor__combineCss_closure1() {
    },
    _EvaluateVisitor__extendModules_closure: function _EvaluateVisitor__extendModules_closure(t0) {
      this.originalSelectors = t0;
    },
    _EvaluateVisitor__extendModules_closure0: function _EvaluateVisitor__extendModules_closure0() {
    },
    _EvaluateVisitor__topologicalModules_visitModule: function _EvaluateVisitor__topologicalModules_visitModule(t0, t1) {
      this.seen = t0;
      this.sorted = t1;
    },
    _EvaluateVisitor_visitAtRootRule_closure: function _EvaluateVisitor_visitAtRootRule_closure(t0, t1) {
      this.$this = t0;
      this.resolved = t1;
    },
    _EvaluateVisitor_visitAtRootRule_closure0: function _EvaluateVisitor_visitAtRootRule_closure0(t0, t1) {
      this.$this = t0;
      this.node = t1;
    },
    _EvaluateVisitor_visitAtRootRule_closure1: function _EvaluateVisitor_visitAtRootRule_closure1(t0, t1) {
      this.$this = t0;
      this.node = t1;
    },
    _EvaluateVisitor__scopeForAtRoot_closure: function _EvaluateVisitor__scopeForAtRoot_closure(t0, t1, t2) {
      this.$this = t0;
      this.newParent = t1;
      this.node = t2;
    },
    _EvaluateVisitor__scopeForAtRoot_closure0: function _EvaluateVisitor__scopeForAtRoot_closure0(t0, t1) {
      this.$this = t0;
      this.innerScope = t1;
    },
    _EvaluateVisitor__scopeForAtRoot_closure1: function _EvaluateVisitor__scopeForAtRoot_closure1(t0, t1) {
      this.$this = t0;
      this.innerScope = t1;
    },
    _EvaluateVisitor__scopeForAtRoot__closure: function _EvaluateVisitor__scopeForAtRoot__closure(t0, t1) {
      this.innerScope = t0;
      this.callback = t1;
    },
    _EvaluateVisitor__scopeForAtRoot_closure2: function _EvaluateVisitor__scopeForAtRoot_closure2(t0, t1) {
      this.$this = t0;
      this.innerScope = t1;
    },
    _EvaluateVisitor__scopeForAtRoot_closure3: function _EvaluateVisitor__scopeForAtRoot_closure3() {
    },
    _EvaluateVisitor__scopeForAtRoot_closure4: function _EvaluateVisitor__scopeForAtRoot_closure4(t0, t1) {
      this.$this = t0;
      this.innerScope = t1;
    },
    _EvaluateVisitor_visitContentRule_closure: function _EvaluateVisitor_visitContentRule_closure(t0, t1) {
      this.$this = t0;
      this.content = t1;
    },
    _EvaluateVisitor_visitDeclaration_closure: function _EvaluateVisitor_visitDeclaration_closure(t0, t1) {
      this.$this = t0;
      this.node = t1;
    },
    _EvaluateVisitor_visitEachRule_closure: function _EvaluateVisitor_visitEachRule_closure(t0, t1, t2) {
      this.$this = t0;
      this.node = t1;
      this.nodeForSpan = t2;
    },
    _EvaluateVisitor_visitEachRule_closure0: function _EvaluateVisitor_visitEachRule_closure0(t0, t1, t2) {
      this.$this = t0;
      this.node = t1;
      this.nodeForSpan = t2;
    },
    _EvaluateVisitor_visitEachRule_closure1: function _EvaluateVisitor_visitEachRule_closure1(t0, t1, t2, t3) {
      var _ = this;
      _.$this = t0;
      _.list = t1;
      _.setVariables = t2;
      _.node = t3;
    },
    _EvaluateVisitor_visitEachRule__closure: function _EvaluateVisitor_visitEachRule__closure(t0, t1, t2) {
      this.$this = t0;
      this.setVariables = t1;
      this.node = t2;
    },
    _EvaluateVisitor_visitEachRule___closure: function _EvaluateVisitor_visitEachRule___closure(t0) {
      this.$this = t0;
    },
    _EvaluateVisitor_visitExtendRule_closure: function _EvaluateVisitor_visitExtendRule_closure(t0, t1) {
      this.$this = t0;
      this.targetText = t1;
    },
    _EvaluateVisitor_visitAtRule_closure: function _EvaluateVisitor_visitAtRule_closure(t0, t1) {
      this.$this = t0;
      this.node = t1;
    },
    _EvaluateVisitor_visitAtRule__closure: function _EvaluateVisitor_visitAtRule__closure(t0, t1) {
      this.$this = t0;
      this.node = t1;
    },
    _EvaluateVisitor_visitAtRule_closure0: function _EvaluateVisitor_visitAtRule_closure0() {
    },
    _EvaluateVisitor_visitForRule_closure: function _EvaluateVisitor_visitForRule_closure(t0, t1) {
      this.$this = t0;
      this.node = t1;
    },
    _EvaluateVisitor_visitForRule_closure0: function _EvaluateVisitor_visitForRule_closure0(t0, t1) {
      this.$this = t0;
      this.node = t1;
    },
    _EvaluateVisitor_visitForRule_closure1: function _EvaluateVisitor_visitForRule_closure1(t0, t1) {
      this.fromNumber = t0;
      this.toNumber = t1;
    },
    _EvaluateVisitor_visitForRule_closure2: function _EvaluateVisitor_visitForRule_closure2(t0) {
      this.toNumber = t0;
    },
    _EvaluateVisitor_visitForRule_closure3: function _EvaluateVisitor_visitForRule_closure3(t0, t1, t2, t3, t4) {
      var _ = this;
      _._box_0 = t0;
      _.$this = t1;
      _.node = t2;
      _.from = t3;
      _.direction = t4;
    },
    _EvaluateVisitor_visitForRule__closure: function _EvaluateVisitor_visitForRule__closure(t0) {
      this.$this = t0;
    },
    _EvaluateVisitor_visitForwardRule_closure: function _EvaluateVisitor_visitForwardRule_closure(t0, t1) {
      this.$this = t0;
      this.node = t1;
    },
    _EvaluateVisitor_visitIfRule_closure: function _EvaluateVisitor_visitIfRule_closure(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    _EvaluateVisitor_visitIfRule__closure: function _EvaluateVisitor_visitIfRule__closure(t0) {
      this.$this = t0;
    },
    _EvaluateVisitor__visitDynamicImport_closure: function _EvaluateVisitor__visitDynamicImport_closure(t0, t1) {
      this.$this = t0;
      this.$import = t1;
    },
    _EvaluateVisitor__visitDynamicImport__closure: function _EvaluateVisitor__visitDynamicImport__closure(t0, t1, t2) {
      this.$this = t0;
      this.importer = t1;
      this.stylesheet = t2;
    },
    _EvaluateVisitor__visitDynamicImport__closure0: function _EvaluateVisitor__visitDynamicImport__closure0(t0, t1, t2, t3) {
      var _ = this;
      _._box_0 = t0;
      _.$this = t1;
      _.importer = t2;
      _.stylesheet = t3;
    },
    _EvaluateVisitor_visitIncludeRule_closure: function _EvaluateVisitor_visitIncludeRule_closure(t0, t1) {
      this.$this = t0;
      this.node = t1;
    },
    _EvaluateVisitor_visitIncludeRule_closure0: function _EvaluateVisitor_visitIncludeRule_closure0(t0, t1, t2) {
      this.$this = t0;
      this.contentCallable = t1;
      this.mixin = t2;
    },
    _EvaluateVisitor_visitIncludeRule__closure: function _EvaluateVisitor_visitIncludeRule__closure(t0, t1) {
      this.$this = t0;
      this.mixin = t1;
    },
    _EvaluateVisitor_visitIncludeRule___closure: function _EvaluateVisitor_visitIncludeRule___closure(t0, t1) {
      this.$this = t0;
      this.mixin = t1;
    },
    _EvaluateVisitor_visitMediaRule_closure: function _EvaluateVisitor_visitMediaRule_closure(t0, t1, t2, t3) {
      var _ = this;
      _.$this = t0;
      _.mergedQueries = t1;
      _.queries = t2;
      _.node = t3;
    },
    _EvaluateVisitor_visitMediaRule__closure: function _EvaluateVisitor_visitMediaRule__closure(t0, t1) {
      this.$this = t0;
      this.node = t1;
    },
    _EvaluateVisitor_visitMediaRule___closure: function _EvaluateVisitor_visitMediaRule___closure(t0, t1) {
      this.$this = t0;
      this.node = t1;
    },
    _EvaluateVisitor_visitMediaRule_closure0: function _EvaluateVisitor_visitMediaRule_closure0(t0) {
      this.mergedQueries = t0;
    },
    _EvaluateVisitor__visitMediaQueries_closure: function _EvaluateVisitor__visitMediaQueries_closure(t0, t1) {
      this.$this = t0;
      this.resolved = t1;
    },
    _EvaluateVisitor_visitStyleRule_closure: function _EvaluateVisitor_visitStyleRule_closure(t0, t1) {
      this.$this = t0;
      this.selectorText = t1;
    },
    _EvaluateVisitor_visitStyleRule_closure0: function _EvaluateVisitor_visitStyleRule_closure0(t0, t1) {
      this.$this = t0;
      this.node = t1;
    },
    _EvaluateVisitor_visitStyleRule_closure1: function _EvaluateVisitor_visitStyleRule_closure1() {
    },
    _EvaluateVisitor_visitStyleRule_closure2: function _EvaluateVisitor_visitStyleRule_closure2(t0, t1) {
      this.$this = t0;
      this.selectorText = t1;
    },
    _EvaluateVisitor_visitStyleRule_closure3: function _EvaluateVisitor_visitStyleRule_closure3(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    _EvaluateVisitor_visitStyleRule_closure4: function _EvaluateVisitor_visitStyleRule_closure4(t0, t1, t2) {
      this.$this = t0;
      this.rule = t1;
      this.node = t2;
    },
    _EvaluateVisitor_visitStyleRule__closure: function _EvaluateVisitor_visitStyleRule__closure(t0, t1) {
      this.$this = t0;
      this.node = t1;
    },
    _EvaluateVisitor_visitStyleRule_closure5: function _EvaluateVisitor_visitStyleRule_closure5() {
    },
    _EvaluateVisitor_visitSupportsRule_closure: function _EvaluateVisitor_visitSupportsRule_closure(t0, t1) {
      this.$this = t0;
      this.node = t1;
    },
    _EvaluateVisitor_visitSupportsRule__closure: function _EvaluateVisitor_visitSupportsRule__closure(t0, t1) {
      this.$this = t0;
      this.node = t1;
    },
    _EvaluateVisitor_visitSupportsRule_closure0: function _EvaluateVisitor_visitSupportsRule_closure0() {
    },
    _EvaluateVisitor_visitVariableDeclaration_closure: function _EvaluateVisitor_visitVariableDeclaration_closure(t0, t1) {
      this.$this = t0;
      this.node = t1;
    },
    _EvaluateVisitor_visitVariableDeclaration_closure0: function _EvaluateVisitor_visitVariableDeclaration_closure0(t0, t1, t2) {
      this.$this = t0;
      this.node = t1;
      this.value = t2;
    },
    _EvaluateVisitor_visitUseRule_closure: function _EvaluateVisitor_visitUseRule_closure(t0, t1) {
      this.$this = t0;
      this.node = t1;
    },
    _EvaluateVisitor_visitWarnRule_closure: function _EvaluateVisitor_visitWarnRule_closure(t0, t1) {
      this.$this = t0;
      this.node = t1;
    },
    _EvaluateVisitor_visitWhileRule_closure: function _EvaluateVisitor_visitWhileRule_closure(t0, t1) {
      this.$this = t0;
      this.node = t1;
    },
    _EvaluateVisitor_visitWhileRule__closure: function _EvaluateVisitor_visitWhileRule__closure(t0) {
      this.$this = t0;
    },
    _EvaluateVisitor_visitBinaryOperationExpression_closure: function _EvaluateVisitor_visitBinaryOperationExpression_closure(t0, t1) {
      this.$this = t0;
      this.node = t1;
    },
    _EvaluateVisitor_visitVariableExpression_closure: function _EvaluateVisitor_visitVariableExpression_closure(t0, t1) {
      this.$this = t0;
      this.node = t1;
    },
    _EvaluateVisitor_visitListExpression_closure: function _EvaluateVisitor_visitListExpression_closure(t0) {
      this.$this = t0;
    },
    _EvaluateVisitor_visitFunctionExpression_closure: function _EvaluateVisitor_visitFunctionExpression_closure(t0, t1, t2) {
      this.$this = t0;
      this.node = t1;
      this.plainName = t2;
    },
    _EvaluateVisitor__runUserDefinedCallable_closure: function _EvaluateVisitor__runUserDefinedCallable_closure(t0, t1, t2, t3, t4) {
      var _ = this;
      _.$this = t0;
      _.callable = t1;
      _.evaluated = t2;
      _.nodeWithSpan = t3;
      _.run = t4;
    },
    _EvaluateVisitor__runUserDefinedCallable__closure: function _EvaluateVisitor__runUserDefinedCallable__closure(t0, t1, t2, t3, t4) {
      var _ = this;
      _.$this = t0;
      _.evaluated = t1;
      _.callable = t2;
      _.nodeWithSpan = t3;
      _.run = t4;
    },
    _EvaluateVisitor__runUserDefinedCallable___closure: function _EvaluateVisitor__runUserDefinedCallable___closure(t0, t1, t2, t3, t4) {
      var _ = this;
      _.$this = t0;
      _.evaluated = t1;
      _.callable = t2;
      _.nodeWithSpan = t3;
      _.run = t4;
    },
    _EvaluateVisitor__runUserDefinedCallable____closure: function _EvaluateVisitor__runUserDefinedCallable____closure() {
    },
    _EvaluateVisitor__runFunctionCallable_closure: function _EvaluateVisitor__runFunctionCallable_closure(t0, t1) {
      this.$this = t0;
      this.callable = t1;
    },
    _EvaluateVisitor__runBuiltInCallable_closure: function _EvaluateVisitor__runBuiltInCallable_closure(t0, t1, t2) {
      this.overload = t0;
      this.evaluated = t1;
      this.namedSet = t2;
    },
    _EvaluateVisitor__runBuiltInCallable_closure0: function _EvaluateVisitor__runBuiltInCallable_closure0() {
    },
    _EvaluateVisitor__evaluateArguments_closure: function _EvaluateVisitor__evaluateArguments_closure(t0) {
      this.$this = t0;
    },
    _EvaluateVisitor__evaluateArguments_closure0: function _EvaluateVisitor__evaluateArguments_closure0(t0) {
      this.$this = t0;
    },
    _EvaluateVisitor__evaluateArguments_closure1: function _EvaluateVisitor__evaluateArguments_closure1() {
    },
    _EvaluateVisitor__evaluateArguments_closure2: function _EvaluateVisitor__evaluateArguments_closure2(t0) {
      this.restNodeForSpan = t0;
    },
    _EvaluateVisitor__evaluateArguments_closure3: function _EvaluateVisitor__evaluateArguments_closure3(t0, t1, t2) {
      this.named = t0;
      this.namedNodes = t1;
      this.restNodeForSpan = t2;
    },
    _EvaluateVisitor__evaluateArguments_closure4: function _EvaluateVisitor__evaluateArguments_closure4() {
    },
    _EvaluateVisitor__evaluateArguments_closure5: function _EvaluateVisitor__evaluateArguments_closure5(t0) {
      this.keywordRestNodeForSpan = t0;
    },
    _EvaluateVisitor__evaluateMacroArguments_closure: function _EvaluateVisitor__evaluateMacroArguments_closure() {
    },
    _EvaluateVisitor__evaluateMacroArguments_closure0: function _EvaluateVisitor__evaluateMacroArguments_closure0() {
    },
    _EvaluateVisitor__evaluateMacroArguments_closure1: function _EvaluateVisitor__evaluateMacroArguments_closure1(t0) {
      this.named = t0;
    },
    _EvaluateVisitor__evaluateMacroArguments_closure2: function _EvaluateVisitor__evaluateMacroArguments_closure2() {
    },
    _EvaluateVisitor__addRestMap_closure: function _EvaluateVisitor__addRestMap_closure(t0) {
      this.T = t0;
    },
    _EvaluateVisitor__addRestMap_closure0: function _EvaluateVisitor__addRestMap_closure0(t0, t1, t2, t3, t4) {
      var _ = this;
      _._box_0 = t0;
      _.$this = t1;
      _.values = t2;
      _.map = t3;
      _.nodeForSpan = t4;
    },
    _EvaluateVisitor__verifyArguments_closure: function _EvaluateVisitor__verifyArguments_closure(t0, t1, t2) {
      this.$arguments = t0;
      this.positional = t1;
      this.named = t2;
    },
    _EvaluateVisitor_visitStringExpression_closure: function _EvaluateVisitor_visitStringExpression_closure(t0) {
      this.$this = t0;
    },
    _EvaluateVisitor_visitCssAtRule_closure: function _EvaluateVisitor_visitCssAtRule_closure(t0, t1) {
      this.$this = t0;
      this.node = t1;
    },
    _EvaluateVisitor_visitCssAtRule_closure0: function _EvaluateVisitor_visitCssAtRule_closure0() {
    },
    _EvaluateVisitor_visitCssKeyframeBlock_closure: function _EvaluateVisitor_visitCssKeyframeBlock_closure(t0, t1) {
      this.$this = t0;
      this.node = t1;
    },
    _EvaluateVisitor_visitCssKeyframeBlock_closure0: function _EvaluateVisitor_visitCssKeyframeBlock_closure0() {
    },
    _EvaluateVisitor_visitCssMediaRule_closure: function _EvaluateVisitor_visitCssMediaRule_closure(t0, t1, t2) {
      this.$this = t0;
      this.mergedQueries = t1;
      this.node = t2;
    },
    _EvaluateVisitor_visitCssMediaRule__closure: function _EvaluateVisitor_visitCssMediaRule__closure(t0, t1) {
      this.$this = t0;
      this.node = t1;
    },
    _EvaluateVisitor_visitCssMediaRule___closure: function _EvaluateVisitor_visitCssMediaRule___closure(t0, t1) {
      this.$this = t0;
      this.node = t1;
    },
    _EvaluateVisitor_visitCssMediaRule_closure0: function _EvaluateVisitor_visitCssMediaRule_closure0(t0) {
      this.mergedQueries = t0;
    },
    _EvaluateVisitor_visitCssStyleRule_closure: function _EvaluateVisitor_visitCssStyleRule_closure(t0, t1, t2) {
      this.$this = t0;
      this.rule = t1;
      this.node = t2;
    },
    _EvaluateVisitor_visitCssStyleRule__closure: function _EvaluateVisitor_visitCssStyleRule__closure(t0, t1) {
      this.$this = t0;
      this.node = t1;
    },
    _EvaluateVisitor_visitCssStyleRule_closure0: function _EvaluateVisitor_visitCssStyleRule_closure0() {
    },
    _EvaluateVisitor_visitCssSupportsRule_closure: function _EvaluateVisitor_visitCssSupportsRule_closure(t0, t1) {
      this.$this = t0;
      this.node = t1;
    },
    _EvaluateVisitor_visitCssSupportsRule__closure: function _EvaluateVisitor_visitCssSupportsRule__closure(t0, t1) {
      this.$this = t0;
      this.node = t1;
    },
    _EvaluateVisitor_visitCssSupportsRule_closure0: function _EvaluateVisitor_visitCssSupportsRule_closure0() {
    },
    _EvaluateVisitor__performInterpolation_closure: function _EvaluateVisitor__performInterpolation_closure(t0, t1) {
      this.$this = t0;
      this.warnForColor = t1;
    },
    _EvaluateVisitor__serialize_closure: function _EvaluateVisitor__serialize_closure(t0, t1) {
      this.value = t0;
      this.quote = t1;
    },
    _EvaluateVisitor__stackTrace_closure: function _EvaluateVisitor__stackTrace_closure(t0) {
      this.$this = t0;
    },
    _ImportedCssVisitor: function _ImportedCssVisitor(t0) {
      this._visitor = t0;
    },
    _ImportedCssVisitor_visitCssAtRule_closure: function _ImportedCssVisitor_visitCssAtRule_closure() {
    },
    _ImportedCssVisitor_visitCssMediaRule_closure: function _ImportedCssVisitor_visitCssMediaRule_closure(t0) {
      this.hasBeenMerged = t0;
    },
    _ImportedCssVisitor_visitCssStyleRule_closure: function _ImportedCssVisitor_visitCssStyleRule_closure() {
    },
    _ImportedCssVisitor_visitCssSupportsRule_closure: function _ImportedCssVisitor_visitCssSupportsRule_closure() {
    },
    _ArgumentResults: function _ArgumentResults(t0, t1, t2, t3, t4) {
      var _ = this;
      _.positional = t0;
      _.positionalNodes = t1;
      _.named = t2;
      _.namedNodes = t3;
      _.separator = t4;
    }
  },
  T = {Expression: function Expression() {
    }, NumberExpression: function NumberExpression(t0, t1, t2) {
      this.value = t0;
      this.unit = t1;
      this.span = t2;
    }, ParenthesizedExpression: function ParenthesizedExpression(t0, t1) {
      this.expression = t0;
      this.span = t1;
    }, SelectorExpression: function SelectorExpression(t0) {
      this.span = t0;
    }, MixinRule: function MixinRule(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _.hasContent = t0;
      _.name = t1;
      _.$arguments = t2;
      _.span = t3;
      _.children = t4;
      _.hasDeclarations = t5;
    }, UseRule: function UseRule(t0, t1, t2) {
      this.url = t0;
      this.namespace = t1;
      this.span = t2;
    }, Selector: function Selector() {
    }, EmptyExtender: function EmptyExtender() {
    },
    _prependParent: function(compound) {
      var t3, _i,
        t1 = compound.components,
        first = C.JSArray_methods.get$first(t1),
        t2 = J.getInterceptor$(first);
      if (!!t2.$isUniversalSelector)
        return;
      if (!!t2.$isTypeSelector) {
        t2 = first.name;
        if (t2.namespace != null)
          return;
        t3 = H.setRuntimeTypeInfo([], [M.SimpleSelector]);
        t3.push(new M.ParentSelector(t2.name));
        for (t1 = H.SubListIterable$(t1, 1, null, H.getTypeArgumentByIndex(t1, 0)), t1 = new H.ListIterator(t1, t1.get$length(t1)); t1.moveNext$0();)
          t3.push(t1.__internal$_current);
        return X.CompoundSelector$(t3);
      } else {
        t2 = H.setRuntimeTypeInfo([], [M.SimpleSelector]);
        t2.push(new M.ParentSelector(null));
        for (t3 = t1.length, _i = 0; _i < t3; ++_i)
          t2.push(t1[_i]);
        return X.CompoundSelector$(t2);
      }
    },
    closure51: function closure51() {
    },
    _closure8: function _closure8() {
    },
    _closure9: function _closure9() {
    },
    closure50: function closure50() {
    },
    _closure6: function _closure6() {
    },
    _closure7: function _closure7() {
    },
    __closure: function __closure(t0) {
      this.parent = t0;
    },
    closure49: function closure49() {
    },
    closure48: function closure48() {
    },
    closure47: function closure47() {
    },
    closure54: function closure54() {
    },
    closure53: function closure53() {
    },
    _closure10: function _closure10() {
    },
    closure52: function closure52() {
    },
    TrackingLogger: function TrackingLogger(t0) {
      this._tracking$_logger = t0;
      this._emittedDebug = this._emittedWarning = false;
    },
    _parseNumber: function(value, unit) {
      var t1, t2, invalidUnit, operands, numerator, denominator, numeratorUnits, denominatorUnits;
      if (unit == null || unit.length === 0)
        return new T.SassNumber(value, C.List_empty0, C.List_empty0, null);
      if (!J.contains$1$asx(unit, "*") && !C.JSString_methods.contains$1(unit, "/")) {
        t1 = P.String;
        t2 = H.setRuntimeTypeInfo([unit], [t1]);
        t1 = P.List_List$unmodifiable(t2, t1);
        return new T.SassNumber(value, t1, C.List_empty0, null);
      }
      invalidUnit = new P.ArgumentError(true, unit, "unit", "is invalid.");
      operands = unit.split("/");
      t1 = operands.length;
      if (t1 > 2)
        throw H.wrapException(invalidUnit);
      numerator = operands[0];
      denominator = t1 === 1 ? null : operands[1];
      t1 = P.String;
      numeratorUnits = numerator.length === 0 ? H.setRuntimeTypeInfo([], [t1]) : H.setRuntimeTypeInfo(numerator.split("*"), [t1]);
      if (C.JSArray_methods.any$1(numeratorUnits, new T._parseNumber_closure()))
        throw H.wrapException(invalidUnit);
      denominatorUnits = denominator == null ? H.setRuntimeTypeInfo([], [t1]) : H.setRuntimeTypeInfo(denominator.split("*"), [t1]);
      if (C.JSArray_methods.any$1(denominatorUnits, new T._parseNumber_closure0()))
        throw H.wrapException(invalidUnit);
      return T.SassNumber$withUnits(value, denominatorUnits, numeratorUnits);
    },
    _NodeSassNumber: function _NodeSassNumber() {
    },
    closure3: function closure3() {
    },
    closure4: function closure4() {
    },
    closure5: function closure5() {
    },
    closure6: function closure6() {
    },
    closure7: function closure7() {
    },
    closure8: function closure8() {
    },
    _parseNumber_closure: function _parseNumber_closure() {
    },
    _parseNumber_closure0: function _parseNumber_closure0() {
    },
    SelectorParser: function SelectorParser(t0, t1, t2, t3) {
      var _ = this;
      _._allowParent = t0;
      _._allowPlaceholder = t1;
      _.scanner = t2;
      _.logger = t3;
    },
    SelectorParser_parse_closure: function SelectorParser_parse_closure(t0) {
      this.$this = t0;
    },
    SelectorParser_parseCompoundSelector_closure: function SelectorParser_parseCompoundSelector_closure(t0) {
      this.$this = t0;
    },
    SassNumber$withUnits: function(value, denominatorUnits, numeratorUnits) {
      var t1 = numeratorUnits == null ? C.List_empty0 : P.List_List$unmodifiable(numeratorUnits, P.String);
      return new T.SassNumber(value, t1, denominatorUnits == null ? C.List_empty0 : P.List_List$unmodifiable(denominatorUnits, P.String), null);
    },
    SassNumber: function SassNumber(t0, t1, t2, t3) {
      var _ = this;
      _.value = t0;
      _.numeratorUnits = t1;
      _.denominatorUnits = t2;
      _.asSlash = t3;
    },
    SassNumber_valueInUnits_closure: function SassNumber_valueInUnits_closure(t0, t1, t2) {
      this._box_0 = t0;
      this.$this = t1;
      this.newNumerator = t2;
    },
    SassNumber_valueInUnits_closure0: function SassNumber_valueInUnits_closure0(t0, t1, t2) {
      this.$this = t0;
      this.newNumerators = t1;
      this.newDenominators = t2;
    },
    SassNumber_valueInUnits_closure1: function SassNumber_valueInUnits_closure1(t0, t1, t2) {
      this._box_0 = t0;
      this.$this = t1;
      this.newDenominator = t2;
    },
    SassNumber_valueInUnits_closure2: function SassNumber_valueInUnits_closure2(t0, t1, t2) {
      this.$this = t0;
      this.newNumerators = t1;
      this.newDenominators = t2;
    },
    SassNumber_modulo_closure: function SassNumber_modulo_closure() {
    },
    SassNumber_plus_closure: function SassNumber_plus_closure() {
    },
    SassNumber_minus_closure: function SassNumber_minus_closure() {
    },
    SassNumber__multiplyUnits_closure: function SassNumber__multiplyUnits_closure(t0, t1, t2) {
      this._box_0 = t0;
      this.$this = t1;
      this.numerator = t2;
    },
    SassNumber__multiplyUnits_closure0: function SassNumber__multiplyUnits_closure0(t0, t1) {
      this.newNumerators = t0;
      this.numerator = t1;
    },
    SassNumber__multiplyUnits_closure1: function SassNumber__multiplyUnits_closure1(t0, t1, t2) {
      this._box_0 = t0;
      this.$this = t1;
      this.numerator = t2;
    },
    SassNumber__multiplyUnits_closure2: function SassNumber__multiplyUnits_closure2(t0, t1) {
      this.newNumerators = t0;
      this.numerator = t1;
    },
    SassNumber__areAnyConvertible_closure: function SassNumber__areAnyConvertible_closure(t0, t1) {
      this.$this = t0;
      this.units2 = t1;
    },
    SassNumber__canonicalMultiplier_closure: function SassNumber__canonicalMultiplier_closure() {
    },
    SingleMapping_SingleMapping$fromEntries: function(entries) {
      var lines, t1, t2, urls, t3, files, t4, t5, targetEntries, lineNum, _i, sourceEntry, sourceUrl, t6, urlId, _null = null,
        sourceEntries = P.List_List$from(entries, true, _null);
      C.JSArray_methods.sort$0(sourceEntries);
      lines = H.setRuntimeTypeInfo([], [T.TargetLineEntry]);
      t1 = P.String;
      t2 = P.int;
      urls = P.LinkedHashMap_LinkedHashMap$_empty(t1, t2);
      t3 = Y.SourceFile;
      files = P.LinkedHashMap_LinkedHashMap$_empty(t2, t3);
      for (t4 = sourceEntries.length, t5 = [T.TargetEntry], targetEntries = _null, lineNum = targetEntries, _i = 0; _i < sourceEntries.length; sourceEntries.length === t4 || (0, H.throwConcurrentModificationError)(sourceEntries), ++_i) {
        sourceEntry = sourceEntries[_i];
        if (lineNum == null || sourceEntry.get$target().get$line() > lineNum) {
          lineNum = sourceEntry.get$target().get$line();
          targetEntries = H.setRuntimeTypeInfo([], t5);
          lines.push(new T.TargetLineEntry(lineNum, targetEntries));
        }
        if (sourceEntry.get$source() == null)
          targetEntries.push(new T.TargetEntry(sourceEntry.get$target().get$column(), _null, _null, _null, _null));
        else {
          sourceUrl = sourceEntry.get$source().get$sourceUrl();
          t6 = sourceUrl == null ? "" : sourceUrl.toString$0(0);
          urlId = urls.putIfAbsent$2(t6, new T.SingleMapping_SingleMapping$fromEntries_closure(urls));
          if (sourceEntry.get$source() instanceof Y.FileLocation)
            files.putIfAbsent$2(urlId, new T.SingleMapping_SingleMapping$fromEntries_closure0(sourceEntry));
          sourceEntry.get$identifierName();
          targetEntries.push(new T.TargetEntry(sourceEntry.get$target().get$column(), urlId, sourceEntry.get$source().get$line(), sourceEntry.get$source().get$column(), _null));
        }
      }
      t4 = urls.get$values();
      t3 = H.MappedIterable_MappedIterable(t4, new T.SingleMapping_SingleMapping$fromEntries_closure1(files), H.getRuntimeTypeArgument(t4, "Iterable", 0), t3);
      t3 = P.List_List$from(t3, true, H.getRuntimeTypeArgument(t3, "Iterable", 0));
      t4 = urls.get$keys();
      t4 = P.List_List$from(t4, true, H.getRuntimeTypeArgument(t4, "Iterable", 0));
      t2 = P.LinkedHashMap_LinkedHashMap$_empty(t1, t2).get$keys();
      return new T.SingleMapping(t4, P.List_List$from(t2, true, H.getRuntimeTypeArgument(t2, "Iterable", 0)), t3, lines, _null, P.LinkedHashMap_LinkedHashMap$_empty(t1, _null));
    },
    Mapping: function Mapping() {
    },
    SingleMapping: function SingleMapping(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _.urls = t0;
      _.names = t1;
      _.files = t2;
      _.lines = t3;
      _.targetUrl = t4;
      _.sourceRoot = null;
      _.extensions = t5;
    },
    SingleMapping_SingleMapping$fromEntries_closure: function SingleMapping_SingleMapping$fromEntries_closure(t0) {
      this.urls = t0;
    },
    SingleMapping_SingleMapping$fromEntries_closure0: function SingleMapping_SingleMapping$fromEntries_closure0(t0) {
      this.sourceEntry = t0;
    },
    SingleMapping_SingleMapping$fromEntries_closure1: function SingleMapping_SingleMapping$fromEntries_closure1(t0) {
      this.files = t0;
    },
    SingleMapping_toJson_closure: function SingleMapping_toJson_closure() {
    },
    SingleMapping_toJson_closure0: function SingleMapping_toJson_closure0(t0) {
      this.result = t0;
    },
    TargetLineEntry: function TargetLineEntry(t0, t1) {
      this.line = t0;
      this.entries = t1;
    },
    TargetEntry: function TargetEntry(t0, t1, t2, t3, t4) {
      var _ = this;
      _.column = t0;
      _.sourceUrlId = t1;
      _.sourceLine = t2;
      _.sourceColumn = t3;
      _.sourceNameId = t4;
    },
    LazyTrace: function LazyTrace(t0) {
      this._thunk = t0;
      this._lazy_trace$_inner = null;
    },
    LazyTrace_terse_closure: function LazyTrace_terse_closure(t0) {
      this.$this = t0;
    },
    _collectToList: function(element, soFar, $T) {
      if (soFar == null)
        soFar = H.setRuntimeTypeInfo([], [$T]);
      J.add$1$ax(soFar, element);
      return soFar;
    },
    _debounceAggregate: function(duration, collect, $T, $R) {
      var t1 = {};
      t1.soFar = t1.timer = null;
      t1.shouldClose = false;
      return new L._StreamTransformer(new T._debounceAggregate_closure(t1, duration, collect), new T._debounceAggregate_closure0(t1), H.instantiate1(L.from_handlers__StreamTransformer__defaultHandleError$closure(), $R), [$T, $R]);
    },
    _debounceAggregate_closure: function _debounceAggregate_closure(t0, t1, t2) {
      this._box_0 = t0;
      this.duration = t1;
      this.collect = t2;
    },
    _debounceAggregate__closure: function _debounceAggregate__closure(t0, t1) {
      this._box_0 = t0;
      this.sink = t1;
    },
    _debounceAggregate_closure0: function _debounceAggregate_closure0(t0) {
      this._box_0 = t0;
    },
    isWhitespace: function(character) {
      return character === 32 || character === 9 || T.isNewline(character);
    },
    isNewline: function(character) {
      return character === 10 || character === 13 || character === 12;
    },
    isAlphabetic0: function(character) {
      var t1;
      if (!(character >= 97 && character <= 122))
        t1 = character >= 65 && character <= 90;
      else
        t1 = true;
      return t1;
    },
    isDigit: function(character) {
      return character != null && character >= 48 && character <= 57;
    },
    isHex: function(character) {
      if (character == null)
        return false;
      if (T.isDigit(character))
        return true;
      if (character >= 97 && character <= 102)
        return true;
      if (character >= 65 && character <= 70)
        return true;
      return false;
    },
    asHex: function(character) {
      if (character <= 57)
        return character - 48;
      if (character <= 70)
        return 10 + character - 65;
      return 10 + character - 97;
    },
    hexCharFor: function(number) {
      return number < 10 ? 48 + number : 87 + number;
    },
    opposite: function(character) {
      switch (character) {
        case 40:
          return 41;
        case 123:
          return 125;
        case 91:
          return 93;
        default:
          return;
      }
    },
    characterEqualsIgnoreCase: function(character1, character2) {
      var upperCase1;
      if (character1 === character2)
        return true;
      if ((character1 ^ character2) !== 32)
        return false;
      upperCase1 = character1 & 4294967263;
      return upperCase1 >= 65 && upperCase1 <= 90;
    },
    fuzzyEquals: function(number1, number2) {
      return Math.abs(number1 - number2) < $.$get$epsilon();
    },
    fuzzyLessThan: function(number1, number2) {
      return number1 < number2 && !(Math.abs(number1 - number2) < $.$get$epsilon());
    },
    fuzzyLessThanOrEquals: function(number1, number2) {
      return number1 < number2 || Math.abs(number1 - number2) < $.$get$epsilon();
    },
    fuzzyGreaterThan: function(number1, number2) {
      return number1 > number2 && !(Math.abs(number1 - number2) < $.$get$epsilon());
    },
    fuzzyGreaterThanOrEquals: function(number1, number2) {
      return number1 > number2 || Math.abs(number1 - number2) < $.$get$epsilon();
    },
    fuzzyIsInt: function(number) {
      if (typeof number === "number" && Math.floor(number) === number)
        return true;
      return Math.abs(C.JSNumber_methods.$mod(Math.abs(number - 0.5), 1) - 0.5) < $.$get$epsilon();
    },
    fuzzyRound: function(number) {
      var t1;
      if (number > 0) {
        t1 = C.JSNumber_methods.$mod(number, 1);
        return t1 < 0.5 && !(Math.abs(t1 - 0.5) < $.$get$epsilon()) ? C.JSNumber_methods.floor$0(number) : C.JSNumber_methods.ceil$0(number);
      } else {
        t1 = C.JSNumber_methods.$mod(number, 1);
        return t1 < 0.5 || Math.abs(t1 - 0.5) < $.$get$epsilon() ? C.JSNumber_methods.floor$0(number) : C.JSNumber_methods.ceil$0(number);
      }
    },
    fuzzyCheckRange: function(number, min, max) {
      var t1 = $.$get$epsilon();
      if (Math.abs(number - min) < t1)
        return min;
      if (Math.abs(number - max) < t1)
        return max;
      if (number > min && number < max)
        return number;
      return;
    },
    fuzzyAssertRange: function(number, min, max, $name) {
      var result = T.fuzzyCheckRange(number, min, max);
      if (result != null)
        return result;
      throw H.wrapException(P.RangeError$value(number, $name, "must be between " + min + " and " + max + "."));
    }
  },
  D = {ListExpression: function ListExpression(t0, t1, t2, t3) {
      var _ = this;
      _.contents = t0;
      _.separator = t1;
      _.hasBrackets = t2;
      _.span = t3;
    }, ListExpression_toString_closure: function ListExpression_toString_closure(t0) {
      this.$this = t0;
    }, StringExpression: function StringExpression(t0, t1) {
      this.text = t0;
      this.hasQuotes = t1;
    }, ErrorRule: function ErrorRule(t0, t1) {
      this.expression = t0;
      this.span = t1;
    },
    SelectorList$: function(components) {
      var t1 = P.List_List$unmodifiable(components, S.ComplexSelector);
      if (t1.length === 0)
        H.throwExpression(P.ArgumentError$("components may not be empty."));
      return new D.SelectorList(t1);
    },
    SelectorList_SelectorList$parse: function(contents, allowParent, allowPlaceholder, logger) {
      var t1 = S.SpanScanner$(contents, null);
      return new T.SelectorParser(allowParent, allowPlaceholder, t1, logger == null ? C.StderrLogger_false : logger).parse$0();
    },
    SelectorList: function SelectorList(t0) {
      this.components = t0;
    },
    SelectorList_isInvisible_closure: function SelectorList_isInvisible_closure() {
    },
    SelectorList_asSassList_closure: function SelectorList_asSassList_closure() {
    },
    SelectorList_asSassList__closure: function SelectorList_asSassList__closure() {
    },
    SelectorList_unify_closure: function SelectorList_unify_closure(t0) {
      this.other = t0;
    },
    SelectorList_unify__closure: function SelectorList_unify__closure(t0) {
      this.complex1 = t0;
    },
    SelectorList_unify___closure: function SelectorList_unify___closure() {
    },
    SelectorList_resolveParentSelectors_closure: function SelectorList_resolveParentSelectors_closure(t0, t1, t2) {
      this.$this = t0;
      this.implicitParent = t1;
      this.parent = t2;
    },
    SelectorList_resolveParentSelectors__closure: function SelectorList_resolveParentSelectors__closure(t0) {
      this.complex = t0;
    },
    SelectorList_resolveParentSelectors__closure0: function SelectorList_resolveParentSelectors__closure0(t0) {
      this._box_0 = t0;
    },
    SelectorList__complexContainsParentSelector_closure: function SelectorList__complexContainsParentSelector_closure() {
    },
    SelectorList__complexContainsParentSelector__closure: function SelectorList__complexContainsParentSelector__closure() {
    },
    SelectorList__resolveParentSelectorsCompound_closure: function SelectorList__resolveParentSelectorsCompound_closure() {
    },
    SelectorList__resolveParentSelectorsCompound_closure0: function SelectorList__resolveParentSelectorsCompound_closure0(t0) {
      this.parent = t0;
    },
    SelectorList__resolveParentSelectorsCompound_closure1: function SelectorList__resolveParentSelectorsCompound_closure1(t0, t1) {
      this.compound = t0;
      this.resolvedMembers = t1;
    },
    PseudoSelector$: function($name, argument, element, selector) {
      var t1 = !element,
        t2 = t1 && !D.PseudoSelector__isFakePseudoElement($name);
      return new D.PseudoSelector($name, B.unvendor($name), t2, t1, argument, selector);
    },
    PseudoSelector__isFakePseudoElement: function($name) {
      switch (C.JSString_methods._codeUnitAt$1($name, 0)) {
        case 97:
        case 65:
          return B.equalsIgnoreCase($name, "after");
        case 98:
        case 66:
          return B.equalsIgnoreCase($name, "before");
        case 102:
        case 70:
          return B.equalsIgnoreCase($name, "first-line") || B.equalsIgnoreCase($name, "first-letter");
        default:
          return false;
      }
    },
    PseudoSelector: function PseudoSelector(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _.name = t0;
      _.normalizedName = t1;
      _.isClass = t2;
      _.isSyntacticClass = t3;
      _.argument = t4;
      _.selector = t5;
      _._pseudo$_maxSpecificity = _._pseudo$_minSpecificity = null;
    },
    QualifiedName: function QualifiedName(t0, t1) {
      this.name = t0;
      this.namespace = t1;
    },
    Callable: function Callable() {
    },
    compileStylesheet: function(options, graph, source, destination, ifModified) {
      return D.compileStylesheet$body(options, graph, source, destination, ifModified);
    },
    compileStylesheet$body: function(options, graph, source, destination, ifModified) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$returnValue, $async$handler = 2, $async$currentError, $async$next = [], syntax, result, importCache, error, exception, t1, t2, t3, t4, t5, t6, t7, result0, css, buffer, sourceName, destinationName, importer, $async$exception;
      var $async$compileStylesheet = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$currentError = $async$result;
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              importer = new F.FilesystemImporter(D.absolute("."));
              if (ifModified)
                try {
                  if (source != null && destination != null && !graph.modifiedSince$3($.$get$context().toUri$1(source), B.modificationTime(destination), importer)) {
                    // goto return
                    $async$goto = 1;
                    break;
                  }
                } catch (exception) {
                  if (!(H.unwrapException(exception) instanceof B.FileSystemException))
                    throw exception;
                }
              syntax = null;
              if (H.boolTypeCast(options._ifParsed$1("indented")) === true)
                syntax = C.Syntax_Sass;
              else if (source != null)
                syntax = M.Syntax_forPath(source);
              else
                syntax = C.Syntax_SCSS;
              result = null;
              $async$handler = 4;
              t1 = options._options;
              $async$goto = H.boolTypeCast(t1.$index(0, "async")) ? 7 : 9;
              break;
            case 7:
              // then
              t2 = H.setRuntimeTypeInfo([], [B.AsyncImporter]);
              t3 = H.subtypeCast(t1.$index(0, "load-path"), "$isList", [P.String], "$asList");
              t4 = H.boolTypeCast(t1.$index(0, "quiet")) ? $.$get$Logger_quiet() : new S.StderrLogger(options.get$color());
              t3 = O.AsyncImportCache__toImporters(t2, t3, null);
              t2 = t4 == null ? C.StderrLogger_false : t4;
              t4 = P.Uri;
              importCache = new O.AsyncImportCache(t3, t2, P.LinkedHashMap_LinkedHashMap$_empty(t4, [S.Tuple3, B.AsyncImporter, P.Uri, P.Uri]), P.LinkedHashMap_LinkedHashMap$_empty(t4, V.Stylesheet), P.LinkedHashMap_LinkedHashMap$_empty(t4, E.ImporterResult));
              $async$goto = source == null ? 10 : 12;
              break;
            case 10:
              // then
              $async$goto = 13;
              return P._asyncAwait(B.readStdin(), $async$compileStylesheet);
            case 13:
              // returning from await.
              t2 = $async$result;
              t3 = syntax;
              t4 = H.boolTypeCast(t1.$index(0, "quiet")) ? $.$get$Logger_quiet() : new S.StderrLogger(options.get$color());
              t5 = D.absolute(".");
              t6 = J.$eq$(t1.$index(0, "style"), "compressed") ? C.OutputStyle_compressed : C.OutputStyle_expanded;
              t7 = options.get$emitSourceMap();
              $async$goto = 14;
              return P._asyncAwait(X.compileStringAsync(t2, H.boolTypeCast(t1.$index(0, "charset")), null, importCache, new F.FilesystemImporter(t5), null, null, t4, null, t7, t6, t3, null, true), $async$compileStylesheet);
            case 14:
              // returning from await.
              result0 = $async$result;
              // goto join
              $async$goto = 11;
              break;
            case 12:
              // else
              t2 = syntax;
              t3 = H.boolTypeCast(t1.$index(0, "quiet")) ? $.$get$Logger_quiet() : new S.StderrLogger(options.get$color());
              t4 = J.$eq$(t1.$index(0, "style"), "compressed") ? C.OutputStyle_compressed : C.OutputStyle_expanded;
              t5 = options.get$emitSourceMap();
              $async$goto = 15;
              return P._asyncAwait(X.compileAsync(source, H.boolTypeCast(t1.$index(0, "charset")), null, importCache, null, null, t3, null, t5, t4, t2, true), $async$compileStylesheet);
            case 15:
              // returning from await.
              result0 = $async$result;
            case 11:
              // join
              result = result0;
              // goto join
              $async$goto = 8;
              break;
            case 9:
              // else
              $async$goto = source == null ? 16 : 18;
              break;
            case 16:
              // then
              $async$goto = 19;
              return P._asyncAwait(B.readStdin(), $async$compileStylesheet);
            case 19:
              // returning from await.
              t2 = $async$result;
              t3 = syntax;
              t4 = H.boolTypeCast(t1.$index(0, "quiet")) ? $.$get$Logger_quiet() : new S.StderrLogger(options.get$color());
              t5 = D.absolute(".");
              t6 = J.$eq$(t1.$index(0, "style"), "compressed") ? C.OutputStyle_compressed : C.OutputStyle_expanded;
              t7 = options.get$emitSourceMap();
              result0 = U.compileString(t2, H.boolTypeCast(t1.$index(0, "charset")), null, graph.importCache, new F.FilesystemImporter(t5), null, null, t4, null, t7, t6, t3, null, true);
              // goto join
              $async$goto = 17;
              break;
            case 18:
              // else
              t2 = syntax;
              t3 = H.boolTypeCast(t1.$index(0, "quiet")) ? $.$get$Logger_quiet() : new S.StderrLogger(options.get$color());
              t4 = J.$eq$(t1.$index(0, "style"), "compressed") ? C.OutputStyle_compressed : C.OutputStyle_expanded;
              t5 = options.get$emitSourceMap();
              result0 = U.compile(source, H.boolTypeCast(t1.$index(0, "charset")), null, graph.importCache, null, null, t3, null, t5, t4, t2, true);
            case 17:
              // join
              result = result0;
            case 8:
              // join
              $async$handler = 2;
              // goto after finally
              $async$goto = 6;
              break;
            case 4:
              // catch
              $async$handler = 3;
              $async$exception = $async$currentError;
              t1 = H.unwrapException($async$exception);
              if (t1 instanceof E.SassException) {
                error = t1;
                if (options.get$emitErrorCss())
                  if (destination == null)
                    P.print(error.toCssString$0());
                  else {
                    B.ensureDir($.$get$context().dirname$1(destination));
                    B.writeFile(destination, error.toCssString$0() + "\n");
                  }
                throw $async$exception;
              } else
                throw $async$exception;
              // goto after finally
              $async$goto = 6;
              break;
            case 3:
              // uncaught
              // goto rethrow
              $async$goto = 2;
              break;
            case 6:
              // after finally
              css = result._serialize.css + D._writeSourceMap(options, result._serialize.sourceMap, destination);
              if (destination == null) {
                if (css.length !== 0)
                  P.print(css);
              } else {
                B.ensureDir($.$get$context().dirname$1(destination));
                B.writeFile(destination, css + "\n");
              }
              t1 = options._options;
              if (!H.boolTypeCast(t1.$index(0, "quiet")))
                t1 = !H.boolTypeCast(t1.$index(0, "update")) && !H.boolTypeCast(t1.$index(0, "watch"));
              else
                t1 = true;
              if (t1) {
                // goto return
                $async$goto = 1;
                break;
              }
              buffer = new P.StringBuffer("");
              t1 = options.get$color() ? buffer._contents = "\x1b[32m" : "";
              if (source == null)
                sourceName = "stdin";
              else {
                t2 = $.$get$context();
                sourceName = t2.prettyUri$1(t2.toUri$1(source));
              }
              t2 = $.$get$context();
              destinationName = t2.prettyUri$1(t2.toUri$1(destination));
              t1 += "Compiled " + H.S(sourceName) + " to " + H.S(destinationName) + ".";
              buffer._contents = t1;
              if (options.get$color())
                buffer._contents = t1 + "\x1b[0m";
              P.print(buffer);
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return P._asyncRethrow($async$currentError, $async$completer);
          }
      });
      return P._asyncStartSync($async$compileStylesheet, $async$completer);
    },
    _writeSourceMap: function(options, sourceMap, destination) {
      var t1, sourceMapText, url, sourceMapPath, t2;
      if (sourceMap == null)
        return "";
      if (destination != null) {
        t1 = $.$get$context();
        sourceMap.targetUrl = J.toString$0$(t1.toUri$1(X.ParsedPath_ParsedPath$parse(destination, t1.style).get$basename()));
      }
      B.mapInPlace(sourceMap.urls, new D._writeSourceMap_closure(options, destination));
      t1 = options._options;
      sourceMapText = C.C_JsonCodec.encode$2$toEncodable(sourceMap.toJson$1$includeSourceContents(H.boolTypeCast(t1.$index(0, "embed-sources"))), null);
      if (H.boolTypeCast(t1.$index(0, "embed-source-map")))
        url = P.Uri_Uri$dataFromString(sourceMapText, C.C_Utf8Codec, "application/json");
      else {
        sourceMapPath = J.$add$ansx(destination, ".map");
        t2 = $.$get$context();
        B.ensureDir(t2.dirname$1(sourceMapPath));
        B.writeFile(sourceMapPath, sourceMapText);
        url = t2.toUri$1(t2.relative$2$from(sourceMapPath, t2.dirname$1(destination)));
      }
      t1 = (J.$eq$(t1.$index(0, "style"), "compressed") ? C.OutputStyle_compressed : C.OutputStyle_expanded) === C.OutputStyle_compressed ? "" : "\n\n";
      return t1 + ("/*# sourceMappingURL=" + H.S(url) + " */");
    },
    _writeSourceMap_closure: function _writeSourceMap_closure(t0, t1) {
      this.options = t0;
      this.destination = t1;
    },
    closure80: function closure80() {
    },
    closure79: function closure79() {
    },
    closure78: function closure78() {
    },
    closure77: function closure77() {
    },
    closure76: function closure76() {
    },
    closure75: function closure75() {
    },
    _closure11: function _closure11() {
    },
    _closure12: function _closure12(t0) {
      this._box_0 = t0;
    },
    _closure13: function _closure13(t0) {
      this._box_0 = t0;
    },
    closure74: function closure74() {
    },
    closure72: function closure72() {
    },
    closure73: function closure73() {
    },
    _codepointForIndex: function(index, lengthInCodepoints, allowNegative) {
      var result;
      if (index === 0)
        return 0;
      if (index > 0)
        return Math.min(index - 1, H.checkNum(lengthInCodepoints));
      result = lengthInCodepoints + index;
      if (result < 0 && !allowNegative)
        return 0;
      return result;
    },
    closure46: function closure46() {
    },
    closure45: function closure45() {
    },
    closure41: function closure41() {
    },
    closure40: function closure40() {
    },
    closure39: function closure39() {
    },
    closure38: function closure38() {
    },
    closure44: function closure44() {
    },
    closure43: function closure43() {
    },
    closure42: function closure42() {
    },
    Exports: function Exports() {
    },
    _NodeSassList: function _NodeSassList() {
    },
    closure17: function closure17() {
    },
    _closure3: function _closure3() {
    },
    closure18: function closure18() {
    },
    closure19: function closure19() {
    },
    closure20: function closure20() {
    },
    closure21: function closure21() {
    },
    closure22: function closure22() {
    },
    closure23: function closure23() {
    },
    _NodeSassString: function _NodeSassString() {
    },
    closure: function closure() {
    },
    closure0: function closure0() {
    },
    closure1: function closure1() {
    },
    closure2: function closure2() {
    },
    SourceMapBuffer: function SourceMapBuffer(t0, t1, t2) {
      var _ = this;
      _._source_map_buffer$_buffer = t0;
      _._entries = t1;
      _._sourceFiles = t2;
      _._column = _._line = 0;
      _._inSpan = false;
    },
    SourceMapBuffer_sourceFiles_closure: function SourceMapBuffer_sourceFiles_closure() {
    },
    SourceMapBuffer__addEntry_closure: function SourceMapBuffer__addEntry_closure(t0) {
      this.source = t0;
    },
    SourceMapBuffer_buildSourceMap_closure: function SourceMapBuffer_buildSourceMap_closure(t0, t1) {
      this._box_0 = t0;
      this.prefixLength = t1;
    },
    SassArgumentList: function SassArgumentList(t0, t1, t2, t3) {
      var _ = this;
      _._keywords = t0;
      _._wereKeywordsAccessed = false;
      _._list$_contents = t1;
      _.separator = t2;
      _.hasBrackets = t3;
    },
    SassList$: function(contents, separator, brackets) {
      var t1 = new D.SassList(P.List_List$unmodifiable(contents, F.Value), separator, brackets);
      t1.SassList$3$brackets(contents, separator, brackets);
      return t1;
    },
    SassList: function SassList(t0, t1, t2) {
      this._list$_contents = t0;
      this.separator = t1;
      this.hasBrackets = t2;
    },
    SassList_isBlank_closure: function SassList_isBlank_closure() {
    },
    ListSeparator: function ListSeparator(t0) {
      this._list$_name = t0;
    },
    SassString$: function(text, quotes) {
      return new D.SassString(text, quotes);
    },
    SassString: function SassString(t0, t1) {
      this.text = t0;
      this.hasQuotes = t1;
      this._sassLength = null;
    },
    RecursiveStatementVisitor: function RecursiveStatementVisitor() {
    },
    SourceLocationMixin: function SourceLocationMixin() {
    },
    current: function() {
      var exception, t1, path, lastIndex, uri = null;
      try {
        uri = P.Uri_base();
      } catch (exception) {
        if (!!J.getInterceptor$(H.unwrapException(exception)).$isException) {
          t1 = $._current;
          if (t1 != null)
            return t1;
          throw exception;
        } else
          throw exception;
      }
      if (J.$eq$(uri, $._currentUriBase))
        return $._current;
      $._currentUriBase = uri;
      if ($.$get$Style_platform() == $.$get$Style_url())
        return $._current = uri.resolve$1(".").toString$0(0);
      else {
        path = uri.toFilePath$0();
        lastIndex = path.length - 1;
        return $._current = lastIndex === 0 ? path : C.JSString_methods.substring$2(path, 0, lastIndex);
      }
    },
    absolute: function(part1) {
      var _null = null;
      return $.$get$context().absolute$7(part1, _null, _null, _null, _null, _null, _null);
    },
    dirname: function(path) {
      return $.$get$context().dirname$1(path);
    },
    join: function(part1, part2, part3) {
      var _null = null;
      return $.$get$context().join$8(0, part1, part2, part3, _null, _null, _null, _null, _null);
    },
    prettyUri: function(uri) {
      return $.$get$context().prettyUri$1(uri);
    }
  },
  A = {MapExpression: function MapExpression(t0, t1) {
      this.pairs = t0;
      this.span = t1;
    }, MapExpression_toString_closure: function MapExpression_toString_closure() {
    }, IncludeRule: function IncludeRule(t0, t1, t2, t3, t4) {
      var _ = this;
      _.namespace = t0;
      _.name = t1;
      _.$arguments = t2;
      _.content = t3;
      _.span = t4;
    },
    watch: function(options, graph) {
      return A.watch$body(options, graph);
    },
    watch$body: function(options, graph) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$returnValue, t4, t5, t6, t7, dirWatcher, watcher, destination, t1, t2, t3;
      var $async$watch = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = P.String;
              t2 = [t1];
              t3 = H.setRuntimeTypeInfo([], t2);
              for (options._ensureSources$0(), t4 = options._sourceDirectoriesToDestinations.get$keys(), t4 = t4.get$iterator(t4); t4.moveNext$0();)
                t3.push(t4.get$current(t4));
              for (options._ensureSources$0(), t4 = options._sourcesToDestinations.get$keys(), t4 = H.MappedIterable_MappedIterable(t4, D.path__dirname$closure(), H.getRuntimeTypeArgument(t4, "Iterable", 0), t1), t4 = new H.MappedIterator(J.get$iterator$ax(t4.__internal$_iterable), t4._f); t4.moveNext$0();)
                t3.push(t4.__internal$_current);
              for (t4 = options._options, t2 = J.get$iterator$ax(H.subtypeCast(t4.$index(0, "load-path"), "$isList", t2, "$asList")); t2.moveNext$0();)
                t3.push(t2.get$current(t2));
              t2 = H.boolTypeCast(t4.$index(0, "poll"));
              t5 = [P.Stream, E.WatchEvent];
              t6 = E.WatchEvent;
              t7 = new L.StreamGroup(C._StreamGroupState_dormant, new H.JsLinkedHashMap([t5, [P.StreamSubscription, E.WatchEvent]]), [t6]);
              t7._controller = P.StreamController_StreamController(t7.get$_onCancel(), t7.get$_onListen(), t7.get$_onPause(), t7.get$_onResume(), true, t6);
              dirWatcher = new U.MultiDirWatcher(P.LinkedHashMap_LinkedHashMap$_empty(t1, t5), t7, t2);
              $async$goto = 3;
              return P._asyncAwait(P.Future_wait(new H.MappedListIterable(t3, new A.watch_closure(dirWatcher), [H.getTypeArgumentByIndex(t3, 0), [P.Future, -1]]), -1), $async$watch);
            case 3:
              // returning from await.
              watcher = new A._Watcher(options, graph);
              options._ensureSources$0(), t1 = options._sourcesToDestinations.get$keys(), t1 = t1.get$iterator(t1);
            case 4:
              // for condition
              if (!t1.moveNext$0()) {
                // goto after for
                $async$goto = 5;
                break;
              }
              t2 = t1.get$current(t1);
              options._ensureSources$0();
              destination = options._sourcesToDestinations.$index(0, t2);
              t3 = $.$get$context();
              graph.addCanonical$3(new F.FilesystemImporter(t3.absolute$7(".", null, null, null, null, null, null)), t3.toUri$1(t3.canonicalize$1(t2)), t3.toUri$1(t2));
              $async$goto = 6;
              return P._asyncAwait(watcher.compile$3$ifModified(t2, destination, true), $async$watch);
            case 6:
              // returning from await.
              if (!$async$result && H.boolTypeCast(t4.$index(0, "stop-on-error"))) {
                dirWatcher._group._controller._subscribe$4(null, null, null, false).cancel$0();
                // goto return
                $async$goto = 1;
                break;
              }
              // goto for condition
              $async$goto = 4;
              break;
            case 5:
              // after for
              P.print("Sass is watching for changes. Press Ctrl-C to stop.\n");
              $async$goto = 7;
              return P._asyncAwait(watcher.watch$1(0, dirWatcher), $async$watch);
            case 7:
              // returning from await.
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$watch, $async$completer);
    },
    watch_closure: function watch_closure(t0) {
      this.dirWatcher = t0;
    },
    _Watcher: function _Watcher(t0, t1) {
      this._watch$_options = t0;
      this._graph = t1;
    },
    _Watcher__debounceEvents_closure: function _Watcher__debounceEvents_closure() {
    },
    _Watcher__debounceEvents__closure: function _Watcher__debounceEvents__closure(t0) {
      this.typeForPath = t0;
    },
    MergedExtension_merge: function(left, right) {
      var t2, t3, t4,
        t1 = left.extender;
      if (!J.$eq$(t1, right.extender) || !J.$eq$(left.target, right.target))
        throw H.wrapException(P.ArgumentError$(left.toString$0(0) + " and " + right.toString$0(0) + " aren't the same extension."));
      t2 = left.mediaContext;
      t3 = t2 == null;
      if (!t3) {
        t4 = right.mediaContext;
        t4 = t4 != null && !C.C_ListEquality.equals$2(t2, t4);
      } else
        t4 = false;
      if (t4)
        throw H.wrapException(E.SassException$("From " + left.span.message$1(0, "") + "\nYou may not @extend the same selector from within different media queries.", right.span));
      if (right.isOptional && right.mediaContext == null)
        return left;
      if (left.isOptional && t3)
        return right;
      if (t3)
        t2 = right.mediaContext;
      t3 = left.specificity;
      if (t3 == null)
        t3 = t1.get$maxSpecificity();
      return new A.MergedExtension(left, right, t1, left.target, t3, true, false, t2, left.extenderSpan, left.span);
    },
    MergedExtension: function MergedExtension(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9) {
      var _ = this;
      _.left = t0;
      _.right = t1;
      _.extender = t2;
      _.target = t3;
      _.specificity = t4;
      _.isOptional = t5;
      _.isOriginal = t6;
      _.mediaContext = t7;
      _.extenderSpan = t8;
      _.span = t9;
    },
    closure71: function closure71() {
    },
    closure70: function closure70() {
    },
    closure68: function closure68() {
    },
    closure69: function closure69() {
    },
    closure67: function closure67() {
    },
    closure66: function closure66() {
    },
    closure65: function closure65() {
    },
    _NodeSassMap: function _NodeSassMap() {
    },
    closure10: function closure10() {
    },
    _closure1: function _closure1() {
    },
    _closure2: function _closure2() {
    },
    closure11: function closure11() {
    },
    closure12: function closure12() {
    },
    closure13: function closure13() {
    },
    closure14: function closure14() {
    },
    closure15: function closure15() {
    },
    closure16: function closure16() {
    },
    SassMap: function SassMap(t0) {
      this.contents = t0;
    },
    SassMap_asList_closure: function SassMap_asList_closure(t0) {
      this.result = t0;
    },
    Frame_Frame$parseVM: function(frame) {
      return A.Frame__catchFormatException(frame, new A.Frame_Frame$parseVM_closure(frame));
    },
    Frame_Frame$parseV8: function(frame) {
      return A.Frame__catchFormatException(frame, new A.Frame_Frame$parseV8_closure(frame));
    },
    Frame_Frame$parseFirefox: function(frame) {
      return A.Frame__catchFormatException(frame, new A.Frame_Frame$parseFirefox_closure(frame));
    },
    Frame_Frame$parseFriendly: function(frame) {
      return A.Frame__catchFormatException(frame, new A.Frame_Frame$parseFriendly_closure(frame));
    },
    Frame__uriOrPathToUri: function(uriOrPath) {
      if (J.getInterceptor$asx(uriOrPath).contains$1(uriOrPath, $.$get$Frame__uriRegExp()))
        return P.Uri_parse(uriOrPath);
      else if (C.JSString_methods.contains$1(uriOrPath, $.$get$Frame__windowsRegExp()))
        return P._Uri__Uri$file(uriOrPath, true);
      else if (C.JSString_methods.startsWith$1(uriOrPath, "/"))
        return P._Uri__Uri$file(uriOrPath, false);
      if (C.JSString_methods.contains$1(uriOrPath, "\\"))
        return $.$get$windows().toUri$1(uriOrPath);
      return P.Uri_parse(uriOrPath);
    },
    Frame__catchFormatException: function(text, body) {
      var t1, exception;
      try {
        t1 = body.call$0();
        return t1;
      } catch (exception) {
        if (!!J.getInterceptor$(H.unwrapException(exception)).$isFormatException)
          return new N.UnparsedFrame(P._Uri__Uri(null, "unparsed", null, null), text);
        else
          throw exception;
      }
    },
    Frame: function Frame(t0, t1, t2, t3) {
      var _ = this;
      _.uri = t0;
      _.line = t1;
      _.column = t2;
      _.member = t3;
    },
    Frame_Frame$parseVM_closure: function Frame_Frame$parseVM_closure(t0) {
      this.frame = t0;
    },
    Frame_Frame$parseV8_closure: function Frame_Frame$parseV8_closure(t0) {
      this.frame = t0;
    },
    Frame_Frame$parseV8_closure_parseLocation: function Frame_Frame$parseV8_closure_parseLocation(t0) {
      this.frame = t0;
    },
    Frame_Frame$parseFirefox_closure: function Frame_Frame$parseFirefox_closure(t0) {
      this.frame = t0;
    },
    Frame_Frame$parseFriendly_closure: function Frame_Frame$parseFriendly_closure(t0) {
      this.frame = t0;
    },
    AsciiGlyphSet: function AsciiGlyphSet() {
    }
  },
  S = {VariableExpression: function VariableExpression(t0, t1, t2) {
      this.namespace = t0;
      this.name = t1;
      this.span = t2;
    },
    ComplexSelector$: function(components, lineBreak) {
      var t1 = P.List_List$unmodifiable(components, S.ComplexSelectorComponent);
      if (t1.length === 0)
        H.throwExpression(P.ArgumentError$("components may not be empty."));
      return new S.ComplexSelector(t1, lineBreak);
    },
    ComplexSelector: function ComplexSelector(t0, t1) {
      var _ = this;
      _.components = t0;
      _.lineBreak = t1;
      _._complex$_isInvisible = _._maxSpecificity = _._minSpecificity = null;
    },
    ComplexSelector_isInvisible_closure: function ComplexSelector_isInvisible_closure() {
    },
    ComplexSelectorComponent: function ComplexSelectorComponent() {
    },
    Combinator: function Combinator(t0) {
      this._complex$_text = t0;
    },
    AsyncBuiltInCallable$parsed: function($name, $arguments, callback) {
      var t1 = H.setRuntimeTypeInfo([], [[S.Tuple2, B.ArgumentDeclaration, {func: 1, ret: {futureOr: 1, type: F.Value}, args: [[P.List, F.Value]]}]]);
      t1.push(new S.Tuple2($arguments, callback, [B.ArgumentDeclaration, {func: 1, ret: {futureOr: 1, type: F.Value}, args: [[P.List, F.Value]]}]));
      return new S.AsyncBuiltInCallable($name, t1);
    },
    AsyncBuiltInCallable: function AsyncBuiltInCallable(t0, t1) {
      this.name = t0;
      this._async_built_in$_overloads = t1;
    },
    AsyncBuiltInCallable_callbackFor_closure: function AsyncBuiltInCallable_callbackFor_closure(t0, t1) {
      this.positional = t0;
      this.names = t1;
    },
    AsyncBuiltInCallable_callbackFor_closure0: function AsyncBuiltInCallable_callbackFor_closure0(t0) {
      this.$this = t0;
    },
    Extension$oneOff: function(extender, isOriginal, specificity) {
      var _null = null;
      return new S.Extension(extender, _null, specificity == null ? extender.get$maxSpecificity() : specificity, true, isOriginal, _null, _null, _null);
    },
    Extension: function Extension(t0, t1, t2, t3, t4, t5, t6, t7) {
      var _ = this;
      _.extender = t0;
      _.target = t1;
      _.specificity = t2;
      _.isOptional = t3;
      _.isOriginal = t4;
      _.mediaContext = t5;
      _.extenderSpan = t6;
      _.span = t7;
    },
    StderrLogger: function StderrLogger(t0) {
      this.color = t0;
    },
    SpanScanner$: function(string, sourceUrl) {
      var t1, t2, t3, t4;
      string.toString;
      t1 = new H.CodeUnits(string);
      t2 = H.setRuntimeTypeInfo([0], [P.int]);
      t3 = typeof sourceUrl === "string";
      t4 = t3 ? P.Uri_parse(sourceUrl) : sourceUrl;
      t2 = new Y.SourceFile(t4, t2, new Uint32Array(H._ensureNativeList(t1.toList$0(t1))));
      t2.SourceFile$decoded$2$url(t1, sourceUrl);
      t1 = t3 ? P.Uri_parse(sourceUrl) : H.interceptedTypeCast(sourceUrl, "$isUri");
      return new S.SpanScanner(t2, t1, string);
    },
    SpanScanner: function SpanScanner(t0, t1, t2) {
      var _ = this;
      _._sourceFile = t0;
      _.sourceUrl = t1;
      _.string = t2;
      _._string_scanner$_position = 0;
      _._lastMatchPosition = _._lastMatch = null;
    },
    _SpanScannerState: function _SpanScannerState(t0, t1) {
      this._scanner = t0;
      this.position = t1;
    },
    Tuple2: function Tuple2(t0, t1, t2) {
      this.item1 = t0;
      this.item2 = t1;
      this.$ti = t2;
    },
    Tuple3: function Tuple3(t0, t1, t2, t3) {
      var _ = this;
      _.item1 = t0;
      _.item2 = t1;
      _.item3 = t2;
      _.$ti = t3;
    }
  };
  var holders = [C, H, J, P, N, Z, V, G, E, F, Y, L, Q, B, O, U, M, X, K, R, T, D, A, S];
  hunkHelpers.setFunctionNamesIfNecessary(holders);
  var $ = {};
  H.JS_CONST.prototype = {};
  J.Interceptor.prototype = {
    $eq: function(receiver, other) {
      return receiver === other;
    },
    get$hashCode: function(receiver) {
      return H.Primitives_objectHashCode(receiver);
    },
    toString$0: function(receiver) {
      return "Instance of '" + H.Primitives_objectTypeName(receiver) + "'";
    },
    noSuchMethod$1: function(receiver, invocation) {
      throw H.wrapException(P.NoSuchMethodError$(receiver, invocation.get$memberName(), invocation.get$positionalArguments(), invocation.get$namedArguments()));
    }
  };
  J.JSBool.prototype = {
    toString$0: function(receiver) {
      return String(receiver);
    },
    get$hashCode: function(receiver) {
      return receiver ? 519018 : 218159;
    },
    $isbool: 1
  };
  J.JSNull.prototype = {
    $eq: function(receiver, other) {
      return null == other;
    },
    toString$0: function(receiver) {
      return "null";
    },
    get$hashCode: function(receiver) {
      return 0;
    },
    noSuchMethod$1: function(receiver, invocation) {
      return this.super$Interceptor$noSuchMethod(receiver, invocation);
    },
    $isNull: 1
  };
  J.JavaScriptObject.prototype = {
    get$hashCode: function(receiver) {
      return 0;
    },
    toString$0: function(receiver) {
      return String(receiver);
    },
    $is_SystemError: 1,
    $isJSError: 1,
    $isFunction: 1,
    $isJSFunction: 1,
    $isNodeImporterResult: 1,
    $isRenderOptions: 1,
    $isRenderResult: 1,
    $is_NodeSassColor: 1,
    $is_NodeSassList: 1,
    $is_NodeSassMap: 1,
    $is_NodeSassNumber: 1,
    $is_NodeSassString: 1,
    get$isTTY: function(obj) {
      return obj.isTTY;
    },
    get$write: function(obj) {
      return obj.write;
    },
    write$1: function(receiver, p0) {
      return receiver.write(p0);
    },
    createInterface$1: function(receiver, p0) {
      return receiver.createInterface(p0);
    },
    on$2: function(receiver, p0, p1) {
      return receiver.on(p0, p1);
    },
    get$close: function(obj) {
      return obj.close;
    },
    close$0: function(receiver) {
      return receiver.close();
    },
    setPrompt$1: function(receiver, p0) {
      return receiver.setPrompt(p0);
    },
    readFileSync$2: function(receiver, p0, p1) {
      return receiver.readFileSync(p0, p1);
    },
    writeFileSync$2: function(receiver, p0, p1) {
      return receiver.writeFileSync(p0, p1);
    },
    mkdirSync$1: function(receiver, p0) {
      return receiver.mkdirSync(p0);
    },
    statSync$1: function(receiver, p0) {
      return receiver.statSync(p0);
    },
    unlinkSync$1: function(receiver, p0) {
      return receiver.unlinkSync(p0);
    },
    readdirSync$1: function(receiver, p0) {
      return receiver.readdirSync(p0);
    },
    isFile$0: function(receiver) {
      return receiver.isFile();
    },
    isDirectory$0: function(receiver) {
      return receiver.isDirectory();
    },
    get$mtime: function(obj) {
      return obj.mtime;
    },
    getTime$0: function(receiver) {
      return receiver.getTime();
    },
    get$message: function(obj) {
      return obj.message;
    },
    message$1: function(receiver, p0) {
      return receiver.message(p0);
    },
    get$code: function(obj) {
      return obj.code;
    },
    get$syscall: function(obj) {
      return obj.syscall;
    },
    get$path: function(obj) {
      return obj.path;
    },
    get$platform: function(obj) {
      return obj.platform;
    },
    get$env: function(obj) {
      return obj.env;
    },
    watch$2: function(receiver, p0, p1) {
      return receiver.watch(p0, p1);
    },
    set$run_: function(obj, v) {
      return obj.run_ = v;
    },
    set$render: function(obj, v) {
      return obj.render = v;
    },
    set$renderSync: function(obj, v) {
      return obj.renderSync = v;
    },
    set$info: function(obj, v) {
      return obj.info = v;
    },
    set$types: function(obj, v) {
      return obj.types = v;
    },
    call$1: function(receiver, p0) {
      return receiver.call(p0);
    },
    call$1$1: function(receiver, p0) {
      return receiver.call(p0);
    },
    get$current: function(obj) {
      return obj.current;
    },
    yield$0: function(receiver) {
      return receiver.yield();
    },
    run$1: function(receiver, p0) {
      return receiver.run(p0);
    },
    run$0: function(receiver) {
      return receiver.run();
    },
    call$2: function(receiver, p0, p1) {
      return receiver.call(p0, p1);
    },
    call$0: function(receiver) {
      return receiver.call();
    },
    call$3: function(receiver, p0, p1, p2) {
      return receiver.call(p0, p1, p2);
    },
    call$1$3: function(receiver, p0, p1, p2) {
      return receiver.call(p0, p1, p2);
    },
    call$2$2: function(receiver, p0, p1) {
      return receiver.call(p0, p1);
    },
    call$1$0: function(receiver) {
      return receiver.call();
    },
    apply$2: function(receiver, p0, p1) {
      return receiver.apply(p0, p1);
    },
    get$file: function(obj) {
      return obj.file;
    },
    get$contents: function(obj) {
      return obj.contents;
    },
    get$options: function(obj) {
      return obj.options;
    },
    get$data: function(obj) {
      return obj.data;
    },
    get$includePaths: function(obj) {
      return obj.includePaths;
    },
    get$indentType: function(obj) {
      return obj.indentType;
    },
    get$indentWidth: function(obj) {
      return obj.indentWidth;
    },
    get$linefeed: function(obj) {
      return obj.linefeed;
    },
    set$context: function(obj, v) {
      return obj.context = v;
    },
    get$importer: function(obj) {
      return obj.importer;
    },
    get$functions: function(obj) {
      return obj.functions;
    },
    get$indentedSyntax: function(obj) {
      return obj.indentedSyntax;
    },
    get$omitSourceMapUrl: function(obj) {
      return obj.omitSourceMapUrl;
    },
    get$outFile: function(obj) {
      return obj.outFile;
    },
    get$outputStyle: function(obj) {
      return obj.outputStyle;
    },
    get$fiber: function(obj) {
      return obj.fiber;
    },
    get$sourceMap: function(obj) {
      return obj.sourceMap;
    },
    get$sourceMapContents: function(obj) {
      return obj.sourceMapContents;
    },
    get$sourceMapEmbed: function(obj) {
      return obj.sourceMapEmbed;
    },
    get$sourceMapRoot: function(obj) {
      return obj.sourceMapRoot;
    },
    map$1$1: function(receiver, p0) {
      return receiver.map(p0);
    },
    map$1: function(receiver, p0) {
      return receiver.map(p0);
    },
    get$start: function(obj) {
      return obj.start;
    },
    get$end: function(obj) {
      return obj.end;
    },
    get$dartValue: function(obj) {
      return obj.dartValue;
    },
    set$dartValue: function(obj, v) {
      return obj.dartValue = v;
    }
  };
  J.PlainJavaScriptObject.prototype = {};
  J.UnknownJavaScriptObject.prototype = {};
  J.JavaScriptFunction.prototype = {
    toString$0: function(receiver) {
      var dartClosure = receiver[$.$get$DART_CLOSURE_PROPERTY_NAME()];
      if (dartClosure == null)
        return this.super$JavaScriptObject$toString(receiver);
      return "JavaScript function for " + H.S(J.toString$0$(dartClosure));
    },
    $signature: function() {
      return {func: 1, opt: [,,,,,,,,,,,,,,,,]};
    },
    $isFunction: 1
  };
  J.JSArray.prototype = {
    cast$1$0: function(receiver, $R) {
      return new H.CastList(receiver, [H.getTypeArgumentByIndex(receiver, 0), $R]);
    },
    add$1: function(receiver, value) {
      if (!!receiver.fixed$length)
        H.throwExpression(P.UnsupportedError$("add"));
      receiver.push(value);
    },
    removeAt$1: function(receiver, index) {
      var t1;
      if (!!receiver.fixed$length)
        H.throwExpression(P.UnsupportedError$("removeAt"));
      t1 = receiver.length;
      if (index >= t1)
        throw H.wrapException(P.RangeError$value(index, null, null));
      return receiver.splice(index, 1)[0];
    },
    insert$2: function(receiver, index, value) {
      var t1;
      if (!!receiver.fixed$length)
        H.throwExpression(P.UnsupportedError$("insert"));
      t1 = receiver.length;
      if (index > t1)
        throw H.wrapException(P.RangeError$value(index, null, null));
      receiver.splice(index, 0, value);
    },
    insertAll$2: function(receiver, index, iterable) {
      var t1, insertionLength, end;
      if (!!receiver.fixed$length)
        H.throwExpression(P.UnsupportedError$("insertAll"));
      P.RangeError_checkValueInInterval(index, 0, receiver.length, "index");
      t1 = J.getInterceptor$(iterable);
      if (!t1.$isEfficientLengthIterable)
        iterable = t1.toList$0(iterable);
      insertionLength = J.get$length$asx(iterable);
      this.set$length(receiver, receiver.length + insertionLength);
      end = index + insertionLength;
      this.setRange$4(receiver, end, receiver.length, receiver, index);
      this.setRange$3(receiver, index, end, iterable);
    },
    setAll$2: function(receiver, index, iterable) {
      var t1, index0;
      if (!!receiver.immutable$list)
        H.throwExpression(P.UnsupportedError$("setAll"));
      P.RangeError_checkValueInInterval(index, 0, receiver.length, "index");
      for (t1 = J.get$iterator$ax(iterable); t1.moveNext$0(); index = index0) {
        index0 = index + 1;
        this.$indexSet(receiver, index, t1.get$current(t1));
      }
    },
    removeLast$0: function(receiver) {
      if (!!receiver.fixed$length)
        H.throwExpression(P.UnsupportedError$("removeLast"));
      if (receiver.length === 0)
        throw H.wrapException(H.diagnoseIndexError(receiver, -1));
      return receiver.pop();
    },
    remove$1: function(receiver, element) {
      var i;
      if (!!receiver.fixed$length)
        H.throwExpression(P.UnsupportedError$("remove"));
      for (i = 0; i < receiver.length; ++i)
        if (J.$eq$(receiver[i], element)) {
          receiver.splice(i, 1);
          return true;
        }
      return false;
    },
    _removeWhere$2: function(receiver, test, removeMatching) {
      var i, element, t1, retained = [],
        end = receiver.length;
      for (i = 0; i < end; ++i) {
        element = receiver[i];
        if (!test.call$1(element))
          retained.push(element);
        if (receiver.length !== end)
          throw H.wrapException(P.ConcurrentModificationError$(receiver));
      }
      t1 = retained.length;
      if (t1 === end)
        return;
      this.set$length(receiver, t1);
      for (i = 0; i < retained.length; ++i)
        receiver[i] = retained[i];
    },
    where$1: function(receiver, f) {
      return new H.WhereIterable(receiver, f, [H.getTypeArgumentByIndex(receiver, 0)]);
    },
    expand$1$1: function(receiver, f, $T) {
      return new H.ExpandIterable(receiver, f, [H.getTypeArgumentByIndex(receiver, 0), $T]);
    },
    addAll$1: function(receiver, collection) {
      var t1;
      if (!!receiver.fixed$length)
        H.throwExpression(P.UnsupportedError$("addAll"));
      for (t1 = J.get$iterator$ax(collection); t1.moveNext$0();)
        receiver.push(t1.get$current(t1));
    },
    forEach$1: function(receiver, f) {
      var i,
        end = receiver.length;
      for (i = 0; i < end; ++i) {
        f.call$1(receiver[i]);
        if (receiver.length !== end)
          throw H.wrapException(P.ConcurrentModificationError$(receiver));
      }
    },
    map$1$1: function(receiver, f, $T) {
      return new H.MappedListIterable(receiver, f, [H.getTypeArgumentByIndex(receiver, 0), $T]);
    },
    map$1: function($receiver, f) {
      return this.map$1$1($receiver, f, null);
    },
    join$1: function(receiver, separator) {
      var i,
        list = new Array(receiver.length);
      list.fixed$length = Array;
      for (i = 0; i < receiver.length; ++i)
        list[i] = H.S(receiver[i]);
      return list.join(separator);
    },
    join$0: function($receiver) {
      return this.join$1($receiver, "");
    },
    take$1: function(receiver, n) {
      return H.SubListIterable$(receiver, 0, n, H.getTypeArgumentByIndex(receiver, 0));
    },
    skip$1: function(receiver, n) {
      return H.SubListIterable$(receiver, n, null, H.getTypeArgumentByIndex(receiver, 0));
    },
    fold$1$2: function(receiver, initialValue, combine) {
      var value, i,
        $length = receiver.length;
      for (value = initialValue, i = 0; i < $length; ++i) {
        value = combine.call$2(value, receiver[i]);
        if (receiver.length !== $length)
          throw H.wrapException(P.ConcurrentModificationError$(receiver));
      }
      return value;
    },
    fold$2: function($receiver, initialValue, combine) {
      return this.fold$1$2($receiver, initialValue, combine, null);
    },
    lastWhere$2$orElse: function(receiver, test, orElse) {
      var i, element,
        $length = receiver.length;
      for (i = $length - 1; i >= 0; --i) {
        element = receiver[i];
        if (test.call$1(element))
          return element;
        if ($length !== receiver.length)
          throw H.wrapException(P.ConcurrentModificationError$(receiver));
      }
      if (orElse != null)
        return orElse.call$0();
      throw H.wrapException(H.IterableElementError_noElement());
    },
    elementAt$1: function(receiver, index) {
      return receiver[index];
    },
    sublist$2: function(receiver, start, end) {
      if (start < 0 || start > receiver.length)
        throw H.wrapException(P.RangeError$range(start, 0, receiver.length, "start", null));
      if (end == null)
        end = receiver.length;
      else if (end < start || end > receiver.length)
        throw H.wrapException(P.RangeError$range(end, start, receiver.length, "end", null));
      if (start === end)
        return H.setRuntimeTypeInfo([], [H.getTypeArgumentByIndex(receiver, 0)]);
      return H.setRuntimeTypeInfo(receiver.slice(start, end), [H.getTypeArgumentByIndex(receiver, 0)]);
    },
    sublist$1: function($receiver, start) {
      return this.sublist$2($receiver, start, null);
    },
    getRange$2: function(receiver, start, end) {
      P.RangeError_checkValidRange(start, end, receiver.length);
      return H.SubListIterable$(receiver, start, end, H.getTypeArgumentByIndex(receiver, 0));
    },
    get$first: function(receiver) {
      if (receiver.length > 0)
        return receiver[0];
      throw H.wrapException(H.IterableElementError_noElement());
    },
    get$last: function(receiver) {
      var t1 = receiver.length;
      if (t1 > 0)
        return receiver[t1 - 1];
      throw H.wrapException(H.IterableElementError_noElement());
    },
    get$single: function(receiver) {
      var t1 = receiver.length;
      if (t1 === 1)
        return receiver[0];
      if (t1 === 0)
        throw H.wrapException(H.IterableElementError_noElement());
      throw H.wrapException(H.IterableElementError_tooMany());
    },
    removeRange$2: function(receiver, start, end) {
      if (!!receiver.fixed$length)
        H.throwExpression(P.UnsupportedError$("removeRange"));
      P.RangeError_checkValidRange(start, end, receiver.length);
      receiver.splice(start, end - start);
    },
    setRange$4: function(receiver, start, end, iterable, skipCount) {
      var $length, t1, otherStart, otherList, i;
      if (!!receiver.immutable$list)
        H.throwExpression(P.UnsupportedError$("setRange"));
      P.RangeError_checkValidRange(start, end, receiver.length);
      $length = end - start;
      if ($length === 0)
        return;
      P.RangeError_checkNotNegative(skipCount, "skipCount");
      t1 = J.getInterceptor$(iterable);
      if (!!t1.$isList) {
        otherStart = skipCount;
        otherList = iterable;
      } else {
        otherList = t1.skip$1(iterable, skipCount).toList$1$growable(0, false);
        otherStart = 0;
      }
      t1 = J.getInterceptor$asx(otherList);
      if (otherStart + $length > t1.get$length(otherList))
        throw H.wrapException(H.IterableElementError_tooFew());
      if (otherStart < start)
        for (i = $length - 1; i >= 0; --i)
          receiver[start + i] = t1.$index(otherList, otherStart + i);
      else
        for (i = 0; i < $length; ++i)
          receiver[start + i] = t1.$index(otherList, otherStart + i);
    },
    setRange$3: function($receiver, start, end, iterable) {
      return this.setRange$4($receiver, start, end, iterable, 0);
    },
    fillRange$3: function(receiver, start, end, fillValue) {
      var i;
      if (!!receiver.immutable$list)
        H.throwExpression(P.UnsupportedError$("fill range"));
      P.RangeError_checkValidRange(start, end, receiver.length);
      for (i = start; i < end; ++i)
        receiver[i] = fillValue;
    },
    any$1: function(receiver, test) {
      var i,
        end = receiver.length;
      for (i = 0; i < end; ++i) {
        if (test.call$1(receiver[i]))
          return true;
        if (receiver.length !== end)
          throw H.wrapException(P.ConcurrentModificationError$(receiver));
      }
      return false;
    },
    every$1: function(receiver, test) {
      var i,
        end = receiver.length;
      for (i = 0; i < end; ++i) {
        if (!test.call$1(receiver[i]))
          return false;
        if (receiver.length !== end)
          throw H.wrapException(P.ConcurrentModificationError$(receiver));
      }
      return true;
    },
    get$reversed: function(receiver) {
      return new H.ReversedListIterable(receiver, [H.getTypeArgumentByIndex(receiver, 0)]);
    },
    sort$1: function(receiver, compare) {
      if (!!receiver.immutable$list)
        H.throwExpression(P.UnsupportedError$("sort"));
      H.Sort_sort(receiver, compare == null ? J._interceptors_JSArray__compareAny$closure() : compare);
    },
    sort$0: function($receiver) {
      return this.sort$1($receiver, null);
    },
    indexOf$1: function(receiver, element) {
      var i;
      if (0 >= receiver.length)
        return -1;
      for (i = 0; i < receiver.length; ++i)
        if (J.$eq$(receiver[i], element))
          return i;
      return -1;
    },
    contains$1: function(receiver, other) {
      var i;
      for (i = 0; i < receiver.length; ++i)
        if (J.$eq$(receiver[i], other))
          return true;
      return false;
    },
    get$isEmpty: function(receiver) {
      return receiver.length === 0;
    },
    get$isNotEmpty: function(receiver) {
      return receiver.length !== 0;
    },
    toString$0: function(receiver) {
      return P.IterableBase_iterableToFullString(receiver, "[", "]");
    },
    toList$1$growable: function(receiver, growable) {
      var t1 = H.setRuntimeTypeInfo(receiver.slice(0), [H.getTypeArgumentByIndex(receiver, 0)]);
      return t1;
    },
    toList$0: function($receiver) {
      return this.toList$1$growable($receiver, true);
    },
    toSet$0: function(receiver) {
      return P.LinkedHashSet_LinkedHashSet$from(receiver, H.getTypeArgumentByIndex(receiver, 0));
    },
    get$iterator: function(receiver) {
      return new J.ArrayIterator(receiver, receiver.length);
    },
    get$hashCode: function(receiver) {
      return H.Primitives_objectHashCode(receiver);
    },
    get$length: function(receiver) {
      return receiver.length;
    },
    set$length: function(receiver, newLength) {
      if (!!receiver.fixed$length)
        H.throwExpression(P.UnsupportedError$("set length"));
      if (newLength < 0)
        throw H.wrapException(P.RangeError$range(newLength, 0, null, "newLength", null));
      receiver.length = newLength;
    },
    $index: function(receiver, index) {
      if (typeof index !== "number" || Math.floor(index) !== index)
        throw H.wrapException(H.diagnoseIndexError(receiver, index));
      if (index >= receiver.length || index < 0)
        throw H.wrapException(H.diagnoseIndexError(receiver, index));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      if (!!receiver.immutable$list)
        H.throwExpression(P.UnsupportedError$("indexed set"));
      if (typeof index !== "number" || Math.floor(index) !== index)
        throw H.wrapException(H.diagnoseIndexError(receiver, index));
      if (index >= receiver.length || index < 0)
        throw H.wrapException(H.diagnoseIndexError(receiver, index));
      receiver[index] = value;
    },
    $add: function(receiver, other) {
      var totalLength = receiver.length + other.length,
        t1 = H.setRuntimeTypeInfo([], [H.getTypeArgumentByIndex(receiver, 0)]);
      this.set$length(t1, totalLength);
      this.setRange$3(t1, 0, receiver.length, receiver);
      this.setRange$3(t1, receiver.length, totalLength, other);
      return t1;
    },
    $isEfficientLengthIterable: 1,
    $isIterable: 1,
    $isList: 1
  };
  J.JSUnmodifiableArray.prototype = {};
  J.ArrayIterator.prototype = {
    get$current: function(_) {
      return this._current;
    },
    moveNext$0: function() {
      var t2, _this = this,
        t1 = _this._iterable,
        $length = t1.length;
      if (_this._length !== $length)
        throw H.wrapException(H.throwConcurrentModificationError(t1));
      t2 = _this._index;
      if (t2 >= $length) {
        _this._current = null;
        return false;
      }
      _this._current = t1[t2];
      _this._index = t2 + 1;
      return true;
    }
  };
  J.JSNumber.prototype = {
    compareTo$1: function(receiver, b) {
      var bIsNegative;
      if (typeof b !== "number")
        throw H.wrapException(H.argumentErrorValue(b));
      if (receiver < b)
        return -1;
      else if (receiver > b)
        return 1;
      else if (receiver === b) {
        if (receiver === 0) {
          bIsNegative = this.get$isNegative(b);
          if (this.get$isNegative(receiver) === bIsNegative)
            return 0;
          if (this.get$isNegative(receiver))
            return -1;
          return 1;
        }
        return 0;
      } else if (isNaN(receiver)) {
        if (isNaN(b))
          return 0;
        return 1;
      } else
        return -1;
    },
    get$isNegative: function(receiver) {
      return receiver === 0 ? 1 / receiver < 0 : receiver < 0;
    },
    ceil$0: function(receiver) {
      var truncated, d;
      if (receiver >= 0) {
        if (receiver <= 2147483647) {
          truncated = receiver | 0;
          return receiver === truncated ? truncated : truncated + 1;
        }
      } else if (receiver >= -2147483648)
        return receiver | 0;
      d = Math.ceil(receiver);
      if (isFinite(d))
        return d;
      throw H.wrapException(P.UnsupportedError$("" + receiver + ".ceil()"));
    },
    floor$0: function(receiver) {
      var truncated, d;
      if (receiver >= 0) {
        if (receiver <= 2147483647)
          return receiver | 0;
      } else if (receiver >= -2147483648) {
        truncated = receiver | 0;
        return receiver === truncated ? truncated : truncated - 1;
      }
      d = Math.floor(receiver);
      if (isFinite(d))
        return d;
      throw H.wrapException(P.UnsupportedError$("" + receiver + ".floor()"));
    },
    round$0: function(receiver) {
      if (receiver > 0) {
        if (receiver !== 1 / 0)
          return Math.round(receiver);
      } else if (receiver > -1 / 0)
        return 0 - Math.round(0 - receiver);
      throw H.wrapException(P.UnsupportedError$("" + receiver + ".round()"));
    },
    clamp$2: function(receiver, lowerLimit, upperLimit) {
      if (C.JSInt_methods.compareTo$1(lowerLimit, upperLimit) > 0)
        throw H.wrapException(H.argumentErrorValue(lowerLimit));
      if (this.compareTo$1(receiver, lowerLimit) < 0)
        return lowerLimit;
      if (this.compareTo$1(receiver, upperLimit) > 0)
        return upperLimit;
      return receiver;
    },
    toRadixString$1: function(receiver, radix) {
      var result, match, exponent, t1;
      if (radix < 2 || radix > 36)
        throw H.wrapException(P.RangeError$range(radix, 2, 36, "radix", null));
      result = receiver.toString(radix);
      if (C.JSString_methods.codeUnitAt$1(result, result.length - 1) !== 41)
        return result;
      match = /^([\da-z]+)(?:\.([\da-z]+))?\(e\+(\d+)\)$/.exec(result);
      if (match == null)
        H.throwExpression(P.UnsupportedError$("Unexpected toString result: " + result));
      result = match[1];
      exponent = +match[3];
      t1 = match[2];
      if (t1 != null) {
        result += t1;
        exponent -= t1.length;
      }
      return result + C.JSString_methods.$mul("0", exponent);
    },
    toString$0: function(receiver) {
      if (receiver === 0 && 1 / receiver < 0)
        return "-0.0";
      else
        return "" + receiver;
    },
    get$hashCode: function(receiver) {
      var absolute, floorLog2, factor, scaled,
        intValue = receiver | 0;
      if (receiver === intValue)
        return 536870911 & intValue;
      absolute = Math.abs(receiver);
      floorLog2 = Math.log(absolute) / 0.6931471805599453 | 0;
      factor = Math.pow(2, floorLog2);
      scaled = absolute < 1 ? absolute / factor : factor / absolute;
      return 536870911 & ((scaled * 9007199254740992 | 0) + (scaled * 3542243181176521 | 0)) * 599197 + floorLog2 * 1259;
    },
    $add: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(H.argumentErrorValue(other));
      return receiver + other;
    },
    $mod: function(receiver, other) {
      var result = receiver % other;
      if (result === 0)
        return 0;
      if (result > 0)
        return result;
      if (other < 0)
        return result - other;
      else
        return result + other;
    },
    $tdiv: function(receiver, other) {
      if ((receiver | 0) === receiver)
        if (other >= 1 || other < -1)
          return receiver / other | 0;
      return this._tdivSlow$1(receiver, other);
    },
    _tdivFast$1: function(receiver, other) {
      return (receiver | 0) === receiver ? receiver / other | 0 : this._tdivSlow$1(receiver, other);
    },
    _tdivSlow$1: function(receiver, other) {
      var quotient = receiver / other;
      if (quotient >= -2147483648 && quotient <= 2147483647)
        return quotient | 0;
      if (quotient > 0) {
        if (quotient !== 1 / 0)
          return Math.floor(quotient);
      } else if (quotient > -1 / 0)
        return Math.ceil(quotient);
      throw H.wrapException(P.UnsupportedError$("Result of truncating division is " + H.S(quotient) + ": " + H.S(receiver) + " ~/ " + other));
    },
    _shrOtherPositive$1: function(receiver, other) {
      var t1;
      if (receiver > 0)
        t1 = this._shrBothPositive$1(receiver, other);
      else {
        t1 = other > 31 ? 31 : other;
        t1 = receiver >> t1 >>> 0;
      }
      return t1;
    },
    _shrReceiverPositive$1: function(receiver, other) {
      if (other < 0)
        throw H.wrapException(H.argumentErrorValue(other));
      return this._shrBothPositive$1(receiver, other);
    },
    _shrBothPositive$1: function(receiver, other) {
      return other > 31 ? 0 : receiver >>> other;
    },
    $isComparable: 1,
    $asComparable: function() {
      return [P.num];
    },
    $isdouble: 1,
    $isnum: 1
  };
  J.JSInt.prototype = {$isint: 1};
  J.JSDouble.prototype = {};
  J.JSString.prototype = {
    codeUnitAt$1: function(receiver, index) {
      if (typeof index !== "number" || Math.floor(index) !== index)
        throw H.wrapException(H.diagnoseIndexError(receiver, index));
      if (index < 0)
        throw H.wrapException(H.diagnoseIndexError(receiver, index));
      if (index >= receiver.length)
        H.throwExpression(H.diagnoseIndexError(receiver, index));
      return receiver.charCodeAt(index);
    },
    _codeUnitAt$1: function(receiver, index) {
      if (index >= receiver.length)
        throw H.wrapException(H.diagnoseIndexError(receiver, index));
      return receiver.charCodeAt(index);
    },
    allMatches$2: function(receiver, string, start) {
      var t1;
      if (typeof string !== "string")
        H.throwExpression(H.argumentErrorValue(string));
      t1 = string.length;
      if (start > t1)
        throw H.wrapException(P.RangeError$range(start, 0, string.length, null, null));
      return new H._StringAllMatchesIterable(string, receiver, start);
    },
    allMatches$1: function($receiver, string) {
      return this.allMatches$2($receiver, string, 0);
    },
    matchAsPrefix$2: function(receiver, string, start) {
      var t1, t2, i;
      if (start < 0 || start > string.length)
        throw H.wrapException(P.RangeError$range(start, 0, string.length, null, null));
      t1 = receiver.length;
      if (start + t1 > string.length)
        return;
      for (t2 = J.getInterceptor$s(string), i = 0; i < t1; ++i)
        if (t2.codeUnitAt$1(string, start + i) !== this._codeUnitAt$1(receiver, i))
          return;
      return new H.StringMatch(start, receiver);
    },
    $add: function(receiver, other) {
      if (typeof other !== "string")
        throw H.wrapException(P.ArgumentError$value(other, null, null));
      return receiver + other;
    },
    endsWith$1: function(receiver, other) {
      var otherLength = other.length,
        t1 = receiver.length;
      if (otherLength > t1)
        return false;
      return other === this.substring$1(receiver, t1 - otherLength);
    },
    replaceFirst$2: function(receiver, from, to) {
      P.RangeError_checkValueInInterval(0, 0, receiver.length, "startIndex");
      return H.stringReplaceFirstUnchecked(receiver, from, to, 0);
    },
    replaceRange$3: function(receiver, start, end, replacement) {
      if (typeof replacement !== "string")
        H.throwExpression(H.argumentErrorValue(replacement));
      if (typeof start !== "number" || Math.floor(start) !== start)
        H.throwExpression(H.argumentErrorValue(start));
      end = P.RangeError_checkValidRange(start, end, receiver.length);
      return H.stringReplaceRangeUnchecked(receiver, start, end, replacement);
    },
    startsWith$2: function(receiver, pattern, index) {
      var endIndex;
      if (typeof index !== "number" || Math.floor(index) !== index)
        H.throwExpression(H.argumentErrorValue(index));
      if (index < 0 || index > receiver.length)
        throw H.wrapException(P.RangeError$range(index, 0, receiver.length, null, null));
      if (typeof pattern === "string") {
        endIndex = index + pattern.length;
        if (endIndex > receiver.length)
          return false;
        return pattern === receiver.substring(index, endIndex);
      }
      return J.matchAsPrefix$2$s(pattern, receiver, index) != null;
    },
    startsWith$1: function($receiver, pattern) {
      return this.startsWith$2($receiver, pattern, 0);
    },
    substring$2: function(receiver, startIndex, endIndex) {
      var _null = null;
      if (typeof startIndex !== "number" || Math.floor(startIndex) !== startIndex)
        H.throwExpression(H.argumentErrorValue(startIndex));
      if (endIndex == null)
        endIndex = receiver.length;
      if (startIndex < 0)
        throw H.wrapException(P.RangeError$value(startIndex, _null, _null));
      if (startIndex > endIndex)
        throw H.wrapException(P.RangeError$value(startIndex, _null, _null));
      if (endIndex > receiver.length)
        throw H.wrapException(P.RangeError$value(endIndex, _null, _null));
      return receiver.substring(startIndex, endIndex);
    },
    substring$1: function($receiver, startIndex) {
      return this.substring$2($receiver, startIndex, null);
    },
    trim$0: function(receiver) {
      var startIndex, t1, endIndex0,
        result = receiver.trim(),
        endIndex = result.length;
      if (endIndex === 0)
        return result;
      if (this._codeUnitAt$1(result, 0) === 133) {
        startIndex = J.JSString__skipLeadingWhitespace(result, 1);
        if (startIndex === endIndex)
          return "";
      } else
        startIndex = 0;
      t1 = endIndex - 1;
      endIndex0 = this.codeUnitAt$1(result, t1) === 133 ? J.JSString__skipTrailingWhitespace(result, t1) : endIndex;
      if (startIndex === 0 && endIndex0 === endIndex)
        return result;
      return result.substring(startIndex, endIndex0);
    },
    trimRight$0: function(receiver) {
      var result, endIndex, t1;
      if (typeof receiver.trimRight != "undefined") {
        result = receiver.trimRight();
        endIndex = result.length;
        if (endIndex === 0)
          return result;
        t1 = endIndex - 1;
        if (this.codeUnitAt$1(result, t1) === 133)
          endIndex = J.JSString__skipTrailingWhitespace(result, t1);
      } else {
        endIndex = J.JSString__skipTrailingWhitespace(receiver, receiver.length);
        result = receiver;
      }
      if (endIndex === result.length)
        return result;
      if (endIndex === 0)
        return "";
      return result.substring(0, endIndex);
    },
    $mul: function(receiver, times) {
      var s, result;
      if (0 >= times)
        return "";
      if (times === 1 || receiver.length === 0)
        return receiver;
      if (times !== times >>> 0)
        throw H.wrapException(C.C_OutOfMemoryError);
      for (s = receiver, result = ""; true;) {
        if ((times & 1) === 1)
          result = s + result;
        times = times >>> 1;
        if (times === 0)
          break;
        s += s;
      }
      return result;
    },
    padLeft$2: function(receiver, width, padding) {
      var delta = width - receiver.length;
      if (delta <= 0)
        return receiver;
      return this.$mul(padding, delta) + receiver;
    },
    padRight$1: function(receiver, width) {
      var delta = width - receiver.length;
      if (delta <= 0)
        return receiver;
      return receiver + this.$mul(" ", delta);
    },
    indexOf$2: function(receiver, pattern, start) {
      var t1, t2, i;
      if (pattern == null)
        H.throwExpression(H.argumentErrorValue(pattern));
      if (start < 0 || start > receiver.length)
        throw H.wrapException(P.RangeError$range(start, 0, receiver.length, null, null));
      if (typeof pattern === "string")
        return receiver.indexOf(pattern, start);
      for (t1 = receiver.length, t2 = J.getInterceptor$s(pattern), i = start; i <= t1; ++i)
        if (t2.matchAsPrefix$2(pattern, receiver, i) != null)
          return i;
      return -1;
    },
    indexOf$1: function($receiver, pattern) {
      return this.indexOf$2($receiver, pattern, 0);
    },
    lastIndexOf$2: function(receiver, pattern, start) {
      var t1, t2, i;
      if (pattern == null)
        H.throwExpression(H.argumentErrorValue(pattern));
      if (start == null)
        start = receiver.length;
      else if (start < 0 || start > receiver.length)
        throw H.wrapException(P.RangeError$range(start, 0, receiver.length, null, null));
      if (typeof pattern === "string") {
        t1 = pattern.length;
        t2 = receiver.length;
        if (start + t1 > t2)
          start = t2 - t1;
        return receiver.lastIndexOf(pattern, start);
      }
      for (t1 = J.getInterceptor$s(pattern), i = start; i >= 0; --i)
        if (t1.matchAsPrefix$2(pattern, receiver, i) != null)
          return i;
      return -1;
    },
    lastIndexOf$1: function($receiver, pattern) {
      return this.lastIndexOf$2($receiver, pattern, null);
    },
    contains$2: function(receiver, other, startIndex) {
      if (other == null)
        H.throwExpression(H.argumentErrorValue(other));
      if (startIndex > receiver.length)
        throw H.wrapException(P.RangeError$range(startIndex, 0, receiver.length, null, null));
      return H.stringContainsUnchecked(receiver, other, startIndex);
    },
    contains$1: function($receiver, other) {
      return this.contains$2($receiver, other, 0);
    },
    get$isNotEmpty: function(receiver) {
      return receiver.length !== 0;
    },
    compareTo$1: function(receiver, other) {
      var t1;
      if (typeof other !== "string")
        throw H.wrapException(H.argumentErrorValue(other));
      if (receiver === other)
        t1 = 0;
      else
        t1 = receiver < other ? -1 : 1;
      return t1;
    },
    toString$0: function(receiver) {
      return receiver;
    },
    get$hashCode: function(receiver) {
      var t1, hash, i;
      for (t1 = receiver.length, hash = 0, i = 0; i < t1; ++i) {
        hash = 536870911 & hash + receiver.charCodeAt(i);
        hash = 536870911 & hash + ((524287 & hash) << 10);
        hash ^= hash >> 6;
      }
      hash = 536870911 & hash + ((67108863 & hash) << 3);
      hash ^= hash >> 11;
      return 536870911 & hash + ((16383 & hash) << 15);
    },
    get$length: function(receiver) {
      return receiver.length;
    },
    $isComparable: 1,
    $asComparable: function() {
      return [P.String];
    },
    $isString: 1
  };
  H._CastIterableBase.prototype = {
    get$iterator: function(_) {
      return new H.CastIterator(J.get$iterator$ax(this.get$_source()), this.$ti);
    },
    get$length: function(_) {
      return J.get$length$asx(this.get$_source());
    },
    get$isEmpty: function(_) {
      return J.get$isEmpty$asx(this.get$_source());
    },
    get$isNotEmpty: function(_) {
      return J.get$isNotEmpty$asx(this.get$_source());
    },
    skip$1: function(_, count) {
      return H.CastIterable_CastIterable(J.skip$1$ax(this.get$_source(), count), H.getTypeArgumentByIndex(this, 0), H.getTypeArgumentByIndex(this, 1));
    },
    take$1: function(_, count) {
      return H.CastIterable_CastIterable(J.take$1$ax(this.get$_source(), count), H.getTypeArgumentByIndex(this, 0), H.getTypeArgumentByIndex(this, 1));
    },
    elementAt$1: function(_, index) {
      return H.subtypeOfRuntimeTypeCast(J.elementAt$1$ax(this.get$_source(), index), H.getTypeArgumentByIndex(this, 1));
    },
    get$first: function(_) {
      return H.subtypeOfRuntimeTypeCast(J.get$first$ax(this.get$_source()), H.getTypeArgumentByIndex(this, 1));
    },
    get$last: function(_) {
      return H.subtypeOfRuntimeTypeCast(J.get$last$ax(this.get$_source()), H.getTypeArgumentByIndex(this, 1));
    },
    get$single: function(_) {
      return H.subtypeOfRuntimeTypeCast(J.get$single$ax(this.get$_source()), H.getTypeArgumentByIndex(this, 1));
    },
    contains$1: function(_, other) {
      return J.contains$1$asx(this.get$_source(), other);
    },
    toString$0: function(_) {
      return J.toString$0$(this.get$_source());
    },
    $asIterable: function($S, $T) {
      return [$T];
    }
  };
  H.CastIterator.prototype = {
    moveNext$0: function() {
      return this._source.moveNext$0();
    },
    get$current: function(_) {
      var t1 = this._source;
      return H.subtypeOfRuntimeTypeCast(t1.get$current(t1), H.getTypeArgumentByIndex(this, 1));
    }
  };
  H.CastIterable.prototype = {
    cast$1$0: function(_, $R) {
      return H.CastIterable_CastIterable(this._source, H.getTypeArgumentByIndex(this, 0), $R);
    },
    get$_source: function() {
      return this._source;
    }
  };
  H._EfficientLengthCastIterable.prototype = {$isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function($S, $T) {
      return [$T];
    }
  };
  H._CastListBase.prototype = {
    $index: function(_, index) {
      return H.subtypeOfRuntimeTypeCast(J.$index$asx(this._source, index), H.getTypeArgumentByIndex(this, 1));
    },
    $indexSet: function(_, index, value) {
      J.$indexSet$ax(this._source, index, H.subtypeOfRuntimeTypeCast(value, H.getTypeArgumentByIndex(this, 0)));
    },
    set$length: function(_, $length) {
      J.set$length$asx(this._source, $length);
    },
    add$1: function(_, value) {
      J.add$1$ax(this._source, H.subtypeOfRuntimeTypeCast(value, H.getTypeArgumentByIndex(this, 0)));
    },
    setRange$4: function(_, start, end, iterable, skipCount) {
      J.setRange$4$ax(this._source, start, end, H.CastIterable_CastIterable(iterable, H.getTypeArgumentByIndex(this, 1), H.getTypeArgumentByIndex(this, 0)), skipCount);
    },
    fillRange$3: function(_, start, end, fillValue) {
      J.fillRange$3$ax(this._source, start, end, H.subtypeOfRuntimeTypeCast(fillValue, H.getTypeArgumentByIndex(this, 0)));
    },
    $isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function($S, $T) {
      return [$T];
    },
    $asListMixin: function($S, $T) {
      return [$T];
    },
    $isList: 1,
    $asList: function($S, $T) {
      return [$T];
    }
  };
  H.CastList.prototype = {
    cast$1$0: function(_, $R) {
      return new H.CastList(this._source, [H.getTypeArgumentByIndex(this, 0), $R]);
    },
    get$_source: function() {
      return this._source;
    }
  };
  H.CastSet.prototype = {
    cast$1$0: function(_, $R) {
      return new H.CastSet(this._source, this._emptySet, [H.getTypeArgumentByIndex(this, 0), $R]);
    },
    add$1: function(_, value) {
      return this._source.add$1(0, H.subtypeOfRuntimeTypeCast(value, H.getTypeArgumentByIndex(this, 0)));
    },
    addAll$1: function(_, elements) {
      this._source.addAll$1(0, H.CastIterable_CastIterable(elements, H.getTypeArgumentByIndex(this, 1), H.getTypeArgumentByIndex(this, 0)));
    },
    toSet$0: function(_) {
      var t1 = this._emptySet,
        result = t1 == null ? P.LinkedHashSet_LinkedHashSet(H.getTypeArgumentByIndex(this, 1)) : t1.call$0();
      result.addAll$1(0, this);
      return result;
    },
    $isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function($S, $T) {
      return [$T];
    },
    $isSet: 1,
    $asSet: function($S, $T) {
      return [$T];
    },
    get$_source: function() {
      return this._source;
    }
  };
  H.CastQueue.prototype = {
    cast$1$0: function(_, $R) {
      return new H.CastQueue(this._source, [H.getTypeArgumentByIndex(this, 0), $R]);
    },
    add$1: function(_, value) {
      this._source._collection$_add$1(H.subtypeOfRuntimeTypeCast(value, H.getTypeArgumentByIndex(this, 0)));
    },
    $isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function($S, $T) {
      return [$T];
    },
    $isQueue: 1,
    $asQueue: function($S, $T) {
      return [$T];
    },
    get$_source: function() {
      return this._source;
    }
  };
  H.CodeUnits.prototype = {
    get$length: function(_) {
      return this.__internal$_string.length;
    },
    $index: function(_, i) {
      return C.JSString_methods.codeUnitAt$1(this.__internal$_string, i);
    },
    $asEfficientLengthIterable: function() {
      return [P.int];
    },
    $asListMixin: function() {
      return [P.int];
    },
    $asIterable: function() {
      return [P.int];
    },
    $asList: function() {
      return [P.int];
    }
  };
  H.EfficientLengthIterable.prototype = {};
  H.ListIterable.prototype = {
    get$iterator: function(_) {
      return new H.ListIterator(this, this.get$length(this));
    },
    get$isEmpty: function(_) {
      return this.get$length(this) === 0;
    },
    get$first: function(_) {
      if (this.get$length(this) === 0)
        throw H.wrapException(H.IterableElementError_noElement());
      return this.elementAt$1(0, 0);
    },
    get$last: function(_) {
      var _this = this;
      if (_this.get$length(_this) === 0)
        throw H.wrapException(H.IterableElementError_noElement());
      return _this.elementAt$1(0, _this.get$length(_this) - 1);
    },
    get$single: function(_) {
      var _this = this;
      if (_this.get$length(_this) === 0)
        throw H.wrapException(H.IterableElementError_noElement());
      if (_this.get$length(_this) > 1)
        throw H.wrapException(H.IterableElementError_tooMany());
      return _this.elementAt$1(0, 0);
    },
    contains$1: function(_, element) {
      var i, _this = this,
        $length = _this.get$length(_this);
      for (i = 0; i < $length; ++i) {
        if (J.$eq$(_this.elementAt$1(0, i), element))
          return true;
        if ($length !== _this.get$length(_this))
          throw H.wrapException(P.ConcurrentModificationError$(_this));
      }
      return false;
    },
    any$1: function(_, test) {
      var i, _this = this,
        $length = _this.get$length(_this);
      for (i = 0; i < $length; ++i) {
        if (test.call$1(_this.elementAt$1(0, i)))
          return true;
        if ($length !== _this.get$length(_this))
          throw H.wrapException(P.ConcurrentModificationError$(_this));
      }
      return false;
    },
    firstWhere$2$orElse: function(_, test, orElse) {
      var i, element, _this = this,
        $length = _this.get$length(_this);
      for (i = 0; i < $length; ++i) {
        element = _this.elementAt$1(0, i);
        if (test.call$1(element))
          return element;
        if ($length !== _this.get$length(_this))
          throw H.wrapException(P.ConcurrentModificationError$(_this));
      }
      return orElse.call$0();
    },
    join$1: function(_, separator) {
      var first, t1, i, _this = this,
        $length = _this.get$length(_this);
      if (separator.length !== 0) {
        if ($length === 0)
          return "";
        first = H.S(_this.elementAt$1(0, 0));
        if ($length !== _this.get$length(_this))
          throw H.wrapException(P.ConcurrentModificationError$(_this));
        for (t1 = first, i = 1; i < $length; ++i) {
          t1 = t1 + separator + H.S(_this.elementAt$1(0, i));
          if ($length !== _this.get$length(_this))
            throw H.wrapException(P.ConcurrentModificationError$(_this));
        }
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      } else {
        for (i = 0, t1 = ""; i < $length; ++i) {
          t1 += H.S(_this.elementAt$1(0, i));
          if ($length !== _this.get$length(_this))
            throw H.wrapException(P.ConcurrentModificationError$(_this));
        }
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      }
    },
    join$0: function($receiver) {
      return this.join$1($receiver, "");
    },
    where$1: function(_, test) {
      return this.super$Iterable$where(0, test);
    },
    map$1$1: function(_, f, $T) {
      return new H.MappedListIterable(this, f, [H.getRuntimeTypeArgument(this, "ListIterable", 0), $T]);
    },
    reduce$1: function(_, combine) {
      var value, i, _this = this,
        $length = _this.get$length(_this);
      if ($length === 0)
        throw H.wrapException(H.IterableElementError_noElement());
      value = _this.elementAt$1(0, 0);
      for (i = 1; i < $length; ++i) {
        value = combine.call$2(value, _this.elementAt$1(0, i));
        if ($length !== _this.get$length(_this))
          throw H.wrapException(P.ConcurrentModificationError$(_this));
      }
      return value;
    },
    fold$1$2: function(_, initialValue, combine) {
      var value, i, _this = this,
        $length = _this.get$length(_this);
      for (value = initialValue, i = 0; i < $length; ++i) {
        value = combine.call$2(value, _this.elementAt$1(0, i));
        if ($length !== _this.get$length(_this))
          throw H.wrapException(P.ConcurrentModificationError$(_this));
      }
      return value;
    },
    fold$2: function($receiver, initialValue, combine) {
      return this.fold$1$2($receiver, initialValue, combine, null);
    },
    skip$1: function(_, count) {
      return H.SubListIterable$(this, count, null, H.getRuntimeTypeArgument(this, "ListIterable", 0));
    },
    take$1: function(_, count) {
      return H.SubListIterable$(this, 0, count, H.getRuntimeTypeArgument(this, "ListIterable", 0));
    },
    toList$1$growable: function(_, growable) {
      var i, _this = this,
        result = H.setRuntimeTypeInfo([], [H.getRuntimeTypeArgument(_this, "ListIterable", 0)]);
      C.JSArray_methods.set$length(result, _this.get$length(_this));
      for (i = 0; i < _this.get$length(_this); ++i)
        result[i] = _this.elementAt$1(0, i);
      return result;
    },
    toList$0: function($receiver) {
      return this.toList$1$growable($receiver, true);
    },
    toSet$0: function(_) {
      var i, _this = this,
        result = P.LinkedHashSet_LinkedHashSet(H.getRuntimeTypeArgument(_this, "ListIterable", 0));
      for (i = 0; i < _this.get$length(_this); ++i)
        result.add$1(0, _this.elementAt$1(0, i));
      return result;
    }
  };
  H.SubListIterable.prototype = {
    get$_endIndex: function() {
      var $length = J.get$length$asx(this.__internal$_iterable),
        t1 = this._endOrLength;
      if (t1 == null || t1 > $length)
        return $length;
      return t1;
    },
    get$_startIndex: function() {
      var $length = J.get$length$asx(this.__internal$_iterable),
        t1 = this.__internal$_start;
      if (t1 > $length)
        return $length;
      return t1;
    },
    get$length: function(_) {
      var t2,
        $length = J.get$length$asx(this.__internal$_iterable),
        t1 = this.__internal$_start;
      if (t1 >= $length)
        return 0;
      t2 = this._endOrLength;
      if (t2 == null || t2 >= $length)
        return $length - t1;
      return t2 - t1;
    },
    elementAt$1: function(_, index) {
      var _this = this,
        realIndex = _this.get$_startIndex() + index;
      if (index < 0 || realIndex >= _this.get$_endIndex())
        throw H.wrapException(P.IndexError$(index, _this, "index", null, null));
      return J.elementAt$1$ax(_this.__internal$_iterable, realIndex);
    },
    skip$1: function(_, count) {
      var newStart, t1, _this = this;
      P.RangeError_checkNotNegative(count, "count");
      newStart = _this.__internal$_start + count;
      t1 = _this._endOrLength;
      if (t1 != null && newStart >= t1)
        return new H.EmptyIterable(_this.$ti);
      return H.SubListIterable$(_this.__internal$_iterable, newStart, t1, H.getTypeArgumentByIndex(_this, 0));
    },
    take$1: function(_, count) {
      var t1, t2, newEnd, _this = this;
      P.RangeError_checkNotNegative(count, "count");
      t1 = _this._endOrLength;
      t2 = _this.__internal$_start;
      if (t1 == null)
        return H.SubListIterable$(_this.__internal$_iterable, t2, t2 + count, H.getTypeArgumentByIndex(_this, 0));
      else {
        newEnd = t2 + count;
        if (t1 < newEnd)
          return _this;
        return H.SubListIterable$(_this.__internal$_iterable, t2, newEnd, H.getTypeArgumentByIndex(_this, 0));
      }
    },
    toList$1$growable: function(_, growable) {
      var $length, t3, result, t4, i, _this = this,
        start = _this.__internal$_start,
        t1 = _this.__internal$_iterable,
        t2 = J.getInterceptor$asx(t1),
        end = t2.get$length(t1),
        end0 = _this._endOrLength;
      if (end0 != null && end0 < end)
        end = end0;
      $length = end - start;
      if ($length < 0)
        $length = 0;
      t3 = _this.$ti;
      if (growable) {
        result = H.setRuntimeTypeInfo([], t3);
        C.JSArray_methods.set$length(result, $length);
      } else {
        t4 = new Array($length);
        t4.fixed$length = Array;
        result = H.setRuntimeTypeInfo(t4, t3);
      }
      for (i = 0; i < $length; ++i) {
        result[i] = t2.elementAt$1(t1, start + i);
        if (t2.get$length(t1) < end)
          throw H.wrapException(P.ConcurrentModificationError$(_this));
      }
      return result;
    },
    toList$0: function($receiver) {
      return this.toList$1$growable($receiver, true);
    }
  };
  H.ListIterator.prototype = {
    get$current: function(_) {
      return this.__internal$_current;
    },
    moveNext$0: function() {
      var t3, _this = this,
        t1 = _this.__internal$_iterable,
        t2 = J.getInterceptor$asx(t1),
        $length = t2.get$length(t1);
      if (_this.__internal$_length !== $length)
        throw H.wrapException(P.ConcurrentModificationError$(t1));
      t3 = _this.__internal$_index;
      if (t3 >= $length) {
        _this.__internal$_current = null;
        return false;
      }
      _this.__internal$_current = t2.elementAt$1(t1, t3);
      ++_this.__internal$_index;
      return true;
    }
  };
  H.MappedIterable.prototype = {
    get$iterator: function(_) {
      return new H.MappedIterator(J.get$iterator$ax(this.__internal$_iterable), this._f);
    },
    get$length: function(_) {
      return J.get$length$asx(this.__internal$_iterable);
    },
    get$isEmpty: function(_) {
      return J.get$isEmpty$asx(this.__internal$_iterable);
    },
    get$first: function(_) {
      return this._f.call$1(J.get$first$ax(this.__internal$_iterable));
    },
    get$last: function(_) {
      return this._f.call$1(J.get$last$ax(this.__internal$_iterable));
    },
    get$single: function(_) {
      return this._f.call$1(J.get$single$ax(this.__internal$_iterable));
    },
    elementAt$1: function(_, index) {
      return this._f.call$1(J.elementAt$1$ax(this.__internal$_iterable, index));
    },
    $asIterable: function($S, $T) {
      return [$T];
    }
  };
  H.EfficientLengthMappedIterable.prototype = {$isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function($S, $T) {
      return [$T];
    }
  };
  H.MappedIterator.prototype = {
    moveNext$0: function() {
      var _this = this,
        t1 = _this._iterator;
      if (t1.moveNext$0()) {
        _this.__internal$_current = _this._f.call$1(t1.get$current(t1));
        return true;
      }
      _this.__internal$_current = null;
      return false;
    },
    get$current: function(_) {
      return this.__internal$_current;
    }
  };
  H.MappedListIterable.prototype = {
    get$length: function(_) {
      return J.get$length$asx(this._source);
    },
    elementAt$1: function(_, index) {
      return this._f.call$1(J.elementAt$1$ax(this._source, index));
    },
    $asEfficientLengthIterable: function($S, $T) {
      return [$T];
    },
    $asListIterable: function($S, $T) {
      return [$T];
    },
    $asIterable: function($S, $T) {
      return [$T];
    }
  };
  H.WhereIterable.prototype = {
    get$iterator: function(_) {
      return new H.WhereIterator(J.get$iterator$ax(this.__internal$_iterable), this._f);
    },
    map$1$1: function(_, f, $T) {
      return new H.MappedIterable(this, f, [H.getTypeArgumentByIndex(this, 0), $T]);
    }
  };
  H.WhereIterator.prototype = {
    moveNext$0: function() {
      var t1, t2;
      for (t1 = this._iterator, t2 = this._f; t1.moveNext$0();)
        if (t2.call$1(t1.get$current(t1)))
          return true;
      return false;
    },
    get$current: function(_) {
      var t1 = this._iterator;
      return t1.get$current(t1);
    }
  };
  H.ExpandIterable.prototype = {
    get$iterator: function(_) {
      return new H.ExpandIterator(J.get$iterator$ax(this.__internal$_iterable), this._f, C.C_EmptyIterator);
    },
    $asIterable: function($S, $T) {
      return [$T];
    }
  };
  H.ExpandIterator.prototype = {
    get$current: function(_) {
      return this.__internal$_current;
    },
    moveNext$0: function() {
      var t2, t3, _this = this,
        t1 = _this._currentExpansion;
      if (t1 == null)
        return false;
      for (t2 = _this._iterator, t3 = _this._f; !t1.moveNext$0();) {
        _this.__internal$_current = null;
        if (t2.moveNext$0()) {
          _this._currentExpansion = null;
          t1 = J.get$iterator$ax(t3.call$1(t2.get$current(t2)));
          _this._currentExpansion = t1;
        } else
          return false;
      }
      t1 = _this._currentExpansion;
      _this.__internal$_current = t1.get$current(t1);
      return true;
    }
  };
  H.TakeIterable.prototype = {
    get$iterator: function(_) {
      return new H.TakeIterator(J.get$iterator$ax(this.__internal$_iterable), this._takeCount);
    }
  };
  H.EfficientLengthTakeIterable.prototype = {
    get$length: function(_) {
      var iterableLength = J.get$length$asx(this.__internal$_iterable),
        t1 = this._takeCount;
      if (iterableLength > t1)
        return t1;
      return iterableLength;
    },
    $isEfficientLengthIterable: 1
  };
  H.TakeIterator.prototype = {
    moveNext$0: function() {
      if (--this._remaining >= 0)
        return this._iterator.moveNext$0();
      this._remaining = -1;
      return false;
    },
    get$current: function(_) {
      var t1;
      if (this._remaining < 0)
        return;
      t1 = this._iterator;
      return t1.get$current(t1);
    }
  };
  H.SkipIterable.prototype = {
    skip$1: function(_, count) {
      if (count == null)
        H.throwExpression(P.ArgumentError$notNull("count"));
      P.RangeError_checkNotNegative(count, "count");
      return new H.SkipIterable(this.__internal$_iterable, this._skipCount + count, this.$ti);
    },
    get$iterator: function(_) {
      return new H.SkipIterator(J.get$iterator$ax(this.__internal$_iterable), this._skipCount);
    }
  };
  H.EfficientLengthSkipIterable.prototype = {
    get$length: function(_) {
      var $length = J.get$length$asx(this.__internal$_iterable) - this._skipCount;
      if ($length >= 0)
        return $length;
      return 0;
    },
    skip$1: function(_, count) {
      if (count == null)
        H.throwExpression(P.ArgumentError$notNull("count"));
      P.RangeError_checkNotNegative(count, "count");
      return new H.EfficientLengthSkipIterable(this.__internal$_iterable, this._skipCount + count, this.$ti);
    },
    $isEfficientLengthIterable: 1
  };
  H.SkipIterator.prototype = {
    moveNext$0: function() {
      var t1, i;
      for (t1 = this._iterator, i = 0; i < this._skipCount; ++i)
        t1.moveNext$0();
      this._skipCount = 0;
      return t1.moveNext$0();
    },
    get$current: function(_) {
      var t1 = this._iterator;
      return t1.get$current(t1);
    }
  };
  H.SkipWhileIterable.prototype = {
    get$iterator: function(_) {
      return new H.SkipWhileIterator(J.get$iterator$ax(this.__internal$_iterable), this._f);
    }
  };
  H.SkipWhileIterator.prototype = {
    moveNext$0: function() {
      var t1, t2, _this = this;
      if (!_this._hasSkipped) {
        _this._hasSkipped = true;
        for (t1 = _this._iterator, t2 = _this._f; t1.moveNext$0();)
          if (!t2.call$1(t1.get$current(t1)))
            return true;
      }
      return _this._iterator.moveNext$0();
    },
    get$current: function(_) {
      var t1 = this._iterator;
      return t1.get$current(t1);
    }
  };
  H.EmptyIterable.prototype = {
    get$iterator: function(_) {
      return C.C_EmptyIterator;
    },
    get$isEmpty: function(_) {
      return true;
    },
    get$length: function(_) {
      return 0;
    },
    get$first: function(_) {
      throw H.wrapException(H.IterableElementError_noElement());
    },
    get$last: function(_) {
      throw H.wrapException(H.IterableElementError_noElement());
    },
    get$single: function(_) {
      throw H.wrapException(H.IterableElementError_noElement());
    },
    elementAt$1: function(_, index) {
      throw H.wrapException(P.RangeError$range(index, 0, 0, "index", null));
    },
    contains$1: function(_, element) {
      return false;
    },
    join$1: function(_, separator) {
      return "";
    },
    join$0: function($receiver) {
      return this.join$1($receiver, "");
    },
    where$1: function(_, test) {
      return this;
    },
    map$1$1: function(_, f, $T) {
      return new H.EmptyIterable([$T]);
    },
    skip$1: function(_, count) {
      P.RangeError_checkNotNegative(count, "count");
      return this;
    },
    take$1: function(_, count) {
      P.RangeError_checkNotNegative(count, "count");
      return this;
    },
    toList$1$growable: function(_, growable) {
      var t1 = H.setRuntimeTypeInfo([], this.$ti);
      return t1;
    },
    toList$0: function($receiver) {
      return this.toList$1$growable($receiver, true);
    },
    toSet$0: function(_) {
      return P.LinkedHashSet_LinkedHashSet(H.getTypeArgumentByIndex(this, 0));
    }
  };
  H.EmptyIterator.prototype = {
    moveNext$0: function() {
      return false;
    },
    get$current: function(_) {
      return;
    }
  };
  H.FollowedByIterable.prototype = {
    get$iterator: function(_) {
      return new H.FollowedByIterator(J.get$iterator$ax(this.__internal$_first), this._second);
    },
    get$length: function(_) {
      var t1 = this._second;
      return J.get$length$asx(this.__internal$_first) + t1.get$length(t1);
    },
    get$isEmpty: function(_) {
      var t1;
      if (J.get$isEmpty$asx(this.__internal$_first)) {
        t1 = this._second;
        t1 = t1.get$isEmpty(t1);
      } else
        t1 = false;
      return t1;
    },
    get$isNotEmpty: function(_) {
      var t1;
      if (!J.get$isNotEmpty$asx(this.__internal$_first)) {
        t1 = this._second;
        t1 = t1.get$isNotEmpty(t1);
      } else
        t1 = true;
      return t1;
    },
    contains$1: function(_, value) {
      var t1;
      if (!J.contains$1$asx(this.__internal$_first, value)) {
        t1 = this._second;
        t1 = t1.contains$1(t1, value);
      } else
        t1 = true;
      return t1;
    },
    get$first: function(_) {
      var t1,
        iterator = J.get$iterator$ax(this.__internal$_first);
      if (iterator.moveNext$0())
        return iterator.get$current(iterator);
      t1 = this._second;
      return t1.get$first(t1);
    },
    get$last: function(_) {
      var last,
        t1 = this._second,
        iterator = t1.get$iterator(t1);
      if (iterator.moveNext$0()) {
        last = iterator.get$current(iterator);
        for (; iterator.moveNext$0();)
          last = iterator.get$current(iterator);
        return last;
      }
      return J.get$last$ax(this.__internal$_first);
    }
  };
  H.EfficientLengthFollowedByIterable.prototype = {
    skip$1: function(_, count) {
      var _this = this,
        t1 = _this.__internal$_first,
        t2 = J.getInterceptor$asx(t1),
        firstLength = t2.get$length(t1);
      if (count >= firstLength) {
        t1 = _this._second;
        return t1.skip$1(t1, count - firstLength);
      }
      return new H.EfficientLengthFollowedByIterable(t2.skip$1(t1, count), _this._second, _this.$ti);
    },
    take$1: function(_, count) {
      var t1 = this.__internal$_first,
        t2 = J.getInterceptor$asx(t1),
        firstLength = t2.get$length(t1);
      if (count <= firstLength)
        return t2.take$1(t1, count);
      t2 = this._second;
      return new H.EfficientLengthFollowedByIterable(t1, t2.take$1(t2, count - firstLength), this.$ti);
    },
    elementAt$1: function(_, index) {
      var t1 = this.__internal$_first,
        t2 = J.getInterceptor$asx(t1),
        firstLength = t2.get$length(t1);
      if (index < firstLength)
        return t2.elementAt$1(t1, index);
      t1 = this._second;
      return t1.elementAt$1(t1, index - firstLength);
    },
    get$first: function(_) {
      var t1 = this.__internal$_first,
        t2 = J.getInterceptor$asx(t1);
      if (t2.get$isNotEmpty(t1))
        return t2.get$first(t1);
      t1 = this._second;
      return t1.get$first(t1);
    },
    get$last: function(_) {
      var t1 = this._second;
      if (t1.get$isNotEmpty(t1))
        return t1.get$last(t1);
      return J.get$last$ax(this.__internal$_first);
    },
    $isEfficientLengthIterable: 1
  };
  H.FollowedByIterator.prototype = {
    moveNext$0: function() {
      var t1, _this = this;
      if (_this._currentIterator.moveNext$0())
        return true;
      t1 = _this._nextIterable;
      if (t1 != null) {
        t1 = t1.get$iterator(t1);
        _this._currentIterator = t1;
        _this._nextIterable = null;
        return t1.moveNext$0();
      }
      return false;
    },
    get$current: function(_) {
      var t1 = this._currentIterator;
      return t1.get$current(t1);
    }
  };
  H.WhereTypeIterable.prototype = {
    get$iterator: function(_) {
      return new H.WhereTypeIterator(J.get$iterator$ax(this._source), this.$ti);
    }
  };
  H.WhereTypeIterator.prototype = {
    moveNext$0: function() {
      var t1, t2, t3;
      for (t1 = this._source, t2 = H.getTypeArgumentByIndex(this, 0); t1.moveNext$0();) {
        t3 = t1.get$current(t1);
        if (H.checkSubtypeOfRuntimeType(t3, t2))
          return true;
      }
      return false;
    },
    get$current: function(_) {
      var t1 = this._source;
      return t1.get$current(t1);
    }
  };
  H.FixedLengthListMixin.prototype = {
    set$length: function(receiver, newLength) {
      throw H.wrapException(P.UnsupportedError$("Cannot change the length of a fixed-length list"));
    },
    add$1: function(receiver, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot add to a fixed-length list"));
    }
  };
  H.UnmodifiableListMixin.prototype = {
    $indexSet: function(_, index, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot modify an unmodifiable list"));
    },
    set$length: function(_, newLength) {
      throw H.wrapException(P.UnsupportedError$("Cannot change the length of an unmodifiable list"));
    },
    add$1: function(_, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot add to an unmodifiable list"));
    },
    setRange$4: function(_, start, end, iterable, skipCount) {
      throw H.wrapException(P.UnsupportedError$("Cannot modify an unmodifiable list"));
    },
    fillRange$3: function(_, start, end, fillValue) {
      throw H.wrapException(P.UnsupportedError$("Cannot modify an unmodifiable list"));
    }
  };
  H.UnmodifiableListBase.prototype = {};
  H.ReversedListIterable.prototype = {
    get$length: function(_) {
      return J.get$length$asx(this._source);
    },
    elementAt$1: function(_, index) {
      var t1 = this._source,
        t2 = J.getInterceptor$asx(t1);
      return t2.elementAt$1(t1, t2.get$length(t1) - 1 - index);
    }
  };
  H.Symbol0.prototype = {
    get$hashCode: function(_) {
      var hash = this._hashCode;
      if (hash != null)
        return hash;
      hash = 536870911 & 664597 * J.get$hashCode$(this._name);
      this._hashCode = hash;
      return hash;
    },
    toString$0: function(_) {
      return 'Symbol("' + H.S(this._name) + '")';
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return other instanceof H.Symbol0 && this._name == other._name;
    },
    $isSymbol: 1
  };
  H.__CastListBase__CastIterableBase_ListMixin.prototype = {};
  H.ConstantMapView.prototype = {};
  H.ConstantMap.prototype = {
    get$isEmpty: function(_) {
      return this.get$length(this) === 0;
    },
    get$isNotEmpty: function(_) {
      return this.get$length(this) !== 0;
    },
    toString$0: function(_) {
      return P.MapBase_mapToString(this);
    },
    $indexSet: function(_, key, val) {
      return H.ConstantMap__throwUnmodifiable();
    },
    putIfAbsent$2: function(key, ifAbsent) {
      return H.ConstantMap__throwUnmodifiable();
    },
    remove$1: function(_, key) {
      return H.ConstantMap__throwUnmodifiable();
    },
    addAll$1: function(_, other) {
      return H.ConstantMap__throwUnmodifiable();
    },
    get$entries: function() {
      return this.entries$body$ConstantMap([P.MapEntry, H.getTypeArgumentByIndex(this, 0), H.getTypeArgumentByIndex(this, 1)]);
    },
    entries$body$ConstantMap: function($async$type) {
      var $async$self = this;
      return P._makeSyncStarIterable(function() {
        var $async$goto = 0, $async$handler = 1, $async$currentError, t1, t2, key;
        return function $async$get$entries($async$errorCode, $async$result) {
          if ($async$errorCode === 1) {
            $async$currentError = $async$result;
            $async$goto = $async$handler;
          }
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = $async$self.get$keys(), t1 = t1.get$iterator(t1), t2 = $async$self.$ti;
              case 2:
                // for condition
                if (!t1.moveNext$0()) {
                  // goto after for
                  $async$goto = 3;
                  break;
                }
                key = t1.get$current(t1);
                $async$goto = 4;
                return new P.MapEntry(key, $async$self.$index(0, key), t2);
              case 4:
                // after yield
                // goto for condition
                $async$goto = 2;
                break;
              case 3:
                // after for
                // implicit return
                return P._IterationMarker_endOfIteration();
              case 1:
                // rethrow
                return P._IterationMarker_uncaughtError($async$currentError);
            }
        };
      }, $async$type);
    },
    $isMap: 1
  };
  H.ConstantStringMap.prototype = {
    get$length: function(_) {
      return this.__js_helper$_length;
    },
    containsKey$1: function(key) {
      if (typeof key !== "string")
        return false;
      if ("__proto__" === key)
        return false;
      return this._jsObject.hasOwnProperty(key);
    },
    $index: function(_, key) {
      if (!this.containsKey$1(key))
        return;
      return this._fetch$1(key);
    },
    _fetch$1: function(key) {
      return this._jsObject[key];
    },
    forEach$1: function(_, f) {
      var t1, i, key,
        keys = this._keys;
      for (t1 = keys.length, i = 0; i < t1; ++i) {
        key = keys[i];
        f.call$2(key, this._fetch$1(key));
      }
    },
    get$keys: function() {
      return new H._ConstantMapKeyIterable(this, [H.getTypeArgumentByIndex(this, 0)]);
    },
    get$values: function() {
      var _this = this;
      return H.MappedIterable_MappedIterable(_this._keys, new H.ConstantStringMap_values_closure(_this), H.getTypeArgumentByIndex(_this, 0), H.getTypeArgumentByIndex(_this, 1));
    }
  };
  H.ConstantStringMap_values_closure.prototype = {
    call$1: function(key) {
      return this.$this._fetch$1(key);
    },
    $signature: function() {
      var t1 = this.$this;
      return {func: 1, ret: H.getTypeArgumentByIndex(t1, 1), args: [H.getTypeArgumentByIndex(t1, 0)]};
    }
  };
  H.ConstantProtoMap.prototype = {
    containsKey$1: function(key) {
      if (typeof key !== "string")
        return false;
      if ("__proto__" === key)
        return true;
      return this._jsObject.hasOwnProperty(key);
    },
    _fetch$1: function(key) {
      return "__proto__" === key ? this._protoValue : this._jsObject[key];
    }
  };
  H._ConstantMapKeyIterable.prototype = {
    get$iterator: function(_) {
      var t1 = this._map._keys;
      return new J.ArrayIterator(t1, t1.length);
    },
    get$length: function(_) {
      return this._map._keys.length;
    }
  };
  H.Instantiation.prototype = {
    Instantiation$1: function(_genericClosure) {
      if (false)
        {}
    },
    toString$0: function(_) {
      var types = "<" + C.JSArray_methods.join$1(this.get$_types(), ", ") + ">";
      return H.S(this._genericClosure) + " with " + types;
    }
  };
  H.Instantiation1.prototype = {
    get$_types: function() {
      return [new H.TypeImpl(H.getTypeArgumentByIndex(this, 0))];
    },
    call$2: function(a0, a1) {
      return this._genericClosure.call$1$2(a0, a1, this.$ti[0]);
    },
    call$0: function() {
      return this._genericClosure.call$1$0(this.$ti[0]);
    },
    call$3: function(a0, a1, a2) {
      return this._genericClosure.call$1$3(a0, a1, a2, this.$ti[0]);
    },
    call$4: function(a0, a1, a2, a3) {
      return this._genericClosure.call$1$4(a0, a1, a2, a3, this.$ti[0]);
    },
    $signature: function() {
      return H.instantiatedGenericFunctionType(H.extractFunctionTypeObjectFromInternal(this._genericClosure), this.$ti);
    }
  };
  H.JSInvocationMirror.prototype = {
    get$memberName: function() {
      var t1 = this.__js_helper$_memberName;
      return t1;
    },
    get$positionalArguments: function() {
      var t1, argumentCount, list, index, _this = this;
      if (_this._kind === 1)
        return C.List_empty;
      t1 = _this.__js_helper$_arguments;
      argumentCount = t1.length - _this._namedArgumentNames.length - _this._typeArgumentCount;
      if (argumentCount === 0)
        return C.List_empty;
      list = [];
      for (index = 0; index < argumentCount; ++index)
        list.push(t1[index]);
      return J.JSArray_markUnmodifiableList(list);
    },
    get$namedArguments: function() {
      var t1, namedArgumentCount, t2, namedArgumentsStartIndex, t3, map, i, _this = this;
      if (_this._kind !== 0)
        return C.Map_empty;
      t1 = _this._namedArgumentNames;
      namedArgumentCount = t1.length;
      t2 = _this.__js_helper$_arguments;
      namedArgumentsStartIndex = t2.length - namedArgumentCount - _this._typeArgumentCount;
      if (namedArgumentCount === 0)
        return C.Map_empty;
      t3 = P.Symbol;
      map = new H.JsLinkedHashMap([t3, null]);
      for (i = 0; i < namedArgumentCount; ++i)
        map.$indexSet(0, new H.Symbol0(t1[i]), t2[namedArgumentsStartIndex + i]);
      return new H.ConstantMapView(map, [t3, null]);
    }
  };
  H.Primitives_functionNoSuchMethod_closure.prototype = {
    call$2: function($name, argument) {
      var t1 = this._box_0;
      t1.names = t1.names + "$" + H.S($name);
      this.namedArgumentList.push($name);
      this.$arguments.push(argument);
      ++t1.argumentCount;
    }
  };
  H.TypeErrorDecoder.prototype = {
    matchTypeError$1: function(message) {
      var result, t1, _this = this,
        match = new RegExp(_this._pattern).exec(message);
      if (match == null)
        return;
      result = Object.create(null);
      t1 = _this.__js_helper$_arguments;
      if (t1 !== -1)
        result.arguments = match[t1 + 1];
      t1 = _this._argumentsExpr;
      if (t1 !== -1)
        result.argumentsExpr = match[t1 + 1];
      t1 = _this._expr;
      if (t1 !== -1)
        result.expr = match[t1 + 1];
      t1 = _this._method;
      if (t1 !== -1)
        result.method = match[t1 + 1];
      t1 = _this.__js_helper$_receiver;
      if (t1 !== -1)
        result.receiver = match[t1 + 1];
      return result;
    }
  };
  H.NullError.prototype = {
    toString$0: function(_) {
      var t1 = this._method;
      if (t1 == null)
        return "NoSuchMethodError: " + H.S(this._message);
      return "NoSuchMethodError: method not found: '" + t1 + "' on null";
    }
  };
  H.JsNoSuchMethodError.prototype = {
    toString$0: function(_) {
      var t2, _this = this,
        _s38_ = "NoSuchMethodError: method not found: '",
        t1 = _this._method;
      if (t1 == null)
        return "NoSuchMethodError: " + H.S(_this._message);
      t2 = _this.__js_helper$_receiver;
      if (t2 == null)
        return _s38_ + t1 + "' (" + H.S(_this._message) + ")";
      return _s38_ + t1 + "' on '" + t2 + "' (" + H.S(_this._message) + ")";
    }
  };
  H.UnknownJsTypeError.prototype = {
    toString$0: function(_) {
      var t1 = this._message;
      return t1.length === 0 ? "Error" : "Error: " + t1;
    }
  };
  H.ExceptionAndStackTrace.prototype = {};
  H.unwrapException_saveStackTrace.prototype = {
    call$1: function(error) {
      if (!!J.getInterceptor$(error).$isError)
        if (error.$thrownJsError == null)
          error.$thrownJsError = this.ex;
      return error;
    },
    $signature: 10
  };
  H._StackTrace.prototype = {
    toString$0: function(_) {
      var trace,
        t1 = this._trace;
      if (t1 != null)
        return t1;
      t1 = this._exception;
      trace = t1 !== null && typeof t1 === "object" ? t1.stack : null;
      return this._trace = trace == null ? "" : trace;
    },
    $isStackTrace: 1
  };
  H.Closure.prototype = {
    toString$0: function(_) {
      return "Closure '" + H.Primitives_objectTypeName(this).trim() + "'";
    },
    $isFunction: 1,
    get$$call: function() {
      return this;
    },
    "call*": "call$1",
    $requiredArgCount: 1,
    $defaultValues: null
  };
  H.TearOffClosure.prototype = {};
  H.StaticClosure.prototype = {
    toString$0: function(_) {
      var $name = this.$static_name;
      if ($name == null)
        return "Closure of unknown static method";
      return "Closure '" + H.unminifyOrTag($name) + "'";
    }
  };
  H.BoundClosure.prototype = {
    $eq: function(_, other) {
      var _this = this;
      if (other == null)
        return false;
      if (_this === other)
        return true;
      if (!(other instanceof H.BoundClosure))
        return false;
      return _this._self === other._self && _this._target === other._target && _this.__js_helper$_receiver === other.__js_helper$_receiver;
    },
    get$hashCode: function(_) {
      var receiverHashCode,
        t1 = this.__js_helper$_receiver;
      if (t1 == null)
        receiverHashCode = H.Primitives_objectHashCode(this._self);
      else
        receiverHashCode = typeof t1 !== "object" ? J.get$hashCode$(t1) : H.Primitives_objectHashCode(t1);
      return (receiverHashCode ^ H.Primitives_objectHashCode(this._target)) >>> 0;
    },
    toString$0: function(_) {
      var receiver = this.__js_helper$_receiver;
      if (receiver == null)
        receiver = this._self;
      return "Closure '" + H.S(this.__js_helper$_name) + "' of " + ("Instance of '" + H.Primitives_objectTypeName(receiver) + "'");
    }
  };
  H.CastErrorImplementation.prototype = {
    toString$0: function(_) {
      return this.message;
    },
    get$message: function(receiver) {
      return this.message;
    }
  };
  H.RuntimeError.prototype = {
    toString$0: function(_) {
      return "RuntimeError: " + H.S(this.message);
    },
    get$message: function(receiver) {
      return this.message;
    }
  };
  H.TypeImpl.prototype = {
    get$_typeName: function() {
      var t1 = this.__typeName;
      return t1 == null ? this.__typeName = H.runtimeTypeToString(this._rti) : t1;
    },
    toString$0: function(_) {
      return this.get$_typeName();
    },
    get$hashCode: function(_) {
      var t1 = this._hashCode;
      return t1 == null ? this._hashCode = C.JSString_methods.get$hashCode(this.get$_typeName()) : t1;
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return other instanceof H.TypeImpl && this.get$_typeName() === other.get$_typeName();
    }
  };
  H.JsLinkedHashMap.prototype = {
    get$length: function(_) {
      return this.__js_helper$_length;
    },
    get$isEmpty: function(_) {
      return this.__js_helper$_length === 0;
    },
    get$isNotEmpty: function(_) {
      return !this.get$isEmpty(this);
    },
    get$keys: function() {
      return new H.LinkedHashMapKeyIterable(this, [H.getTypeArgumentByIndex(this, 0)]);
    },
    get$values: function() {
      var _this = this;
      return H.MappedIterable_MappedIterable(_this.get$keys(), new H.JsLinkedHashMap_values_closure(_this), H.getTypeArgumentByIndex(_this, 0), H.getTypeArgumentByIndex(_this, 1));
    },
    containsKey$1: function(key) {
      var strings, nums, _this = this;
      if (typeof key === "string") {
        strings = _this._strings;
        if (strings == null)
          return false;
        return _this._containsTableEntry$2(strings, key);
      } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
        nums = _this._nums;
        if (nums == null)
          return false;
        return _this._containsTableEntry$2(nums, key);
      } else
        return _this.internalContainsKey$1(key);
    },
    internalContainsKey$1: function(key) {
      var _this = this,
        rest = _this._rest;
      if (rest == null)
        return false;
      return _this.internalFindBucketIndex$2(_this._getTableBucket$2(rest, _this.internalComputeHashCode$1(key)), key) >= 0;
    },
    addAll$1: function(_, other) {
      other.forEach$1(0, new H.JsLinkedHashMap_addAll_closure(this));
    },
    $index: function(_, key) {
      var strings, cell, t1, nums, _this = this;
      if (typeof key === "string") {
        strings = _this._strings;
        if (strings == null)
          return;
        cell = _this._getTableCell$2(strings, key);
        t1 = cell == null ? null : cell.hashMapCellValue;
        return t1;
      } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
        nums = _this._nums;
        if (nums == null)
          return;
        cell = _this._getTableCell$2(nums, key);
        t1 = cell == null ? null : cell.hashMapCellValue;
        return t1;
      } else
        return _this.internalGet$1(key);
    },
    internalGet$1: function(key) {
      var bucket, index, _this = this,
        rest = _this._rest;
      if (rest == null)
        return;
      bucket = _this._getTableBucket$2(rest, _this.internalComputeHashCode$1(key));
      index = _this.internalFindBucketIndex$2(bucket, key);
      if (index < 0)
        return;
      return bucket[index].hashMapCellValue;
    },
    $indexSet: function(_, key, value) {
      var strings, nums, _this = this;
      if (typeof key === "string") {
        strings = _this._strings;
        _this._addHashTableEntry$3(strings == null ? _this._strings = _this._newHashTable$0() : strings, key, value);
      } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
        nums = _this._nums;
        _this._addHashTableEntry$3(nums == null ? _this._nums = _this._newHashTable$0() : nums, key, value);
      } else
        _this.internalSet$2(key, value);
    },
    internalSet$2: function(key, value) {
      var hash, bucket, index, _this = this,
        rest = _this._rest;
      if (rest == null)
        rest = _this._rest = _this._newHashTable$0();
      hash = _this.internalComputeHashCode$1(key);
      bucket = _this._getTableBucket$2(rest, hash);
      if (bucket == null)
        _this._setTableEntry$3(rest, hash, [_this._newLinkedCell$2(key, value)]);
      else {
        index = _this.internalFindBucketIndex$2(bucket, key);
        if (index >= 0)
          bucket[index].hashMapCellValue = value;
        else
          bucket.push(_this._newLinkedCell$2(key, value));
      }
    },
    putIfAbsent$2: function(key, ifAbsent) {
      var value;
      if (this.containsKey$1(key))
        return this.$index(0, key);
      value = ifAbsent.call$0();
      this.$indexSet(0, key, value);
      return value;
    },
    remove$1: function(_, key) {
      var _this = this;
      if (typeof key === "string")
        return _this.__js_helper$_removeHashTableEntry$2(_this._strings, key);
      else if (typeof key === "number" && (key & 0x3ffffff) === key)
        return _this.__js_helper$_removeHashTableEntry$2(_this._nums, key);
      else
        return _this.internalRemove$1(key);
    },
    internalRemove$1: function(key) {
      var hash, bucket, index, cell, _this = this,
        rest = _this._rest;
      if (rest == null)
        return;
      hash = _this.internalComputeHashCode$1(key);
      bucket = _this._getTableBucket$2(rest, hash);
      index = _this.internalFindBucketIndex$2(bucket, key);
      if (index < 0)
        return;
      cell = bucket.splice(index, 1)[0];
      _this.__js_helper$_unlinkCell$1(cell);
      if (bucket.length === 0)
        _this._deleteTableEntry$2(rest, hash);
      return cell.hashMapCellValue;
    },
    clear$0: function(_) {
      var _this = this;
      if (_this.__js_helper$_length > 0) {
        _this._strings = _this._nums = _this._rest = _this._first = _this._last = null;
        _this.__js_helper$_length = 0;
        _this._modified$0();
      }
    },
    forEach$1: function(_, action) {
      var _this = this,
        cell = _this._first,
        modifications = _this._modifications;
      for (; cell != null;) {
        action.call$2(cell.hashMapCellKey, cell.hashMapCellValue);
        if (modifications !== _this._modifications)
          throw H.wrapException(P.ConcurrentModificationError$(_this));
        cell = cell._next;
      }
    },
    _addHashTableEntry$3: function(table, key, value) {
      var cell = this._getTableCell$2(table, key);
      if (cell == null)
        this._setTableEntry$3(table, key, this._newLinkedCell$2(key, value));
      else
        cell.hashMapCellValue = value;
    },
    __js_helper$_removeHashTableEntry$2: function(table, key) {
      var cell;
      if (table == null)
        return;
      cell = this._getTableCell$2(table, key);
      if (cell == null)
        return;
      this.__js_helper$_unlinkCell$1(cell);
      this._deleteTableEntry$2(table, key);
      return cell.hashMapCellValue;
    },
    _modified$0: function() {
      this._modifications = this._modifications + 1 & 67108863;
    },
    _newLinkedCell$2: function(key, value) {
      var last, _this = this,
        cell = new H.LinkedHashMapCell(key, value);
      if (_this._first == null)
        _this._first = _this._last = cell;
      else {
        last = _this._last;
        cell._previous = last;
        _this._last = last._next = cell;
      }
      ++_this.__js_helper$_length;
      _this._modified$0();
      return cell;
    },
    __js_helper$_unlinkCell$1: function(cell) {
      var _this = this,
        previous = cell._previous,
        next = cell._next;
      if (previous == null)
        _this._first = next;
      else
        previous._next = next;
      if (next == null)
        _this._last = previous;
      else
        next._previous = previous;
      --_this.__js_helper$_length;
      _this._modified$0();
    },
    internalComputeHashCode$1: function(key) {
      return J.get$hashCode$(key) & 0x3ffffff;
    },
    internalFindBucketIndex$2: function(bucket, key) {
      var $length, i;
      if (bucket == null)
        return -1;
      $length = bucket.length;
      for (i = 0; i < $length; ++i)
        if (J.$eq$(bucket[i].hashMapCellKey, key))
          return i;
      return -1;
    },
    toString$0: function(_) {
      return P.MapBase_mapToString(this);
    },
    _getTableCell$2: function(table, key) {
      return table[key];
    },
    _getTableBucket$2: function(table, key) {
      return table[key];
    },
    _setTableEntry$3: function(table, key, value) {
      table[key] = value;
    },
    _deleteTableEntry$2: function(table, key) {
      delete table[key];
    },
    _containsTableEntry$2: function(table, key) {
      return this._getTableCell$2(table, key) != null;
    },
    _newHashTable$0: function() {
      var _s20_ = "<non-identifier-key>",
        table = Object.create(null);
      this._setTableEntry$3(table, _s20_, table);
      this._deleteTableEntry$2(table, _s20_);
      return table;
    }
  };
  H.JsLinkedHashMap_values_closure.prototype = {
    call$1: function(each) {
      return this.$this.$index(0, each);
    },
    $signature: function() {
      var t1 = this.$this;
      return {func: 1, ret: H.getTypeArgumentByIndex(t1, 1), args: [H.getTypeArgumentByIndex(t1, 0)]};
    }
  };
  H.JsLinkedHashMap_addAll_closure.prototype = {
    call$2: function(key, value) {
      this.$this.$indexSet(0, key, value);
    },
    $signature: function() {
      var t1 = this.$this;
      return {func: 1, ret: P.Null, args: [H.getTypeArgumentByIndex(t1, 0), H.getTypeArgumentByIndex(t1, 1)]};
    }
  };
  H.LinkedHashMapCell.prototype = {};
  H.LinkedHashMapKeyIterable.prototype = {
    get$length: function(_) {
      return this._map.__js_helper$_length;
    },
    get$isEmpty: function(_) {
      return this._map.__js_helper$_length === 0;
    },
    get$iterator: function(_) {
      var t1 = this._map,
        t2 = new H.LinkedHashMapKeyIterator(t1, t1._modifications);
      t2._cell = t1._first;
      return t2;
    },
    contains$1: function(_, element) {
      return this._map.containsKey$1(element);
    }
  };
  H.LinkedHashMapKeyIterator.prototype = {
    get$current: function(_) {
      return this.__js_helper$_current;
    },
    moveNext$0: function() {
      var _this = this,
        t1 = _this._map;
      if (_this._modifications !== t1._modifications)
        throw H.wrapException(P.ConcurrentModificationError$(t1));
      else {
        t1 = _this._cell;
        if (t1 == null) {
          _this.__js_helper$_current = null;
          return false;
        } else {
          _this.__js_helper$_current = t1.hashMapCellKey;
          _this._cell = t1._next;
          return true;
        }
      }
    }
  };
  H.initHooks_closure.prototype = {
    call$1: function(o) {
      return this.getTag(o);
    },
    $signature: 10
  };
  H.initHooks_closure0.prototype = {
    call$2: function(o, tag) {
      return this.getUnknownTag(o, tag);
    }
  };
  H.initHooks_closure1.prototype = {
    call$1: function(tag) {
      return this.prototypeForTag(tag);
    }
  };
  H.JSSyntaxRegExp.prototype = {
    toString$0: function(_) {
      return "RegExp/" + this.pattern + "/" + this._nativeRegExp.flags;
    },
    get$_nativeGlobalVersion: function() {
      var _this = this,
        t1 = _this._nativeGlobalRegExp;
      if (t1 != null)
        return t1;
      t1 = _this._nativeRegExp;
      return _this._nativeGlobalRegExp = H.JSSyntaxRegExp_makeNative(_this.pattern, t1.multiline, !t1.ignoreCase, t1.unicode, t1.dotAll, true);
    },
    get$_nativeAnchoredVersion: function() {
      var _this = this,
        t1 = _this._nativeAnchoredRegExp;
      if (t1 != null)
        return t1;
      t1 = _this._nativeRegExp;
      return _this._nativeAnchoredRegExp = H.JSSyntaxRegExp_makeNative(_this.pattern + "|()", t1.multiline, !t1.ignoreCase, t1.unicode, t1.dotAll, true);
    },
    firstMatch$1: function(string) {
      var m;
      if (typeof string !== "string")
        H.throwExpression(H.argumentErrorValue(string));
      m = this._nativeRegExp.exec(string);
      if (m == null)
        return;
      return new H._MatchImplementation(m);
    },
    allMatches$2: function(_, string, start) {
      if (start > string.length)
        throw H.wrapException(P.RangeError$range(start, 0, string.length, null, null));
      return new H._AllMatchesIterable(this, string, start);
    },
    allMatches$1: function($receiver, string) {
      return this.allMatches$2($receiver, string, 0);
    },
    _execGlobal$2: function(string, start) {
      var match,
        regexp = this.get$_nativeGlobalVersion();
      regexp.lastIndex = start;
      match = regexp.exec(string);
      if (match == null)
        return;
      return new H._MatchImplementation(match);
    },
    _execAnchored$2: function(string, start) {
      var match,
        regexp = this.get$_nativeAnchoredVersion();
      regexp.lastIndex = start;
      match = regexp.exec(string);
      if (match == null)
        return;
      if (match.pop() != null)
        return;
      return new H._MatchImplementation(match);
    },
    matchAsPrefix$2: function(_, string, start) {
      if (start < 0 || start > string.length)
        throw H.wrapException(P.RangeError$range(start, 0, string.length, null, null));
      return this._execAnchored$2(string, start);
    }
  };
  H._MatchImplementation.prototype = {
    get$start: function(_) {
      return this._match.index;
    },
    get$end: function(_) {
      var t1 = this._match;
      return t1.index + t1[0].length;
    },
    $isMatch: 1,
    $isRegExpMatch: 1
  };
  H._AllMatchesIterable.prototype = {
    get$iterator: function(_) {
      return new H._AllMatchesIterator(this._re, this._string, this.__js_helper$_start);
    },
    $asIterable: function() {
      return [P.RegExpMatch];
    }
  };
  H._AllMatchesIterator.prototype = {
    get$current: function(_) {
      return this.__js_helper$_current;
    },
    moveNext$0: function() {
      var t2, t3, match, nextIndex, _this = this,
        t1 = _this._string;
      if (t1 == null)
        return false;
      t2 = _this._nextIndex;
      if (t2 <= t1.length) {
        t3 = _this._regExp;
        match = t3._execGlobal$2(t1, t2);
        if (match != null) {
          _this.__js_helper$_current = match;
          nextIndex = match.get$end(match);
          if (match._match.index === nextIndex) {
            if (t3._nativeRegExp.unicode) {
              t1 = _this._nextIndex;
              t2 = t1 + 1;
              t3 = _this._string;
              if (t2 < t3.length) {
                t1 = J.getInterceptor$s(t3).codeUnitAt$1(t3, t1);
                if (t1 >= 55296 && t1 <= 56319) {
                  t1 = C.JSString_methods.codeUnitAt$1(t3, t2);
                  t1 = t1 >= 56320 && t1 <= 57343;
                } else
                  t1 = false;
              } else
                t1 = false;
            } else
              t1 = false;
            nextIndex = (t1 ? nextIndex + 1 : nextIndex) + 1;
          }
          _this._nextIndex = nextIndex;
          return true;
        }
      }
      _this._string = _this.__js_helper$_current = null;
      return false;
    }
  };
  H.StringMatch.prototype = {
    get$end: function(_) {
      return this.start + this.pattern.length;
    },
    group$1: function(group_) {
      if (group_ !== 0)
        throw H.wrapException(P.RangeError$value(group_, null, null));
      return this.pattern;
    },
    $isMatch: 1,
    get$start: function(receiver) {
      return this.start;
    }
  };
  H._StringAllMatchesIterable.prototype = {
    get$iterator: function(_) {
      return new H._StringAllMatchesIterator(this._input, this._pattern, this.__js_helper$_index);
    },
    get$first: function(_) {
      var t1 = this._pattern,
        index = this._input.indexOf(t1, this.__js_helper$_index);
      if (index >= 0)
        return new H.StringMatch(index, t1);
      throw H.wrapException(H.IterableElementError_noElement());
    },
    $asIterable: function() {
      return [P.Match];
    }
  };
  H._StringAllMatchesIterator.prototype = {
    moveNext$0: function() {
      var index, end, _this = this,
        t1 = _this.__js_helper$_index,
        t2 = _this._pattern,
        t3 = t2.length,
        t4 = _this._input,
        t5 = t4.length;
      if (t1 + t3 > t5) {
        _this.__js_helper$_current = null;
        return false;
      }
      index = t4.indexOf(t2, t1);
      if (index < 0) {
        _this.__js_helper$_index = t5 + 1;
        _this.__js_helper$_current = null;
        return false;
      }
      end = index + t3;
      _this.__js_helper$_current = new H.StringMatch(index, t2);
      _this.__js_helper$_index = end === _this.__js_helper$_index ? end + 1 : end;
      return true;
    },
    get$current: function(_) {
      return this.__js_helper$_current;
    }
  };
  H.NativeTypedData.prototype = {
    _invalidPosition$3: function(receiver, position, $length, $name) {
      if (typeof position !== "number" || Math.floor(position) !== position)
        throw H.wrapException(P.ArgumentError$value(position, $name, "Invalid list position"));
      else
        throw H.wrapException(P.RangeError$range(position, 0, $length, $name, null));
    },
    _checkPosition$3: function(receiver, position, $length, $name) {
      if (position >>> 0 !== position || position > $length)
        this._invalidPosition$3(receiver, position, $length, $name);
    }
  };
  H.NativeTypedArray.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    },
    _setRangeFast$4: function(receiver, start, end, source, skipCount) {
      var count, sourceLength,
        targetLength = receiver.length;
      this._checkPosition$3(receiver, start, targetLength, "start");
      this._checkPosition$3(receiver, end, targetLength, "end");
      if (start > end)
        throw H.wrapException(P.RangeError$range(start, 0, end, null, null));
      count = end - start;
      if (skipCount < 0)
        throw H.wrapException(P.ArgumentError$(skipCount));
      sourceLength = source.length;
      if (sourceLength - skipCount < count)
        throw H.wrapException(P.StateError$("Not enough elements"));
      if (skipCount !== 0 || sourceLength !== count)
        source = source.subarray(skipCount, skipCount + count);
      receiver.set(source, start);
    },
    $isJavaScriptIndexingBehavior: 1,
    $asJavaScriptIndexingBehavior: function() {
    }
  };
  H.NativeTypedArrayOfDouble.prototype = {
    $index: function(receiver, index) {
      H._checkValidIndex(index, receiver, receiver.length);
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      H._checkValidIndex(index, receiver, receiver.length);
      receiver[index] = value;
    },
    setRange$4: function(receiver, start, end, iterable, skipCount) {
      if (!!J.getInterceptor$(iterable).$isNativeTypedArrayOfDouble) {
        this._setRangeFast$4(receiver, start, end, iterable, skipCount);
        return;
      }
      this.super$ListMixin$setRange(receiver, start, end, iterable, skipCount);
    },
    $isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [P.double];
    },
    $asListMixin: function() {
      return [P.double];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [P.double];
    },
    $isList: 1,
    $asList: function() {
      return [P.double];
    }
  };
  H.NativeTypedArrayOfInt.prototype = {
    $indexSet: function(receiver, index, value) {
      H._checkValidIndex(index, receiver, receiver.length);
      receiver[index] = value;
    },
    setRange$4: function(receiver, start, end, iterable, skipCount) {
      if (!!J.getInterceptor$(iterable).$isNativeTypedArrayOfInt) {
        this._setRangeFast$4(receiver, start, end, iterable, skipCount);
        return;
      }
      this.super$ListMixin$setRange(receiver, start, end, iterable, skipCount);
    },
    $isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [P.int];
    },
    $asListMixin: function() {
      return [P.int];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [P.int];
    },
    $isList: 1,
    $asList: function() {
      return [P.int];
    }
  };
  H.NativeFloat32List.prototype = {
    sublist$2: function(receiver, start, end) {
      return new Float32Array(receiver.subarray(start, H._checkValidRange(start, end, receiver.length)));
    }
  };
  H.NativeFloat64List.prototype = {
    sublist$2: function(receiver, start, end) {
      return new Float64Array(receiver.subarray(start, H._checkValidRange(start, end, receiver.length)));
    }
  };
  H.NativeInt16List.prototype = {
    $index: function(receiver, index) {
      H._checkValidIndex(index, receiver, receiver.length);
      return receiver[index];
    },
    sublist$2: function(receiver, start, end) {
      return new Int16Array(receiver.subarray(start, H._checkValidRange(start, end, receiver.length)));
    }
  };
  H.NativeInt32List.prototype = {
    $index: function(receiver, index) {
      H._checkValidIndex(index, receiver, receiver.length);
      return receiver[index];
    },
    sublist$2: function(receiver, start, end) {
      return new Int32Array(receiver.subarray(start, H._checkValidRange(start, end, receiver.length)));
    }
  };
  H.NativeInt8List.prototype = {
    $index: function(receiver, index) {
      H._checkValidIndex(index, receiver, receiver.length);
      return receiver[index];
    },
    sublist$2: function(receiver, start, end) {
      return new Int8Array(receiver.subarray(start, H._checkValidRange(start, end, receiver.length)));
    }
  };
  H.NativeUint16List.prototype = {
    $index: function(receiver, index) {
      H._checkValidIndex(index, receiver, receiver.length);
      return receiver[index];
    },
    sublist$2: function(receiver, start, end) {
      return new Uint16Array(receiver.subarray(start, H._checkValidRange(start, end, receiver.length)));
    }
  };
  H.NativeUint32List.prototype = {
    $index: function(receiver, index) {
      H._checkValidIndex(index, receiver, receiver.length);
      return receiver[index];
    },
    sublist$2: function(receiver, start, end) {
      return new Uint32Array(receiver.subarray(start, H._checkValidRange(start, end, receiver.length)));
    }
  };
  H.NativeUint8ClampedList.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      H._checkValidIndex(index, receiver, receiver.length);
      return receiver[index];
    },
    sublist$2: function(receiver, start, end) {
      return new Uint8ClampedArray(receiver.subarray(start, H._checkValidRange(start, end, receiver.length)));
    }
  };
  H.NativeUint8List.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      H._checkValidIndex(index, receiver, receiver.length);
      return receiver[index];
    },
    sublist$2: function(receiver, start, end) {
      return new Uint8Array(receiver.subarray(start, H._checkValidRange(start, end, receiver.length)));
    },
    $isNativeUint8List: 1,
    $isUint8List: 1
  };
  H._NativeTypedArrayOfDouble_NativeTypedArray_ListMixin.prototype = {};
  H._NativeTypedArrayOfDouble_NativeTypedArray_ListMixin_FixedLengthListMixin.prototype = {};
  H._NativeTypedArrayOfInt_NativeTypedArray_ListMixin.prototype = {};
  H._NativeTypedArrayOfInt_NativeTypedArray_ListMixin_FixedLengthListMixin.prototype = {};
  P._AsyncRun__initializeScheduleImmediate_internalCallback.prototype = {
    call$1: function(_) {
      var t1 = this._box_0,
        f = t1.storedCallback;
      t1.storedCallback = null;
      f.call$0();
    },
    $signature: 17
  };
  P._AsyncRun__initializeScheduleImmediate_closure.prototype = {
    call$1: function(callback) {
      var t1, t2;
      this._box_0.storedCallback = callback;
      t1 = this.div;
      t2 = this.span;
      t1.firstChild ? t1.removeChild(t2) : t1.appendChild(t2);
    }
  };
  P._AsyncRun__scheduleImmediateJsOverride_internalCallback.prototype = {
    call$0: function() {
      this.callback.call$0();
    },
    "call*": "call$0",
    $requiredArgCount: 0
  };
  P._AsyncRun__scheduleImmediateWithSetImmediate_internalCallback.prototype = {
    call$0: function() {
      this.callback.call$0();
    },
    "call*": "call$0",
    $requiredArgCount: 0
  };
  P._TimerImpl.prototype = {
    _TimerImpl$2: function(milliseconds, callback) {
      if (self.setTimeout != null)
        this._handle = self.setTimeout(H.convertDartClosureToJS(new P._TimerImpl_internalCallback(this, callback), 0), milliseconds);
      else
        throw H.wrapException(P.UnsupportedError$("`setTimeout()` not found."));
    },
    _TimerImpl$periodic$2: function(milliseconds, callback) {
      if (self.setTimeout != null)
        this._handle = self.setInterval(H.convertDartClosureToJS(new P._TimerImpl$periodic_closure(this, milliseconds, Date.now(), callback), 0), milliseconds);
      else
        throw H.wrapException(P.UnsupportedError$("Periodic timer."));
    },
    cancel$0: function() {
      if (self.setTimeout != null) {
        var t1 = this._handle;
        if (t1 == null)
          return;
        if (this._once)
          self.clearTimeout(t1);
        else
          self.clearInterval(t1);
        this._handle = null;
      } else
        throw H.wrapException(P.UnsupportedError$("Canceling a timer."));
    }
  };
  P._TimerImpl_internalCallback.prototype = {
    call$0: function() {
      var t1 = this.$this;
      t1._handle = null;
      t1._tick = 1;
      this.callback.call$0();
    },
    "call*": "call$0",
    $requiredArgCount: 0
  };
  P._TimerImpl$periodic_closure.prototype = {
    call$0: function() {
      var duration, _this = this,
        t1 = _this.$this,
        tick = t1._tick + 1,
        t2 = _this.milliseconds;
      if (t2 > 0) {
        duration = Date.now() - _this.start;
        if (duration > (tick + 1) * t2)
          tick = C.JSInt_methods.$tdiv(duration, t2);
      }
      t1._tick = tick;
      _this.callback.call$1(t1);
    },
    "call*": "call$0",
    $requiredArgCount: 0
  };
  P._AsyncAwaitCompleter.prototype = {
    complete$1: function(value) {
      var t1, _this = this;
      if (_this.isSync)
        _this._completer.complete$1(value);
      else if (H.checkSubtype(value, "$isFuture", _this.$ti, "$asFuture")) {
        t1 = _this._completer;
        value.then$1$2$onError(t1.get$complete(), t1.get$completeError(), -1);
      } else
        P.scheduleMicrotask(new P._AsyncAwaitCompleter_complete_closure(_this, value));
    },
    completeError$2: function(e, st) {
      if (this.isSync)
        this._completer.completeError$2(e, st);
      else
        P.scheduleMicrotask(new P._AsyncAwaitCompleter_completeError_closure(this, e, st));
    }
  };
  P._AsyncAwaitCompleter_complete_closure.prototype = {
    call$0: function() {
      this.$this._completer.complete$1(this.value);
    },
    "call*": "call$0",
    $requiredArgCount: 0
  };
  P._AsyncAwaitCompleter_completeError_closure.prototype = {
    call$0: function() {
      this.$this._completer.completeError$2(this.e, this.st);
    },
    "call*": "call$0",
    $requiredArgCount: 0
  };
  P._awaitOnObject_closure.prototype = {
    call$1: function(result) {
      return this.bodyFunction.call$2(0, result);
    },
    $signature: 29
  };
  P._awaitOnObject_closure0.prototype = {
    call$2: function(error, stackTrace) {
      this.bodyFunction.call$2(1, new H.ExceptionAndStackTrace(error, stackTrace));
    },
    "call*": "call$2",
    $requiredArgCount: 2,
    $signature: 18
  };
  P._wrapJsFunctionForAsync_closure.prototype = {
    call$2: function(errorCode, result) {
      this.$protected(errorCode, result);
    },
    "call*": "call$2",
    $requiredArgCount: 2
  };
  P._asyncStarHelper_closure.prototype = {
    call$0: function() {
      var t1 = this.controller,
        t2 = t1.controller,
        t3 = t2._async$_state;
      if ((t3 & 1) !== 0 ? (t2.get$_subscription()._async$_state & 4) !== 0 : (t3 & 2) === 0) {
        t1.isSuspended = true;
        return;
      }
      this.bodyFunctionOrErrorCode.call$2(null, 0);
    },
    "call*": "call$0",
    $requiredArgCount: 0
  };
  P._asyncStarHelper_closure0.prototype = {
    call$1: function(_) {
      var errorCode = this.controller.cancelationCompleter != null ? 2 : 0;
      this.bodyFunctionOrErrorCode.call$2(errorCode, null);
    },
    $signature: 17
  };
  P._AsyncStarStreamController.prototype = {
    add$1: function(_, $event) {
      return this.controller.add$1(0, $event);
    },
    _AsyncStarStreamController$1: function(body, $T) {
      var t1 = new P._AsyncStarStreamController__resumeBody(body);
      this.controller = P.StreamController_StreamController(new P._AsyncStarStreamController_closure(this, body), new P._AsyncStarStreamController_closure0(t1), null, new P._AsyncStarStreamController_closure1(this, t1), false, $T);
    }
  };
  P._AsyncStarStreamController__resumeBody.prototype = {
    call$0: function() {
      P.scheduleMicrotask(new P._AsyncStarStreamController__resumeBody_closure(this.body));
    }
  };
  P._AsyncStarStreamController__resumeBody_closure.prototype = {
    call$0: function() {
      this.body.call$2(0, null);
    },
    "call*": "call$0",
    $requiredArgCount: 0
  };
  P._AsyncStarStreamController_closure0.prototype = {
    call$0: function() {
      this._resumeBody.call$0();
    }
  };
  P._AsyncStarStreamController_closure1.prototype = {
    call$0: function() {
      var t1 = this.$this;
      if (t1.isSuspended) {
        t1.isSuspended = false;
        this._resumeBody.call$0();
      }
    }
  };
  P._AsyncStarStreamController_closure.prototype = {
    call$0: function() {
      var t1 = this.$this;
      if ((t1.controller._async$_state & 4) === 0) {
        t1.cancelationCompleter = new P._AsyncCompleter(new P._Future($.Zone__current, [null]), [null]);
        if (t1.isSuspended) {
          t1.isSuspended = false;
          P.scheduleMicrotask(new P._AsyncStarStreamController__closure(this.body));
        }
        return t1.cancelationCompleter.future;
      }
    },
    "call*": "call$0",
    $requiredArgCount: 0
  };
  P._AsyncStarStreamController__closure.prototype = {
    call$0: function() {
      this.body.call$2(2, null);
    },
    "call*": "call$0",
    $requiredArgCount: 0
  };
  P._IterationMarker.prototype = {
    toString$0: function(_) {
      return "IterationMarker(" + this.state + ", " + H.S(this.value) + ")";
    }
  };
  P._SyncStarIterator.prototype = {
    get$current: function(_) {
      var t1 = this._nestedIterator;
      if (t1 == null)
        return this._async$_current;
      return t1.get$current(t1);
    },
    moveNext$0: function() {
      var t1, value, state, inner, _this = this;
      for (; true;) {
        t1 = _this._nestedIterator;
        if (t1 != null)
          if (t1.moveNext$0())
            return true;
          else
            _this._nestedIterator = null;
        value = function(body, SUCCESS, ERROR) {
          var errorValue,
            errorCode = SUCCESS;
          while (true)
            try {
              return body(errorCode, errorValue);
            } catch (error) {
              errorValue = error;
              errorCode = ERROR;
            }
        }(_this._body, 0, 1);
        if (value instanceof P._IterationMarker) {
          state = value.state;
          if (state === 2) {
            t1 = _this._suspendedBodies;
            if (t1 == null || t1.length === 0) {
              _this._async$_current = null;
              return false;
            }
            _this._body = t1.pop();
            continue;
          } else {
            t1 = value.value;
            if (state === 3)
              throw t1;
            else {
              inner = J.get$iterator$ax(t1);
              if (!!inner.$is_SyncStarIterator) {
                t1 = _this._suspendedBodies;
                if (t1 == null)
                  t1 = _this._suspendedBodies = [];
                t1.push(_this._body);
                _this._body = inner._body;
                continue;
              } else {
                _this._nestedIterator = inner;
                continue;
              }
            }
          }
        } else {
          _this._async$_current = value;
          return true;
        }
      }
      return false;
    }
  };
  P._SyncStarIterable.prototype = {
    get$iterator: function(_) {
      return new P._SyncStarIterator(this._outerHelper());
    }
  };
  P._BroadcastStream.prototype = {
    get$isBroadcast: function() {
      return true;
    }
  };
  P._BroadcastSubscription.prototype = {
    _async$_onPause$0: function() {
    },
    _async$_onResume$0: function() {
    }
  };
  P._BroadcastStreamController.prototype = {
    set$onPause: function(onPauseHandler) {
      throw H.wrapException(P.UnsupportedError$("Broadcast stream controllers do not support pause callbacks"));
    },
    set$onResume: function(onResumeHandler) {
      throw H.wrapException(P.UnsupportedError$("Broadcast stream controllers do not support pause callbacks"));
    },
    get$stream: function() {
      return new P._BroadcastStream(this, this.$ti);
    },
    get$_mayAddEvent: function() {
      return this._async$_state < 4;
    },
    _ensureDoneFuture$0: function() {
      var t1 = this._doneFuture;
      if (t1 != null)
        return t1;
      return this._doneFuture = new P._Future($.Zone__current, [null]);
    },
    _removeListener$1: function(subscription) {
      var previous = subscription._async$_previous,
        next = subscription._async$_next;
      if (previous == null)
        this._firstSubscription = next;
      else
        previous._async$_next = next;
      if (next == null)
        this._lastSubscription = previous;
      else
        next._async$_previous = previous;
      subscription._async$_previous = subscription;
      subscription._async$_next = subscription;
    },
    _subscribe$4: function(onData, onError, onDone, cancelOnError) {
      var t1, t2, subscription, oldLast, _this = this;
      if ((_this._async$_state & 4) !== 0) {
        if (onDone == null)
          onDone = P.async___nullDoneHandler$closure();
        t1 = new P._DoneStreamSubscription($.Zone__current, onDone, _this.$ti);
        t1._schedule$0();
        return t1;
      }
      t1 = $.Zone__current;
      t2 = cancelOnError ? 1 : 0;
      subscription = new P._BroadcastSubscription(_this, t1, t2, _this.$ti);
      subscription._BufferingStreamSubscription$4(onData, onError, onDone, cancelOnError, H.getTypeArgumentByIndex(_this, 0));
      subscription._async$_previous = subscription;
      subscription._async$_next = subscription;
      subscription._eventState = _this._async$_state & 1;
      oldLast = _this._lastSubscription;
      _this._lastSubscription = subscription;
      subscription._async$_next = null;
      subscription._async$_previous = oldLast;
      if (oldLast == null)
        _this._firstSubscription = subscription;
      else
        oldLast._async$_next = subscription;
      if (_this._firstSubscription === subscription)
        P._runGuarded(_this.onListen);
      return subscription;
    },
    _recordCancel$1: function(sub) {
      var t1, _this = this;
      if (sub._async$_next === sub)
        return;
      t1 = sub._eventState;
      if ((t1 & 2) !== 0)
        sub._eventState = t1 | 4;
      else {
        _this._removeListener$1(sub);
        if ((_this._async$_state & 2) === 0 && _this._firstSubscription == null)
          _this._callOnCancel$0();
      }
      return;
    },
    _recordPause$1: function(subscription) {
    },
    _recordResume$1: function(subscription) {
    },
    _addEventError$0: function() {
      if ((this._async$_state & 4) !== 0)
        return new P.StateError("Cannot add new events after calling close");
      return new P.StateError("Cannot add new events while doing an addStream");
    },
    add$1: function(_, data) {
      if (!this.get$_mayAddEvent())
        throw H.wrapException(this._addEventError$0());
      this._sendData$1(data);
    },
    addError$2: function(error, stackTrace) {
      var replacement;
      if (error == null)
        error = new P.NullThrownError();
      if (!this.get$_mayAddEvent())
        throw H.wrapException(this._addEventError$0());
      replacement = $.Zone__current.errorCallback$2(error, stackTrace);
      if (replacement != null) {
        error = replacement.error;
        if (error == null)
          error = new P.NullThrownError();
        stackTrace = replacement.stackTrace;
      }
      this._sendError$2(error, stackTrace);
    },
    close$0: function(_) {
      var doneFuture, _this = this;
      if ((_this._async$_state & 4) !== 0)
        return _this._doneFuture;
      if (!_this.get$_mayAddEvent())
        throw H.wrapException(_this._addEventError$0());
      _this._async$_state |= 4;
      doneFuture = _this._ensureDoneFuture$0();
      _this._sendDone$0();
      return doneFuture;
    },
    _forEachListener$1: function(action) {
      var subscription, id, next, _this = this,
        t1 = _this._async$_state;
      if ((t1 & 2) !== 0)
        throw H.wrapException(P.StateError$("Cannot fire new event. Controller is already firing an event"));
      subscription = _this._firstSubscription;
      if (subscription == null)
        return;
      id = t1 & 1;
      _this._async$_state = t1 ^ 3;
      for (; subscription != null;) {
        t1 = subscription._eventState;
        if ((t1 & 1) === id) {
          subscription._eventState = t1 | 2;
          action.call$1(subscription);
          t1 = subscription._eventState ^= 1;
          next = subscription._async$_next;
          if ((t1 & 4) !== 0)
            _this._removeListener$1(subscription);
          subscription._eventState &= 4294967293;
          subscription = next;
        } else
          subscription = subscription._async$_next;
      }
      _this._async$_state &= 4294967293;
      if (_this._firstSubscription == null)
        _this._callOnCancel$0();
    },
    _callOnCancel$0: function() {
      var _this = this;
      if ((_this._async$_state & 4) !== 0 && _this._doneFuture._async$_state === 0)
        _this._doneFuture._asyncComplete$1(null);
      P._runGuarded(_this.onCancel);
    },
    $isEventSink: 1,
    set$onListen: function(val) {
      return this.onListen = val;
    },
    set$onCancel: function(val) {
      return this.onCancel = val;
    }
  };
  P._SyncBroadcastStreamController.prototype = {
    get$_mayAddEvent: function() {
      return P._BroadcastStreamController.prototype.get$_mayAddEvent.call(this) && (this._async$_state & 2) === 0;
    },
    _addEventError$0: function() {
      if ((this._async$_state & 2) !== 0)
        return new P.StateError("Cannot fire new event. Controller is already firing an event");
      return this.super$_BroadcastStreamController$_addEventError();
    },
    _sendData$1: function(data) {
      var _this = this,
        t1 = _this._firstSubscription;
      if (t1 == null)
        return;
      if (t1 === _this._lastSubscription) {
        _this._async$_state |= 2;
        t1._async$_add$1(data);
        _this._async$_state &= 4294967293;
        if (_this._firstSubscription == null)
          _this._callOnCancel$0();
        return;
      }
      _this._forEachListener$1(new P._SyncBroadcastStreamController__sendData_closure(data));
    },
    _sendError$2: function(error, stackTrace) {
      if (this._firstSubscription == null)
        return;
      this._forEachListener$1(new P._SyncBroadcastStreamController__sendError_closure(error, stackTrace));
    },
    _sendDone$0: function() {
      if (this._firstSubscription != null)
        this._forEachListener$1(new P._SyncBroadcastStreamController__sendDone_closure());
      else
        this._doneFuture._asyncComplete$1(null);
    }
  };
  P._SyncBroadcastStreamController__sendData_closure.prototype = {
    call$1: function(subscription) {
      subscription._async$_add$1(this.data);
    }
  };
  P._SyncBroadcastStreamController__sendError_closure.prototype = {
    call$1: function(subscription) {
      subscription._addError$2(this.error, this.stackTrace);
    }
  };
  P._SyncBroadcastStreamController__sendDone_closure.prototype = {
    call$1: function(subscription) {
      subscription._close$0();
    }
  };
  P.Future.prototype = {};
  P.Future_wait_handleError.prototype = {
    call$2: function(theError, theStackTrace) {
      var _this = this,
        t1 = _this._box_0,
        t2 = --t1.remaining;
      if (t1.values != null) {
        t1.values = null;
        if (t1.remaining === 0 || _this.eagerError)
          _this.result._completeError$2(theError, theStackTrace);
        else {
          t1.error = theError;
          t1.stackTrace = theStackTrace;
        }
      } else if (t2 === 0 && !_this.eagerError)
        _this.result._completeError$2(t1.error, t1.stackTrace);
    },
    "call*": "call$2",
    $requiredArgCount: 2,
    $signature: 18
  };
  P.Future_wait_closure.prototype = {
    call$1: function(value) {
      var _this = this,
        t1 = _this._box_0,
        t2 = --t1.remaining,
        t3 = t1.values;
      if (t3 != null) {
        t3[_this.pos] = value;
        if (t2 === 0)
          _this.result._completeWithValue$1(t3);
      } else if (t1.remaining === 0 && !_this.eagerError)
        _this.result._completeError$2(t1.error, t1.stackTrace);
    },
    $signature: function() {
      return {func: 1, ret: P.Null, args: [this.T]};
    }
  };
  P._Completer.prototype = {
    completeError$2: function(error, stackTrace) {
      var replacement;
      if (error == null)
        error = new P.NullThrownError();
      if (this.future._async$_state !== 0)
        throw H.wrapException(P.StateError$("Future already completed"));
      replacement = $.Zone__current.errorCallback$2(error, stackTrace);
      if (replacement != null) {
        error = replacement.error;
        if (error == null)
          error = new P.NullThrownError();
        stackTrace = replacement.stackTrace;
      }
      this._completeError$2(error, stackTrace);
    },
    completeError$1: function(error) {
      return this.completeError$2(error, null);
    }
  };
  P._AsyncCompleter.prototype = {
    complete$1: function(value) {
      var t1 = this.future;
      if (t1._async$_state !== 0)
        throw H.wrapException(P.StateError$("Future already completed"));
      t1._asyncComplete$1(value);
    },
    complete$0: function() {
      return this.complete$1(null);
    },
    _completeError$2: function(error, stackTrace) {
      this.future._asyncCompleteError$2(error, stackTrace);
    }
  };
  P._SyncCompleter.prototype = {
    complete$1: function(value) {
      var t1 = this.future;
      if (t1._async$_state !== 0)
        throw H.wrapException(P.StateError$("Future already completed"));
      t1._complete$1(value);
    },
    complete$0: function() {
      return this.complete$1(null);
    },
    _completeError$2: function(error, stackTrace) {
      this.future._completeError$2(error, stackTrace);
    }
  };
  P._FutureListener.prototype = {
    matchesErrorTest$1: function(asyncError) {
      if (this.state !== 6)
        return true;
      return this.result._zone.runUnary$2(this.callback, asyncError.error);
    },
    handleError$1: function(asyncError) {
      var errorCallback = this.errorCallback,
        t1 = this.result._zone;
      if (H.functionTypeTest(errorCallback, {func: 1, args: [P.Object, P.StackTrace]}))
        return t1.runBinary$3(errorCallback, asyncError.error, asyncError.stackTrace);
      else
        return t1.runUnary$2(errorCallback, asyncError.error);
    }
  };
  P._Future.prototype = {
    then$1$2$onError: function(f, onError, $R) {
      var currentZone = $.Zone__current;
      if (currentZone !== C.C__RootZone) {
        f = currentZone.registerUnaryCallback$1(f);
        if (onError != null)
          onError = P._registerErrorHandler(onError, currentZone);
      }
      return this._thenNoZoneRegistration$1$2(f, onError, $R);
    },
    then$1$1: function(f, $R) {
      return this.then$1$2$onError(f, null, $R);
    },
    then$1: function(f) {
      return this.then$1$2$onError(f, null, null);
    },
    _thenNoZoneRegistration$1$2: function(f, onError, $E) {
      var result = new P._Future($.Zone__current, [$E]);
      this._addListener$1(new P._FutureListener(result, onError == null ? 1 : 3, f, onError));
      return result;
    },
    whenComplete$1: function(action) {
      var t1 = $.Zone__current,
        result = new P._Future(t1, this.$ti);
      this._addListener$1(new P._FutureListener(result, 8, t1 !== C.C__RootZone ? t1.registerCallback$1(action) : action, null));
      return result;
    },
    _addListener$1: function(listener) {
      var t2, _this = this,
        t1 = _this._async$_state;
      if (t1 <= 1) {
        listener._nextListener = _this._resultOrListeners;
        _this._resultOrListeners = listener;
      } else {
        if (t1 === 2) {
          t1 = _this._resultOrListeners;
          t2 = t1._async$_state;
          if (t2 < 4) {
            t1._addListener$1(listener);
            return;
          }
          _this._async$_state = t2;
          _this._resultOrListeners = t1._resultOrListeners;
        }
        _this._zone.scheduleMicrotask$1(new P._Future__addListener_closure(_this, listener));
      }
    },
    _prependListeners$1: function(listeners) {
      var t1, existingListeners, cursor, cursor0, t2, _this = this, _box_0 = {};
      _box_0.listeners = listeners;
      if (listeners == null)
        return;
      t1 = _this._async$_state;
      if (t1 <= 1) {
        existingListeners = _this._resultOrListeners;
        cursor = _this._resultOrListeners = listeners;
        if (existingListeners != null) {
          for (; cursor0 = cursor._nextListener, cursor0 != null; cursor = cursor0)
            ;
          cursor._nextListener = existingListeners;
        }
      } else {
        if (t1 === 2) {
          t1 = _this._resultOrListeners;
          t2 = t1._async$_state;
          if (t2 < 4) {
            t1._prependListeners$1(listeners);
            return;
          }
          _this._async$_state = t2;
          _this._resultOrListeners = t1._resultOrListeners;
        }
        _box_0.listeners = _this._reverseListeners$1(listeners);
        _this._zone.scheduleMicrotask$1(new P._Future__prependListeners_closure(_box_0, _this));
      }
    },
    _removeListeners$0: function() {
      var current = this._resultOrListeners;
      this._resultOrListeners = null;
      return this._reverseListeners$1(current);
    },
    _reverseListeners$1: function(listeners) {
      var current, prev, next;
      for (current = listeners, prev = null; current != null; prev = current, current = next) {
        next = current._nextListener;
        current._nextListener = prev;
      }
      return prev;
    },
    _complete$1: function(value) {
      var listeners, _this = this,
        t1 = _this.$ti;
      if (H.checkSubtype(value, "$isFuture", t1, "$asFuture"))
        if (H.checkSubtype(value, "$is_Future", t1, null))
          P._Future__chainCoreFuture(value, _this);
        else
          P._Future__chainForeignFuture(value, _this);
      else {
        listeners = _this._removeListeners$0();
        _this._async$_state = 4;
        _this._resultOrListeners = value;
        P._Future__propagateToListeners(_this, listeners);
      }
    },
    _completeWithValue$1: function(value) {
      var _this = this,
        listeners = _this._removeListeners$0();
      _this._async$_state = 4;
      _this._resultOrListeners = value;
      P._Future__propagateToListeners(_this, listeners);
    },
    _completeError$2: function(error, stackTrace) {
      var _this = this,
        listeners = _this._removeListeners$0();
      _this._async$_state = 8;
      _this._resultOrListeners = new P.AsyncError(error, stackTrace);
      P._Future__propagateToListeners(_this, listeners);
    },
    _completeError$1: function(error) {
      return this._completeError$2(error, null);
    },
    _asyncComplete$1: function(value) {
      var _this = this;
      if (H.checkSubtype(value, "$isFuture", _this.$ti, "$asFuture")) {
        _this._chainFuture$1(value);
        return;
      }
      _this._async$_state = 1;
      _this._zone.scheduleMicrotask$1(new P._Future__asyncComplete_closure(_this, value));
    },
    _chainFuture$1: function(value) {
      var _this = this;
      if (H.checkSubtype(value, "$is_Future", _this.$ti, null)) {
        if (value._async$_state === 8) {
          _this._async$_state = 1;
          _this._zone.scheduleMicrotask$1(new P._Future__chainFuture_closure(_this, value));
        } else
          P._Future__chainCoreFuture(value, _this);
        return;
      }
      P._Future__chainForeignFuture(value, _this);
    },
    _asyncCompleteError$2: function(error, stackTrace) {
      this._async$_state = 1;
      this._zone.scheduleMicrotask$1(new P._Future__asyncCompleteError_closure(this, error, stackTrace));
    },
    $isFuture: 1
  };
  P._Future__addListener_closure.prototype = {
    call$0: function() {
      P._Future__propagateToListeners(this.$this, this.listener);
    },
    "call*": "call$0",
    $requiredArgCount: 0
  };
  P._Future__prependListeners_closure.prototype = {
    call$0: function() {
      P._Future__propagateToListeners(this.$this, this._box_0.listeners);
    },
    "call*": "call$0",
    $requiredArgCount: 0
  };
  P._Future__chainForeignFuture_closure.prototype = {
    call$1: function(value) {
      var t1 = this.target;
      t1._async$_state = 0;
      t1._complete$1(value);
    },
    $signature: 17
  };
  P._Future__chainForeignFuture_closure0.prototype = {
    call$2: function(error, stackTrace) {
      this.target._completeError$2(error, stackTrace);
    },
    call$1: function(error) {
      return this.call$2(error, null);
    },
    "call*": "call$2",
    $defaultValues: function() {
      return [null];
    },
    $signature: 51
  };
  P._Future__chainForeignFuture_closure1.prototype = {
    call$0: function() {
      this.target._completeError$2(this.e, this.s);
    },
    "call*": "call$0",
    $requiredArgCount: 0
  };
  P._Future__asyncComplete_closure.prototype = {
    call$0: function() {
      this.$this._completeWithValue$1(this.value);
    },
    "call*": "call$0",
    $requiredArgCount: 0
  };
  P._Future__chainFuture_closure.prototype = {
    call$0: function() {
      P._Future__chainCoreFuture(this.value, this.$this);
    },
    "call*": "call$0",
    $requiredArgCount: 0
  };
  P._Future__asyncCompleteError_closure.prototype = {
    call$0: function() {
      this.$this._completeError$2(this.error, this.stackTrace);
    },
    "call*": "call$0",
    $requiredArgCount: 0
  };
  P._Future__propagateToListeners_handleWhenCompleteCallback.prototype = {
    call$0: function() {
      var e, s, t1, exception, t2, originalSource, _this = this, completeResult = null;
      try {
        t1 = _this.listener;
        completeResult = t1.result._zone.run$1(0, t1.callback);
      } catch (exception) {
        e = H.unwrapException(exception);
        s = H.getTraceFromException(exception);
        if (_this.hasError) {
          t1 = _this._box_1.source._resultOrListeners.error;
          t2 = e;
          t2 = t1 == null ? t2 == null : t1 === t2;
          t1 = t2;
        } else
          t1 = false;
        t2 = _this._box_0;
        if (t1)
          t2.listenerValueOrError = _this._box_1.source._resultOrListeners;
        else
          t2.listenerValueOrError = new P.AsyncError(e, s);
        t2.listenerHasError = true;
        return;
      }
      if (!!J.getInterceptor$(completeResult).$isFuture) {
        if (completeResult instanceof P._Future && completeResult._async$_state >= 4) {
          if (completeResult._async$_state === 8) {
            t1 = _this._box_0;
            t1.listenerValueOrError = completeResult._resultOrListeners;
            t1.listenerHasError = true;
          }
          return;
        }
        originalSource = _this._box_1.source;
        t1 = _this._box_0;
        t1.listenerValueOrError = completeResult.then$1$1(new P._Future__propagateToListeners_handleWhenCompleteCallback_closure(originalSource), null);
        t1.listenerHasError = false;
      }
    }
  };
  P._Future__propagateToListeners_handleWhenCompleteCallback_closure.prototype = {
    call$1: function(_) {
      return this.originalSource;
    },
    $signature: 45
  };
  P._Future__propagateToListeners_handleValueCallback.prototype = {
    call$0: function() {
      var e, s, t1, exception, _this = this;
      try {
        t1 = _this.listener;
        _this._box_0.listenerValueOrError = t1.result._zone.runUnary$2(t1.callback, _this.sourceResult);
      } catch (exception) {
        e = H.unwrapException(exception);
        s = H.getTraceFromException(exception);
        t1 = _this._box_0;
        t1.listenerValueOrError = new P.AsyncError(e, s);
        t1.listenerHasError = true;
      }
    }
  };
  P._Future__propagateToListeners_handleError.prototype = {
    call$0: function() {
      var asyncError, e, s, t1, t2, exception, t3, t4, _this = this;
      try {
        asyncError = _this._box_1.source._resultOrListeners;
        t1 = _this.listener;
        if (t1.matchesErrorTest$1(asyncError) && t1.errorCallback != null) {
          t2 = _this._box_0;
          t2.listenerValueOrError = t1.handleError$1(asyncError);
          t2.listenerHasError = false;
        }
      } catch (exception) {
        e = H.unwrapException(exception);
        s = H.getTraceFromException(exception);
        t1 = _this._box_1.source._resultOrListeners;
        t2 = t1.error;
        t3 = e;
        t4 = _this._box_0;
        if (t2 == null ? t3 == null : t2 === t3)
          t4.listenerValueOrError = t1;
        else
          t4.listenerValueOrError = new P.AsyncError(e, s);
        t4.listenerHasError = true;
      }
    }
  };
  P._AsyncCallbackEntry.prototype = {};
  P.Stream.prototype = {
    get$isBroadcast: function() {
      return false;
    },
    get$length: function(_) {
      var t1 = {},
        future = new P._Future($.Zone__current, [P.int]);
      t1.count = 0;
      this.listen$4$cancelOnError$onDone$onError(new P.Stream_length_closure(t1, this), true, new P.Stream_length_closure0(t1, future), future.get$_completeError());
      return future;
    }
  };
  P.Stream_Stream$fromFuture_closure.prototype = {
    call$1: function(value) {
      var t1 = this.controller;
      t1._async$_add$1(value);
      t1._closeUnchecked$0();
    },
    $signature: function() {
      return {func: 1, ret: P.Null, args: [this.T]};
    }
  };
  P.Stream_Stream$fromFuture_closure0.prototype = {
    call$2: function(error, stackTrace) {
      var t1 = this.controller;
      t1._addError$2(error, stackTrace);
      t1._closeUnchecked$0();
    },
    "call*": "call$2",
    $requiredArgCount: 2,
    $signature: 12
  };
  P.Stream_length_closure.prototype = {
    call$1: function(_) {
      ++this._box_0.count;
    },
    $signature: function() {
      return {func: 1, ret: P.Null, args: [H.getRuntimeTypeArgument(this.$this, "Stream", 0)]};
    }
  };
  P.Stream_length_closure0.prototype = {
    call$0: function() {
      this.future._complete$1(this._box_0.count);
    },
    "call*": "call$0",
    $requiredArgCount: 0
  };
  P.StreamSubscription.prototype = {};
  P.EventSink.prototype = {};
  P.StreamTransformerBase.prototype = {};
  P._StreamController.prototype = {
    get$stream: function() {
      return new P._ControllerStream(this, this.$ti);
    },
    get$_pendingEvents: function() {
      if ((this._async$_state & 8) === 0)
        return this._varData;
      return this._varData.varData;
    },
    _ensurePendingEvents$0: function() {
      var t1, state, _this = this;
      if ((_this._async$_state & 8) === 0) {
        t1 = _this._varData;
        return t1 == null ? _this._varData = new P._StreamImplEvents() : t1;
      }
      state = _this._varData;
      t1 = state.varData;
      return t1 == null ? state.varData = new P._StreamImplEvents() : t1;
    },
    get$_subscription: function() {
      if ((this._async$_state & 8) !== 0)
        return this._varData.varData;
      return this._varData;
    },
    _badEventState$0: function() {
      if ((this._async$_state & 4) !== 0)
        return new P.StateError("Cannot add event after closing");
      return new P.StateError("Cannot add event while adding a stream");
    },
    addStream$2$cancelOnError: function(source, cancelOnError) {
      var t2, t3, t4, _this = this,
        t1 = _this._async$_state;
      if (t1 >= 4)
        throw H.wrapException(_this._badEventState$0());
      if ((t1 & 2) !== 0) {
        t1 = new P._Future($.Zone__current, [null]);
        t1._asyncComplete$1(null);
        return t1;
      }
      t1 = _this._varData;
      t2 = new P._Future($.Zone__current, [null]);
      t3 = source.listen$4$cancelOnError$onDone$onError(_this.get$_async$_add(), false, _this.get$_close(), _this.get$_addError());
      t4 = _this._async$_state;
      if ((t4 & 1) !== 0 ? (_this.get$_subscription()._async$_state & 4) !== 0 : (t4 & 2) === 0)
        t3.pause$0(0);
      _this._varData = new P._StreamControllerAddStreamState(t1, t2, t3);
      _this._async$_state |= 8;
      return t2;
    },
    _ensureDoneFuture$0: function() {
      var t1 = this._doneFuture;
      if (t1 == null)
        t1 = this._doneFuture = (this._async$_state & 2) !== 0 ? $.$get$Future__nullFuture() : new P._Future($.Zone__current, [null]);
      return t1;
    },
    add$1: function(_, value) {
      if (this._async$_state >= 4)
        throw H.wrapException(this._badEventState$0());
      this._async$_add$1(value);
    },
    addError$2: function(error, stackTrace) {
      var replacement;
      if (this._async$_state >= 4)
        throw H.wrapException(this._badEventState$0());
      if (error == null)
        error = new P.NullThrownError();
      replacement = $.Zone__current.errorCallback$2(error, stackTrace);
      if (replacement != null) {
        error = replacement.error;
        if (error == null)
          error = new P.NullThrownError();
        stackTrace = replacement.stackTrace;
      }
      this._addError$2(error, stackTrace);
    },
    addError$1: function(error) {
      return this.addError$2(error, null);
    },
    close$0: function(_) {
      var _this = this,
        t1 = _this._async$_state;
      if ((t1 & 4) !== 0)
        return _this._ensureDoneFuture$0();
      if (t1 >= 4)
        throw H.wrapException(_this._badEventState$0());
      _this._closeUnchecked$0();
      return _this._ensureDoneFuture$0();
    },
    _closeUnchecked$0: function() {
      var t1 = this._async$_state |= 4;
      if ((t1 & 1) !== 0)
        this._sendDone$0();
      else if ((t1 & 3) === 0)
        this._ensurePendingEvents$0().add$1(0, C.C__DelayedDone);
    },
    _async$_add$1: function(value) {
      var t1 = this._async$_state;
      if ((t1 & 1) !== 0)
        this._sendData$1(value);
      else if ((t1 & 3) === 0)
        this._ensurePendingEvents$0().add$1(0, new P._DelayedData(value));
    },
    _addError$2: function(error, stackTrace) {
      var t1 = this._async$_state;
      if ((t1 & 1) !== 0)
        this._sendError$2(error, stackTrace);
      else if ((t1 & 3) === 0)
        this._ensurePendingEvents$0().add$1(0, new P._DelayedError(error, stackTrace));
    },
    _close$0: function() {
      var addState = this._varData;
      this._varData = addState.varData;
      this._async$_state &= 4294967287;
      addState.addStreamFuture._asyncComplete$1(null);
    },
    _subscribe$4: function(onData, onError, onDone, cancelOnError) {
      var t1, t2, subscription, pendingEvents, addState, _this = this;
      if ((_this._async$_state & 3) !== 0)
        throw H.wrapException(P.StateError$("Stream has already been listened to."));
      t1 = $.Zone__current;
      t2 = cancelOnError ? 1 : 0;
      subscription = new P._ControllerSubscription(_this, t1, t2, _this.$ti);
      subscription._BufferingStreamSubscription$4(onData, onError, onDone, cancelOnError, H.getTypeArgumentByIndex(_this, 0));
      pendingEvents = _this.get$_pendingEvents();
      t2 = _this._async$_state |= 1;
      if ((t2 & 8) !== 0) {
        addState = _this._varData;
        addState.varData = subscription;
        addState.addSubscription.resume$0();
      } else
        _this._varData = subscription;
      subscription._setPendingEvents$1(pendingEvents);
      subscription._guardCallback$1(new P._StreamController__subscribe_closure(_this));
      return subscription;
    },
    _recordCancel$1: function(subscription) {
      var e, s, t1, exception, result0, _this = this, result = null;
      if ((_this._async$_state & 8) !== 0)
        result = _this._varData.cancel$0();
      _this._varData = null;
      _this._async$_state = _this._async$_state & 4294967286 | 2;
      t1 = _this.onCancel;
      if (t1 != null)
        if (result == null)
          try {
            result = t1.call$0();
          } catch (exception) {
            e = H.unwrapException(exception);
            s = H.getTraceFromException(exception);
            result0 = new P._Future($.Zone__current, [null]);
            result0._asyncCompleteError$2(e, s);
            result = result0;
          }
        else
          result = result.whenComplete$1(t1);
      t1 = new P._StreamController__recordCancel_complete(_this);
      if (result != null)
        result = result.whenComplete$1(t1);
      else
        t1.call$0();
      return result;
    },
    _recordPause$1: function(subscription) {
      if ((this._async$_state & 8) !== 0)
        this._varData.addSubscription.pause$0(0);
      P._runGuarded(this.onPause);
    },
    _recordResume$1: function(subscription) {
      if ((this._async$_state & 8) !== 0)
        this._varData.addSubscription.resume$0();
      P._runGuarded(this.onResume);
    },
    $isEventSink: 1,
    set$onListen: function(val) {
      return this.onListen = val;
    },
    set$onPause: function(val) {
      return this.onPause = val;
    },
    set$onResume: function(val) {
      return this.onResume = val;
    },
    set$onCancel: function(val) {
      return this.onCancel = val;
    }
  };
  P._StreamController__subscribe_closure.prototype = {
    call$0: function() {
      P._runGuarded(this.$this.onListen);
    }
  };
  P._StreamController__recordCancel_complete.prototype = {
    call$0: function() {
      var t1 = this.$this._doneFuture;
      if (t1 != null && t1._async$_state === 0)
        t1._asyncComplete$1(null);
    },
    "call*": "call$0",
    $requiredArgCount: 0
  };
  P._SyncStreamControllerDispatch.prototype = {
    _sendData$1: function(data) {
      this.get$_subscription()._async$_add$1(data);
    },
    _sendError$2: function(error, stackTrace) {
      this.get$_subscription()._addError$2(error, stackTrace);
    },
    _sendDone$0: function() {
      this.get$_subscription()._close$0();
    }
  };
  P._AsyncStreamControllerDispatch.prototype = {
    _sendData$1: function(data) {
      this.get$_subscription()._addPending$1(new P._DelayedData(data));
    },
    _sendError$2: function(error, stackTrace) {
      this.get$_subscription()._addPending$1(new P._DelayedError(error, stackTrace));
    },
    _sendDone$0: function() {
      this.get$_subscription()._addPending$1(C.C__DelayedDone);
    }
  };
  P._AsyncStreamController.prototype = {};
  P._SyncStreamController.prototype = {};
  P._ControllerStream.prototype = {
    get$hashCode: function(_) {
      return (H.Primitives_objectHashCode(this._async$_controller) ^ 892482866) >>> 0;
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (this === other)
        return true;
      return other instanceof P._ControllerStream && other._async$_controller === this._async$_controller;
    }
  };
  P._ControllerSubscription.prototype = {
    _async$_onCancel$0: function() {
      return this._async$_controller._recordCancel$1(this);
    },
    _async$_onPause$0: function() {
      this._async$_controller._recordPause$1(this);
    },
    _async$_onResume$0: function() {
      this._async$_controller._recordResume$1(this);
    }
  };
  P._AddStreamState.prototype = {
    cancel$0: function() {
      var cancel = this.addSubscription.cancel$0();
      if (cancel == null) {
        this.addStreamFuture._asyncComplete$1(null);
        return;
      }
      return cancel.whenComplete$1(new P._AddStreamState_cancel_closure(this));
    }
  };
  P._AddStreamState_cancel_closure.prototype = {
    call$0: function() {
      this.$this.addStreamFuture._asyncComplete$1(null);
    },
    "call*": "call$0",
    $requiredArgCount: 0
  };
  P._StreamControllerAddStreamState.prototype = {};
  P._BufferingStreamSubscription.prototype = {
    _BufferingStreamSubscription$4: function(onData, onError, onDone, cancelOnError, $T) {
      var handleError, _this = this,
        handleData = onData == null ? P.async___nullDataHandler$closure() : onData,
        t1 = _this._zone;
      _this._onData = t1.registerUnaryCallback$1(handleData);
      handleError = onError == null ? P.async___nullErrorHandler$closure() : onError;
      if (H.functionTypeTest(handleError, {func: 1, ret: -1, args: [P.Object, P.StackTrace]}))
        _this._onError = t1.registerBinaryCallback$1(handleError);
      else if (H.functionTypeTest(handleError, {func: 1, ret: -1, args: [P.Object]}))
        _this._onError = t1.registerUnaryCallback$1(handleError);
      else
        H.throwExpression(P.ArgumentError$("handleError callback must take either an Object (the error), or both an Object (the error) and a StackTrace."));
      _this._onDone = t1.registerCallback$1(onDone == null ? P.async___nullDoneHandler$closure() : onDone);
    },
    _setPendingEvents$1: function(pendingEvents) {
      var _this = this;
      if (pendingEvents == null)
        return;
      _this._pending = pendingEvents;
      if (pendingEvents.lastPendingEvent != null) {
        _this._async$_state = (_this._async$_state | 64) >>> 0;
        pendingEvents.schedule$1(_this);
      }
    },
    pause$1: function(_, resumeSignal) {
      var t2, t3, _this = this,
        t1 = _this._async$_state;
      if ((t1 & 8) !== 0)
        return;
      t2 = (t1 + 128 | 4) >>> 0;
      _this._async$_state = t2;
      if (t1 < 128 && _this._pending != null) {
        t3 = _this._pending;
        if (t3._async$_state === 1)
          t3._async$_state = 3;
      }
      if ((t1 & 4) === 0 && (t2 & 32) === 0)
        _this._guardCallback$1(_this.get$_async$_onPause());
    },
    pause$0: function($receiver) {
      return this.pause$1($receiver, null);
    },
    resume$0: function() {
      var _this = this,
        t1 = _this._async$_state;
      if ((t1 & 8) !== 0)
        return;
      if (t1 >= 128) {
        t1 = _this._async$_state = t1 - 128;
        if (t1 < 128)
          if ((t1 & 64) !== 0 && _this._pending.lastPendingEvent != null)
            _this._pending.schedule$1(_this);
          else {
            t1 = (t1 & 4294967291) >>> 0;
            _this._async$_state = t1;
            if ((t1 & 32) === 0)
              _this._guardCallback$1(_this.get$_async$_onResume());
          }
      }
    },
    cancel$0: function() {
      var _this = this,
        t1 = (_this._async$_state & 4294967279) >>> 0;
      _this._async$_state = t1;
      if ((t1 & 8) === 0)
        _this._cancel$0();
      t1 = _this._cancelFuture;
      return t1 == null ? $.$get$Future__nullFuture() : t1;
    },
    _cancel$0: function() {
      var t2, _this = this,
        t1 = _this._async$_state = (_this._async$_state | 8) >>> 0;
      if ((t1 & 64) !== 0) {
        t2 = _this._pending;
        if (t2._async$_state === 1)
          t2._async$_state = 3;
      }
      if ((t1 & 32) === 0)
        _this._pending = null;
      _this._cancelFuture = _this._async$_onCancel$0();
    },
    _async$_add$1: function(data) {
      var t1 = this._async$_state;
      if ((t1 & 8) !== 0)
        return;
      if (t1 < 32)
        this._sendData$1(data);
      else
        this._addPending$1(new P._DelayedData(data));
    },
    _addError$2: function(error, stackTrace) {
      var t1 = this._async$_state;
      if ((t1 & 8) !== 0)
        return;
      if (t1 < 32)
        this._sendError$2(error, stackTrace);
      else
        this._addPending$1(new P._DelayedError(error, stackTrace));
    },
    _close$0: function() {
      var _this = this,
        t1 = _this._async$_state;
      if ((t1 & 8) !== 0)
        return;
      t1 = (t1 | 2) >>> 0;
      _this._async$_state = t1;
      if (t1 < 32)
        _this._sendDone$0();
      else
        _this._addPending$1(C.C__DelayedDone);
    },
    _async$_onPause$0: function() {
    },
    _async$_onResume$0: function() {
    },
    _async$_onCancel$0: function() {
      return;
    },
    _addPending$1: function($event) {
      var t1, _this = this,
        pending = _this._pending;
      (pending == null ? _this._pending = new P._StreamImplEvents() : pending).add$1(0, $event);
      t1 = _this._async$_state;
      if ((t1 & 64) === 0) {
        t1 = (t1 | 64) >>> 0;
        _this._async$_state = t1;
        if (t1 < 128)
          _this._pending.schedule$1(_this);
      }
    },
    _sendData$1: function(data) {
      var _this = this,
        t1 = _this._async$_state;
      _this._async$_state = (t1 | 32) >>> 0;
      _this._zone.runUnaryGuarded$2(_this._onData, data);
      _this._async$_state = (_this._async$_state & 4294967263) >>> 0;
      _this._checkState$1((t1 & 4) !== 0);
    },
    _sendError$2: function(error, stackTrace) {
      var _this = this,
        t1 = _this._async$_state,
        t2 = new P._BufferingStreamSubscription__sendError_sendError(_this, error, stackTrace);
      if ((t1 & 1) !== 0) {
        _this._async$_state = (t1 | 16) >>> 0;
        _this._cancel$0();
        t1 = _this._cancelFuture;
        if (t1 != null && t1 !== $.$get$Future__nullFuture())
          t1.whenComplete$1(t2);
        else
          t2.call$0();
      } else {
        t2.call$0();
        _this._checkState$1((t1 & 4) !== 0);
      }
    },
    _sendDone$0: function() {
      var t2, _this = this,
        t1 = new P._BufferingStreamSubscription__sendDone_sendDone(_this);
      _this._cancel$0();
      _this._async$_state = (_this._async$_state | 16) >>> 0;
      t2 = _this._cancelFuture;
      if (t2 != null && t2 !== $.$get$Future__nullFuture())
        t2.whenComplete$1(t1);
      else
        t1.call$0();
    },
    _guardCallback$1: function(callback) {
      var _this = this,
        t1 = _this._async$_state;
      _this._async$_state = (t1 | 32) >>> 0;
      callback.call$0();
      _this._async$_state = (_this._async$_state & 4294967263) >>> 0;
      _this._checkState$1((t1 & 4) !== 0);
    },
    _checkState$1: function(wasInputPaused) {
      var t2, isInputPaused, _this = this,
        t1 = _this._async$_state;
      if ((t1 & 64) !== 0 && _this._pending.lastPendingEvent == null) {
        t1 = _this._async$_state = (t1 & 4294967231) >>> 0;
        if ((t1 & 4) !== 0)
          if (t1 < 128) {
            t2 = _this._pending;
            t2 = t2 == null || t2.lastPendingEvent == null;
          } else
            t2 = false;
        else
          t2 = false;
        if (t2) {
          t1 = (t1 & 4294967291) >>> 0;
          _this._async$_state = t1;
        }
      }
      for (; true; wasInputPaused = isInputPaused) {
        if ((t1 & 8) !== 0)
          return _this._pending = null;
        isInputPaused = (t1 & 4) !== 0;
        if (wasInputPaused === isInputPaused)
          break;
        _this._async$_state = (t1 ^ 32) >>> 0;
        if (isInputPaused)
          _this._async$_onPause$0();
        else
          _this._async$_onResume$0();
        t1 = (_this._async$_state & 4294967263) >>> 0;
        _this._async$_state = t1;
      }
      if ((t1 & 64) !== 0 && t1 < 128)
        _this._pending.schedule$1(_this);
    },
    $isStreamSubscription: 1
  };
  P._BufferingStreamSubscription__sendError_sendError.prototype = {
    call$0: function() {
      var onError, t3,
        t1 = this.$this,
        t2 = t1._async$_state;
      if ((t2 & 8) !== 0 && (t2 & 16) === 0)
        return;
      t1._async$_state = (t2 | 32) >>> 0;
      onError = t1._onError;
      t2 = this.error;
      t3 = t1._zone;
      if (H.functionTypeTest(onError, {func: 1, ret: -1, args: [P.Object, P.StackTrace]}))
        t3.runBinaryGuarded$3(onError, t2, this.stackTrace);
      else
        t3.runUnaryGuarded$2(t1._onError, t2);
      t1._async$_state = (t1._async$_state & 4294967263) >>> 0;
    },
    "call*": "call$0",
    $requiredArgCount: 0
  };
  P._BufferingStreamSubscription__sendDone_sendDone.prototype = {
    call$0: function() {
      var t1 = this.$this,
        t2 = t1._async$_state;
      if ((t2 & 16) === 0)
        return;
      t1._async$_state = (t2 | 42) >>> 0;
      t1._zone.runGuarded$1(t1._onDone);
      t1._async$_state = (t1._async$_state & 4294967263) >>> 0;
    },
    "call*": "call$0",
    $requiredArgCount: 0
  };
  P._StreamImpl.prototype = {
    listen$4$cancelOnError$onDone$onError: function(onData, cancelOnError, onDone, onError) {
      return this._async$_controller._subscribe$4(onData, onError, onDone, true === cancelOnError);
    },
    listen$3$onDone$onError: function(onData, onDone, onError) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
    }
  };
  P._DelayedEvent.prototype = {
    get$next: function() {
      return this.next;
    },
    set$next: function(val) {
      return this.next = val;
    }
  };
  P._DelayedData.prototype = {
    perform$1: function(dispatch) {
      dispatch._sendData$1(this.value);
    }
  };
  P._DelayedError.prototype = {
    perform$1: function(dispatch) {
      dispatch._sendError$2(this.error, this.stackTrace);
    }
  };
  P._DelayedDone.prototype = {
    perform$1: function(dispatch) {
      dispatch._sendDone$0();
    },
    get$next: function() {
      return;
    },
    set$next: function(_) {
      throw H.wrapException(P.StateError$("No events after a done."));
    }
  };
  P._PendingEvents.prototype = {
    schedule$1: function(dispatch) {
      var _this = this,
        t1 = _this._async$_state;
      if (t1 === 1)
        return;
      if (t1 >= 1) {
        _this._async$_state = 1;
        return;
      }
      P.scheduleMicrotask(new P._PendingEvents_schedule_closure(_this, dispatch));
      _this._async$_state = 1;
    }
  };
  P._PendingEvents_schedule_closure.prototype = {
    call$0: function() {
      var $event, t2,
        t1 = this.$this,
        oldState = t1._async$_state;
      t1._async$_state = 0;
      if (oldState === 3)
        return;
      $event = t1.firstPendingEvent;
      t2 = $event.get$next();
      t1.firstPendingEvent = t2;
      if (t2 == null)
        t1.lastPendingEvent = null;
      $event.perform$1(this.dispatch);
    },
    "call*": "call$0",
    $requiredArgCount: 0
  };
  P._StreamImplEvents.prototype = {
    add$1: function(_, $event) {
      var _this = this,
        t1 = _this.lastPendingEvent;
      if (t1 == null)
        _this.firstPendingEvent = _this.lastPendingEvent = $event;
      else {
        t1.set$next($event);
        _this.lastPendingEvent = $event;
      }
    }
  };
  P._DoneStreamSubscription.prototype = {
    _schedule$0: function() {
      var _this = this;
      if ((_this._async$_state & 2) !== 0)
        return;
      _this._zone.scheduleMicrotask$1(_this.get$_sendDone());
      _this._async$_state = (_this._async$_state | 2) >>> 0;
    },
    pause$1: function(_, resumeSignal) {
      this._async$_state += 4;
    },
    pause$0: function($receiver) {
      return this.pause$1($receiver, null);
    },
    resume$0: function() {
      var t1 = this._async$_state;
      if (t1 >= 4) {
        t1 = this._async$_state = t1 - 4;
        if (t1 < 4 && (t1 & 1) === 0)
          this._schedule$0();
      }
    },
    cancel$0: function() {
      return $.$get$Future__nullFuture();
    },
    _sendDone$0: function() {
      var _this = this,
        t1 = _this._async$_state = (_this._async$_state & 4294967293) >>> 0;
      if (t1 >= 4)
        return;
      _this._async$_state = (t1 | 1) >>> 0;
      _this._zone.runGuarded$1(_this._onDone);
    },
    $isStreamSubscription: 1
  };
  P._StreamIterator.prototype = {
    get$current: function(_) {
      if (this._subscription != null && this._isPaused)
        return this._stateData;
      return;
    },
    moveNext$0: function() {
      var future, _this = this,
        t1 = _this._subscription;
      if (t1 != null) {
        if (_this._isPaused) {
          future = new P._Future($.Zone__current, [P.bool]);
          _this._stateData = future;
          _this._isPaused = false;
          t1.resume$0();
          return future;
        }
        throw H.wrapException(P.StateError$("Already waiting for next."));
      }
      return _this._initializeOrDone$0();
    },
    _initializeOrDone$0: function() {
      var _this = this,
        stateData = _this._stateData;
      if (stateData != null) {
        _this._subscription = stateData.listen$4$cancelOnError$onDone$onError(_this.get$_onData(), true, _this.get$_onDone(), _this.get$_onError());
        return _this._stateData = new P._Future($.Zone__current, [P.bool]);
      }
      return $.$get$Future__falseFuture();
    },
    cancel$0: function() {
      var _this = this,
        subscription = _this._subscription,
        stateData = _this._stateData;
      _this._stateData = null;
      if (subscription != null) {
        _this._subscription = null;
        if (!_this._isPaused)
          stateData._asyncComplete$1(false);
        return subscription.cancel$0();
      }
      return $.$get$Future__nullFuture();
    },
    _onData$1: function(data) {
      var t1, _this = this,
        moveNextFuture = _this._stateData;
      _this._stateData = data;
      _this._isPaused = true;
      moveNextFuture._complete$1(true);
      t1 = _this._subscription;
      if (t1 != null && _this._isPaused)
        t1.pause$0(0);
    },
    _onError$2: function(error, stackTrace) {
      var moveNextFuture = this._stateData;
      this._stateData = this._subscription = null;
      moveNextFuture._completeError$2(error, stackTrace);
    },
    _onError$1: function(error) {
      return this._onError$2(error, null);
    },
    _onDone$0: function() {
      var moveNextFuture = this._stateData;
      this._stateData = this._subscription = null;
      moveNextFuture._complete$1(false);
    }
  };
  P._ForwardingStream.prototype = {
    get$isBroadcast: function() {
      return this._async$_source.get$isBroadcast();
    },
    listen$4$cancelOnError$onDone$onError: function(onData, cancelOnError, onDone, onError) {
      var t1, t2, _this = this;
      cancelOnError = true === cancelOnError;
      t1 = $.Zone__current;
      t2 = cancelOnError ? 1 : 0;
      t2 = new P._ForwardingStreamSubscription(_this, t1, t2, _this.$ti);
      t2._BufferingStreamSubscription$4(onData, onError, onDone, cancelOnError, H.getTypeArgumentByIndex(_this, 1));
      t2._subscription = _this._async$_source.listen$3$onDone$onError(t2.get$_handleData(), t2.get$_handleDone(), t2.get$_handleError());
      return t2;
    },
    listen$3$onDone$onError: function(onData, onDone, onError) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
    },
    _handleData$2: function(data, sink) {
      sink._async$_add$1(data);
    },
    $asStream: function($S, $T) {
      return [$T];
    }
  };
  P._ForwardingStreamSubscription.prototype = {
    _async$_add$1: function(data) {
      if ((this._async$_state & 2) !== 0)
        return;
      this.super$_BufferingStreamSubscription$_add(data);
    },
    _addError$2: function(error, stackTrace) {
      if ((this._async$_state & 2) !== 0)
        return;
      this.super$_BufferingStreamSubscription$_addError(error, stackTrace);
    },
    _async$_onPause$0: function() {
      var t1 = this._subscription;
      if (t1 == null)
        return;
      t1.pause$0(0);
    },
    _async$_onResume$0: function() {
      var t1 = this._subscription;
      if (t1 == null)
        return;
      t1.resume$0();
    },
    _async$_onCancel$0: function() {
      var t1 = this._subscription;
      if (t1 != null) {
        this._subscription = null;
        return t1.cancel$0();
      }
      return;
    },
    _handleData$1: function(data) {
      this._stream._handleData$2(data, this);
    },
    _handleError$2: function(error, stackTrace) {
      this._addError$2(error, stackTrace);
    },
    _handleDone$0: function() {
      this._close$0();
    },
    $asStreamSubscription: function($S, $T) {
      return [$T];
    },
    $as_BufferingStreamSubscription: function($S, $T) {
      return [$T];
    }
  };
  P._ExpandStream.prototype = {
    _handleData$2: function(inputEvent, sink) {
      var value, e, s, t1, exception;
      try {
        for (t1 = J.get$iterator$ax(this._expand.call$1(inputEvent)); t1.moveNext$0();) {
          value = t1.get$current(t1);
          sink._async$_add$1(value);
        }
      } catch (exception) {
        e = H.unwrapException(exception);
        s = H.getTraceFromException(exception);
        P._addErrorWithReplacement(sink, e, s);
      }
    }
  };
  P.Timer.prototype = {};
  P.AsyncError.prototype = {
    toString$0: function(_) {
      return H.S(this.error);
    },
    $isError: 1
  };
  P._ZoneFunction.prototype = {};
  P.ZoneSpecification.prototype = {};
  P._ZoneSpecification.prototype = {$isZoneSpecification: 1};
  P.ZoneDelegate.prototype = {};
  P.Zone.prototype = {};
  P._ZoneDelegate.prototype = {$isZoneDelegate: 1};
  P._Zone.prototype = {$isZone: 1};
  P._CustomZone.prototype = {
    get$_delegate: function() {
      var t1 = this._delegateCache;
      if (t1 != null)
        return t1;
      return this._delegateCache = new P._ZoneDelegate(this);
    },
    get$errorZone: function() {
      return this._handleUncaughtError.zone;
    },
    runGuarded$1: function(f) {
      var e, s, exception;
      try {
        this.run$1(0, f);
      } catch (exception) {
        e = H.unwrapException(exception);
        s = H.getTraceFromException(exception);
        this.handleUncaughtError$2(e, s);
      }
    },
    runUnaryGuarded$1$2: function(f, arg) {
      var e, s, exception;
      try {
        this.runUnary$2(f, arg);
      } catch (exception) {
        e = H.unwrapException(exception);
        s = H.getTraceFromException(exception);
        this.handleUncaughtError$2(e, s);
      }
    },
    runUnaryGuarded$2: function(f, arg) {
      return this.runUnaryGuarded$1$2(f, arg, null);
    },
    runBinaryGuarded$2$3: function(f, arg1, arg2) {
      var e, s, exception;
      try {
        this.runBinary$3(f, arg1, arg2);
      } catch (exception) {
        e = H.unwrapException(exception);
        s = H.getTraceFromException(exception);
        this.handleUncaughtError$2(e, s);
      }
    },
    runBinaryGuarded$3: function(f, arg1, arg2) {
      return this.runBinaryGuarded$2$3(f, arg1, arg2, null, null);
    },
    bindCallback$1$1: function(f) {
      return new P._CustomZone_bindCallback_closure(this, this.registerCallback$1(f));
    },
    bindCallback$1: function(f) {
      return this.bindCallback$1$1(f, null);
    },
    bindUnaryCallback$2$1: function(f, $R, $T) {
      return new P._CustomZone_bindUnaryCallback_closure(this, this.registerUnaryCallback$1(f), $T, $R);
    },
    bindCallbackGuarded$1: function(f) {
      return new P._CustomZone_bindCallbackGuarded_closure(this, this.registerCallback$1(f));
    },
    $index: function(_, key) {
      var value,
        t1 = this._async$_map,
        result = t1.$index(0, key);
      if (result != null || t1.containsKey$1(key))
        return result;
      value = this.parent.$index(0, key);
      if (value != null)
        t1.$indexSet(0, key, value);
      return value;
    },
    handleUncaughtError$2: function(error, stackTrace) {
      var implementation = this._handleUncaughtError,
        t1 = implementation.zone,
        parentDelegate = P._parentDelegate(t1);
      return implementation.$function.call$5(t1, parentDelegate, this, error, stackTrace);
    },
    fork$2$specification$zoneValues: function(specification, zoneValues) {
      var implementation = this._fork,
        t1 = implementation.zone,
        parentDelegate = P._parentDelegate(t1);
      return implementation.$function.call$5(t1, parentDelegate, this, specification, zoneValues);
    },
    run$1$1: function(_, f) {
      var implementation = this._run,
        t1 = implementation.zone,
        parentDelegate = P._parentDelegate(t1);
      return implementation.$function.call$4(t1, parentDelegate, this, f);
    },
    run$1: function($receiver, f) {
      return this.run$1$1($receiver, f, null);
    },
    runUnary$2$2: function(f, arg) {
      var implementation = this._runUnary,
        t1 = implementation.zone,
        parentDelegate = P._parentDelegate(t1);
      return implementation.$function.call$5(t1, parentDelegate, this, f, arg);
    },
    runUnary$2: function(f, arg) {
      return this.runUnary$2$2(f, arg, null, null);
    },
    runBinary$3$3: function(f, arg1, arg2) {
      var implementation = this._runBinary,
        t1 = implementation.zone,
        parentDelegate = P._parentDelegate(t1);
      return implementation.$function.call$6(t1, parentDelegate, this, f, arg1, arg2);
    },
    runBinary$3: function(f, arg1, arg2) {
      return this.runBinary$3$3(f, arg1, arg2, null, null, null);
    },
    registerCallback$1$1: function(callback) {
      var implementation = this._registerCallback,
        t1 = implementation.zone,
        parentDelegate = P._parentDelegate(t1);
      return implementation.$function.call$4(t1, parentDelegate, this, callback);
    },
    registerCallback$1: function(callback) {
      return this.registerCallback$1$1(callback, null);
    },
    registerUnaryCallback$2$1: function(callback) {
      var implementation = this._registerUnaryCallback,
        t1 = implementation.zone,
        parentDelegate = P._parentDelegate(t1);
      return implementation.$function.call$4(t1, parentDelegate, this, callback);
    },
    registerUnaryCallback$1: function(callback) {
      return this.registerUnaryCallback$2$1(callback, null, null);
    },
    registerBinaryCallback$3$1: function(callback) {
      var implementation = this._registerBinaryCallback,
        t1 = implementation.zone,
        parentDelegate = P._parentDelegate(t1);
      return implementation.$function.call$4(t1, parentDelegate, this, callback);
    },
    registerBinaryCallback$1: function(callback) {
      return this.registerBinaryCallback$3$1(callback, null, null, null);
    },
    errorCallback$2: function(error, stackTrace) {
      var parentDelegate,
        implementation = this._errorCallback,
        implementationZone = implementation.zone;
      if (implementationZone === C.C__RootZone)
        return;
      parentDelegate = P._parentDelegate(implementationZone);
      return implementation.$function.call$5(implementationZone, parentDelegate, this, error, stackTrace);
    },
    scheduleMicrotask$1: function(f) {
      var implementation = this._scheduleMicrotask,
        t1 = implementation.zone,
        parentDelegate = P._parentDelegate(t1);
      return implementation.$function.call$4(t1, parentDelegate, this, f);
    },
    createTimer$2: function(duration, f) {
      var implementation = this._createTimer,
        t1 = implementation.zone,
        parentDelegate = P._parentDelegate(t1);
      return implementation.$function.call$5(t1, parentDelegate, this, duration, f);
    },
    print$1: function(line) {
      var implementation = this._print,
        t1 = implementation.zone,
        parentDelegate = P._parentDelegate(t1);
      return implementation.$function.call$4(t1, parentDelegate, this, line);
    },
    get$_run: function() {
      return this._run;
    },
    get$_runUnary: function() {
      return this._runUnary;
    },
    get$_runBinary: function() {
      return this._runBinary;
    },
    get$_registerCallback: function() {
      return this._registerCallback;
    },
    get$_registerUnaryCallback: function() {
      return this._registerUnaryCallback;
    },
    get$_registerBinaryCallback: function() {
      return this._registerBinaryCallback;
    },
    get$_errorCallback: function() {
      return this._errorCallback;
    },
    get$_scheduleMicrotask: function() {
      return this._scheduleMicrotask;
    },
    get$_createTimer: function() {
      return this._createTimer;
    },
    get$_createPeriodicTimer: function() {
      return this._createPeriodicTimer;
    },
    get$_print: function() {
      return this._print;
    },
    get$_fork: function() {
      return this._fork;
    },
    get$_handleUncaughtError: function() {
      return this._handleUncaughtError;
    },
    get$parent: function() {
      return this.parent;
    },
    get$_async$_map: function() {
      return this._async$_map;
    }
  };
  P._CustomZone_bindCallback_closure.prototype = {
    call$0: function() {
      return this.$this.run$1(0, this.registered);
    }
  };
  P._CustomZone_bindUnaryCallback_closure.prototype = {
    call$1: function(arg) {
      return this.$this.runUnary$2(this.registered, arg);
    },
    $signature: function() {
      return {func: 1, ret: this.R, args: [this.T]};
    }
  };
  P._CustomZone_bindCallbackGuarded_closure.prototype = {
    call$0: function() {
      return this.$this.runGuarded$1(this.registered);
    },
    "call*": "call$0",
    $requiredArgCount: 0
  };
  P._rootHandleUncaughtError_closure.prototype = {
    call$0: function() {
      var error,
        t1 = this._box_0,
        t2 = t1.error;
      t1 = t2 == null ? t1.error = new P.NullThrownError() : t2;
      t2 = this.stackTrace;
      if (t2 == null)
        throw H.wrapException(t1);
      error = H.wrapException(t1);
      error.stack = t2.toString$0(0);
      throw error;
    }
  };
  P._RootZone.prototype = {
    get$_run: function() {
      return C._ZoneFunction__RootZone__rootRun;
    },
    get$_runUnary: function() {
      return C._ZoneFunction__RootZone__rootRunUnary;
    },
    get$_runBinary: function() {
      return C._ZoneFunction__RootZone__rootRunBinary;
    },
    get$_registerCallback: function() {
      return C._ZoneFunction__RootZone__rootRegisterCallback;
    },
    get$_registerUnaryCallback: function() {
      return C._ZoneFunction_Eeh;
    },
    get$_registerBinaryCallback: function() {
      return C._ZoneFunction_7G2;
    },
    get$_errorCallback: function() {
      return C._ZoneFunction__RootZone__rootErrorCallback;
    },
    get$_scheduleMicrotask: function() {
      return C._ZoneFunction__RootZone__rootScheduleMicrotask;
    },
    get$_createTimer: function() {
      return C._ZoneFunction__RootZone__rootCreateTimer;
    },
    get$_createPeriodicTimer: function() {
      return C._ZoneFunction_3bB;
    },
    get$_print: function() {
      return C._ZoneFunction__RootZone__rootPrint;
    },
    get$_fork: function() {
      return C._ZoneFunction__RootZone__rootFork;
    },
    get$_handleUncaughtError: function() {
      return C._ZoneFunction_NMc;
    },
    get$parent: function() {
      return;
    },
    get$_async$_map: function() {
      return $.$get$_RootZone__rootMap();
    },
    get$_delegate: function() {
      var t1 = $._RootZone__rootDelegate;
      if (t1 != null)
        return t1;
      return $._RootZone__rootDelegate = new P._ZoneDelegate(this);
    },
    get$errorZone: function() {
      return this;
    },
    runGuarded$1: function(f) {
      var e, s, exception, _null = null;
      try {
        if (C.C__RootZone === $.Zone__current) {
          f.call$0();
          return;
        }
        P._rootRun(_null, _null, this, f);
      } catch (exception) {
        e = H.unwrapException(exception);
        s = H.getTraceFromException(exception);
        P._rootHandleUncaughtError(_null, _null, this, e, s);
      }
    },
    runUnaryGuarded$1$2: function(f, arg) {
      var e, s, exception, _null = null;
      try {
        if (C.C__RootZone === $.Zone__current) {
          f.call$1(arg);
          return;
        }
        P._rootRunUnary(_null, _null, this, f, arg);
      } catch (exception) {
        e = H.unwrapException(exception);
        s = H.getTraceFromException(exception);
        P._rootHandleUncaughtError(_null, _null, this, e, s);
      }
    },
    runUnaryGuarded$2: function(f, arg) {
      return this.runUnaryGuarded$1$2(f, arg, null);
    },
    runBinaryGuarded$2$3: function(f, arg1, arg2) {
      var e, s, exception, _null = null;
      try {
        if (C.C__RootZone === $.Zone__current) {
          f.call$2(arg1, arg2);
          return;
        }
        P._rootRunBinary(_null, _null, this, f, arg1, arg2);
      } catch (exception) {
        e = H.unwrapException(exception);
        s = H.getTraceFromException(exception);
        P._rootHandleUncaughtError(_null, _null, this, e, s);
      }
    },
    runBinaryGuarded$3: function(f, arg1, arg2) {
      return this.runBinaryGuarded$2$3(f, arg1, arg2, null, null);
    },
    bindCallback$1$1: function(f) {
      return new P._RootZone_bindCallback_closure(this, f);
    },
    bindCallback$1: function(f) {
      return this.bindCallback$1$1(f, null);
    },
    bindCallbackGuarded$1: function(f) {
      return new P._RootZone_bindCallbackGuarded_closure(this, f);
    },
    $index: function(_, key) {
      return;
    },
    handleUncaughtError$2: function(error, stackTrace) {
      P._rootHandleUncaughtError(null, null, this, error, stackTrace);
    },
    fork$2$specification$zoneValues: function(specification, zoneValues) {
      return P._rootFork(null, null, this, specification, zoneValues);
    },
    run$1$1: function(_, f) {
      if ($.Zone__current === C.C__RootZone)
        return f.call$0();
      return P._rootRun(null, null, this, f);
    },
    run$1: function($receiver, f) {
      return this.run$1$1($receiver, f, null);
    },
    runUnary$2$2: function(f, arg) {
      if ($.Zone__current === C.C__RootZone)
        return f.call$1(arg);
      return P._rootRunUnary(null, null, this, f, arg);
    },
    runUnary$2: function(f, arg) {
      return this.runUnary$2$2(f, arg, null, null);
    },
    runBinary$3$3: function(f, arg1, arg2) {
      if ($.Zone__current === C.C__RootZone)
        return f.call$2(arg1, arg2);
      return P._rootRunBinary(null, null, this, f, arg1, arg2);
    },
    runBinary$3: function(f, arg1, arg2) {
      return this.runBinary$3$3(f, arg1, arg2, null, null, null);
    },
    registerCallback$1$1: function(f) {
      return f;
    },
    registerCallback$1: function(f) {
      return this.registerCallback$1$1(f, null);
    },
    registerUnaryCallback$2$1: function(f) {
      return f;
    },
    registerUnaryCallback$1: function(f) {
      return this.registerUnaryCallback$2$1(f, null, null);
    },
    registerBinaryCallback$3$1: function(f) {
      return f;
    },
    registerBinaryCallback$1: function(f) {
      return this.registerBinaryCallback$3$1(f, null, null, null);
    },
    errorCallback$2: function(error, stackTrace) {
      return;
    },
    scheduleMicrotask$1: function(f) {
      P._rootScheduleMicrotask(null, null, this, f);
    },
    createTimer$2: function(duration, f) {
      return P.Timer__createTimer(duration, f);
    },
    print$1: function(line) {
      H.printString(line);
    }
  };
  P._RootZone_bindCallback_closure.prototype = {
    call$0: function() {
      return this.$this.run$1(0, this.f);
    }
  };
  P._RootZone_bindCallbackGuarded_closure.prototype = {
    call$0: function() {
      return this.$this.runGuarded$1(this.f);
    },
    "call*": "call$0",
    $requiredArgCount: 0
  };
  P._HashMap.prototype = {
    get$length: function(_) {
      return this._collection$_length;
    },
    get$isEmpty: function(_) {
      return this._collection$_length === 0;
    },
    get$isNotEmpty: function(_) {
      return this._collection$_length !== 0;
    },
    get$keys: function() {
      return new P._HashMapKeyIterable(this, [H.getTypeArgumentByIndex(this, 0)]);
    },
    get$values: function() {
      var _this = this,
        t1 = H.getTypeArgumentByIndex(_this, 0);
      return H.MappedIterable_MappedIterable(new P._HashMapKeyIterable(_this, [t1]), new P._HashMap_values_closure(_this), t1, H.getTypeArgumentByIndex(_this, 1));
    },
    containsKey$1: function(key) {
      var strings, nums;
      if (typeof key === "string" && key !== "__proto__") {
        strings = this._collection$_strings;
        return strings == null ? false : strings[key] != null;
      } else if (typeof key === "number" && (key & 1073741823) === key) {
        nums = this._collection$_nums;
        return nums == null ? false : nums[key] != null;
      } else
        return this._containsKey$1(key);
    },
    _containsKey$1: function(key) {
      var rest = this._collection$_rest;
      if (rest == null)
        return false;
      return this._findBucketIndex$2(this._getBucket$2(rest, key), key) >= 0;
    },
    addAll$1: function(_, other) {
      other.forEach$1(0, new P._HashMap_addAll_closure(this));
    },
    $index: function(_, key) {
      var strings, t1, nums;
      if (typeof key === "string" && key !== "__proto__") {
        strings = this._collection$_strings;
        t1 = strings == null ? null : P._HashMap__getTableEntry(strings, key);
        return t1;
      } else if (typeof key === "number" && (key & 1073741823) === key) {
        nums = this._collection$_nums;
        t1 = nums == null ? null : P._HashMap__getTableEntry(nums, key);
        return t1;
      } else
        return this._get$1(key);
    },
    _get$1: function(key) {
      var bucket, index,
        rest = this._collection$_rest;
      if (rest == null)
        return;
      bucket = this._getBucket$2(rest, key);
      index = this._findBucketIndex$2(bucket, key);
      return index < 0 ? null : bucket[index + 1];
    },
    $indexSet: function(_, key, value) {
      var strings, nums, _this = this;
      if (typeof key === "string" && key !== "__proto__") {
        strings = _this._collection$_strings;
        _this._collection$_addHashTableEntry$3(strings == null ? _this._collection$_strings = P._HashMap__newHashTable() : strings, key, value);
      } else if (typeof key === "number" && (key & 1073741823) === key) {
        nums = _this._collection$_nums;
        _this._collection$_addHashTableEntry$3(nums == null ? _this._collection$_nums = P._HashMap__newHashTable() : nums, key, value);
      } else
        _this._set$2(key, value);
    },
    _set$2: function(key, value) {
      var hash, bucket, index, _this = this,
        rest = _this._collection$_rest;
      if (rest == null)
        rest = _this._collection$_rest = P._HashMap__newHashTable();
      hash = _this._computeHashCode$1(key);
      bucket = rest[hash];
      if (bucket == null) {
        P._HashMap__setTableEntry(rest, hash, [key, value]);
        ++_this._collection$_length;
        _this._collection$_keys = null;
      } else {
        index = _this._findBucketIndex$2(bucket, key);
        if (index >= 0)
          bucket[index + 1] = value;
        else {
          bucket.push(key, value);
          ++_this._collection$_length;
          _this._collection$_keys = null;
        }
      }
    },
    putIfAbsent$2: function(key, ifAbsent) {
      var value;
      if (this.containsKey$1(key))
        return this.$index(0, key);
      value = ifAbsent.call$0();
      this.$indexSet(0, key, value);
      return value;
    },
    remove$1: function(_, key) {
      var t1;
      if (typeof key === "string" && key !== "__proto__")
        return this._removeHashTableEntry$2(this._collection$_strings, key);
      else {
        t1 = this._remove$1(key);
        return t1;
      }
    },
    _remove$1: function(key) {
      var bucket, index, _this = this,
        rest = _this._collection$_rest;
      if (rest == null)
        return;
      bucket = _this._getBucket$2(rest, key);
      index = _this._findBucketIndex$2(bucket, key);
      if (index < 0)
        return;
      --_this._collection$_length;
      _this._collection$_keys = null;
      return bucket.splice(index, 2)[1];
    },
    forEach$1: function(_, action) {
      var $length, i, key, _this = this,
        keys = _this._computeKeys$0();
      for ($length = keys.length, i = 0; i < $length; ++i) {
        key = keys[i];
        action.call$2(key, _this.$index(0, key));
        if (keys !== _this._collection$_keys)
          throw H.wrapException(P.ConcurrentModificationError$(_this));
      }
    },
    _computeKeys$0: function() {
      var result, strings, names, entries, index, i, nums, rest, bucket, $length, i0, _this = this,
        t1 = _this._collection$_keys;
      if (t1 != null)
        return t1;
      result = new Array(_this._collection$_length);
      result.fixed$length = Array;
      strings = _this._collection$_strings;
      if (strings != null) {
        names = Object.getOwnPropertyNames(strings);
        entries = names.length;
        for (index = 0, i = 0; i < entries; ++i) {
          result[index] = names[i];
          ++index;
        }
      } else
        index = 0;
      nums = _this._collection$_nums;
      if (nums != null) {
        names = Object.getOwnPropertyNames(nums);
        entries = names.length;
        for (i = 0; i < entries; ++i) {
          result[index] = +names[i];
          ++index;
        }
      }
      rest = _this._collection$_rest;
      if (rest != null) {
        names = Object.getOwnPropertyNames(rest);
        entries = names.length;
        for (i = 0; i < entries; ++i) {
          bucket = rest[names[i]];
          $length = bucket.length;
          for (i0 = 0; i0 < $length; i0 += 2) {
            result[index] = bucket[i0];
            ++index;
          }
        }
      }
      return _this._collection$_keys = result;
    },
    _collection$_addHashTableEntry$3: function(table, key, value) {
      if (table[key] == null) {
        ++this._collection$_length;
        this._collection$_keys = null;
      }
      P._HashMap__setTableEntry(table, key, value);
    },
    _removeHashTableEntry$2: function(table, key) {
      var value;
      if (table != null && table[key] != null) {
        value = P._HashMap__getTableEntry(table, key);
        delete table[key];
        --this._collection$_length;
        this._collection$_keys = null;
        return value;
      } else
        return;
    },
    _computeHashCode$1: function(key) {
      return J.get$hashCode$(key) & 1073741823;
    },
    _getBucket$2: function(table, key) {
      return table[this._computeHashCode$1(key)];
    },
    _findBucketIndex$2: function(bucket, key) {
      var $length, i;
      if (bucket == null)
        return -1;
      $length = bucket.length;
      for (i = 0; i < $length; i += 2)
        if (J.$eq$(bucket[i], key))
          return i;
      return -1;
    }
  };
  P._HashMap_values_closure.prototype = {
    call$1: function(each) {
      return this.$this.$index(0, each);
    },
    $signature: function() {
      var t1 = this.$this;
      return {func: 1, ret: H.getTypeArgumentByIndex(t1, 1), args: [H.getTypeArgumentByIndex(t1, 0)]};
    }
  };
  P._HashMap_addAll_closure.prototype = {
    call$2: function(key, value) {
      this.$this.$indexSet(0, key, value);
    },
    $signature: function() {
      var t1 = this.$this;
      return {func: 1, ret: P.Null, args: [H.getTypeArgumentByIndex(t1, 0), H.getTypeArgumentByIndex(t1, 1)]};
    }
  };
  P._HashMapKeyIterable.prototype = {
    get$length: function(_) {
      return this._collection$_map._collection$_length;
    },
    get$isEmpty: function(_) {
      return this._collection$_map._collection$_length === 0;
    },
    get$iterator: function(_) {
      var t1 = this._collection$_map;
      return new P._HashMapKeyIterator(t1, t1._computeKeys$0());
    },
    contains$1: function(_, element) {
      return this._collection$_map.containsKey$1(element);
    }
  };
  P._HashMapKeyIterator.prototype = {
    get$current: function(_) {
      return this._collection$_current;
    },
    moveNext$0: function() {
      var _this = this,
        keys = _this._collection$_keys,
        offset = _this._offset,
        t1 = _this._collection$_map;
      if (keys !== t1._collection$_keys)
        throw H.wrapException(P.ConcurrentModificationError$(t1));
      else if (offset >= keys.length) {
        _this._collection$_current = null;
        return false;
      } else {
        _this._collection$_current = keys[offset];
        _this._offset = offset + 1;
        return true;
      }
    }
  };
  P._LinkedIdentityHashMap.prototype = {
    internalComputeHashCode$1: function(key) {
      return H.objectHashCode(key) & 1073741823;
    },
    internalFindBucketIndex$2: function(bucket, key) {
      var $length, i, t1;
      if (bucket == null)
        return -1;
      $length = bucket.length;
      for (i = 0; i < $length; ++i) {
        t1 = bucket[i].hashMapCellKey;
        if (t1 == null ? key == null : t1 === key)
          return i;
      }
      return -1;
    }
  };
  P._LinkedCustomHashMap.prototype = {
    $index: function(_, key) {
      if (!this._validKey.call$1(key))
        return;
      return this.super$JsLinkedHashMap$internalGet(key);
    },
    $indexSet: function(_, key, value) {
      this.super$JsLinkedHashMap$internalSet(key, value);
    },
    containsKey$1: function(key) {
      if (!this._validKey.call$1(key))
        return false;
      return this.super$JsLinkedHashMap$internalContainsKey(key);
    },
    remove$1: function(_, key) {
      if (!this._validKey.call$1(key))
        return;
      return this.super$JsLinkedHashMap$internalRemove(key);
    },
    internalComputeHashCode$1: function(key) {
      return this._collection$_hashCode.call$1(key) & 1073741823;
    },
    internalFindBucketIndex$2: function(bucket, key) {
      var $length, t1, i;
      if (bucket == null)
        return -1;
      $length = bucket.length;
      for (t1 = this._equals, i = 0; i < $length; ++i)
        if (t1.call$2(bucket[i].hashMapCellKey, key))
          return i;
      return -1;
    }
  };
  P._LinkedCustomHashMap_closure.prototype = {
    call$1: function(v) {
      return H.checkSubtypeOfRuntimeType(v, this.K);
    },
    $signature: 19
  };
  P._LinkedHashSet.prototype = {
    _newSet$0: function() {
      return new P._LinkedHashSet(this.$ti);
    },
    _newSimilarSet$1$0: function($R) {
      return new P._LinkedHashSet([$R]);
    },
    _newSimilarSet$0: function() {
      return this._newSimilarSet$1$0(null);
    },
    get$iterator: function(_) {
      var t1 = new P._LinkedHashSetIterator(this, this._collection$_modifications);
      t1._collection$_cell = this._collection$_first;
      return t1;
    },
    get$length: function(_) {
      return this._collection$_length;
    },
    get$isEmpty: function(_) {
      return this._collection$_length === 0;
    },
    get$isNotEmpty: function(_) {
      return this._collection$_length !== 0;
    },
    contains$1: function(_, object) {
      var strings, nums;
      if (typeof object === "string" && object !== "__proto__") {
        strings = this._collection$_strings;
        if (strings == null)
          return false;
        return strings[object] != null;
      } else if (typeof object === "number" && (object & 1073741823) === object) {
        nums = this._collection$_nums;
        if (nums == null)
          return false;
        return nums[object] != null;
      } else
        return this._contains$1(object);
    },
    _contains$1: function(object) {
      var rest = this._collection$_rest;
      if (rest == null)
        return false;
      return this._findBucketIndex$2(this._getBucket$2(rest, object), object) >= 0;
    },
    get$first: function(_) {
      var t1 = this._collection$_first;
      if (t1 == null)
        throw H.wrapException(P.StateError$("No elements"));
      return t1._element;
    },
    get$last: function(_) {
      var t1 = this._collection$_last;
      if (t1 == null)
        throw H.wrapException(P.StateError$("No elements"));
      return t1._element;
    },
    add$1: function(_, element) {
      var strings, nums, _this = this;
      if (typeof element === "string" && element !== "__proto__") {
        strings = _this._collection$_strings;
        return _this._collection$_addHashTableEntry$2(strings == null ? _this._collection$_strings = P._LinkedHashSet__newHashTable() : strings, element);
      } else if (typeof element === "number" && (element & 1073741823) === element) {
        nums = _this._collection$_nums;
        return _this._collection$_addHashTableEntry$2(nums == null ? _this._collection$_nums = P._LinkedHashSet__newHashTable() : nums, element);
      } else
        return _this._collection$_add$1(element);
    },
    _collection$_add$1: function(element) {
      var hash, bucket, _this = this,
        rest = _this._collection$_rest;
      if (rest == null)
        rest = _this._collection$_rest = P._LinkedHashSet__newHashTable();
      hash = _this._computeHashCode$1(element);
      bucket = rest[hash];
      if (bucket == null)
        rest[hash] = [_this._collection$_newLinkedCell$1(element)];
      else {
        if (_this._findBucketIndex$2(bucket, element) >= 0)
          return false;
        bucket.push(_this._collection$_newLinkedCell$1(element));
      }
      return true;
    },
    remove$1: function(_, object) {
      var _this = this;
      if (typeof object === "string" && object !== "__proto__")
        return _this._removeHashTableEntry$2(_this._collection$_strings, object);
      else if (typeof object === "number" && (object & 1073741823) === object)
        return _this._removeHashTableEntry$2(_this._collection$_nums, object);
      else
        return _this._remove$1(object);
    },
    _remove$1: function(object) {
      var bucket, index, _this = this,
        rest = _this._collection$_rest;
      if (rest == null)
        return false;
      bucket = _this._getBucket$2(rest, object);
      index = _this._findBucketIndex$2(bucket, object);
      if (index < 0)
        return false;
      _this._unlinkCell$1(bucket.splice(index, 1)[0]);
      return true;
    },
    _collection$_addHashTableEntry$2: function(table, element) {
      if (table[element] != null)
        return false;
      table[element] = this._collection$_newLinkedCell$1(element);
      return true;
    },
    _removeHashTableEntry$2: function(table, element) {
      var cell;
      if (table == null)
        return false;
      cell = table[element];
      if (cell == null)
        return false;
      this._unlinkCell$1(cell);
      delete table[element];
      return true;
    },
    _collection$_modified$0: function() {
      this._collection$_modifications = 1073741823 & this._collection$_modifications + 1;
    },
    _collection$_newLinkedCell$1: function(element) {
      var last, _this = this,
        cell = new P._LinkedHashSetCell(element);
      if (_this._collection$_first == null)
        _this._collection$_first = _this._collection$_last = cell;
      else {
        last = _this._collection$_last;
        cell._collection$_previous = last;
        _this._collection$_last = last._collection$_next = cell;
      }
      ++_this._collection$_length;
      _this._collection$_modified$0();
      return cell;
    },
    _unlinkCell$1: function(cell) {
      var _this = this,
        previous = cell._collection$_previous,
        next = cell._collection$_next;
      if (previous == null)
        _this._collection$_first = next;
      else
        previous._collection$_next = next;
      if (next == null)
        _this._collection$_last = previous;
      else
        next._collection$_previous = previous;
      --_this._collection$_length;
      _this._collection$_modified$0();
    },
    _computeHashCode$1: function(element) {
      return J.get$hashCode$(element) & 1073741823;
    },
    _getBucket$2: function(table, element) {
      return table[this._computeHashCode$1(element)];
    },
    _findBucketIndex$2: function(bucket, element) {
      var $length, i;
      if (bucket == null)
        return -1;
      $length = bucket.length;
      for (i = 0; i < $length; ++i)
        if (J.$eq$(bucket[i]._element, element))
          return i;
      return -1;
    }
  };
  P._LinkedIdentityHashSet.prototype = {
    _newSet$0: function() {
      return new P._LinkedIdentityHashSet(this.$ti);
    },
    _newSimilarSet$1$0: function($R) {
      return new P._LinkedIdentityHashSet([$R]);
    },
    _newSimilarSet$0: function() {
      return this._newSimilarSet$1$0(null);
    },
    _computeHashCode$1: function(key) {
      return H.objectHashCode(key) & 1073741823;
    },
    _findBucketIndex$2: function(bucket, element) {
      var $length, i, t1;
      if (bucket == null)
        return -1;
      $length = bucket.length;
      for (i = 0; i < $length; ++i) {
        t1 = bucket[i]._element;
        if (t1 == null ? element == null : t1 === element)
          return i;
      }
      return -1;
    }
  };
  P._LinkedHashSetCell.prototype = {};
  P._LinkedHashSetIterator.prototype = {
    get$current: function(_) {
      return this._collection$_current;
    },
    moveNext$0: function() {
      var _this = this,
        t1 = _this._set;
      if (_this._collection$_modifications !== t1._collection$_modifications)
        throw H.wrapException(P.ConcurrentModificationError$(t1));
      else {
        t1 = _this._collection$_cell;
        if (t1 == null) {
          _this._collection$_current = null;
          return false;
        } else {
          _this._collection$_current = t1._element;
          _this._collection$_cell = t1._collection$_next;
          return true;
        }
      }
    }
  };
  P.UnmodifiableListView.prototype = {
    cast$1$0: function(_, $R) {
      return new P.UnmodifiableListView(J.cast$1$0$ax(this._collection$_source, $R), [$R]);
    },
    get$length: function(_) {
      return J.get$length$asx(this._collection$_source);
    },
    $index: function(_, index) {
      return J.elementAt$1$ax(this._collection$_source, index);
    }
  };
  P.HashMap_HashMap$from_closure.prototype = {
    call$2: function(k, v) {
      this.result.$indexSet(0, k, v);
    },
    $signature: 12
  };
  P.IterableBase.prototype = {};
  P.LinkedHashMap_LinkedHashMap$from_closure.prototype = {
    call$2: function(k, v) {
      this.result.$indexSet(0, k, v);
    },
    $signature: 12
  };
  P.ListBase.prototype = {$isEfficientLengthIterable: 1, $isIterable: 1, $isList: 1};
  P.ListMixin.prototype = {
    get$iterator: function(receiver) {
      return new H.ListIterator(receiver, this.get$length(receiver));
    },
    elementAt$1: function(receiver, index) {
      return this.$index(receiver, index);
    },
    get$isEmpty: function(receiver) {
      return this.get$length(receiver) === 0;
    },
    get$isNotEmpty: function(receiver) {
      return !this.get$isEmpty(receiver);
    },
    get$first: function(receiver) {
      if (this.get$length(receiver) === 0)
        throw H.wrapException(H.IterableElementError_noElement());
      return this.$index(receiver, 0);
    },
    get$last: function(receiver) {
      if (this.get$length(receiver) === 0)
        throw H.wrapException(H.IterableElementError_noElement());
      return this.$index(receiver, this.get$length(receiver) - 1);
    },
    get$single: function(receiver) {
      if (this.get$length(receiver) === 0)
        throw H.wrapException(H.IterableElementError_noElement());
      if (this.get$length(receiver) > 1)
        throw H.wrapException(H.IterableElementError_tooMany());
      return this.$index(receiver, 0);
    },
    contains$1: function(receiver, element) {
      var i,
        $length = this.get$length(receiver);
      for (i = 0; i < $length; ++i) {
        if (J.$eq$(this.$index(receiver, i), element))
          return true;
        if ($length !== this.get$length(receiver))
          throw H.wrapException(P.ConcurrentModificationError$(receiver));
      }
      return false;
    },
    every$1: function(receiver, test) {
      var i,
        $length = this.get$length(receiver);
      for (i = 0; i < $length; ++i) {
        if (!test.call$1(this.$index(receiver, i)))
          return false;
        if ($length !== this.get$length(receiver))
          throw H.wrapException(P.ConcurrentModificationError$(receiver));
      }
      return true;
    },
    any$1: function(receiver, test) {
      var i,
        $length = this.get$length(receiver);
      for (i = 0; i < $length; ++i) {
        if (test.call$1(this.$index(receiver, i)))
          return true;
        if ($length !== this.get$length(receiver))
          throw H.wrapException(P.ConcurrentModificationError$(receiver));
      }
      return false;
    },
    join$1: function(receiver, separator) {
      var t1;
      if (this.get$length(receiver) === 0)
        return "";
      t1 = P.StringBuffer__writeAll("", receiver, separator);
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    join$0: function($receiver) {
      return this.join$1($receiver, "");
    },
    where$1: function(receiver, test) {
      return new H.WhereIterable(receiver, test, [H.getRuntimeTypeArgumentIntercepted(this, receiver, "ListMixin", 0)]);
    },
    map$1$1: function(receiver, f, $T) {
      return new H.MappedListIterable(receiver, f, [H.getRuntimeTypeArgumentIntercepted(this, receiver, "ListMixin", 0), $T]);
    },
    expand$1$1: function(receiver, f, $T) {
      return new H.ExpandIterable(receiver, f, [H.getRuntimeTypeArgumentIntercepted(this, receiver, "ListMixin", 0), $T]);
    },
    skip$1: function(receiver, count) {
      return H.SubListIterable$(receiver, count, null, H.getRuntimeTypeArgumentIntercepted(this, receiver, "ListMixin", 0));
    },
    take$1: function(receiver, count) {
      return H.SubListIterable$(receiver, 0, count, H.getRuntimeTypeArgumentIntercepted(this, receiver, "ListMixin", 0));
    },
    toList$1$growable: function(receiver, growable) {
      var i, _this = this,
        result = H.setRuntimeTypeInfo([], [H.getRuntimeTypeArgumentIntercepted(_this, receiver, "ListMixin", 0)]);
      C.JSArray_methods.set$length(result, _this.get$length(receiver));
      for (i = 0; i < _this.get$length(receiver); ++i)
        result[i] = _this.$index(receiver, i);
      return result;
    },
    toList$0: function($receiver) {
      return this.toList$1$growable($receiver, true);
    },
    toSet$0: function(receiver) {
      var i,
        result = P.LinkedHashSet_LinkedHashSet(H.getRuntimeTypeArgumentIntercepted(this, receiver, "ListMixin", 0));
      for (i = 0; i < this.get$length(receiver); ++i)
        result.add$1(0, this.$index(receiver, i));
      return result;
    },
    add$1: function(receiver, element) {
      var t1 = this.get$length(receiver);
      this.set$length(receiver, t1 + 1);
      this.$indexSet(receiver, t1, element);
    },
    cast$1$0: function(receiver, $R) {
      return new H.CastList(receiver, [H.getRuntimeTypeArgumentIntercepted(this, receiver, "ListMixin", 0), $R]);
    },
    sublist$2: function(receiver, start, end) {
      var $length, result, i,
        listLength = this.get$length(receiver);
      P.RangeError_checkValidRange(start, end, listLength);
      $length = end - start;
      result = H.setRuntimeTypeInfo([], [H.getRuntimeTypeArgumentIntercepted(this, receiver, "ListMixin", 0)]);
      C.JSArray_methods.set$length(result, $length);
      for (i = 0; i < $length; ++i)
        result[i] = this.$index(receiver, start + i);
      return result;
    },
    getRange$2: function(receiver, start, end) {
      P.RangeError_checkValidRange(start, end, this.get$length(receiver));
      return H.SubListIterable$(receiver, start, end, H.getRuntimeTypeArgumentIntercepted(this, receiver, "ListMixin", 0));
    },
    fillRange$3: function(receiver, start, end, fill) {
      var i;
      P.RangeError_checkValidRange(start, end, this.get$length(receiver));
      for (i = start; i < end; ++i)
        this.$indexSet(receiver, i, fill);
    },
    setRange$4: function(receiver, start, end, iterable, skipCount) {
      var $length, otherStart, otherList, t1, i, _this = this;
      P.RangeError_checkValidRange(start, end, _this.get$length(receiver));
      $length = end - start;
      if ($length === 0)
        return;
      P.RangeError_checkNotNegative(skipCount, "skipCount");
      if (H.checkSubtype(iterable, "$isList", [H.getRuntimeTypeArgumentIntercepted(_this, receiver, "ListMixin", 0)], "$asList")) {
        otherStart = skipCount;
        otherList = iterable;
      } else {
        otherList = J.skip$1$ax(iterable, skipCount).toList$1$growable(0, false);
        otherStart = 0;
      }
      t1 = J.getInterceptor$asx(otherList);
      if (otherStart + $length > t1.get$length(otherList))
        throw H.wrapException(H.IterableElementError_tooFew());
      if (otherStart < start)
        for (i = $length - 1; i >= 0; --i)
          _this.$indexSet(receiver, start + i, t1.$index(otherList, otherStart + i));
      else
        for (i = 0; i < $length; ++i)
          _this.$indexSet(receiver, start + i, t1.$index(otherList, otherStart + i));
    },
    get$reversed: function(receiver) {
      return new H.ReversedListIterable(receiver, [H.getRuntimeTypeArgumentIntercepted(this, receiver, "ListMixin", 0)]);
    },
    toString$0: function(receiver) {
      return P.IterableBase_iterableToFullString(receiver, "[", "]");
    }
  };
  P.MapBase.prototype = {};
  P.MapBase_mapToString_closure.prototype = {
    call$2: function(k, v) {
      var t2,
        t1 = this._box_0;
      if (!t1.first)
        this.result._contents += ", ";
      t1.first = false;
      t1 = this.result;
      t2 = t1._contents += H.S(k);
      t1._contents = t2 + ": ";
      t1._contents += H.S(v);
    },
    $signature: 12
  };
  P.MapMixin.prototype = {
    forEach$1: function(_, action) {
      var t1, key;
      for (t1 = J.get$iterator$ax(this.get$keys()); t1.moveNext$0();) {
        key = t1.get$current(t1);
        action.call$2(key, this.$index(0, key));
      }
    },
    addAll$1: function(_, other) {
      var t1, key;
      for (t1 = J.get$iterator$ax(other.get$keys()); t1.moveNext$0();) {
        key = t1.get$current(t1);
        this.$indexSet(0, key, other.$index(0, key));
      }
    },
    putIfAbsent$2: function(key, ifAbsent) {
      var t1;
      if (this.containsKey$1(key))
        return this.$index(0, key);
      t1 = ifAbsent.call$0();
      this.$indexSet(0, key, t1);
      return t1;
    },
    get$entries: function() {
      var _this = this;
      return J.map$1$1$ax(_this.get$keys(), new P.MapMixin_entries_closure(_this), [P.MapEntry, H.getRuntimeTypeArgument(_this, "MapMixin", 0), H.getRuntimeTypeArgument(_this, "MapMixin", 1)]);
    },
    containsKey$1: function(key) {
      return J.contains$1$asx(this.get$keys(), key);
    },
    get$length: function(_) {
      return J.get$length$asx(this.get$keys());
    },
    get$isEmpty: function(_) {
      return J.get$isEmpty$asx(this.get$keys());
    },
    get$isNotEmpty: function(_) {
      return J.get$isNotEmpty$asx(this.get$keys());
    },
    get$values: function() {
      return new P._MapBaseValueIterable(this, [H.getRuntimeTypeArgument(this, "MapMixin", 0), H.getRuntimeTypeArgument(this, "MapMixin", 1)]);
    },
    toString$0: function(_) {
      return P.MapBase_mapToString(this);
    },
    $isMap: 1
  };
  P.MapMixin_entries_closure.prototype = {
    call$1: function(key) {
      var t1 = this.$this;
      return new P.MapEntry(key, t1.$index(0, key), [H.getRuntimeTypeArgument(t1, "MapMixin", 0), H.getRuntimeTypeArgument(t1, "MapMixin", 1)]);
    },
    $signature: function() {
      var t1 = this.$this,
        t2 = H.getRuntimeTypeArgument(t1, "MapMixin", 0);
      return {func: 1, ret: [P.MapEntry, t2, H.getRuntimeTypeArgument(t1, "MapMixin", 1)], args: [t2]};
    }
  };
  P.UnmodifiableMapBase.prototype = {};
  P._MapBaseValueIterable.prototype = {
    get$length: function(_) {
      var t1 = this._collection$_map;
      return t1.get$length(t1);
    },
    get$isEmpty: function(_) {
      var t1 = this._collection$_map;
      return t1.get$isEmpty(t1);
    },
    get$isNotEmpty: function(_) {
      var t1 = this._collection$_map;
      return t1.get$isNotEmpty(t1);
    },
    get$first: function(_) {
      var t1 = this._collection$_map;
      return t1.$index(0, J.get$first$ax(t1.get$keys()));
    },
    get$single: function(_) {
      var t1 = this._collection$_map;
      return t1.$index(0, J.get$single$ax(t1.get$keys()));
    },
    get$last: function(_) {
      var t1 = this._collection$_map;
      return t1.$index(0, J.get$last$ax(t1.get$keys()));
    },
    get$iterator: function(_) {
      var t1 = this._collection$_map;
      return new P._MapBaseValueIterator(J.get$iterator$ax(t1.get$keys()), t1);
    },
    $asEfficientLengthIterable: function($K, $V) {
      return [$V];
    },
    $asIterable: function($K, $V) {
      return [$V];
    }
  };
  P._MapBaseValueIterator.prototype = {
    moveNext$0: function() {
      var _this = this,
        t1 = _this._collection$_keys;
      if (t1.moveNext$0()) {
        _this._collection$_current = _this._collection$_map.$index(0, t1.get$current(t1));
        return true;
      }
      _this._collection$_current = null;
      return false;
    },
    get$current: function(_) {
      return this._collection$_current;
    }
  };
  P._UnmodifiableMapMixin.prototype = {
    $indexSet: function(_, key, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot modify unmodifiable map"));
    },
    addAll$1: function(_, other) {
      throw H.wrapException(P.UnsupportedError$("Cannot modify unmodifiable map"));
    },
    remove$1: function(_, key) {
      throw H.wrapException(P.UnsupportedError$("Cannot modify unmodifiable map"));
    },
    putIfAbsent$2: function(key, ifAbsent) {
      throw H.wrapException(P.UnsupportedError$("Cannot modify unmodifiable map"));
    }
  };
  P.MapView.prototype = {
    $index: function(_, key) {
      return this._collection$_map.$index(0, key);
    },
    $indexSet: function(_, key, value) {
      this._collection$_map.$indexSet(0, key, value);
    },
    addAll$1: function(_, other) {
      this._collection$_map.addAll$1(0, other);
    },
    putIfAbsent$2: function(key, ifAbsent) {
      return this._collection$_map.putIfAbsent$2(key, ifAbsent);
    },
    containsKey$1: function(key) {
      return this._collection$_map.containsKey$1(key);
    },
    forEach$1: function(_, action) {
      this._collection$_map.forEach$1(0, action);
    },
    get$isEmpty: function(_) {
      var t1 = this._collection$_map;
      return t1.get$isEmpty(t1);
    },
    get$isNotEmpty: function(_) {
      var t1 = this._collection$_map;
      return t1.get$isNotEmpty(t1);
    },
    get$length: function(_) {
      var t1 = this._collection$_map;
      return t1.get$length(t1);
    },
    get$keys: function() {
      return this._collection$_map.get$keys();
    },
    remove$1: function(_, key) {
      return this._collection$_map.remove$1(0, key);
    },
    toString$0: function(_) {
      return this._collection$_map.toString$0(0);
    },
    get$values: function() {
      return this._collection$_map.get$values();
    },
    get$entries: function() {
      return this._collection$_map.get$entries();
    },
    $isMap: 1
  };
  P.UnmodifiableMapView.prototype = {};
  P.Queue.prototype = {$isEfficientLengthIterable: 1, $isIterable: 1};
  P.ListQueue.prototype = {
    cast$1$0: function(_, $R) {
      return new H.CastQueue(this, [H.getTypeArgumentByIndex(this, 0), $R]);
    },
    get$iterator: function(_) {
      var _this = this;
      return new P._ListQueueIterator(_this, _this._collection$_tail, _this._modificationCount, _this._collection$_head);
    },
    get$isEmpty: function(_) {
      return this._collection$_head === this._collection$_tail;
    },
    get$length: function(_) {
      return (this._collection$_tail - this._collection$_head & this._collection$_table.length - 1) >>> 0;
    },
    get$first: function(_) {
      var t1 = this._collection$_head;
      if (t1 === this._collection$_tail)
        throw H.wrapException(H.IterableElementError_noElement());
      return this._collection$_table[t1];
    },
    get$last: function(_) {
      var t1 = this._collection$_head,
        t2 = this._collection$_tail;
      if (t1 === t2)
        throw H.wrapException(H.IterableElementError_noElement());
      t1 = this._collection$_table;
      return t1[(t2 - 1 & t1.length - 1) >>> 0];
    },
    get$single: function(_) {
      var _this = this;
      if (_this._collection$_head === _this._collection$_tail)
        throw H.wrapException(H.IterableElementError_noElement());
      if (_this.get$length(_this) > 1)
        throw H.wrapException(H.IterableElementError_tooMany());
      return _this._collection$_table[_this._collection$_head];
    },
    elementAt$1: function(_, index) {
      var t1;
      P.RangeError_checkValidIndex(index, this, null);
      t1 = this._collection$_table;
      return t1[(this._collection$_head + index & t1.length - 1) >>> 0];
    },
    add$1: function(_, value) {
      this._collection$_add$1(value);
    },
    addAll$1: function(_, elements) {
      var addCount, $length, t2, t3, t4, newTable, endSpace, preSpace, _this = this,
        t1 = _this.$ti;
      if (H.checkSubtype(elements, "$isList", t1, "$asList")) {
        addCount = J.get$length$asx(elements);
        $length = _this.get$length(_this);
        t2 = $length + addCount;
        t3 = _this._collection$_table;
        t4 = t3.length;
        if (t2 >= t4) {
          t3 = new Array(P.ListQueue__nextPowerOf2(t2 + C.JSInt_methods._shrOtherPositive$1(t2, 1)));
          t3.fixed$length = Array;
          newTable = H.setRuntimeTypeInfo(t3, t1);
          _this._collection$_tail = _this._collection$_writeToList$1(newTable);
          _this._collection$_table = newTable;
          _this._collection$_head = 0;
          C.JSArray_methods.setRange$4(newTable, $length, t2, elements, 0);
          _this._collection$_tail += addCount;
        } else {
          t1 = _this._collection$_tail;
          endSpace = t4 - t1;
          if (addCount < endSpace) {
            C.JSArray_methods.setRange$4(t3, t1, t1 + addCount, elements, 0);
            _this._collection$_tail += addCount;
          } else {
            preSpace = addCount - endSpace;
            C.JSArray_methods.setRange$4(t3, t1, t1 + endSpace, elements, 0);
            C.JSArray_methods.setRange$4(_this._collection$_table, 0, preSpace, elements, endSpace);
            _this._collection$_tail = preSpace;
          }
        }
        ++_this._modificationCount;
      } else
        for (t1 = J.get$iterator$ax(elements); t1.moveNext$0();)
          _this._collection$_add$1(t1.get$current(t1));
    },
    toString$0: function(_) {
      return P.IterableBase_iterableToFullString(this, "{", "}");
    },
    addFirst$1: function(value) {
      var _this = this,
        t1 = _this._collection$_head,
        t2 = _this._collection$_table;
      t1 = _this._collection$_head = (t1 - 1 & t2.length - 1) >>> 0;
      t2[t1] = value;
      if (t1 === _this._collection$_tail)
        _this._collection$_grow$0();
      ++_this._modificationCount;
    },
    removeFirst$0: function() {
      var t2, result, _this = this,
        t1 = _this._collection$_head;
      if (t1 === _this._collection$_tail)
        throw H.wrapException(H.IterableElementError_noElement());
      ++_this._modificationCount;
      t2 = _this._collection$_table;
      result = t2[t1];
      t2[t1] = null;
      _this._collection$_head = (t1 + 1 & t2.length - 1) >>> 0;
      return result;
    },
    removeLast$0: function(_) {
      var result, _this = this,
        t1 = _this._collection$_head,
        t2 = _this._collection$_tail;
      if (t1 === t2)
        throw H.wrapException(H.IterableElementError_noElement());
      ++_this._modificationCount;
      t1 = _this._collection$_table;
      t2 = _this._collection$_tail = (t2 - 1 & t1.length - 1) >>> 0;
      result = t1[t2];
      t1[t2] = null;
      return result;
    },
    _collection$_add$1: function(element) {
      var _this = this,
        t1 = _this._collection$_table,
        t2 = _this._collection$_tail;
      t1[t2] = element;
      t1 = (t2 + 1 & t1.length - 1) >>> 0;
      _this._collection$_tail = t1;
      if (_this._collection$_head === t1)
        _this._collection$_grow$0();
      ++_this._modificationCount;
    },
    _collection$_grow$0: function() {
      var newTable, t2, split, _this = this,
        t1 = new Array(_this._collection$_table.length * 2);
      t1.fixed$length = Array;
      newTable = H.setRuntimeTypeInfo(t1, _this.$ti);
      t1 = _this._collection$_table;
      t2 = _this._collection$_head;
      split = t1.length - t2;
      C.JSArray_methods.setRange$4(newTable, 0, split, t1, t2);
      C.JSArray_methods.setRange$4(newTable, split, split + _this._collection$_head, _this._collection$_table, 0);
      _this._collection$_head = 0;
      _this._collection$_tail = _this._collection$_table.length;
      _this._collection$_table = newTable;
    },
    _collection$_writeToList$1: function(target) {
      var $length, firstPartSize, _this = this,
        t1 = _this._collection$_head,
        t2 = _this._collection$_tail,
        t3 = _this._collection$_table;
      if (t1 <= t2) {
        $length = t2 - t1;
        C.JSArray_methods.setRange$4(target, 0, $length, t3, t1);
        return $length;
      } else {
        firstPartSize = t3.length - t1;
        C.JSArray_methods.setRange$4(target, 0, firstPartSize, t3, t1);
        C.JSArray_methods.setRange$4(target, firstPartSize, firstPartSize + _this._collection$_tail, _this._collection$_table, 0);
        return _this._collection$_tail + firstPartSize;
      }
    },
    $isQueue: 1
  };
  P._ListQueueIterator.prototype = {
    get$current: function(_) {
      return this._collection$_current;
    },
    moveNext$0: function() {
      var t2, _this = this,
        t1 = _this._queue;
      if (_this._modificationCount !== t1._modificationCount)
        H.throwExpression(P.ConcurrentModificationError$(t1));
      t2 = _this._position;
      if (t2 === _this._collection$_end) {
        _this._collection$_current = null;
        return false;
      }
      t1 = t1._collection$_table;
      _this._collection$_current = t1[t2];
      _this._position = (t2 + 1 & t1.length - 1) >>> 0;
      return true;
    }
  };
  P._SetBase.prototype = {
    cast$1$0: function(_, $R) {
      return P.Set_castFrom(this, this.get$_newSimilarSet(), H.getTypeArgumentByIndex(this, 0), $R);
    },
    difference$1: function(other) {
      var t1, element,
        result = this._newSet$0();
      for (t1 = P._LinkedHashSetIterator$(this, this._collection$_modifications); t1.moveNext$0();) {
        element = t1._collection$_current;
        if (!other.contains$1(0, element))
          result.add$1(0, element);
      }
      return result;
    },
    intersection$1: function(other) {
      var t1, t2, element,
        result = this._newSet$0();
      for (t1 = P._LinkedHashSetIterator$(this, this._collection$_modifications), t2 = other._baseMap; t1.moveNext$0();) {
        element = t1._collection$_current;
        if (t2.containsKey$1(element))
          result.add$1(0, element);
      }
      return result;
    },
    toSet$0: function(_) {
      var t1 = this._newSet$0();
      t1.addAll$1(0, this);
      return t1;
    },
    get$isEmpty: function(_) {
      return this._collection$_length === 0;
    },
    get$isNotEmpty: function(_) {
      return this._collection$_length !== 0;
    },
    followedBy$1: function(_, other) {
      return H.FollowedByIterable_FollowedByIterable$firstEfficient(this, other, H.getTypeArgumentByIndex(this, 0));
    },
    addAll$1: function(_, elements) {
      var t1;
      for (t1 = J.get$iterator$ax(elements); t1.moveNext$0();)
        this.add$1(0, t1.get$current(t1));
    },
    removeAll$1: function(elements) {
      var t1;
      for (t1 = J.get$iterator$ax(elements); t1.moveNext$0();)
        this.remove$1(0, t1.get$current(t1));
    },
    toList$1$growable: function(_, growable) {
      var t1, i, i0, _this = this,
        result = H.setRuntimeTypeInfo([], _this.$ti);
      C.JSArray_methods.set$length(result, _this._collection$_length);
      for (t1 = P._LinkedHashSetIterator$(_this, _this._collection$_modifications), i = 0; t1.moveNext$0(); i = i0) {
        i0 = i + 1;
        result[i] = t1._collection$_current;
      }
      return result;
    },
    toList$0: function($receiver) {
      return this.toList$1$growable($receiver, true);
    },
    map$1$1: function(_, f, $T) {
      return new H.EfficientLengthMappedIterable(this, f, [H.getTypeArgumentByIndex(this, 0), $T]);
    },
    get$single: function(_) {
      var it;
      if (this._collection$_length > 1)
        throw H.wrapException(H.IterableElementError_tooMany());
      it = P._LinkedHashSetIterator$(this, this._collection$_modifications);
      if (!it.moveNext$0())
        throw H.wrapException(H.IterableElementError_noElement());
      return it._collection$_current;
    },
    toString$0: function(_) {
      return P.IterableBase_iterableToFullString(this, "{", "}");
    },
    where$1: function(_, f) {
      return new H.WhereIterable(this, f, this.$ti);
    },
    join$1: function(_, separator) {
      var t1,
        iterator = P._LinkedHashSetIterator$(this, this._collection$_modifications);
      if (!iterator.moveNext$0())
        return "";
      if (separator === "") {
        t1 = "";
        do
          t1 += H.S(iterator._collection$_current);
        while (iterator.moveNext$0());
      } else {
        t1 = H.S(iterator._collection$_current);
        for (; iterator.moveNext$0();)
          t1 = t1 + separator + H.S(iterator._collection$_current);
      }
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    join$0: function($receiver) {
      return this.join$1($receiver, "");
    },
    take$1: function(_, n) {
      return H.TakeIterable_TakeIterable(this, n, H.getTypeArgumentByIndex(this, 0));
    },
    skip$1: function(_, n) {
      return H.SkipIterable_SkipIterable(this, n, H.getTypeArgumentByIndex(this, 0));
    },
    get$first: function(_) {
      var it = P._LinkedHashSetIterator$(this, this._collection$_modifications);
      if (!it.moveNext$0())
        throw H.wrapException(H.IterableElementError_noElement());
      return it._collection$_current;
    },
    get$last: function(_) {
      var result,
        it = P._LinkedHashSetIterator$(this, this._collection$_modifications);
      if (!it.moveNext$0())
        throw H.wrapException(H.IterableElementError_noElement());
      do
        result = it._collection$_current;
      while (it.moveNext$0());
      return result;
    },
    elementAt$1: function(_, index) {
      var t1, elementIndex, element, _s5_ = "index";
      if (index == null)
        H.throwExpression(P.ArgumentError$notNull(_s5_));
      P.RangeError_checkNotNegative(index, _s5_);
      for (t1 = P._LinkedHashSetIterator$(this, this._collection$_modifications), elementIndex = 0; t1.moveNext$0();) {
        element = t1._collection$_current;
        if (index === elementIndex)
          return element;
        ++elementIndex;
      }
      throw H.wrapException(P.IndexError$(index, this, _s5_, null, elementIndex));
    },
    $isEfficientLengthIterable: 1,
    $isIterable: 1,
    $isSet: 1
  };
  P._ListBase_Object_ListMixin.prototype = {};
  P._UnmodifiableMapView_MapView__UnmodifiableMapMixin.prototype = {};
  P.AsciiCodec.prototype = {
    encode$1: function(source) {
      return C.AsciiEncoder_127.convert$1(source);
    },
    get$encoder: function() {
      return C.AsciiEncoder_127;
    }
  };
  P._UnicodeSubsetEncoder.prototype = {
    convert$1: function(string) {
      var t1, t2, i, codeUnit,
        $length = P.RangeError_checkValidRange(0, null, string.length) - 0,
        result = new Uint8Array($length);
      for (t1 = ~this._subsetMask, t2 = J.getInterceptor$s(string), i = 0; i < $length; ++i) {
        codeUnit = t2._codeUnitAt$1(string, i);
        if ((codeUnit & t1) !== 0)
          throw H.wrapException(P.ArgumentError$value(string, "string", "Contains invalid characters."));
        result[i] = codeUnit;
      }
      return result;
    },
    $asConverter: function() {
      return [P.String, [P.List, P.int]];
    }
  };
  P.AsciiEncoder.prototype = {};
  P.Base64Codec.prototype = {
    get$encoder: function() {
      return C.C_Base64Encoder;
    },
    normalize$3: function(source, start, end) {
      var inverseAlphabet, i, sliceStart, buffer, firstPadding, firstPaddingSourceIndex, paddingCount, i0, char, i1, digit1, digit2, char0, value, t1, t2, endLength, $length,
        _s31_ = "Invalid base64 encoding length ";
      end = P.RangeError_checkValidRange(start, end, source.length);
      inverseAlphabet = $.$get$_Base64Decoder__inverseAlphabet();
      for (i = start, sliceStart = i, buffer = null, firstPadding = -1, firstPaddingSourceIndex = -1, paddingCount = 0; i < end; i = i0) {
        i0 = i + 1;
        char = C.JSString_methods._codeUnitAt$1(source, i);
        if (char === 37) {
          i1 = i0 + 2;
          if (i1 <= end) {
            digit1 = H.hexDigitValue(C.JSString_methods._codeUnitAt$1(source, i0));
            digit2 = H.hexDigitValue(C.JSString_methods._codeUnitAt$1(source, i0 + 1));
            char0 = digit1 * 16 + digit2 - (digit2 & 256);
            if (char0 === 37)
              char0 = -1;
            i0 = i1;
          } else
            char0 = -1;
        } else
          char0 = char;
        if (0 <= char0 && char0 <= 127) {
          value = inverseAlphabet[char0];
          if (value >= 0) {
            char0 = C.JSString_methods.codeUnitAt$1("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", value);
            if (char0 === char)
              continue;
            char = char0;
          } else {
            if (value === -1) {
              if (firstPadding < 0) {
                t1 = buffer == null ? null : buffer._contents.length;
                if (t1 == null)
                  t1 = 0;
                firstPadding = t1 + (i - sliceStart);
                firstPaddingSourceIndex = i;
              }
              ++paddingCount;
              if (char === 61)
                continue;
            }
            char = char0;
          }
          if (value !== -2) {
            if (buffer == null)
              buffer = new P.StringBuffer("");
            buffer._contents += C.JSString_methods.substring$2(source, sliceStart, i);
            buffer._contents += H.Primitives_stringFromCharCode(char);
            sliceStart = i0;
            continue;
          }
        }
        throw H.wrapException(P.FormatException$("Invalid base64 data", source, i));
      }
      if (buffer != null) {
        t1 = buffer._contents += C.JSString_methods.substring$2(source, sliceStart, end);
        t2 = t1.length;
        if (firstPadding >= 0)
          P.Base64Codec__checkPadding(source, firstPaddingSourceIndex, end, firstPadding, paddingCount, t2);
        else {
          endLength = C.JSInt_methods.$mod(t2 - 1, 4) + 1;
          if (endLength === 1)
            throw H.wrapException(P.FormatException$(_s31_, source, end));
          for (; endLength < 4;) {
            t1 += "=";
            buffer._contents = t1;
            ++endLength;
          }
        }
        t1 = buffer._contents;
        return C.JSString_methods.replaceRange$3(source, start, end, t1.charCodeAt(0) == 0 ? t1 : t1);
      }
      $length = end - start;
      if (firstPadding >= 0)
        P.Base64Codec__checkPadding(source, firstPaddingSourceIndex, end, firstPadding, paddingCount, $length);
      else {
        endLength = C.JSInt_methods.$mod($length, 4);
        if (endLength === 1)
          throw H.wrapException(P.FormatException$(_s31_, source, end));
        if (endLength > 1)
          source = C.JSString_methods.replaceRange$3(source, end, end, endLength === 2 ? "==" : "=");
      }
      return source;
    },
    $asCodec: function() {
      return [[P.List, P.int], P.String];
    }
  };
  P.Base64Encoder.prototype = {
    convert$1: function(input) {
      var t1 = J.getInterceptor$asx(input);
      if (t1.get$isEmpty(input))
        return "";
      return P.String_String$fromCharCodes(new P._Base64Encoder("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/").encode$4(input, 0, t1.get$length(input), true), 0, null);
    },
    startChunkedConversion$1: function(sink) {
      var t1,
        _s64_ = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      if (!!sink.$isStringConversionSink) {
        t1 = sink.asUtf8Sink$1(false);
        return new P._Utf8Base64EncoderSink(t1, new P._Base64Encoder(_s64_));
      }
      return new P._AsciiBase64EncoderSink(sink, new P._BufferCachingBase64Encoder(_s64_));
    },
    $asConverter: function() {
      return [[P.List, P.int], P.String];
    }
  };
  P._Base64Encoder.prototype = {
    createBuffer$1: function(bufferLength) {
      return new Uint8Array(bufferLength);
    },
    encode$4: function(bytes, start, end, isLast) {
      var output, _this = this,
        byteCount = (_this._state & 3) + (end - start),
        fullChunks = C.JSInt_methods._tdivFast$1(byteCount, 3),
        bufferLength = fullChunks * 4;
      if (isLast && byteCount - fullChunks * 3 > 0)
        bufferLength += 4;
      output = _this.createBuffer$1(bufferLength);
      _this._state = P._Base64Encoder_encodeChunk(_this._alphabet, bytes, start, end, isLast, output, 0, _this._state);
      if (bufferLength > 0)
        return output;
      return;
    }
  };
  P._BufferCachingBase64Encoder.prototype = {
    createBuffer$1: function(bufferLength) {
      var t1 = this.bufferCache;
      if (t1 == null || t1.length < bufferLength)
        t1 = this.bufferCache = new Uint8Array(bufferLength);
      t1 = t1.buffer;
      t1.toString;
      return H.NativeUint8List_NativeUint8List$view(t1, 0, bufferLength);
    }
  };
  P._Base64EncoderSink.prototype = {
    add$1: function(_, source) {
      this._add$4(source, 0, J.get$length$asx(source), false);
    },
    close$0: function(_) {
      this._add$4(null, 0, 0, true);
    },
    addSlice$4: function(source, start, end, isLast) {
      P.RangeError_checkValidRange(start, end, source.length);
      this._add$4(source, start, end, isLast);
    }
  };
  P._AsciiBase64EncoderSink.prototype = {
    _add$4: function(source, start, end, isLast) {
      var buffer = this._encoder.encode$4(source, start, end, isLast);
      if (buffer != null)
        this._sink.add$1(0, P.String_String$fromCharCodes(buffer, 0, null));
      if (isLast)
        this._sink.close$0(0);
    }
  };
  P._Utf8Base64EncoderSink.prototype = {
    _add$4: function(source, start, end, isLast) {
      var buffer = this._encoder.encode$4(source, start, end, isLast);
      if (buffer != null)
        this._sink.addSlice$4(buffer, 0, buffer.length, isLast);
    }
  };
  P.ByteConversionSink.prototype = {};
  P.ByteConversionSinkBase.prototype = {};
  P.ChunkedConversionSink.prototype = {};
  P.Codec.prototype = {
    encode$1: function(input) {
      return this.get$encoder().convert$1(input);
    }
  };
  P.Converter.prototype = {};
  P.Encoding.prototype = {
    $asCodec: function() {
      return [P.String, [P.List, P.int]];
    }
  };
  P.JsonUnsupportedObjectError.prototype = {
    toString$0: function(_) {
      var safeString = P.Error_safeToString(this.unsupportedObject);
      return (this.cause != null ? "Converting object to an encodable object failed:" : "Converting object did not return an encodable object:") + " " + safeString;
    }
  };
  P.JsonCyclicError.prototype = {
    toString$0: function(_) {
      return "Cyclic error in JSON stringify";
    }
  };
  P.JsonCodec.prototype = {
    encode$2$toEncodable: function(value, toEncodable) {
      var t1 = P._JsonStringStringifier_stringify(value, this.get$encoder()._toEncodable, null);
      return t1;
    },
    get$encoder: function() {
      return C.JsonEncoder_null;
    },
    $asCodec: function() {
      return [P.Object, P.String];
    }
  };
  P.JsonEncoder.prototype = {
    convert$1: function(object) {
      var t1,
        output = new P.StringBuffer("");
      P._JsonStringStringifier_printOn(object, output, this._toEncodable, null);
      t1 = output._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    $asConverter: function() {
      return [P.Object, P.String];
    }
  };
  P._JsonStringifier.prototype = {
    writeStringContent$1: function(s) {
      var t1, offset, i, charCode, t2, _this = this,
        $length = s.length;
      for (t1 = J.getInterceptor$s(s), offset = 0, i = 0; i < $length; ++i) {
        charCode = t1._codeUnitAt$1(s, i);
        if (charCode > 92)
          continue;
        if (charCode < 32) {
          if (i > offset)
            _this.writeStringSlice$3(s, offset, i);
          offset = i + 1;
          _this.writeCharCode$1(92);
          switch (charCode) {
            case 8:
              _this.writeCharCode$1(98);
              break;
            case 9:
              _this.writeCharCode$1(116);
              break;
            case 10:
              _this.writeCharCode$1(110);
              break;
            case 12:
              _this.writeCharCode$1(102);
              break;
            case 13:
              _this.writeCharCode$1(114);
              break;
            default:
              _this.writeCharCode$1(117);
              _this.writeCharCode$1(48);
              _this.writeCharCode$1(48);
              t2 = charCode >>> 4 & 15;
              _this.writeCharCode$1(t2 < 10 ? 48 + t2 : 87 + t2);
              t2 = charCode & 15;
              _this.writeCharCode$1(t2 < 10 ? 48 + t2 : 87 + t2);
              break;
          }
        } else if (charCode === 34 || charCode === 92) {
          if (i > offset)
            _this.writeStringSlice$3(s, offset, i);
          offset = i + 1;
          _this.writeCharCode$1(92);
          _this.writeCharCode$1(charCode);
        }
      }
      if (offset === 0)
        _this.writeString$1(s);
      else if (offset < $length)
        _this.writeStringSlice$3(s, offset, $length);
    },
    _checkCycle$1: function(object) {
      var t1, t2, i, t3;
      for (t1 = this._seen, t2 = t1.length, i = 0; i < t2; ++i) {
        t3 = t1[i];
        if (object == null ? t3 == null : object === t3)
          throw H.wrapException(new P.JsonCyclicError(object, null));
      }
      t1.push(object);
    },
    writeObject$1: function(object) {
      var customJson, e, t1, exception, _this = this;
      if (_this.writeJsonValue$1(object))
        return;
      _this._checkCycle$1(object);
      try {
        customJson = _this._toEncodable.call$1(object);
        if (!_this.writeJsonValue$1(customJson)) {
          t1 = P.JsonUnsupportedObjectError$(object, null, _this.get$_partialResult());
          throw H.wrapException(t1);
        }
        _this._seen.pop();
      } catch (exception) {
        e = H.unwrapException(exception);
        t1 = P.JsonUnsupportedObjectError$(object, e, _this.get$_partialResult());
        throw H.wrapException(t1);
      }
    },
    writeJsonValue$1: function(object) {
      var t1, success, _this = this;
      if (typeof object === "number") {
        if (!isFinite(object))
          return false;
        _this.writeNumber$1(object);
        return true;
      } else if (object === true) {
        _this.writeString$1("true");
        return true;
      } else if (object === false) {
        _this.writeString$1("false");
        return true;
      } else if (object == null) {
        _this.writeString$1("null");
        return true;
      } else if (typeof object === "string") {
        _this.writeString$1('"');
        _this.writeStringContent$1(object);
        _this.writeString$1('"');
        return true;
      } else {
        t1 = J.getInterceptor$(object);
        if (!!t1.$isList) {
          _this._checkCycle$1(object);
          _this.writeList$1(object);
          _this._seen.pop();
          return true;
        } else if (!!t1.$isMap) {
          _this._checkCycle$1(object);
          success = _this.writeMap$1(object);
          _this._seen.pop();
          return success;
        } else
          return false;
      }
    },
    writeList$1: function(list) {
      var t1, i, _this = this;
      _this.writeString$1("[");
      t1 = J.getInterceptor$asx(list);
      if (t1.get$isNotEmpty(list)) {
        _this.writeObject$1(t1.$index(list, 0));
        for (i = 1; i < t1.get$length(list); ++i) {
          _this.writeString$1(",");
          _this.writeObject$1(t1.$index(list, i));
        }
      }
      _this.writeString$1("]");
    },
    writeMap$1: function(map) {
      var t1, keyValueList, i, separator, _this = this, _box_0 = {};
      if (map.get$isEmpty(map)) {
        _this.writeString$1("{}");
        return true;
      }
      t1 = map.get$length(map) * 2;
      keyValueList = new Array(t1);
      keyValueList.fixed$length = Array;
      i = _box_0.i = 0;
      _box_0.allStringKeys = true;
      map.forEach$1(0, new P._JsonStringifier_writeMap_closure(_box_0, keyValueList));
      if (!_box_0.allStringKeys)
        return false;
      _this.writeString$1("{");
      for (separator = '"'; i < t1; i += 2, separator = ',"') {
        _this.writeString$1(separator);
        _this.writeStringContent$1(keyValueList[i]);
        _this.writeString$1('":');
        _this.writeObject$1(keyValueList[i + 1]);
      }
      _this.writeString$1("}");
      return true;
    }
  };
  P._JsonStringifier_writeMap_closure.prototype = {
    call$2: function(key, value) {
      var t1, t2, t3, i;
      if (typeof key !== "string")
        this._box_0.allStringKeys = false;
      t1 = this.keyValueList;
      t2 = this._box_0;
      t3 = t2.i;
      i = t2.i = t3 + 1;
      t1[t3] = key;
      t2.i = i + 1;
      t1[i] = value;
    },
    $signature: 12
  };
  P._JsonStringStringifier.prototype = {
    get$_partialResult: function() {
      var t1 = this._sink;
      return !!t1.$isStringBuffer ? t1.toString$0(0) : null;
    },
    writeNumber$1: function(number) {
      this._sink.write$1(0, C.JSNumber_methods.toString$0(number));
    },
    writeString$1: function(string) {
      this._sink.write$1(0, string);
    },
    writeStringSlice$3: function(string, start, end) {
      this._sink.write$1(0, C.JSString_methods.substring$2(string, start, end));
    },
    writeCharCode$1: function(charCode) {
      this._sink.writeCharCode$1(charCode);
    }
  };
  P.StringConversionSinkBase.prototype = {};
  P.StringConversionSinkMixin.prototype = {
    add$1: function(_, str) {
      this.addSlice$4(str, 0, str.length, false);
    },
    asUtf8Sink$1: function(allowMalformed) {
      var t1 = new P.StringBuffer("");
      return new P._Utf8ConversionSink(new P._Utf8Decoder(false, t1), this, t1);
    },
    $isStringConversionSink: 1
  };
  P._StringSinkConversionSink.prototype = {
    close$0: function(_) {
    },
    addSlice$4: function(str, start, end, isLast) {
      var t1, t2, i;
      if (start !== 0 || end !== str.length)
        for (t1 = this._stringSink, t2 = J.getInterceptor$s(str), i = start; i < end; ++i)
          t1._contents += H.Primitives_stringFromCharCode(t2._codeUnitAt$1(str, i));
      else
        this._stringSink._contents += H.S(str);
      if (isLast)
        this.close$0(0);
    },
    add$1: function(_, str) {
      this._stringSink._contents += H.S(str);
    },
    asUtf8Sink$1: function(allowMalformed) {
      return new P._Utf8StringSinkAdapter(new P._Utf8Decoder(false, this._stringSink), this);
    }
  };
  P._StringCallbackSink.prototype = {
    close$0: function(_) {
      var t1 = this._stringSink,
        t2 = t1._contents;
      t1._contents = "";
      this._callback.call$1(t2.charCodeAt(0) == 0 ? t2 : t2);
    },
    asUtf8Sink$1: function(allowMalformed) {
      return new P._Utf8StringSinkAdapter(new P._Utf8Decoder(false, this._stringSink), this);
    }
  };
  P._StringAdapterSink.prototype = {
    add$1: function(_, str) {
      this._sink.add$1(0, str);
    },
    addSlice$4: function(str, start, end, isLast) {
      var t1 = start === 0 && end === str.length,
        t2 = this._sink;
      if (t1)
        t2.add$1(0, str);
      else
        t2.add$1(0, J.substring$2$s(str, start, end));
      if (isLast)
        t2.close$0(0);
    },
    close$0: function(_) {
      this._sink.close$0(0);
    }
  };
  P._Utf8StringSinkAdapter.prototype = {
    close$0: function(_) {
      this._decoder.flush$0();
      this._sink.close$0(0);
    },
    add$1: function(_, chunk) {
      this._decoder.convert$3(chunk, 0, J.get$length$asx(chunk));
    },
    addSlice$4: function(codeUnits, startIndex, endIndex, isLast) {
      this._decoder.convert$3(codeUnits, startIndex, endIndex);
      if (isLast)
        this.close$0(0);
    }
  };
  P._Utf8ConversionSink.prototype = {
    close$0: function(_) {
      var t1, t2, t3, accumulated;
      this._decoder.flush$0();
      t1 = this._convert$_buffer;
      t2 = t1._contents;
      t3 = this._chunkedSink;
      if (t2.length !== 0) {
        accumulated = t2.charCodeAt(0) == 0 ? t2 : t2;
        t1._contents = "";
        t3.addSlice$4(accumulated, 0, accumulated.length, true);
      } else
        t3.close$0(0);
    },
    add$1: function(_, chunk) {
      this.addSlice$4(chunk, 0, J.get$length$asx(chunk), false);
    },
    addSlice$4: function(chunk, startIndex, endIndex, isLast) {
      var t1, t2, accumulated, _this = this;
      _this._decoder.convert$3(chunk, startIndex, endIndex);
      t1 = _this._convert$_buffer;
      t2 = t1._contents;
      if (t2.length !== 0) {
        accumulated = t2.charCodeAt(0) == 0 ? t2 : t2;
        _this._chunkedSink.addSlice$4(accumulated, 0, accumulated.length, isLast);
        t1._contents = "";
        return;
      }
      if (isLast)
        _this.close$0(0);
    }
  };
  P.Utf8Codec.prototype = {
    get$encoder: function() {
      return C.C_Utf8Encoder;
    }
  };
  P.Utf8Encoder.prototype = {
    convert$1: function(string) {
      var t1, encoder,
        end = P.RangeError_checkValidRange(0, null, string.length),
        $length = end - 0;
      if ($length === 0)
        return new Uint8Array(0);
      t1 = new Uint8Array($length * 3);
      encoder = new P._Utf8Encoder(t1);
      if (encoder._fillBuffer$3(string, 0, end) !== end)
        encoder._writeSurrogate$2(J.codeUnitAt$1$s(string, end - 1), 0);
      return C.NativeUint8List_methods.sublist$2(t1, 0, encoder._bufferIndex);
    },
    $asConverter: function() {
      return [P.String, [P.List, P.int]];
    }
  };
  P._Utf8Encoder.prototype = {
    _writeSurrogate$2: function(leadingSurrogate, nextCodeUnit) {
      var rune, _this = this,
        t1 = _this._convert$_buffer,
        t2 = _this._bufferIndex,
        t3 = t2 + 1;
      if ((nextCodeUnit & 64512) === 56320) {
        rune = 65536 + ((leadingSurrogate & 1023) << 10) | nextCodeUnit & 1023;
        _this._bufferIndex = t3;
        t1[t2] = 240 | rune >>> 18;
        t2 = _this._bufferIndex = t3 + 1;
        t1[t3] = 128 | rune >>> 12 & 63;
        t3 = _this._bufferIndex = t2 + 1;
        t1[t2] = 128 | rune >>> 6 & 63;
        _this._bufferIndex = t3 + 1;
        t1[t3] = 128 | rune & 63;
        return true;
      } else {
        _this._bufferIndex = t3;
        t1[t2] = 224 | leadingSurrogate >>> 12;
        t2 = _this._bufferIndex = t3 + 1;
        t1[t3] = 128 | leadingSurrogate >>> 6 & 63;
        _this._bufferIndex = t2 + 1;
        t1[t2] = 128 | leadingSurrogate & 63;
        return false;
      }
    },
    _fillBuffer$3: function(str, start, end) {
      var t1, t2, t3, stringIndex, codeUnit, t4, stringIndex0, t5, _this = this;
      if (start !== end && (J.codeUnitAt$1$s(str, end - 1) & 64512) === 55296)
        --end;
      for (t1 = _this._convert$_buffer, t2 = t1.length, t3 = J.getInterceptor$s(str), stringIndex = start; stringIndex < end; ++stringIndex) {
        codeUnit = t3._codeUnitAt$1(str, stringIndex);
        if (codeUnit <= 127) {
          t4 = _this._bufferIndex;
          if (t4 >= t2)
            break;
          _this._bufferIndex = t4 + 1;
          t1[t4] = codeUnit;
        } else if ((codeUnit & 64512) === 55296) {
          if (_this._bufferIndex + 3 >= t2)
            break;
          stringIndex0 = stringIndex + 1;
          if (_this._writeSurrogate$2(codeUnit, C.JSString_methods._codeUnitAt$1(str, stringIndex0)))
            stringIndex = stringIndex0;
        } else if (codeUnit <= 2047) {
          t4 = _this._bufferIndex;
          t5 = t4 + 1;
          if (t5 >= t2)
            break;
          _this._bufferIndex = t5;
          t1[t4] = 192 | codeUnit >>> 6;
          _this._bufferIndex = t5 + 1;
          t1[t5] = 128 | codeUnit & 63;
        } else {
          t4 = _this._bufferIndex;
          if (t4 + 2 >= t2)
            break;
          t5 = _this._bufferIndex = t4 + 1;
          t1[t4] = 224 | codeUnit >>> 12;
          t4 = _this._bufferIndex = t5 + 1;
          t1[t5] = 128 | codeUnit >>> 6 & 63;
          _this._bufferIndex = t4 + 1;
          t1[t4] = 128 | codeUnit & 63;
        }
      }
      return stringIndex;
    }
  };
  P.Utf8Decoder.prototype = {
    convert$1: function(codeUnits) {
      var end, oneBytes, firstPart, buffer, start, isFirstCharacter, decoder, t1,
        result = P.Utf8Decoder__convertIntercepted(false, codeUnits, 0, null);
      if (result != null)
        return result;
      end = P.RangeError_checkValidRange(0, null, J.get$length$asx(codeUnits));
      oneBytes = P._scanOneByteCharacters(codeUnits, 0, end);
      if (oneBytes > 0) {
        firstPart = P.String_String$fromCharCodes(codeUnits, 0, oneBytes);
        if (oneBytes === end)
          return firstPart;
        buffer = new P.StringBuffer(firstPart);
        start = oneBytes;
        isFirstCharacter = false;
      } else {
        start = 0;
        buffer = null;
        isFirstCharacter = true;
      }
      if (buffer == null)
        buffer = new P.StringBuffer("");
      decoder = new P._Utf8Decoder(false, buffer);
      decoder._isFirstCharacter = isFirstCharacter;
      decoder.convert$3(codeUnits, start, end);
      decoder.flush$2(codeUnits, end);
      t1 = buffer._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    startChunkedConversion$1: function(sink) {
      return (!!sink.$isStringConversionSink ? sink : new P._StringAdapterSink(sink)).asUtf8Sink$1(false);
    },
    $asConverter: function() {
      return [[P.List, P.int], P.String];
    }
  };
  P._Utf8Decoder.prototype = {
    flush$2: function(source, offset) {
      var t1;
      if (this._expectedUnits > 0) {
        t1 = P.FormatException$("Unfinished UTF-8 octet sequence", source, offset);
        throw H.wrapException(t1);
      }
    },
    flush$0: function() {
      return this.flush$2(null, null);
    },
    convert$3: function(codeUnits, startIndex, endIndex) {
      var t1, t2, i, unit, t3, oneBytes, i0, i1, t4, _this = this,
        _s21_ = "Bad UTF-8 encoding 0x",
        value = _this._convert$_value,
        expectedUnits = _this._expectedUnits,
        extraUnits = _this._extraUnits;
      _this._extraUnits = _this._expectedUnits = _this._convert$_value = 0;
      $label0$0:
        for (t1 = J.getInterceptor$asx(codeUnits), t2 = _this._stringSink, i = startIndex; true; i = i1) {
          $label1$1:
            if (expectedUnits > 0) {
              do {
                if (i === endIndex)
                  break $label0$0;
                unit = t1.$index(codeUnits, i);
                if ((unit & 192) !== 128) {
                  t3 = P.FormatException$(_s21_ + C.JSInt_methods.toRadixString$1(unit, 16), codeUnits, i);
                  throw H.wrapException(t3);
                } else {
                  value = (value << 6 | unit & 63) >>> 0;
                  --expectedUnits;
                  ++i;
                }
              } while (expectedUnits > 0);
              if (value <= C.List_127_2047_65535_1114111[extraUnits - 1]) {
                t3 = P.FormatException$("Overlong encoding of 0x" + C.JSInt_methods.toRadixString$1(value, 16), codeUnits, i - extraUnits - 1);
                throw H.wrapException(t3);
              }
              if (value > 1114111) {
                t3 = P.FormatException$("Character outside valid Unicode range: 0x" + C.JSInt_methods.toRadixString$1(value, 16), codeUnits, i - extraUnits - 1);
                throw H.wrapException(t3);
              }
              if (!_this._isFirstCharacter || value !== 65279)
                t2._contents += H.Primitives_stringFromCharCode(value);
              _this._isFirstCharacter = false;
            }
          for (t3 = i < endIndex; t3;) {
            oneBytes = P._scanOneByteCharacters(codeUnits, i, endIndex);
            if (oneBytes > 0) {
              _this._isFirstCharacter = false;
              i0 = i + oneBytes;
              t2._contents += P.String_String$fromCharCodes(codeUnits, i, i0);
              if (i0 === endIndex)
                break;
            } else
              i0 = i;
            i1 = i0 + 1;
            unit = t1.$index(codeUnits, i0);
            if (unit < 0) {
              t4 = P.FormatException$("Negative UTF-8 code unit: -0x" + C.JSInt_methods.toRadixString$1(-unit, 16), codeUnits, i1 - 1);
              throw H.wrapException(t4);
            } else {
              if ((unit & 224) === 192) {
                value = unit & 31;
                expectedUnits = 1;
                extraUnits = 1;
                continue $label0$0;
              }
              if ((unit & 240) === 224) {
                value = unit & 15;
                expectedUnits = 2;
                extraUnits = 2;
                continue $label0$0;
              }
              if ((unit & 248) === 240 && unit < 245) {
                value = unit & 7;
                expectedUnits = 3;
                extraUnits = 3;
                continue $label0$0;
              }
              t4 = P.FormatException$(_s21_ + C.JSInt_methods.toRadixString$1(unit, 16), codeUnits, i1 - 1);
              throw H.wrapException(t4);
            }
          }
          break $label0$0;
        }
      if (expectedUnits > 0) {
        _this._convert$_value = value;
        _this._expectedUnits = expectedUnits;
        _this._extraUnits = extraUnits;
      }
    }
  };
  P.NoSuchMethodError_toString_closure.prototype = {
    call$2: function(key, value) {
      var t3,
        t1 = this.sb,
        t2 = this._box_0;
      t1._contents += t2.comma;
      t3 = t1._contents += H.S(key._name);
      t1._contents = t3 + ": ";
      t1._contents += P.Error_safeToString(value);
      t2.comma = ", ";
    }
  };
  P.bool.prototype = {};
  P.DateTime.prototype = {
    add$1: function(_, duration) {
      return P.DateTime$_withValue(C.JSInt_methods.$add(this._value, duration.get$inMilliseconds()), false);
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return other instanceof P.DateTime && this._value === other._value && true;
    },
    compareTo$1: function(_, other) {
      return C.JSInt_methods.compareTo$1(this._value, other._value);
    },
    get$hashCode: function(_) {
      var t1 = this._value;
      return (t1 ^ C.JSInt_methods._shrOtherPositive$1(t1, 30)) & 1073741823;
    },
    toString$0: function(_) {
      var _this = this,
        y = P.DateTime__fourDigits(H.Primitives_getYear(_this)),
        m = P.DateTime__twoDigits(H.Primitives_getMonth(_this)),
        d = P.DateTime__twoDigits(H.Primitives_getDay(_this)),
        h = P.DateTime__twoDigits(H.Primitives_getHours(_this)),
        min = P.DateTime__twoDigits(H.Primitives_getMinutes(_this)),
        sec = P.DateTime__twoDigits(H.Primitives_getSeconds(_this)),
        ms = P.DateTime__threeDigits(H.Primitives_getMilliseconds(_this)),
        t1 = y + "-" + m + "-" + d + " " + h + ":" + min + ":" + sec + "." + ms;
      return t1;
    },
    $isComparable: 1,
    $asComparable: function() {
      return [P.DateTime];
    }
  };
  P.double.prototype = {};
  P.Duration.prototype = {
    $eq: function(_, other) {
      if (other == null)
        return false;
      return other instanceof P.Duration && this._duration === other._duration;
    },
    get$hashCode: function(_) {
      return C.JSInt_methods.get$hashCode(this._duration);
    },
    compareTo$1: function(_, other) {
      return C.JSInt_methods.compareTo$1(this._duration, other._duration);
    },
    toString$0: function(_) {
      var twoDigitMinutes, twoDigitSeconds, sixDigitUs,
        t1 = new P.Duration_toString_twoDigits(),
        t2 = this._duration;
      if (t2 < 0)
        return "-" + new P.Duration(0 - t2).toString$0(0);
      twoDigitMinutes = t1.call$1(C.JSInt_methods._tdivFast$1(t2, 60000000) % 60);
      twoDigitSeconds = t1.call$1(C.JSInt_methods._tdivFast$1(t2, 1000000) % 60);
      sixDigitUs = new P.Duration_toString_sixDigits().call$1(t2 % 1000000);
      return "" + C.JSInt_methods._tdivFast$1(t2, 3600000000) + ":" + H.S(twoDigitMinutes) + ":" + H.S(twoDigitSeconds) + "." + H.S(sixDigitUs);
    },
    $isComparable: 1,
    $asComparable: function() {
      return [P.Duration];
    }
  };
  P.Duration_toString_sixDigits.prototype = {
    call$1: function(n) {
      if (n >= 100000)
        return "" + n;
      if (n >= 10000)
        return "0" + n;
      if (n >= 1000)
        return "00" + n;
      if (n >= 100)
        return "000" + n;
      if (n >= 10)
        return "0000" + n;
      return "00000" + n;
    },
    $signature: 20
  };
  P.Duration_toString_twoDigits.prototype = {
    call$1: function(n) {
      if (n >= 10)
        return "" + n;
      return "0" + n;
    },
    $signature: 20
  };
  P.Error.prototype = {};
  P.NullThrownError.prototype = {
    toString$0: function(_) {
      return "Throw of null.";
    }
  };
  P.ArgumentError.prototype = {
    get$_errorName: function() {
      return "Invalid argument" + (!this._hasValue ? "(s)" : "");
    },
    get$_errorExplanation: function() {
      return "";
    },
    toString$0: function(_) {
      var message, prefix, explanation, errorValue, _this = this,
        t1 = _this.name,
        nameString = t1 != null ? " (" + t1 + ")" : "";
      t1 = _this.message;
      message = t1 == null ? "" : ": " + H.S(t1);
      prefix = _this.get$_errorName() + nameString + message;
      if (!_this._hasValue)
        return prefix;
      explanation = _this.get$_errorExplanation();
      errorValue = P.Error_safeToString(_this.invalidValue);
      return prefix + explanation + ": " + errorValue;
    },
    get$message: function(receiver) {
      return this.message;
    }
  };
  P.RangeError.prototype = {
    get$_errorName: function() {
      return "RangeError";
    },
    get$_errorExplanation: function() {
      var explanation, t2,
        t1 = this.start;
      if (t1 == null) {
        t1 = this.end;
        explanation = t1 != null ? ": Not less than or equal to " + H.S(t1) : "";
      } else {
        t2 = this.end;
        if (t2 == null)
          explanation = ": Not greater than or equal to " + H.S(t1);
        else if (t2 > t1)
          explanation = ": Not in range " + H.S(t1) + ".." + H.S(t2) + ", inclusive";
        else
          explanation = t2 < t1 ? ": Valid value range is empty" : ": Only valid value is " + H.S(t1);
      }
      return explanation;
    }
  };
  P.IndexError.prototype = {
    get$_errorName: function() {
      return "RangeError";
    },
    get$_errorExplanation: function() {
      if (this.invalidValue < 0)
        return ": index must not be negative";
      var t1 = this.length;
      if (t1 === 0)
        return ": no indices are valid";
      return ": index should be less than " + t1;
    },
    get$length: function(receiver) {
      return this.length;
    }
  };
  P.NoSuchMethodError.prototype = {
    toString$0: function(_) {
      var t1, t2, _i, t3, t4, argument, receiverText, actualParameters, _this = this, _box_0 = {},
        sb = new P.StringBuffer("");
      _box_0.comma = "";
      for (t1 = _this._arguments, t2 = t1.length, _i = 0, t3 = "", t4 = ""; _i < t2; ++_i, t4 = ", ") {
        argument = t1[_i];
        sb._contents = t3 + t4;
        t3 = sb._contents += P.Error_safeToString(argument);
        _box_0.comma = ", ";
      }
      _this._namedArguments.forEach$1(0, new P.NoSuchMethodError_toString_closure(_box_0, sb));
      receiverText = P.Error_safeToString(_this._receiver);
      actualParameters = sb.toString$0(0);
      t1 = "NoSuchMethodError: method not found: '" + H.S(_this._memberName._name) + "'\nReceiver: " + receiverText + "\nArguments: [" + actualParameters + "]";
      return t1;
    }
  };
  P.UnsupportedError.prototype = {
    toString$0: function(_) {
      return "Unsupported operation: " + this.message;
    },
    get$message: function(receiver) {
      return this.message;
    }
  };
  P.UnimplementedError.prototype = {
    toString$0: function(_) {
      var t1 = this.message;
      return t1 != null ? "UnimplementedError: " + t1 : "UnimplementedError";
    },
    get$message: function(receiver) {
      return this.message;
    }
  };
  P.StateError.prototype = {
    toString$0: function(_) {
      return "Bad state: " + this.message;
    },
    get$message: function(receiver) {
      return this.message;
    }
  };
  P.ConcurrentModificationError.prototype = {
    toString$0: function(_) {
      var t1 = this.modifiedObject;
      if (t1 == null)
        return "Concurrent modification during iteration.";
      return "Concurrent modification during iteration: " + P.Error_safeToString(t1) + ".";
    }
  };
  P.OutOfMemoryError.prototype = {
    toString$0: function(_) {
      return "Out of Memory";
    },
    $isError: 1
  };
  P.StackOverflowError.prototype = {
    toString$0: function(_) {
      return "Stack Overflow";
    },
    $isError: 1
  };
  P.CyclicInitializationError.prototype = {
    toString$0: function(_) {
      var t1 = this.variableName;
      return t1 == null ? "Reading static variable during its initialization" : "Reading static variable '" + t1 + "' during its initialization";
    }
  };
  P._Exception.prototype = {
    toString$0: function(_) {
      return "Exception: " + this.message;
    },
    $isException: 1,
    get$message: function(receiver) {
      return this.message;
    }
  };
  P.FormatException.prototype = {
    toString$0: function(_) {
      var source, lineNum, lineStart, previousCharWasCR, i, char, lineEnd, end, start, prefix, postfix, slice,
        t1 = this.message,
        report = t1 != null && "" !== t1 ? "FormatException: " + H.S(t1) : "FormatException",
        offset = this.offset,
        objectSource = this.source;
      if (typeof objectSource === "string") {
        if (offset != null)
          t1 = offset < 0 || offset > objectSource.length;
        else
          t1 = false;
        if (t1)
          offset = null;
        if (offset == null) {
          source = objectSource.length > 78 ? C.JSString_methods.substring$2(objectSource, 0, 75) + "..." : objectSource;
          return report + "\n" + source;
        }
        for (lineNum = 1, lineStart = 0, previousCharWasCR = false, i = 0; i < offset; ++i) {
          char = C.JSString_methods._codeUnitAt$1(objectSource, i);
          if (char === 10) {
            if (lineStart !== i || !previousCharWasCR)
              ++lineNum;
            lineStart = i + 1;
            previousCharWasCR = false;
          } else if (char === 13) {
            ++lineNum;
            lineStart = i + 1;
            previousCharWasCR = true;
          }
        }
        report = lineNum > 1 ? report + (" (at line " + lineNum + ", character " + (offset - lineStart + 1) + ")\n") : report + (" (at character " + (offset + 1) + ")\n");
        lineEnd = objectSource.length;
        for (i = offset; i < lineEnd; ++i) {
          char = C.JSString_methods.codeUnitAt$1(objectSource, i);
          if (char === 10 || char === 13) {
            lineEnd = i;
            break;
          }
        }
        if (lineEnd - lineStart > 78)
          if (offset - lineStart < 75) {
            end = lineStart + 75;
            start = lineStart;
            prefix = "";
            postfix = "...";
          } else {
            if (lineEnd - offset < 75) {
              start = lineEnd - 75;
              end = lineEnd;
              postfix = "";
            } else {
              start = offset - 36;
              end = offset + 36;
              postfix = "...";
            }
            prefix = "...";
          }
        else {
          end = lineEnd;
          start = lineStart;
          prefix = "";
          postfix = "";
        }
        slice = C.JSString_methods.substring$2(objectSource, start, end);
        return report + prefix + slice + postfix + "\n" + C.JSString_methods.$mul(" ", offset - start + prefix.length) + "^\n";
      } else
        return offset != null ? report + (" (at offset " + H.S(offset) + ")") : report;
    },
    $isException: 1,
    get$message: function(receiver) {
      return this.message;
    },
    get$source: function() {
      return this.source;
    }
  };
  P.Function.prototype = {};
  P.int.prototype = {};
  P.Iterable.prototype = {
    cast$1$0: function(_, $R) {
      return H.CastIterable_CastIterable(this, H.getRuntimeTypeArgument(this, "Iterable", 0), $R);
    },
    map$1$1: function(_, f, $T) {
      return H.MappedIterable_MappedIterable(this, f, H.getRuntimeTypeArgument(this, "Iterable", 0), $T);
    },
    where$1: function(_, test) {
      return new H.WhereIterable(this, test, [H.getRuntimeTypeArgument(this, "Iterable", 0)]);
    },
    expand$1$1: function(_, f, $T) {
      return new H.ExpandIterable(this, f, [H.getRuntimeTypeArgument(this, "Iterable", 0), $T]);
    },
    contains$1: function(_, element) {
      var t1;
      for (t1 = this.get$iterator(this); t1.moveNext$0();)
        if (J.$eq$(t1.get$current(t1), element))
          return true;
      return false;
    },
    fold$1$2: function(_, initialValue, combine) {
      var t1, value;
      for (t1 = this.get$iterator(this), value = initialValue; t1.moveNext$0();)
        value = combine.call$2(value, t1.get$current(t1));
      return value;
    },
    fold$2: function($receiver, initialValue, combine) {
      return this.fold$1$2($receiver, initialValue, combine, null);
    },
    join$1: function(_, separator) {
      var t1,
        iterator = this.get$iterator(this);
      if (!iterator.moveNext$0())
        return "";
      if (separator === "") {
        t1 = "";
        do
          t1 += H.S(iterator.get$current(iterator));
        while (iterator.moveNext$0());
      } else {
        t1 = H.S(iterator.get$current(iterator));
        for (; iterator.moveNext$0();)
          t1 = t1 + separator + H.S(iterator.get$current(iterator));
      }
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    join$0: function($receiver) {
      return this.join$1($receiver, "");
    },
    any$1: function(_, test) {
      var t1;
      for (t1 = this.get$iterator(this); t1.moveNext$0();)
        if (test.call$1(t1.get$current(t1)))
          return true;
      return false;
    },
    toList$1$growable: function(_, growable) {
      return P.List_List$from(this, growable, H.getRuntimeTypeArgument(this, "Iterable", 0));
    },
    toList$0: function($receiver) {
      return this.toList$1$growable($receiver, true);
    },
    toSet$0: function(_) {
      return P.LinkedHashSet_LinkedHashSet$from(this, H.getRuntimeTypeArgument(this, "Iterable", 0));
    },
    get$length: function(_) {
      var count,
        it = this.get$iterator(this);
      for (count = 0; it.moveNext$0();)
        ++count;
      return count;
    },
    get$isEmpty: function(_) {
      return !this.get$iterator(this).moveNext$0();
    },
    get$isNotEmpty: function(_) {
      return !this.get$isEmpty(this);
    },
    take$1: function(_, count) {
      return H.TakeIterable_TakeIterable(this, count, H.getRuntimeTypeArgument(this, "Iterable", 0));
    },
    skip$1: function(_, count) {
      return H.SkipIterable_SkipIterable(this, count, H.getRuntimeTypeArgument(this, "Iterable", 0));
    },
    skipWhile$1: function(_, test) {
      return new H.SkipWhileIterable(this, test, [H.getRuntimeTypeArgument(this, "Iterable", 0)]);
    },
    get$first: function(_) {
      var it = this.get$iterator(this);
      if (!it.moveNext$0())
        throw H.wrapException(H.IterableElementError_noElement());
      return it.get$current(it);
    },
    get$last: function(_) {
      var result,
        it = this.get$iterator(this);
      if (!it.moveNext$0())
        throw H.wrapException(H.IterableElementError_noElement());
      do
        result = it.get$current(it);
      while (it.moveNext$0());
      return result;
    },
    get$single: function(_) {
      var result,
        it = this.get$iterator(this);
      if (!it.moveNext$0())
        throw H.wrapException(H.IterableElementError_noElement());
      result = it.get$current(it);
      if (it.moveNext$0())
        throw H.wrapException(H.IterableElementError_tooMany());
      return result;
    },
    firstWhere$2$orElse: function(_, test, orElse) {
      var t1, element;
      for (t1 = this.get$iterator(this); t1.moveNext$0();) {
        element = t1.get$current(t1);
        if (test.call$1(element))
          return element;
      }
      return orElse.call$0();
    },
    elementAt$1: function(_, index) {
      var t1, elementIndex, element, _s5_ = "index";
      if (index == null)
        H.throwExpression(P.ArgumentError$notNull(_s5_));
      P.RangeError_checkNotNegative(index, _s5_);
      for (t1 = this.get$iterator(this), elementIndex = 0; t1.moveNext$0();) {
        element = t1.get$current(t1);
        if (index === elementIndex)
          return element;
        ++elementIndex;
      }
      throw H.wrapException(P.IndexError$(index, this, _s5_, null, elementIndex));
    },
    toString$0: function(_) {
      return P.IterableBase_iterableToShortString(this, "(", ")");
    }
  };
  P._GeneratorIterable.prototype = {
    elementAt$1: function(_, index) {
      P.RangeError_checkValidIndex(index, this, null);
      return this._generator.call$1(index);
    },
    get$length: function(receiver) {
      return this.length;
    }
  };
  P.Iterator.prototype = {};
  P.List.prototype = {$isEfficientLengthIterable: 1, $isIterable: 1};
  P.Map.prototype = {};
  P.MapEntry.prototype = {
    toString$0: function(_) {
      return "MapEntry(" + H.S(this.key) + ": " + H.S(this.value) + ")";
    }
  };
  P.Null.prototype = {
    get$hashCode: function(_) {
      return P.Object.prototype.get$hashCode.call(this, this);
    },
    toString$0: function(_) {
      return "null";
    }
  };
  P.num.prototype = {$isComparable: 1,
    $asComparable: function() {
      return [P.num];
    }
  };
  P.Object.prototype = {constructor: P.Object, $isObject: 1,
    $eq: function(_, other) {
      return this === other;
    },
    get$hashCode: function(_) {
      return H.Primitives_objectHashCode(this);
    },
    toString$0: function(_) {
      return "Instance of '" + H.Primitives_objectTypeName(this) + "'";
    },
    noSuchMethod$1: function(_, invocation) {
      throw H.wrapException(P.NoSuchMethodError$(this, invocation.get$memberName(), invocation.get$positionalArguments(), invocation.get$namedArguments()));
    },
    toString: function() {
      return this.toString$0(this);
    }
  };
  P.Match.prototype = {};
  P.RegExpMatch.prototype = {$isMatch: 1};
  P.Set.prototype = {};
  P.StackTrace.prototype = {};
  P._StringStackTrace.prototype = {
    toString$0: function(_) {
      return this._core$_stackTrace;
    },
    $isStackTrace: 1
  };
  P.String.prototype = {$isComparable: 1,
    $asComparable: function() {
      return [P.String];
    }
  };
  P.Runes.prototype = {
    get$iterator: function(_) {
      return new P.RuneIterator(this.string);
    },
    get$last: function(_) {
      var code, previousCode,
        t1 = this.string,
        t2 = t1.length;
      if (t2 === 0)
        throw H.wrapException(P.StateError$("No elements."));
      code = C.JSString_methods.codeUnitAt$1(t1, t2 - 1);
      if ((code & 64512) === 56320 && t2 > 1) {
        previousCode = C.JSString_methods.codeUnitAt$1(t1, t2 - 2);
        if ((previousCode & 64512) === 55296)
          return P._combineSurrogatePair(previousCode, code);
      }
      return code;
    },
    $asIterable: function() {
      return [P.int];
    }
  };
  P.RuneIterator.prototype = {
    get$current: function(_) {
      return this._currentCodePoint;
    },
    moveNext$0: function() {
      var codeUnit, nextPosition, nextCodeUnit, _this = this,
        t1 = _this._core$_position = _this._nextPosition,
        t2 = _this.string,
        t3 = t2.length;
      if (t1 === t3) {
        _this._currentCodePoint = null;
        return false;
      }
      codeUnit = C.JSString_methods._codeUnitAt$1(t2, t1);
      nextPosition = t1 + 1;
      if ((codeUnit & 64512) === 55296 && nextPosition < t3) {
        nextCodeUnit = C.JSString_methods._codeUnitAt$1(t2, nextPosition);
        if ((nextCodeUnit & 64512) === 56320) {
          _this._nextPosition = nextPosition + 1;
          _this._currentCodePoint = P._combineSurrogatePair(codeUnit, nextCodeUnit);
          return true;
        }
      }
      _this._nextPosition = nextPosition;
      _this._currentCodePoint = codeUnit;
      return true;
    }
  };
  P.StringBuffer.prototype = {
    get$length: function(_) {
      return this._contents.length;
    },
    write$1: function(_, obj) {
      this._contents += H.S(obj);
    },
    writeCharCode$1: function(charCode) {
      this._contents += H.Primitives_stringFromCharCode(charCode);
    },
    toString$0: function(_) {
      var t1 = this._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    }
  };
  P.StringSink.prototype = {};
  P.Symbol.prototype = {};
  P.Uri.prototype = {};
  P.Uri__parseIPv4Address_error.prototype = {
    call$2: function(msg, position) {
      throw H.wrapException(P.FormatException$("Illegal IPv4 address, " + msg, this.host, position));
    }
  };
  P.Uri_parseIPv6Address_error.prototype = {
    call$2: function(msg, position) {
      throw H.wrapException(P.FormatException$("Illegal IPv6 address, " + msg, this.host, position));
    },
    call$1: function(msg) {
      return this.call$2(msg, null);
    }
  };
  P.Uri_parseIPv6Address_parseHex.prototype = {
    call$2: function(start, end) {
      var value;
      if (end - start > 4)
        this.error.call$2("an IPv6 part can only contain a maximum of 4 hex digits", start);
      value = P.int_parse(C.JSString_methods.substring$2(this.host, start, end), null, 16);
      if (value < 0 || value > 65535)
        this.error.call$2("each part must be in the range of `0x0..0xFFFF`", start);
      return value;
    }
  };
  P._Uri.prototype = {
    get$userInfo: function() {
      return this._userInfo;
    },
    get$host: function() {
      var t1 = this._host;
      if (t1 == null)
        return "";
      if (C.JSString_methods.startsWith$1(t1, "["))
        return C.JSString_methods.substring$2(t1, 1, t1.length - 1);
      return t1;
    },
    get$port: function() {
      var t1 = this._port;
      if (t1 == null)
        return P._Uri__defaultPort(this.scheme);
      return t1;
    },
    get$query: function() {
      var t1 = this._query;
      return t1 == null ? "" : t1;
    },
    get$fragment: function() {
      var t1 = this._fragment;
      return t1 == null ? "" : t1;
    },
    get$pathSegments: function() {
      var pathToSplit, t1, t2,
        result = this._pathSegments;
      if (result != null)
        return result;
      pathToSplit = this.path;
      if (pathToSplit.length !== 0 && C.JSString_methods._codeUnitAt$1(pathToSplit, 0) === 47)
        pathToSplit = C.JSString_methods.substring$1(pathToSplit, 1);
      if (pathToSplit === "")
        result = C.List_empty0;
      else {
        t1 = P.String;
        t2 = H.setRuntimeTypeInfo(pathToSplit.split("/"), [t1]);
        result = P.List_List$unmodifiable(new H.MappedListIterable(t2, P.core_Uri_decodeComponent$closure(), [H.getTypeArgumentByIndex(t2, 0), null]), t1);
      }
      return this._pathSegments = result;
    },
    _mergePaths$2: function(base, reference) {
      var backCount, refStart, baseEnd, newEnd, delta, t1;
      for (backCount = 0, refStart = 0; C.JSString_methods.startsWith$2(reference, "../", refStart);) {
        refStart += 3;
        ++backCount;
      }
      baseEnd = C.JSString_methods.lastIndexOf$1(base, "/");
      while (true) {
        if (!(baseEnd > 0 && backCount > 0))
          break;
        newEnd = C.JSString_methods.lastIndexOf$2(base, "/", baseEnd - 1);
        if (newEnd < 0)
          break;
        delta = baseEnd - newEnd;
        t1 = delta !== 2;
        if (!t1 || delta === 3)
          if (C.JSString_methods.codeUnitAt$1(base, newEnd + 1) === 46)
            t1 = !t1 || C.JSString_methods.codeUnitAt$1(base, newEnd + 2) === 46;
          else
            t1 = false;
        else
          t1 = false;
        if (t1)
          break;
        --backCount;
        baseEnd = newEnd;
      }
      return C.JSString_methods.replaceRange$3(base, baseEnd + 1, null, C.JSString_methods.substring$1(reference, refStart - 3 * backCount));
    },
    resolve$1: function(reference) {
      return this.resolveUri$1(P.Uri_parse(reference));
    },
    resolveUri$1: function(reference) {
      var targetScheme, targetUserInfo, targetHost, targetPort, targetPath, targetQuery, t1, mergedPath, t2, _this = this, _null = null;
      if (reference.get$scheme().length !== 0) {
        targetScheme = reference.get$scheme();
        if (reference.get$hasAuthority()) {
          targetUserInfo = reference.get$userInfo();
          targetHost = reference.get$host();
          targetPort = reference.get$hasPort() ? reference.get$port() : _null;
        } else {
          targetPort = _null;
          targetHost = targetPort;
          targetUserInfo = "";
        }
        targetPath = P._Uri__removeDotSegments(reference.get$path(reference));
        targetQuery = reference.get$hasQuery() ? reference.get$query() : _null;
      } else {
        targetScheme = _this.scheme;
        if (reference.get$hasAuthority()) {
          targetUserInfo = reference.get$userInfo();
          targetHost = reference.get$host();
          targetPort = P._Uri__makePort(reference.get$hasPort() ? reference.get$port() : _null, targetScheme);
          targetPath = P._Uri__removeDotSegments(reference.get$path(reference));
          targetQuery = reference.get$hasQuery() ? reference.get$query() : _null;
        } else {
          targetUserInfo = _this._userInfo;
          targetHost = _this._host;
          targetPort = _this._port;
          if (reference.get$path(reference) === "") {
            targetPath = _this.path;
            targetQuery = reference.get$hasQuery() ? reference.get$query() : _this._query;
          } else {
            if (reference.get$hasAbsolutePath())
              targetPath = P._Uri__removeDotSegments(reference.get$path(reference));
            else {
              t1 = _this.path;
              if (t1.length === 0)
                if (targetHost == null)
                  targetPath = targetScheme.length === 0 ? reference.get$path(reference) : P._Uri__removeDotSegments(reference.get$path(reference));
                else
                  targetPath = P._Uri__removeDotSegments("/" + reference.get$path(reference));
              else {
                mergedPath = _this._mergePaths$2(t1, reference.get$path(reference));
                t2 = targetScheme.length === 0;
                if (!t2 || targetHost != null || C.JSString_methods.startsWith$1(t1, "/"))
                  targetPath = P._Uri__removeDotSegments(mergedPath);
                else
                  targetPath = P._Uri__normalizeRelativePath(mergedPath, !t2 || targetHost != null);
              }
            }
            targetQuery = reference.get$hasQuery() ? reference.get$query() : _null;
          }
        }
      }
      return new P._Uri(targetScheme, targetUserInfo, targetHost, targetPort, targetPath, targetQuery, reference.get$hasFragment() ? reference.get$fragment() : _null);
    },
    get$hasAuthority: function() {
      return this._host != null;
    },
    get$hasPort: function() {
      return this._port != null;
    },
    get$hasQuery: function() {
      return this._query != null;
    },
    get$hasFragment: function() {
      return this._fragment != null;
    },
    get$hasAbsolutePath: function() {
      return C.JSString_methods.startsWith$1(this.path, "/");
    },
    toFilePath$0: function() {
      var windows, pathSegments, _this = this,
        t1 = _this.scheme;
      if (t1 !== "" && t1 !== "file")
        throw H.wrapException(P.UnsupportedError$("Cannot extract a file path from a " + H.S(t1) + " URI"));
      t1 = _this._query;
      if ((t1 == null ? "" : t1) !== "")
        throw H.wrapException(P.UnsupportedError$("Cannot extract a file path from a URI with a query component"));
      t1 = _this._fragment;
      if ((t1 == null ? "" : t1) !== "")
        throw H.wrapException(P.UnsupportedError$("Cannot extract a file path from a URI with a fragment component"));
      windows = $.$get$_Uri__isWindowsCached();
      if (windows)
        t1 = P._Uri__toWindowsFilePath(_this);
      else {
        if (_this._host != null && _this.get$host() !== "")
          H.throwExpression(P.UnsupportedError$("Cannot extract a non-Windows file path from a file URI with an authority"));
        pathSegments = _this.get$pathSegments();
        P._Uri__checkNonWindowsPathReservedCharacters(pathSegments, false);
        t1 = P.StringBuffer__writeAll(C.JSString_methods.startsWith$1(_this.path, "/") ? "/" : "", pathSegments, "/");
        t1 = t1.charCodeAt(0) == 0 ? t1 : t1;
      }
      return t1;
    },
    toString$0: function(_) {
      var t2, t3, t4, _this = this,
        t1 = _this._text;
      if (t1 == null) {
        t1 = _this.scheme;
        t2 = t1.length !== 0 ? H.S(t1) + ":" : "";
        t3 = _this._host;
        t4 = t3 == null;
        if (!t4 || t1 === "file") {
          t1 = t2 + "//";
          t2 = _this._userInfo;
          if (t2.length !== 0)
            t1 = t1 + H.S(t2) + "@";
          if (!t4)
            t1 += t3;
          t2 = _this._port;
          if (t2 != null)
            t1 = t1 + ":" + H.S(t2);
        } else
          t1 = t2;
        t1 += _this.path;
        t2 = _this._query;
        if (t2 != null)
          t1 = t1 + "?" + t2;
        t2 = _this._fragment;
        if (t2 != null)
          t1 = t1 + "#" + t2;
        t1 = _this._text = t1.charCodeAt(0) == 0 ? t1 : t1;
      }
      return t1;
    },
    $eq: function(_, other) {
      var t1, t2, _this = this;
      if (other == null)
        return false;
      if (_this === other)
        return true;
      if (!!J.getInterceptor$(other).$isUri)
        if (_this.scheme == other.get$scheme())
          if (_this._host != null === other.get$hasAuthority())
            if (_this._userInfo == other.get$userInfo())
              if (_this.get$host() == other.get$host())
                if (_this.get$port() == other.get$port())
                  if (_this.path === other.get$path(other)) {
                    t1 = _this._query;
                    t2 = t1 == null;
                    if (!t2 === other.get$hasQuery()) {
                      if (t2)
                        t1 = "";
                      if (t1 === other.get$query()) {
                        t1 = _this._fragment;
                        t2 = t1 == null;
                        if (!t2 === other.get$hasFragment()) {
                          if (t2)
                            t1 = "";
                          t1 = t1 === other.get$fragment();
                        } else
                          t1 = false;
                      } else
                        t1 = false;
                    } else
                      t1 = false;
                  } else
                    t1 = false;
                else
                  t1 = false;
              else
                t1 = false;
            else
              t1 = false;
          else
            t1 = false;
        else
          t1 = false;
      else
        t1 = false;
      return t1;
    },
    get$hashCode: function(_) {
      var t1 = this._hashCodeCache;
      return t1 == null ? this._hashCodeCache = C.JSString_methods.get$hashCode(this.toString$0(0)) : t1;
    },
    $isUri: 1,
    get$scheme: function() {
      return this.scheme;
    },
    get$path: function(receiver) {
      return this.path;
    }
  };
  P._Uri__Uri$notSimple_closure.prototype = {
    call$1: function(_) {
      throw H.wrapException(P.FormatException$("Invalid port", this.uri, this.portStart + 1));
    }
  };
  P._Uri__checkNonWindowsPathReservedCharacters_closure.prototype = {
    call$1: function(segment) {
      var _s23_ = "Illegal path character ";
      if (J.contains$1$asx(segment, "/"))
        if (this.argumentError)
          throw H.wrapException(P.ArgumentError$(_s23_ + segment));
        else
          throw H.wrapException(P.UnsupportedError$(_s23_ + segment));
    }
  };
  P._Uri__makePath_closure.prototype = {
    call$1: function(s) {
      return P._Uri__uriEncode(C.List_qg40, s, C.C_Utf8Codec, false);
    }
  };
  P.UriData.prototype = {
    get$uri: function() {
      var t2, queryIndex, end, query, _this = this, _null = null,
        t1 = _this._uriCache;
      if (t1 != null)
        return t1;
      t1 = _this._text;
      t2 = _this._separatorIndices[0] + 1;
      queryIndex = C.JSString_methods.indexOf$2(t1, "?", t2);
      end = t1.length;
      if (queryIndex >= 0) {
        query = P._Uri__normalizeOrSubstring(t1, queryIndex + 1, end, C.List_CVk, false);
        end = queryIndex;
      } else
        query = _null;
      return _this._uriCache = new P._DataUri("data", _null, _null, _null, P._Uri__normalizeOrSubstring(t1, t2, end, C.List_qg4, false), query, _null);
    },
    toString$0: function(_) {
      var t1 = this._text;
      return this._separatorIndices[0] === -1 ? "data:" + t1 : t1;
    }
  };
  P._createTables_closure.prototype = {
    call$1: function(_) {
      return new Uint8Array(96);
    },
    $signature: 52
  };
  P._createTables_build.prototype = {
    call$2: function(state, defaultTransition) {
      var t1 = this.tables[state];
      J.fillRange$3$ax(t1, 0, 96, defaultTransition);
      return t1;
    },
    $signature: 57
  };
  P._createTables_setChars.prototype = {
    call$3: function(target, chars, transition) {
      var t1, i;
      for (t1 = chars.length, i = 0; i < t1; ++i)
        target[C.JSString_methods._codeUnitAt$1(chars, i) ^ 96] = transition;
    }
  };
  P._createTables_setRange.prototype = {
    call$3: function(target, range, transition) {
      var i, n;
      for (i = C.JSString_methods._codeUnitAt$1(range, 0), n = C.JSString_methods._codeUnitAt$1(range, 1); i <= n; ++i)
        target[(i ^ 96) >>> 0] = transition;
    }
  };
  P._SimpleUri.prototype = {
    get$hasAuthority: function() {
      return this._hostStart > 0;
    },
    get$hasPort: function() {
      return this._hostStart > 0 && this._portStart + 1 < this._pathStart;
    },
    get$hasQuery: function() {
      return this._queryStart < this._fragmentStart;
    },
    get$hasFragment: function() {
      return this._fragmentStart < this._uri.length;
    },
    get$_isFile: function() {
      return this._schemeEnd === 4 && C.JSString_methods.startsWith$1(this._uri, "file");
    },
    get$_isHttp: function() {
      return this._schemeEnd === 4 && C.JSString_methods.startsWith$1(this._uri, "http");
    },
    get$_isHttps: function() {
      return this._schemeEnd === 5 && C.JSString_methods.startsWith$1(this._uri, "https");
    },
    get$hasAbsolutePath: function() {
      return C.JSString_methods.startsWith$2(this._uri, "/", this._pathStart);
    },
    get$scheme: function() {
      var t2, _this = this,
        _s7_ = "package",
        t1 = _this._schemeEnd;
      if (t1 <= 0)
        return "";
      t2 = _this._schemeCache;
      if (t2 != null)
        return t2;
      if (_this.get$_isHttp())
        t1 = _this._schemeCache = "http";
      else if (_this.get$_isHttps()) {
        _this._schemeCache = "https";
        t1 = "https";
      } else if (_this.get$_isFile()) {
        _this._schemeCache = "file";
        t1 = "file";
      } else if (t1 === 7 && C.JSString_methods.startsWith$1(_this._uri, _s7_)) {
        _this._schemeCache = _s7_;
        t1 = _s7_;
      } else {
        t1 = C.JSString_methods.substring$2(_this._uri, 0, t1);
        _this._schemeCache = t1;
      }
      return t1;
    },
    get$userInfo: function() {
      var t1 = this._hostStart,
        t2 = this._schemeEnd + 3;
      return t1 > t2 ? C.JSString_methods.substring$2(this._uri, t2, t1 - 1) : "";
    },
    get$host: function() {
      var t1 = this._hostStart;
      return t1 > 0 ? C.JSString_methods.substring$2(this._uri, t1, this._portStart) : "";
    },
    get$port: function() {
      var _this = this;
      if (_this.get$hasPort())
        return P.int_parse(C.JSString_methods.substring$2(_this._uri, _this._portStart + 1, _this._pathStart), null, null);
      if (_this.get$_isHttp())
        return 80;
      if (_this.get$_isHttps())
        return 443;
      return 0;
    },
    get$path: function(_) {
      return C.JSString_methods.substring$2(this._uri, this._pathStart, this._queryStart);
    },
    get$query: function() {
      var t1 = this._queryStart,
        t2 = this._fragmentStart;
      return t1 < t2 ? C.JSString_methods.substring$2(this._uri, t1 + 1, t2) : "";
    },
    get$fragment: function() {
      var t1 = this._fragmentStart,
        t2 = this._uri;
      return t1 < t2.length ? C.JSString_methods.substring$1(t2, t1 + 1) : "";
    },
    get$pathSegments: function() {
      var t2, parts, i,
        start = this._pathStart,
        end = this._queryStart,
        t1 = this._uri;
      if (C.JSString_methods.startsWith$2(t1, "/", start))
        ++start;
      if (start == end)
        return C.List_empty0;
      t2 = P.String;
      parts = H.setRuntimeTypeInfo([], [t2]);
      for (i = start; i < end; ++i)
        if (C.JSString_methods.codeUnitAt$1(t1, i) === 47) {
          parts.push(C.JSString_methods.substring$2(t1, start, i));
          start = i + 1;
        }
      parts.push(C.JSString_methods.substring$2(t1, start, end));
      return P.List_List$unmodifiable(parts, t2);
    },
    _isPort$1: function(port) {
      var portDigitStart = this._portStart + 1;
      return portDigitStart + port.length === this._pathStart && C.JSString_methods.startsWith$2(this._uri, port, portDigitStart);
    },
    removeFragment$0: function() {
      var _this = this,
        t1 = _this._fragmentStart,
        t2 = _this._uri;
      if (t1 >= t2.length)
        return _this;
      return new P._SimpleUri(C.JSString_methods.substring$2(t2, 0, t1), _this._schemeEnd, _this._hostStart, _this._portStart, _this._pathStart, _this._queryStart, t1, _this._schemeCache);
    },
    resolve$1: function(reference) {
      return this.resolveUri$1(P.Uri_parse(reference));
    },
    resolveUri$1: function(reference) {
      if (reference instanceof P._SimpleUri)
        return this._simpleMerge$2(this, reference);
      return this._toNonSimple$0().resolveUri$1(reference);
    },
    _simpleMerge$2: function(base, ref) {
      var t2, t3, isSimple, delta, refStart, baseStart, baseEnd, baseUri, baseStart0, backCount, refStart0, insert,
        t1 = ref._schemeEnd;
      if (t1 > 0)
        return ref;
      t2 = ref._hostStart;
      if (t2 > 0) {
        t3 = base._schemeEnd;
        if (t3 <= 0)
          return ref;
        if (base.get$_isFile())
          isSimple = ref._pathStart != ref._queryStart;
        else if (base.get$_isHttp())
          isSimple = !ref._isPort$1("80");
        else
          isSimple = !base.get$_isHttps() || !ref._isPort$1("443");
        if (isSimple) {
          delta = t3 + 1;
          return new P._SimpleUri(C.JSString_methods.substring$2(base._uri, 0, delta) + C.JSString_methods.substring$1(ref._uri, t1 + 1), t3, t2 + delta, ref._portStart + delta, ref._pathStart + delta, ref._queryStart + delta, ref._fragmentStart + delta, base._schemeCache);
        } else
          return this._toNonSimple$0().resolveUri$1(ref);
      }
      refStart = ref._pathStart;
      t1 = ref._queryStart;
      if (refStart == t1) {
        t2 = ref._fragmentStart;
        if (t1 < t2) {
          t3 = base._queryStart;
          delta = t3 - t1;
          return new P._SimpleUri(C.JSString_methods.substring$2(base._uri, 0, t3) + C.JSString_methods.substring$1(ref._uri, t1), base._schemeEnd, base._hostStart, base._portStart, base._pathStart, t1 + delta, t2 + delta, base._schemeCache);
        }
        t1 = ref._uri;
        if (t2 < t1.length) {
          t3 = base._fragmentStart;
          return new P._SimpleUri(C.JSString_methods.substring$2(base._uri, 0, t3) + C.JSString_methods.substring$1(t1, t2), base._schemeEnd, base._hostStart, base._portStart, base._pathStart, base._queryStart, t2 + (t3 - t2), base._schemeCache);
        }
        return base.removeFragment$0();
      }
      t2 = ref._uri;
      if (C.JSString_methods.startsWith$2(t2, "/", refStart)) {
        t3 = base._pathStart;
        delta = t3 - refStart;
        return new P._SimpleUri(C.JSString_methods.substring$2(base._uri, 0, t3) + C.JSString_methods.substring$1(t2, refStart), base._schemeEnd, base._hostStart, base._portStart, t3, t1 + delta, ref._fragmentStart + delta, base._schemeCache);
      }
      baseStart = base._pathStart;
      baseEnd = base._queryStart;
      if (baseStart == baseEnd && base._hostStart > 0) {
        for (; C.JSString_methods.startsWith$2(t2, "../", refStart);)
          refStart += 3;
        delta = baseStart - refStart + 1;
        return new P._SimpleUri(C.JSString_methods.substring$2(base._uri, 0, baseStart) + "/" + C.JSString_methods.substring$1(t2, refStart), base._schemeEnd, base._hostStart, base._portStart, baseStart, t1 + delta, ref._fragmentStart + delta, base._schemeCache);
      }
      baseUri = base._uri;
      for (baseStart0 = baseStart; C.JSString_methods.startsWith$2(baseUri, "../", baseStart0);)
        baseStart0 += 3;
      backCount = 0;
      while (true) {
        refStart0 = refStart + 3;
        if (!(refStart0 <= t1 && C.JSString_methods.startsWith$2(t2, "../", refStart)))
          break;
        ++backCount;
        refStart = refStart0;
      }
      for (insert = ""; baseEnd > baseStart0;) {
        --baseEnd;
        if (C.JSString_methods.codeUnitAt$1(baseUri, baseEnd) === 47) {
          if (backCount === 0) {
            insert = "/";
            break;
          }
          --backCount;
          insert = "/";
        }
      }
      if (baseEnd === baseStart0 && base._schemeEnd <= 0 && !C.JSString_methods.startsWith$2(baseUri, "/", baseStart)) {
        refStart -= backCount * 3;
        insert = "";
      }
      delta = baseEnd - refStart + insert.length;
      return new P._SimpleUri(C.JSString_methods.substring$2(baseUri, 0, baseEnd) + insert + C.JSString_methods.substring$1(t2, refStart), base._schemeEnd, base._hostStart, base._portStart, baseStart, t1 + delta, ref._fragmentStart + delta, base._schemeCache);
    },
    toFilePath$0: function() {
      var t1, t2, windows, _this = this;
      if (_this._schemeEnd >= 0 && !_this.get$_isFile())
        throw H.wrapException(P.UnsupportedError$("Cannot extract a file path from a " + H.S(_this.get$scheme()) + " URI"));
      t1 = _this._queryStart;
      t2 = _this._uri;
      if (t1 < t2.length) {
        if (t1 < _this._fragmentStart)
          throw H.wrapException(P.UnsupportedError$("Cannot extract a file path from a URI with a query component"));
        throw H.wrapException(P.UnsupportedError$("Cannot extract a file path from a URI with a fragment component"));
      }
      windows = $.$get$_Uri__isWindowsCached();
      if (windows)
        t1 = P._Uri__toWindowsFilePath(_this);
      else {
        if (_this._hostStart < _this._portStart)
          H.throwExpression(P.UnsupportedError$("Cannot extract a non-Windows file path from a file URI with an authority"));
        t1 = C.JSString_methods.substring$2(t2, _this._pathStart, t1);
      }
      return t1;
    },
    get$hashCode: function(_) {
      var t1 = this._hashCodeCache;
      return t1 == null ? this._hashCodeCache = C.JSString_methods.get$hashCode(this._uri) : t1;
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (this === other)
        return true;
      return !!J.getInterceptor$(other).$isUri && this._uri === other.toString$0(0);
    },
    _toNonSimple$0: function() {
      var _this = this, _null = null,
        t1 = _this.get$scheme(),
        t2 = _this.get$userInfo(),
        t3 = _this._hostStart > 0 ? _this.get$host() : _null,
        t4 = _this.get$hasPort() ? _this.get$port() : _null,
        t5 = _this._uri,
        t6 = _this._queryStart,
        t7 = C.JSString_methods.substring$2(t5, _this._pathStart, t6),
        t8 = _this._fragmentStart;
      t6 = t6 < t8 ? _this.get$query() : _null;
      return new P._Uri(t1, t2, t3, t4, t7, t6, t8 < t5.length ? _this.get$fragment() : _null);
    },
    toString$0: function(_) {
      return this._uri;
    },
    $isUri: 1
  };
  P._DataUri.prototype = {};
  P._JSRandom.prototype = {
    nextInt$1: function(max) {
      if (max <= 0 || max > 4294967296)
        throw H.wrapException(P.RangeError$("max must be in range 0 < max \u2264 2^32, was " + max));
      return Math.random() * max >>> 0;
    },
    nextDouble$0: function() {
      return Math.random();
    }
  };
  P.Uint8List.prototype = {$isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [P.int];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [P.int];
    },
    $isList: 1,
    $asList: function() {
      return [P.int];
    }
  };
  N.ArgParser.prototype = {
    addFlag$6$abbr$defaultsTo$help$hide$negatable: function($name, abbr, defaultsTo, help, hide, negatable) {
      var _null = null;
      this._addOption$11$hide$negatable($name, abbr, help, _null, _null, _null, defaultsTo, _null, C.OptionType_nMZ, hide, negatable);
    },
    addFlag$2$hide: function($name, hide) {
      return this.addFlag$6$abbr$defaultsTo$help$hide$negatable($name, null, false, null, hide, true);
    },
    addFlag$2$help: function($name, help) {
      return this.addFlag$6$abbr$defaultsTo$help$hide$negatable($name, null, false, help, false, true);
    },
    addFlag$3$defaultsTo$help: function($name, defaultsTo, help) {
      return this.addFlag$6$abbr$defaultsTo$help$hide$negatable($name, null, defaultsTo, help, false, true);
    },
    addFlag$3$help$negatable: function($name, help, negatable) {
      return this.addFlag$6$abbr$defaultsTo$help$hide$negatable($name, null, false, help, false, negatable);
    },
    addFlag$4$abbr$help$negatable: function($name, abbr, help, negatable) {
      return this.addFlag$6$abbr$defaultsTo$help$hide$negatable($name, abbr, false, help, false, negatable);
    },
    addFlag$3$abbr$help: function($name, abbr, help) {
      return this.addFlag$6$abbr$defaultsTo$help$hide$negatable($name, abbr, false, help, false, true);
    },
    addOption$7$abbr$allowed$defaultsTo$help$hide$valueHelp: function($name, abbr, allowed, defaultsTo, help, hide, valueHelp) {
      this._addOption$11$hide$splitCommas($name, abbr, help, valueHelp, allowed, null, defaultsTo, null, C.OptionType_YwU, hide, null);
    },
    addOption$2$hide: function($name, hide) {
      return this.addOption$7$abbr$allowed$defaultsTo$help$hide$valueHelp($name, null, null, null, null, hide, null);
    },
    addOption$6$abbr$allowed$defaultsTo$help$valueHelp: function($name, abbr, allowed, defaultsTo, help, valueHelp) {
      return this.addOption$7$abbr$allowed$defaultsTo$help$hide$valueHelp($name, abbr, allowed, defaultsTo, help, false, valueHelp);
    },
    addOption$4$allowed$defaultsTo$help: function($name, allowed, defaultsTo, help) {
      return this.addOption$7$abbr$allowed$defaultsTo$help$hide$valueHelp($name, null, allowed, defaultsTo, help, false, null);
    },
    addMultiOption$5$abbr$help$splitCommas$valueHelp: function($name, abbr, help, splitCommas, valueHelp) {
      var t1 = H.setRuntimeTypeInfo([], [P.String]);
      this._addOption$11$hide$splitCommas($name, abbr, help, valueHelp, null, null, t1, null, C.OptionType_qyr, false, false);
    },
    _addOption$12$hide$negatable$splitCommas: function($name, abbr, help, valueHelp, allowed, allowedHelp, defaultsTo, callback, type, hide, negatable, splitCommas) {
      var t2, existing, t3, option,
        t1 = this._arg_parser$_options;
      if (t1.containsKey$1($name))
        throw H.wrapException(P.ArgumentError$('Duplicate option "' + $name + '".'));
      t2 = abbr != null;
      if (t2) {
        existing = this.findByAbbreviation$1(abbr);
        if (existing != null)
          throw H.wrapException(P.ArgumentError$('Abbreviation "' + abbr + '" is already used by "' + existing.name + '".'));
      }
      t3 = allowed == null ? null : P.List_List$unmodifiable(allowed, P.String);
      option = new G.Option($name, abbr, help, valueHelp, t3, null, defaultsTo, negatable, callback, type, splitCommas == null ? type === C.OptionType_qyr : splitCommas, hide);
      if ($name.length === 0)
        H.throwExpression(P.ArgumentError$("Name cannot be empty."));
      else if (C.JSString_methods.startsWith$1($name, "-"))
        H.throwExpression(P.ArgumentError$("Name " + $name + ' cannot start with "-".'));
      t3 = $.$get$Option__invalidChars()._nativeRegExp;
      if (t3.test($name))
        H.throwExpression(P.ArgumentError$('Name "' + $name + '" contains invalid characters.'));
      if (t2) {
        if (abbr.length !== 1)
          H.throwExpression(P.ArgumentError$("Abbreviation must be null or have length 1."));
        else if (abbr === "-")
          H.throwExpression(P.ArgumentError$('Abbreviation cannot be "-".'));
        if (t3.test(abbr))
          H.throwExpression(P.ArgumentError$("Abbreviation is an invalid character."));
      }
      t1.$indexSet(0, $name, option);
      this._optionsAndSeparators.push(option);
    },
    _addOption$11$hide$splitCommas: function($name, abbr, help, valueHelp, allowed, allowedHelp, defaultsTo, callback, type, hide, splitCommas) {
      return this._addOption$12$hide$negatable$splitCommas($name, abbr, help, valueHelp, allowed, allowedHelp, defaultsTo, callback, type, hide, false, splitCommas);
    },
    _addOption$11$hide$negatable: function($name, abbr, help, valueHelp, allowed, allowedHelp, defaultsTo, callback, type, hide, negatable) {
      return this._addOption$12$hide$negatable$splitCommas($name, abbr, help, valueHelp, allowed, allowedHelp, defaultsTo, callback, type, hide, negatable, null);
    },
    findByAbbreviation$1: function(abbr) {
      return this.options._collection$_map.get$values().firstWhere$2$orElse(0, new N.ArgParser_findByAbbreviation_closure(abbr), new N.ArgParser_findByAbbreviation_closure0());
    }
  };
  N.ArgParser_findByAbbreviation_closure.prototype = {
    call$1: function(option) {
      return option.abbr == this.abbr;
    }
  };
  N.ArgParser_findByAbbreviation_closure0.prototype = {
    call$0: function() {
      return;
    }
  };
  Z.ArgParserException.prototype = {};
  V.ArgResults.prototype = {
    $index: function(_, $name) {
      var t1 = this._parser.options._collection$_map;
      if (!t1.containsKey$1($name))
        throw H.wrapException(P.ArgumentError$('Could not find an option named "' + $name + '".'));
      return t1.$index(0, $name).getOrDefault$1(this._parsed.$index(0, $name));
    },
    wasParsed$1: function($name) {
      if (this._parser.options._collection$_map.$index(0, $name) == null)
        throw H.wrapException(P.ArgumentError$('Could not find an option named "' + H.S($name) + '".'));
      return this._parsed.containsKey$1($name);
    }
  };
  G.Option.prototype = {
    getOrDefault$1: function(value) {
      var t1;
      if (value != null)
        return value;
      if (this.type === C.OptionType_qyr) {
        t1 = this.defaultsTo;
        return t1 == null ? H.setRuntimeTypeInfo([], [P.String]) : t1;
      }
      return this.defaultsTo;
    }
  };
  G.OptionType.prototype = {};
  G.Parser0.prototype = {
    parse$0: function() {
      var commandName, commandParser, error, t3, t4, t5, t6, t7, command, exception, _this = this,
        t1 = _this.args,
        t2 = H.setRuntimeTypeInfo(t1.slice(0), [H.getTypeArgumentByIndex(t1, 0)]),
        commandResults = null;
      for (t3 = _this.rest, t4 = _this.grammar, t5 = !t4.allowTrailingOptions, t6 = t4.commands._collection$_map; t1.length !== 0;) {
        t7 = t1[0];
        if (t7 === "--") {
          C.JSArray_methods.removeAt$1(t1, 0);
          break;
        }
        command = t6.$index(0, t7);
        if (command != null) {
          if (t3.length !== 0)
            H.throwExpression(Z.ArgParserException$("Cannot specify arguments before a command.", null));
          commandName = C.JSArray_methods.removeAt$1(t1, 0);
          t5 = P.String;
          t6 = [t5];
          t7 = H.setRuntimeTypeInfo([], t6);
          C.JSArray_methods.addAll$1(t7, t3);
          commandParser = new G.Parser0(commandName, _this, command, t1, t7, P.LinkedHashMap_LinkedHashMap$_empty(t5, null));
          try {
            commandResults = commandParser.parse$0();
          } catch (exception) {
            t1 = H.unwrapException(exception);
            if (t1 instanceof Z.ArgParserException) {
              error = t1;
              if (commandName == null)
                throw exception;
              t1 = error.message;
              t6 = H.setRuntimeTypeInfo([commandName], t6);
              C.JSArray_methods.addAll$1(t6, error.commands);
              throw H.wrapException(Z.ArgParserException$(t1, t6));
            } else
              throw exception;
          }
          C.JSArray_methods.set$length(t3, 0);
          break;
        }
        if (_this.parseSoloOption$0())
          continue;
        if (_this.parseAbbreviation$1(_this))
          continue;
        if (_this.parseLongOption$0())
          continue;
        if (t5)
          break;
        t3.push(C.JSArray_methods.removeAt$1(t1, 0));
      }
      t4.options._collection$_map.forEach$1(0, new G.Parser_parse_closure(_this));
      C.JSArray_methods.addAll$1(t3, t1);
      C.JSArray_methods.set$length(t1, 0);
      return V.ArgResults$_(t4, _this.results, _this.commandName, commandResults, t3, t2);
    },
    readNextArgAsValue$1: function(option) {
      var t1 = this.args,
        t2 = t1.length,
        t3 = 'Missing argument for "' + option.name + '".';
      if (t2 === 0)
        H.throwExpression(Z.ArgParserException$(t3, null));
      this.setOption$3(this.results, option, t1[0]);
      C.JSArray_methods.removeAt$1(t1, 0);
    },
    parseSoloOption$0: function() {
      var t2, option, _this = this,
        t1 = _this.args,
        soloOpt = $.$get$_soloOpt().firstMatch$1(t1[0]);
      if (soloOpt == null)
        return false;
      t2 = soloOpt._match;
      option = _this.grammar.findByAbbreviation$1(t2[1]);
      if (option == null) {
        t1 = _this.parent;
        t2 = 'Could not find an option or flag "-' + H.S(t2[1]) + '".';
        if (t1 == null)
          H.throwExpression(Z.ArgParserException$(t2, null));
        return t1.parseSoloOption$0();
      }
      C.JSArray_methods.removeAt$1(t1, 0);
      if (option.type === C.OptionType_nMZ)
        _this.results.$indexSet(0, option.name, true);
      else
        _this.readNextArgAsValue$1(option);
      return true;
    },
    parseAbbreviation$1: function(innermostCommand) {
      var t2, c, first, t3, t4, i, i0, _this = this,
        t1 = _this.args,
        abbrOpt = $.$get$_abbrOpt().firstMatch$1(t1[0]);
      if (abbrOpt == null)
        return false;
      t2 = abbrOpt._match;
      c = J.substring$2$s(t2[1], 0, 1);
      first = _this.grammar.findByAbbreviation$1(c);
      if (first == null) {
        t1 = _this.parent;
        t2 = 'Could not find an option with short name "-' + c + '".';
        if (t1 == null)
          H.throwExpression(Z.ArgParserException$(t2, null));
        return t1.parseAbbreviation$1(innermostCommand);
      } else if (first.type !== C.OptionType_nMZ)
        _this.setOption$3(_this.results, first, J.substring$1$s(t2[1], 1) + H.S(t2[2]));
      else {
        t3 = t2[2];
        t4 = 'Option "-' + c + '" is a flag and cannot handle value "' + J.substring$1$s(t2[1], 1) + H.S(t3) + '".';
        if (t3 !== "")
          H.throwExpression(Z.ArgParserException$(t4, null));
        for (i = 0; t3 = t2[1], i < t3.length; i = i0) {
          i0 = i + 1;
          innermostCommand.parseShortFlag$1(J.substring$2$s(t3, i, i0));
        }
      }
      C.JSArray_methods.removeAt$1(t1, 0);
      return true;
    },
    parseShortFlag$1: function(c) {
      var t1, t2,
        option = this.grammar.findByAbbreviation$1(c);
      if (option == null) {
        t1 = this.parent;
        t2 = 'Could not find an option with short name "-' + c + '".';
        if (t1 == null)
          H.throwExpression(Z.ArgParserException$(t2, null));
        t1.parseShortFlag$1(c);
        return;
      }
      t1 = option.type;
      t2 = 'Option "-' + c + '" must be a flag to be in a collapsed "-".';
      if (t1 !== C.OptionType_nMZ)
        H.throwExpression(Z.ArgParserException$(t2, null));
      this.results.$indexSet(0, option.name, true);
    },
    parseLongOption$0: function() {
      var t2, $name, t3, option, _this = this, _null = null,
        _s32_ = 'Could not find an option named "',
        t1 = _this.args,
        longOpt = $.$get$_longOpt().firstMatch$1(t1[0]);
      if (longOpt == null)
        return false;
      t2 = longOpt._match;
      $name = t2[1];
      t3 = _this.grammar.options._collection$_map;
      option = t3.$index(0, $name);
      if (option != null) {
        C.JSArray_methods.removeAt$1(t1, 0);
        if (option.type === C.OptionType_nMZ) {
          t1 = t2[3];
          t2 = 'Flag option "' + H.S($name) + '" should not be given a value.';
          if (t1 != null)
            H.throwExpression(Z.ArgParserException$(t2, _null));
          _this.results.$indexSet(0, option.name, true);
        } else {
          t1 = t2[3];
          if (t1 != null)
            _this.setOption$3(_this.results, option, t1);
          else
            _this.readNextArgAsValue$1(option);
        }
      } else if (J.getInterceptor$s($name).startsWith$1($name, "no-")) {
        $name = C.JSString_methods.substring$1($name, 3);
        option = t3.$index(0, $name);
        if (option == null) {
          t1 = _this.parent;
          t2 = _s32_ + $name + '".';
          if (t1 == null)
            H.throwExpression(Z.ArgParserException$(t2, _null));
          return t1.parseLongOption$0();
        }
        C.JSArray_methods.removeAt$1(t1, 0);
        t1 = option.type;
        t2 = 'Cannot negate non-flag option "' + $name + '".';
        if (t1 !== C.OptionType_nMZ)
          H.throwExpression(Z.ArgParserException$(t2, _null));
        t1 = option.negatable;
        t2 = 'Cannot negate option "' + $name + '".';
        if (!t1)
          H.throwExpression(Z.ArgParserException$(t2, _null));
        _this.results.$indexSet(0, option.name, false);
      } else {
        t1 = _this.parent;
        t2 = _s32_ + $name + '".';
        if (t1 == null)
          H.throwExpression(Z.ArgParserException$(t2, _null));
        return t1.parseLongOption$0();
      }
      return true;
    },
    setOption$3: function(results, option, value) {
      var list, t1, t2, t3, _i, element;
      if (option.type !== C.OptionType_qyr) {
        this._validateAllowed$2(option, value);
        results.$indexSet(0, option.name, value);
        return;
      }
      list = results.putIfAbsent$2(option.name, new G.Parser_setOption_closure());
      if (option.splitCommas)
        for (t1 = value.split(","), t2 = t1.length, t3 = J.getInterceptor$ax(list), _i = 0; _i < t2; ++_i) {
          element = t1[_i];
          this._validateAllowed$2(option, element);
          t3.add$1(list, element);
        }
      else {
        this._validateAllowed$2(option, value);
        J.add$1$ax(list, value);
      }
    },
    _validateAllowed$2: function(option, value) {
      var t2,
        t1 = option.allowed;
      if (t1 == null)
        return;
      t1 = C.JSArray_methods.contains$1(t1, value);
      t2 = '"' + H.S(value) + '" is not an allowed value for option "' + option.name + '".';
      if (!t1)
        H.throwExpression(Z.ArgParserException$(t2, null));
    }
  };
  G.Parser_parse_closure.prototype = {
    call$2: function($name, option) {
      var t1 = option.callback;
      if (t1 == null)
        return;
      t1.call$1(option.getOrDefault$1(this.$this.results.$index(0, $name)));
    }
  };
  G.Parser_setOption_closure.prototype = {
    call$0: function() {
      return H.setRuntimeTypeInfo([], [P.String]);
    }
  };
  G.Usage.prototype = {
    generate$0: function() {
      var t1, t2, _i, optionOrSeparator, t3, t4, allowedNames, t5, t6, _i0, $name, isDefault, t7, _this = this;
      _this.buffer = new P.StringBuffer("");
      _this.calculateColumnWidths$0();
      for (t1 = _this.optionsAndSeparators, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
        optionOrSeparator = t1[_i];
        if (typeof optionOrSeparator === "string") {
          t3 = _this.buffer;
          t4 = t3._contents;
          t3._contents = (t4.length !== 0 ? t3._contents = t4 + "\n\n" : t4) + optionOrSeparator;
          _this.newlinesNeeded = 1;
          continue;
        }
        H.interceptedTypeCast(optionOrSeparator, "$isOption");
        if (optionOrSeparator.hide)
          continue;
        t3 = optionOrSeparator.abbr;
        _this.write$2(0, 0, t3 == null ? "" : "-" + t3 + ", ");
        _this.write$2(0, 1, _this.getLongOption$1(optionOrSeparator));
        t3 = optionOrSeparator.help;
        if (t3 != null)
          _this.write$2(0, 2, t3);
        t3 = optionOrSeparator.allowedHelp;
        if (t3 != null) {
          t4 = t3.get$keys();
          allowedNames = P.List_List$from(t4, false, H.getRuntimeTypeArgument(t4, "Iterable", 0));
          t4 = allowedNames.length - 1;
          if (t4 - 0 <= 32)
            H.Sort__insertionSort(allowedNames, 0, t4, J._interceptors_JSArray__compareAny$closure());
          else
            H.Sort__dualPivotQuicksort(allowedNames, 0, t4, J._interceptors_JSArray__compareAny$closure());
          ++_this.newlinesNeeded;
          _this.numHelpLines = _this.currentColumn = 0;
          for (t4 = allowedNames.length, t5 = optionOrSeparator.defaultsTo, t6 = !!J.getInterceptor$(t5).$isList, _i0 = 0; _i0 < allowedNames.length; allowedNames.length === t4 || (0, H.throwConcurrentModificationError)(allowedNames), ++_i0) {
            $name = allowedNames[_i0];
            isDefault = t6 ? C.JSArray_methods.contains$1(t5, $name) : t5 == null ? $name == null : t5 === $name;
            t7 = "      [" + H.S($name) + "]";
            _this.write$2(0, 1, t7 + (isDefault ? " (default)" : ""));
            _this.write$2(0, 2, t3.$index(0, $name));
          }
          ++_this.newlinesNeeded;
          _this.numHelpLines = _this.currentColumn = 0;
        } else if (optionOrSeparator.allowed != null)
          _this.write$2(0, 2, _this.buildAllowedList$1(optionOrSeparator));
        else {
          t3 = optionOrSeparator.type;
          if (t3 === C.OptionType_nMZ) {
            if (optionOrSeparator.defaultsTo === true)
              _this.write$2(0, 2, "(defaults to on)");
          } else if (t3 === C.OptionType_qyr) {
            t3 = optionOrSeparator.defaultsTo;
            if (t3 != null && J.get$isNotEmpty$asx(t3))
              _this.write$2(0, 2, "(defaults to " + J.map$1$ax(t3, new G.Usage_generate_closure()).join$1(0, ", ") + ")");
          } else {
            t3 = optionOrSeparator.defaultsTo;
            if (t3 != null)
              _this.write$2(0, 2, '(defaults to "' + H.S(t3) + '")');
          }
        }
        if (_this.numHelpLines > 1) {
          ++_this.newlinesNeeded;
          _this.numHelpLines = _this.currentColumn = 0;
        }
      }
      return J.toString$0$(_this.buffer);
    },
    getLongOption$1: function(option) {
      var t1 = option.name,
        result = option.negatable ? "--[no-]" + t1 : "--" + t1;
      t1 = option.valueHelp;
      return t1 != null ? result + ("=<" + t1 + ">") : result;
    },
    calculateColumnWidths$0: function() {
      var t1, t2, abbr, title, _i, option, t3, t4, t5, allowed, isDefault, t6;
      for (t1 = this.optionsAndSeparators, t2 = t1.length, abbr = 0, title = 0, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
        option = t1[_i];
        if (!(option instanceof G.Option))
          continue;
        if (option.hide)
          continue;
        t3 = option.abbr;
        abbr = Math.max(abbr, (t3 == null ? "" : "-" + t3 + ", ").length);
        title = Math.max(title, this.getLongOption$1(option).length);
        t3 = option.allowedHelp;
        if (t3 != null)
          for (t3 = t3.get$keys(), t3 = t3.get$iterator(t3), t4 = option.defaultsTo, t5 = !!J.getInterceptor$(t4).$isList; t3.moveNext$0();) {
            allowed = t3.get$current(t3);
            isDefault = t5 ? C.JSArray_methods.contains$1(t4, allowed) : t4 == null ? allowed == null : t4 === allowed;
            t6 = "      [" + H.S(allowed) + "]";
            title = Math.max(title, (t6 + (isDefault ? " (default)" : "")).length);
          }
      }
      this.columnWidths = H.setRuntimeTypeInfo([abbr, title + 4], [P.int]);
    },
    write$2: function(_, column, text) {
      var t1, _i,
        lines = H.setRuntimeTypeInfo(text.split("\n"), [P.String]);
      this.columnWidths.length;
      while (true) {
        if (!(lines.length !== 0 && J.trim$0$s(lines[0]) === ""))
          break;
        P.RangeError_checkValidRange(0, 1, lines.length);
        lines.splice(0, 1);
      }
      while (true) {
        t1 = lines.length;
        if (!(t1 !== 0 && J.trim$0$s(lines[t1 - 1]) === ""))
          break;
        lines.pop();
      }
      for (t1 = lines.length, _i = 0; _i < lines.length; lines.length === t1 || (0, H.throwConcurrentModificationError)(lines), ++_i)
        this.writeLine$2(column, lines[_i]);
    },
    writeLine$2: function(column, text) {
      var t1, t2, _this = this;
      for (; t1 = _this.newlinesNeeded, t1 > 0;) {
        _this.buffer._contents += "\n";
        _this.newlinesNeeded = t1 - 1;
      }
      for (; t1 = _this.currentColumn, t1 !== column;) {
        t2 = _this.buffer;
        if (t1 < 2)
          t2._contents += C.JSString_methods.$mul(" ", _this.columnWidths[t1]);
        else
          t2._contents += "\n";
        _this.currentColumn = (_this.currentColumn + 1) % 3;
      }
      t1 = _this.columnWidths;
      t1.length;
      t2 = _this.buffer;
      if (column < 2)
        t2._contents += J.padRight$1$s(text, t1[column]);
      else {
        t2.toString;
        t2._contents += H.S(text);
      }
      _this.currentColumn = (_this.currentColumn + 1) % 3;
      t1 = column === 2;
      if (t1)
        ++_this.newlinesNeeded;
      if (t1)
        ++_this.numHelpLines;
      else
        _this.numHelpLines = 0;
    },
    buildAllowedList$1: function(option) {
      var t2, first, _i, t3, allowed,
        t1 = option.defaultsTo,
        isDefault = !!J.getInterceptor$(t1).$isList ? C.JSArray_methods.get$contains(t1) : new G.Usage_buildAllowedList_closure(option);
      for (t1 = option.allowed, t2 = t1.length, first = true, _i = 0, t3 = "["; _i < t2; ++_i, first = false) {
        allowed = t1[_i];
        if (!first)
          t3 += ", ";
        t3 += H.S(allowed);
        if (isDefault.call$1(allowed))
          t3 += " (default)";
      }
      t1 = t3 + "]";
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    }
  };
  G.Usage_generate_closure.prototype = {
    call$1: function(value) {
      return '"' + H.S(value) + '"';
    },
    $signature: 31
  };
  G.Usage_buildAllowedList_closure.prototype = {
    call$1: function(value) {
      var t1 = this.option.defaultsTo;
      return value == null ? t1 == null : value === t1;
    },
    $signature: 19
  };
  V.ErrorResult.prototype = {
    complete$1: function(completer) {
      completer.completeError$2(this.error, this.stackTrace);
    },
    get$hashCode: function(_) {
      return (J.get$hashCode$(this.error) ^ J.get$hashCode$(this.stackTrace) ^ 492929599) >>> 0;
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return other instanceof V.ErrorResult && J.$eq$(this.error, other.error) && this.stackTrace == other.stackTrace;
    },
    $isResult: 1,
    $asResult: function() {
      return [P.Null];
    }
  };
  E.Result.prototype = {};
  F.ValueResult.prototype = {
    complete$1: function(completer) {
      completer.complete$1(this.value);
    },
    get$hashCode: function(_) {
      return (J.get$hashCode$(this.value) ^ 842997089) >>> 0;
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return other instanceof F.ValueResult && J.$eq$(this.value, other.value);
    },
    $isResult: 1
  };
  Y.StreamCompleter.prototype = {
    setSourceStream$1: function(sourceStream) {
      var t1 = this._stream_completer$_stream;
      if (t1._sourceStream != null)
        throw H.wrapException(P.StateError$("Source stream already set"));
      t1._sourceStream = sourceStream;
      if (t1._stream_completer$_controller != null)
        t1._linkStreamToController$0();
    },
    setError$2: function(error, stackTrace) {
      var t1 = H.getTypeArgumentByIndex(this, 0);
      this.setSourceStream$1(P.Stream_Stream$fromFuture(P.Future_Future$error(error, stackTrace, t1), t1));
    },
    setError$1: function(error) {
      return this.setError$2(error, null);
    }
  };
  Y._CompleterStream.prototype = {
    listen$4$cancelOnError$onDone$onError: function(onData, cancelOnError, onDone, onError) {
      var t1, _this = this, _null = null;
      if (_this._stream_completer$_controller == null) {
        t1 = _this._sourceStream;
        if (t1 != null && !t1.get$isBroadcast())
          return _this._sourceStream.listen$4$cancelOnError$onDone$onError(onData, cancelOnError, onDone, onError);
        _this._stream_completer$_controller = P.StreamController_StreamController(_null, _null, _null, _null, true, H.getTypeArgumentByIndex(_this, 0));
        if (_this._sourceStream != null)
          _this._linkStreamToController$0();
      }
      t1 = _this._stream_completer$_controller;
      t1.toString;
      return new P._ControllerStream(t1, [H.getTypeArgumentByIndex(t1, 0)]).listen$4$cancelOnError$onDone$onError(onData, cancelOnError, onDone, onError);
    },
    listen$3$onDone$onError: function(onData, onDone, onError) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
    },
    listen$1: function(onData) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, null, null);
    },
    _linkStreamToController$0: function() {
      var t1 = this._stream_completer$_controller.addStream$2$cancelOnError(this._sourceStream, false),
        t2 = this._stream_completer$_controller;
      t1.whenComplete$1(t2.get$close(t2));
    }
  };
  L.StreamGroup.prototype = {
    add$1: function(_, stream) {
      var t1, _this = this;
      if (_this._closed)
        throw H.wrapException(P.StateError$("Can't add a Stream to a closed StreamGroup."));
      t1 = _this._stream_group$_state;
      if (t1 === C._StreamGroupState_dormant)
        _this._subscriptions.putIfAbsent$2(stream, new L.StreamGroup_add_closure());
      else if (t1 === C._StreamGroupState_canceled)
        return stream.listen$1(null).cancel$0();
      else
        _this._subscriptions.putIfAbsent$2(stream, new L.StreamGroup_add_closure0(_this, stream));
      return;
    },
    remove$1: function(_, stream) {
      var t1 = this._subscriptions,
        subscription = t1.remove$1(0, stream),
        future = subscription == null ? null : subscription.cancel$0();
      if (this._closed && t1.get$isEmpty(t1))
        this._controller.close$0(0);
      return future;
    },
    _onListen$0: function() {
      this._stream_group$_state = C._StreamGroupState_listening;
      this._subscriptions.forEach$1(0, new L.StreamGroup__onListen_closure(this));
    },
    _onPause$0: function() {
      this._stream_group$_state = C._StreamGroupState_paused;
      for (var t1 = this._subscriptions.get$values(), t1 = t1.get$iterator(t1); t1.moveNext$0();)
        t1.get$current(t1).pause$0(0);
    },
    _onResume$0: function() {
      this._stream_group$_state = C._StreamGroupState_listening;
      for (var t1 = this._subscriptions.get$values(), t1 = t1.get$iterator(t1); t1.moveNext$0();)
        t1.get$current(t1).resume$0();
    },
    _onCancel$0: function() {
      var t1, t2, t3, futures;
      this._stream_group$_state = C._StreamGroupState_canceled;
      t1 = this._subscriptions;
      t2 = t1.get$values();
      t2 = H.MappedIterable_MappedIterable(t2, new L.StreamGroup__onCancel_closure(), H.getRuntimeTypeArgument(t2, "Iterable", 0), [P.Future,,]);
      t3 = H.getRuntimeTypeArgument(t2, "Iterable", 0);
      futures = P.List_List$from(new H.WhereIterable(t2, new L.StreamGroup__onCancel_closure0(), [t3]), true, t3);
      t1.clear$0(0);
      return futures.length === 0 ? null : P.Future_wait(futures, null);
    },
    _listenToStream$1: function(stream) {
      var t1 = this._controller,
        subscription = stream.listen$3$onDone$onError(t1.get$add(t1), new L.StreamGroup__listenToStream_closure(this, stream), t1.get$addError());
      if (this._stream_group$_state === C._StreamGroupState_paused)
        subscription.pause$0(0);
      return subscription;
    }
  };
  L.StreamGroup_add_closure.prototype = {
    call$0: function() {
      return;
    }
  };
  L.StreamGroup_add_closure0.prototype = {
    call$0: function() {
      return this.$this._listenToStream$1(this.stream);
    }
  };
  L.StreamGroup__onListen_closure.prototype = {
    call$2: function(stream, subscription) {
      var t1;
      if (subscription != null)
        return;
      t1 = this.$this;
      t1._subscriptions.$indexSet(0, stream, t1._listenToStream$1(stream));
    }
  };
  L.StreamGroup__onCancel_closure.prototype = {
    call$1: function(subscription) {
      return subscription.cancel$0();
    }
  };
  L.StreamGroup__onCancel_closure0.prototype = {
    call$1: function(future) {
      return future != null;
    }
  };
  L.StreamGroup__listenToStream_closure.prototype = {
    call$0: function() {
      return this.$this.remove$1(0, this.stream);
    },
    "call*": "call$0",
    $requiredArgCount: 0
  };
  L._StreamGroupState.prototype = {
    toString$0: function(_) {
      return this.name;
    }
  };
  G.StreamQueue.prototype = {
    get$next: function() {
      var t1 = this.$ti,
        t2 = new P._Future($.Zone__current, t1);
      this._addRequest$1(new G._NextRequest(new P._AsyncCompleter(t2, t1), t1));
      return t2;
    },
    _updateRequests$0: function() {
      var t1, t2, t3, _this = this;
      for (t1 = _this._requestQueue, t2 = _this._eventQueue; !t1.get$isEmpty(t1);) {
        t3 = t1._collection$_head;
        if (t3 === t1._collection$_tail)
          H.throwExpression(H.IterableElementError_noElement());
        if (t1._collection$_table[t3].update$2(t2, _this._isDone))
          t1.removeFirst$0();
        else
          return;
      }
      if (!_this._isDone)
        _this._stream_queue$_subscription.pause$0(0);
    },
    _ensureListening$0: function() {
      var t1, _this = this;
      if (_this._isDone)
        return;
      t1 = _this._stream_queue$_subscription;
      if (t1 == null)
        _this._stream_queue$_subscription = _this._stream_queue$_source.listen$3$onDone$onError(new G.StreamQueue__ensureListening_closure(_this), new G.StreamQueue__ensureListening_closure0(_this), new G.StreamQueue__ensureListening_closure1(_this));
      else
        t1.resume$0();
    },
    _addResult$1: function(result) {
      ++this._eventsReceived;
      this._eventQueue._queue_list$_add$1(result);
      this._updateRequests$0();
    },
    _addRequest$1: function(request) {
      var _this = this,
        t1 = _this._requestQueue;
      if (t1._collection$_head === t1._collection$_tail) {
        if (request.update$2(_this._eventQueue, _this._isDone))
          return;
        _this._ensureListening$0();
      }
      t1._collection$_add$1(request);
    }
  };
  G.StreamQueue__ensureListening_closure.prototype = {
    call$1: function(data) {
      var t1 = this.$this;
      t1._addResult$1(new F.ValueResult(data, [H.getTypeArgumentByIndex(t1, 0)]));
    },
    $signature: function() {
      return {func: 1, ret: P.Null, args: [H.getTypeArgumentByIndex(this.$this, 0)]};
    }
  };
  G.StreamQueue__ensureListening_closure1.prototype = {
    call$2: function(error, stackTrace) {
      this.$this._addResult$1(new V.ErrorResult(error, stackTrace));
    },
    "call*": "call$2",
    $requiredArgCount: 2,
    $signature: 18
  };
  G.StreamQueue__ensureListening_closure0.prototype = {
    call$0: function() {
      var t1 = this.$this;
      t1._stream_queue$_subscription = null;
      t1._isDone = true;
      t1._updateRequests$0();
    },
    "call*": "call$0",
    $requiredArgCount: 0
  };
  G._EventRequest.prototype = {};
  G._NextRequest.prototype = {
    update$2: function(events, isDone) {
      if (!events.get$isEmpty(events)) {
        events.removeFirst$0().complete$1(this._stream_queue$_completer);
        return true;
      }
      if (isDone) {
        this._stream_queue$_completer.completeError$2(new P.StateError("No elements"), P.StackTrace_current());
        return true;
      }
      return false;
    },
    $is_EventRequest: 1
  };
  Q.Repl.prototype = {};
  Q.closure130.prototype = {
    call$1: function(text) {
      return true;
    }
  };
  B.ReplAdapter.prototype = {
    runAsync$0: function() {
      var $async$runAsync$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = J.get$isTTY$x(self.process.stdin);
              output = (t1 == null ? false : t1) ? self.process.stdout : null;
              t1 = $async$self.repl;
              $prompt = t1.prompt;
              $async$self.rl = J.createInterface$1$x($.$get$readline(), {input: self.process.stdin, output: output, prompt: $prompt});
              t2 = P.String;
              controller = P.StreamController_StreamController(null, null, null, null, false, t2);
              queue = new G.StreamQueue(new P._ControllerStream(controller, [H.getTypeArgumentByIndex(controller, 0)]), Q.QueueList$(null, [E.Result, t2]), P.ListQueue$([G._EventRequest,,]), [t2]);
              J.on$2$x($async$self.rl, "line", P.allowInterop(new B.ReplAdapter_runAsync_closure(controller)));
              prompt0 = t1.continuation, prompt1 = $prompt, statement = "";
            case 3:
              // for condition
              // trivial condition
              t2 = J.get$isTTY$x(self.process.stdin);
              if (t2 == null ? false : t2)
                J.write$1$x(self.process.stdout, prompt1);
              $async$goto = 5;
              return P._asyncStarHelper(queue.get$next(), $async$runAsync$0, $async$controller);
            case 5:
              // returning from await.
              line = $async$result;
              t2 = J.get$isTTY$x(self.process.stdin);
              if (!(t2 == null ? false : t2)) {
                line0 = prompt1 + H.S(line);
                t2 = $.printToZone;
                if (t2 == null)
                  H.printString(line0);
                else
                  t2.call$1(line0);
              }
              statement = C.JSString_methods.$add(statement, line);
              $async$goto = t1.validator.call$1(statement) ? 6 : 8;
              break;
            case 6:
              // then
              $async$goto = 9;
              $async$nextWhenCanceled = [1];
              return P._asyncStarHelper(P._IterationMarker_yieldSingle(statement), $async$runAsync$0, $async$controller);
            case 9:
              // after yield
              J.setPrompt$1$x($async$self.rl, $prompt);
              prompt1 = $prompt;
              statement = "";
              // goto join
              $async$goto = 7;
              break;
            case 8:
              // else
              statement += "\n";
              J.setPrompt$1$x($async$self.rl, prompt0);
              prompt1 = prompt0;
            case 7:
              // join
              // goto for condition
              $async$goto = 3;
              break;
            case 4:
              // after for
            case 1:
              // return
              return P._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return P._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = P._makeAsyncStarStreamController($async$runAsync$0, P.String),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, $prompt, t2, controller, queue, prompt0, prompt1, statement, line, line0, t1, output;
      return P._streamOfController($async$controller);
    }
  };
  B.ReplAdapter_runAsync_closure.prototype = {
    call$1: function(value) {
      this.controller.add$1(0, value);
    },
    call$0: function() {
      return this.call$1(null);
    },
    "call*": "call$1",
    $requiredArgCount: 0,
    $defaultValues: function() {
      return [null];
    },
    $signature: 11
  };
  B.Stdin.prototype = {};
  B.Stdout.prototype = {};
  B.ReadlineModule.prototype = {};
  B.ReadlineOptions.prototype = {};
  B.ReadlineInterface.prototype = {};
  O.EmptyUnmodifiableSet.prototype = {
    get$iterator: function(_) {
      return C.C_EmptyIterator;
    },
    get$length: function(_) {
      return 0;
    },
    cast$1$0: function(_, $T) {
      return new O.EmptyUnmodifiableSet([$T]);
    },
    contains$1: function(_, element) {
      return false;
    },
    toSet$0: function(_) {
      return P.LinkedHashSet_LinkedHashSet(H.getTypeArgumentByIndex(this, 0));
    },
    add$1: function(_, value) {
      return O.EmptyUnmodifiableSet__throw();
    },
    addAll$1: function(_, elements) {
      return O.EmptyUnmodifiableSet__throw();
    },
    $isEfficientLengthIterable: 1,
    $isSet: 1
  };
  U.DefaultEquality.prototype = {};
  U.ListEquality.prototype = {
    equals$2: function(list1, list2) {
      var t1, $length, t2, i;
      if (list1 == null ? list2 == null : list1 === list2)
        return true;
      if (list1 == null || list2 == null)
        return false;
      t1 = J.getInterceptor$asx(list1);
      $length = t1.get$length(list1);
      t2 = J.getInterceptor$asx(list2);
      if ($length !== t2.get$length(list2))
        return false;
      for (i = 0; i < $length; ++i)
        if (!J.$eq$(t1.$index(list1, i), t2.$index(list2, i)))
          return false;
      return true;
    },
    hash$1: function(list) {
      var t1, hash, i;
      for (t1 = list.length, hash = 0, i = 0; i < t1; ++i) {
        hash = hash + J.get$hashCode$(list[i]) & 2147483647;
        hash = hash + (hash << 10 >>> 0) & 2147483647;
        hash ^= hash >>> 6;
      }
      hash = hash + (hash << 3 >>> 0) & 2147483647;
      hash ^= hash >>> 11;
      return hash + (hash << 15 >>> 0) & 2147483647;
    }
  };
  U._MapEntry.prototype = {
    get$hashCode: function(_) {
      return 3 * J.get$hashCode$(this.key) + 7 * J.get$hashCode$(this.value) & 2147483647;
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return other instanceof U._MapEntry && J.$eq$(this.key, other.key) && J.$eq$(this.value, other.value);
    }
  };
  U.MapEquality.prototype = {
    equals$2: function(map1, map2) {
      var equalElementCounts, t1, key, entry, count;
      if (map1 === map2)
        return true;
      if (map1.get$length(map1) !== map2.get$length(map2))
        return false;
      equalElementCounts = P.HashMap_HashMap(U._MapEntry, P.int);
      for (t1 = map1.get$keys(), t1 = t1.get$iterator(t1); t1.moveNext$0();) {
        key = t1.get$current(t1);
        entry = new U._MapEntry(this, key, map1.$index(0, key));
        count = equalElementCounts.$index(0, entry);
        equalElementCounts.$indexSet(0, entry, (count == null ? 0 : count) + 1);
      }
      for (t1 = map2.get$keys(), t1 = t1.get$iterator(t1); t1.moveNext$0();) {
        key = t1.get$current(t1);
        entry = new U._MapEntry(this, key, map2.$index(0, key));
        count = equalElementCounts.$index(0, entry);
        if (count == null || count === 0)
          return false;
        equalElementCounts.$indexSet(0, entry, count - 1);
      }
      return true;
    },
    hash$1: function(map) {
      var t1, hash, key;
      for (t1 = map.get$keys(), t1 = t1.get$iterator(t1), hash = 0; t1.moveNext$0();) {
        key = t1.get$current(t1);
        hash = hash + 3 * J.get$hashCode$(key) + 7 * J.get$hashCode$(map.$index(0, key)) & 2147483647;
      }
      hash = hash + (hash << 3 >>> 0) & 2147483647;
      hash ^= hash >>> 11;
      return hash + (hash << 15 >>> 0) & 2147483647;
    }
  };
  Y.mapMap_closure.prototype = {
    call$2: function(mapKey, _) {
      return H.subtypeOfRuntimeTypeCast(mapKey, this.K2);
    },
    $signature: function() {
      return {func: 1, ret: this.K2, args: [this.K1, this.V1]};
    }
  };
  Y.mapMap_closure0.prototype = {
    call$2: function(_, mapValue) {
      return H.subtypeOfRuntimeTypeCast(mapValue, this.V2);
    },
    $signature: function() {
      return {func: 1, ret: this.V2, args: [this.K1, this.V1]};
    }
  };
  Y.mapMap_closure1.prototype = {
    call$2: function(mapKey, mapValue) {
      var t1 = this._box_0;
      this.result.$indexSet(0, t1.key.call$2(mapKey, mapValue), t1.value.call$2(mapKey, mapValue));
    },
    $signature: function() {
      return {func: 1, ret: P.Null, args: [this.K1, this.V1]};
    }
  };
  Q.QueueList.prototype = {
    QueueList$1: function(initialCapacity, $E) {
      var t1;
      if (initialCapacity == null || initialCapacity < 8)
        initialCapacity = 8;
      else if ((initialCapacity & initialCapacity - 1) >>> 0 !== 0)
        initialCapacity = Q.QueueList__nextPowerOf2(initialCapacity);
      t1 = new Array(initialCapacity);
      t1.fixed$length = Array;
      this._table = H.setRuntimeTypeInfo(t1, [$E]);
    },
    add$1: function(_, element) {
      this._queue_list$_add$1(element);
    },
    addAll$1: function(_, iterable) {
      var addCount, $length, endSpace, preSpace, _this = this,
        t1 = J.getInterceptor$(iterable);
      if (!!t1.$isList) {
        addCount = t1.get$length(iterable);
        $length = _this.get$length(_this);
        t1 = $length + addCount;
        if (t1 >= J.get$length$asx(_this._table)) {
          _this._preGrow$1(t1);
          J.setRange$4$ax(_this._table, $length, t1, iterable, 0);
          _this.set$_tail(_this.get$_tail() + addCount);
        } else {
          endSpace = J.get$length$asx(_this._table) - _this.get$_tail();
          t1 = _this._table;
          if (addCount < endSpace) {
            J.setRange$4$ax(t1, _this.get$_tail(), _this.get$_tail() + addCount, iterable, 0);
            _this.set$_tail(_this.get$_tail() + addCount);
          } else {
            preSpace = addCount - endSpace;
            J.setRange$4$ax(t1, _this.get$_tail(), _this.get$_tail() + endSpace, iterable, 0);
            J.setRange$4$ax(_this._table, 0, preSpace, iterable, endSpace);
            _this.set$_tail(preSpace);
          }
        }
      } else
        for (t1 = t1.get$iterator(iterable); t1.moveNext$0();)
          _this._queue_list$_add$1(t1.get$current(t1));
    },
    cast$1$0: function(_, $T) {
      var t1 = new Q._CastQueueList(this, null, null, [H.getRuntimeTypeArgument(this, "QueueList", 0), $T]);
      t1._table = J.cast$1$0$ax(this._table, $T);
      return t1;
    },
    toString$0: function(_) {
      return P.IterableBase_iterableToFullString(this, "{", "}");
    },
    addFirst$1: function(element) {
      var _this = this;
      _this.set$_head((_this.get$_head() - 1 & J.get$length$asx(_this._table) - 1) >>> 0);
      J.$indexSet$ax(_this._table, _this.get$_head(), element);
      if (_this.get$_head() == _this.get$_tail())
        _this._grow$0();
    },
    removeFirst$0: function() {
      var result, _this = this;
      if (_this.get$_head() == _this.get$_tail())
        throw H.wrapException(P.StateError$("No element"));
      result = J.$index$asx(_this._table, _this.get$_head());
      J.$indexSet$ax(_this._table, _this.get$_head(), null);
      _this.set$_head((_this.get$_head() + 1 & J.get$length$asx(_this._table) - 1) >>> 0);
      return result;
    },
    get$length: function(_) {
      return (this.get$_tail() - this.get$_head() & J.get$length$asx(this._table) - 1) >>> 0;
    },
    set$length: function(_, value) {
      var delta, newTail, t1, t2, _this = this;
      if (value < 0)
        throw H.wrapException(P.RangeError$("Length " + value + " may not be negative."));
      delta = value - _this.get$length(_this);
      if (delta >= 0) {
        if (J.get$length$asx(_this._table) <= value)
          _this._preGrow$1(value);
        _this.set$_tail((_this.get$_tail() + delta & J.get$length$asx(_this._table) - 1) >>> 0);
        return;
      }
      newTail = _this.get$_tail() + delta;
      t1 = _this._table;
      if (newTail >= 0)
        J.fillRange$3$ax(t1, newTail, _this.get$_tail(), null);
      else {
        newTail += J.get$length$asx(t1);
        J.fillRange$3$ax(_this._table, 0, _this.get$_tail(), null);
        t1 = _this._table;
        t2 = J.getInterceptor$asx(t1);
        t2.fillRange$3(t1, newTail, t2.get$length(t1), null);
      }
      _this.set$_tail(newTail);
    },
    $index: function(_, index) {
      var _this = this;
      if (index < 0 || index >= _this.get$length(_this))
        throw H.wrapException(P.RangeError$("Index " + H.S(index) + " must be in the range [0.." + _this.get$length(_this) + ")."));
      return J.$index$asx(_this._table, (_this.get$_head() + index & J.get$length$asx(_this._table) - 1) >>> 0);
    },
    $indexSet: function(_, index, value) {
      var _this = this;
      if (index < 0 || index >= _this.get$length(_this))
        throw H.wrapException(P.RangeError$("Index " + H.S(index) + " must be in the range [0.." + _this.get$length(_this) + ")."));
      J.$indexSet$ax(_this._table, (_this.get$_head() + index & J.get$length$asx(_this._table) - 1) >>> 0, value);
    },
    _queue_list$_add$1: function(element) {
      var _this = this;
      J.$indexSet$ax(_this._table, _this.get$_tail(), element);
      _this.set$_tail((_this.get$_tail() + 1 & J.get$length$asx(_this._table) - 1) >>> 0);
      if (_this.get$_head() == _this.get$_tail())
        _this._grow$0();
    },
    _grow$0: function() {
      var newTable, split, _this = this,
        t1 = new Array(J.get$length$asx(_this._table) * 2);
      t1.fixed$length = Array;
      newTable = H.setRuntimeTypeInfo(t1, [H.getRuntimeTypeArgument(_this, "QueueList", 0)]);
      split = J.get$length$asx(_this._table) - _this.get$_head();
      C.JSArray_methods.setRange$4(newTable, 0, split, _this._table, _this.get$_head());
      C.JSArray_methods.setRange$4(newTable, split, split + _this.get$_head(), _this._table, 0);
      _this.set$_head(0);
      _this.set$_tail(J.get$length$asx(_this._table));
      _this._table = newTable;
    },
    _writeToList$1: function(target) {
      var $length, firstPartSize, _this = this;
      if (_this.get$_head() <= _this.get$_tail()) {
        $length = _this.get$_tail() - _this.get$_head();
        C.JSArray_methods.setRange$4(target, 0, $length, _this._table, _this.get$_head());
        return $length;
      } else {
        firstPartSize = J.get$length$asx(_this._table) - _this.get$_head();
        C.JSArray_methods.setRange$4(target, 0, firstPartSize, _this._table, _this.get$_head());
        C.JSArray_methods.setRange$4(target, firstPartSize, firstPartSize + _this.get$_tail(), _this._table, 0);
        return _this.get$_tail() + firstPartSize;
      }
    },
    _preGrow$1: function(newElementCount) {
      var newTable, _this = this,
        t1 = new Array(Q.QueueList__nextPowerOf2(newElementCount + C.JSInt_methods._shrOtherPositive$1(newElementCount, 1)));
      t1.fixed$length = Array;
      newTable = H.setRuntimeTypeInfo(t1, [H.getRuntimeTypeArgument(_this, "QueueList", 0)]);
      _this.set$_tail(_this._writeToList$1(newTable));
      _this._table = newTable;
      _this.set$_head(0);
    },
    $isEfficientLengthIterable: 1,
    $isQueue: 1,
    $isIterable: 1,
    $isList: 1,
    get$_head: function() {
      return this._head;
    },
    get$_tail: function() {
      return this._tail;
    },
    set$_head: function(val) {
      return this._head = val;
    },
    set$_tail: function(val) {
      return this._tail = val;
    }
  };
  Q._CastQueueList.prototype = {
    get$_head: function() {
      return this._queue_list$_delegate.get$_head();
    },
    set$_head: function(value) {
      this._queue_list$_delegate.set$_head(value);
    },
    get$_tail: function() {
      return this._queue_list$_delegate.get$_tail();
    },
    set$_tail: function(value) {
      this._queue_list$_delegate.set$_tail(value);
    },
    $asEfficientLengthIterable: function($S, $T) {
      return [$T];
    },
    $asListMixin: function($S, $T) {
      return [$T];
    },
    $asQueue: function($S, $T) {
      return [$T];
    },
    $asIterable: function($S, $T) {
      return [$T];
    },
    $asList: function($S, $T) {
      return [$T];
    },
    $asQueueList: function($S, $T) {
      return [$T];
    }
  };
  Q._QueueList_Object_ListMixin.prototype = {};
  L.UnmodifiableSetView.prototype = {};
  L.UnmodifiableSetMixin.prototype = {
    add$1: function(_, value) {
      return L.UnmodifiableSetMixin__throw();
    },
    addAll$1: function(_, elements) {
      return L.UnmodifiableSetMixin__throw();
    }
  };
  L._UnmodifiableSetView_DelegatingSet_UnmodifiableSetMixin.prototype = {};
  B.defaultCompare_closure.prototype = {
    call$2: function(value1, value2) {
      return J.compareTo$1$ns(H.numberOrStringSuperNativeTypeCast(value1, "$isComparable"), value2);
    },
    $signature: function() {
      var t1 = this.T;
      return {func: 1, ret: P.int, args: [t1, t1]};
    }
  };
  M._DelegatingIterableBase.prototype = {
    cast$1$0: function(_, $T) {
      return J.cast$1$0$ax(this.get$_base(), $T);
    },
    contains$1: function(_, element) {
      return J.contains$1$asx(this.get$_base(), element);
    },
    elementAt$1: function(_, index) {
      return J.elementAt$1$ax(this.get$_base(), index);
    },
    get$first: function(_) {
      return J.get$first$ax(this.get$_base());
    },
    get$isEmpty: function(_) {
      return J.get$isEmpty$asx(this.get$_base());
    },
    get$isNotEmpty: function(_) {
      return J.get$isNotEmpty$asx(this.get$_base());
    },
    get$iterator: function(_) {
      return J.get$iterator$ax(this.get$_base());
    },
    join$1: function(_, separator) {
      return J.join$1$ax(this.get$_base(), separator);
    },
    join$0: function($receiver) {
      return this.join$1($receiver, "");
    },
    get$last: function(_) {
      return J.get$last$ax(this.get$_base());
    },
    get$length: function(_) {
      return J.get$length$asx(this.get$_base());
    },
    map$1$1: function(_, f, $T) {
      return J.map$1$1$ax(this.get$_base(), f, $T);
    },
    get$single: function(_) {
      return J.get$single$ax(this.get$_base());
    },
    skip$1: function(_, n) {
      return J.skip$1$ax(this.get$_base(), n);
    },
    take$1: function(_, n) {
      return J.take$1$ax(this.get$_base(), n);
    },
    toSet$0: function(_) {
      return J.toSet$0$ax(this.get$_base());
    },
    where$1: function(_, test) {
      return J.where$1$ax(this.get$_base(), test);
    },
    toString$0: function(_) {
      return J.toString$0$(this.get$_base());
    },
    $isIterable: 1
  };
  M.DelegatingIterable.prototype = {
    get$_base: function() {
      return this._base;
    }
  };
  M.DelegatingSet.prototype = {
    add$1: function(_, value) {
      return this._base.add$1(0, value);
    },
    addAll$1: function(_, elements) {
      this._base.addAll$1(0, elements);
    },
    cast$1$0: function(_, $T) {
      var t1 = this._base;
      return P.Set_castFrom(t1, t1.get$_newSimilarSet(), H.getTypeArgumentByIndex(t1, 0), $T);
    },
    toSet$0: function(_) {
      return new M.DelegatingSet(this._base.toSet$0(0), this.$ti);
    },
    $isEfficientLengthIterable: 1,
    $isSet: 1
  };
  M.MapKeySet.prototype = {
    get$_base: function() {
      return this._baseMap.get$keys();
    },
    cast$1$0: function(_, $T) {
      var _this = this,
        t1 = [$T];
      if (H.checkSubtype(_this, "$isMapKeySet", t1, null))
        return H.subtypeCast(_this, "$isMapKeySet", t1, "$asMapKeySet");
      return P.Set_castFrom(_this, null, H.getTypeArgumentByIndex(_this, 0), $T);
    },
    contains$1: function(_, element) {
      return this._baseMap.containsKey$1(element);
    },
    get$isEmpty: function(_) {
      var t1 = this._baseMap;
      return t1.get$isEmpty(t1);
    },
    get$isNotEmpty: function(_) {
      var t1 = this._baseMap;
      return t1.get$isNotEmpty(t1);
    },
    get$length: function(_) {
      var t1 = this._baseMap;
      return t1.get$length(t1);
    },
    toString$0: function(_) {
      return "{" + J.join$1$ax(this._baseMap.get$keys(), ", ") + "}";
    },
    $isEfficientLengthIterable: 1,
    $isSet: 1
  };
  M._MapKeySet__DelegatingIterableBase_UnmodifiableSetMixin.prototype = {};
  M.Context.prototype = {
    absolute$7: function(part1, part2, part3, part4, part5, part6, part7) {
      var t1;
      M._validateArgList("absolute", H.setRuntimeTypeInfo([part1, part2, part3, part4, part5, part6, part7], [P.String]));
      t1 = this.style;
      t1 = t1.rootLength$1(part1) > 0 && !t1.isRootRelative$1(part1);
      if (t1)
        return part1;
      t1 = this._context$_current;
      return this.join$8(0, t1 != null ? t1 : D.current(), part1, part2, part3, part4, part5, part6, part7);
    },
    absolute$1: function(part1) {
      return this.absolute$7(part1, null, null, null, null, null, null);
    },
    dirname$1: function(path) {
      var t1, t2,
        parsed = X.ParsedPath_ParsedPath$parse(path, this.style);
      parsed.removeTrailingSeparators$0();
      t1 = parsed.parts;
      t2 = t1.length;
      if (t2 === 0) {
        t1 = parsed.root;
        return t1 == null ? "." : t1;
      }
      if (t2 === 1) {
        t1 = parsed.root;
        return t1 == null ? "." : t1;
      }
      C.JSArray_methods.removeLast$0(t1);
      C.JSArray_methods.removeLast$0(parsed.separators);
      parsed.removeTrailingSeparators$0();
      return parsed.toString$0(0);
    },
    join$8: function(_, part1, part2, part3, part4, part5, part6, part7, part8) {
      var parts = H.setRuntimeTypeInfo([part1, part2, part3, part4, part5, part6, part7, part8], [P.String]);
      M._validateArgList("join", parts);
      return this.joinAll$1(new H.WhereIterable(parts, new M.Context_join_closure(), [H.getTypeArgumentByIndex(parts, 0)]));
    },
    join$2: function($receiver, part1, part2) {
      return this.join$8($receiver, part1, part2, null, null, null, null, null, null);
    },
    joinAll$1: function(parts) {
      var t1, t2, t3, needsSeparator, isAbsoluteAndNotRootRelative, t4, t5, parsed, path;
      for (t1 = parts.get$iterator(parts), t2 = new H.WhereIterator(t1, new M.Context_joinAll_closure()), t3 = this.style, needsSeparator = false, isAbsoluteAndNotRootRelative = false, t4 = ""; t2.moveNext$0();) {
        t5 = t1.get$current(t1);
        if (t3.isRootRelative$1(t5) && isAbsoluteAndNotRootRelative) {
          parsed = X.ParsedPath_ParsedPath$parse(t5, t3);
          path = t4.charCodeAt(0) == 0 ? t4 : t4;
          t4 = C.JSString_methods.substring$2(path, 0, t3.rootLength$2$withDrive(path, true));
          parsed.root = t4;
          if (t3.needsSeparator$1(t4))
            parsed.separators[0] = t3.get$separator();
          t4 = parsed.toString$0(0);
        } else if (t3.rootLength$1(t5) > 0) {
          isAbsoluteAndNotRootRelative = !t3.isRootRelative$1(t5);
          t4 = H.S(t5);
        } else {
          if (!(t5.length !== 0 && t3.containsSeparator$1(t5[0])))
            if (needsSeparator)
              t4 += t3.get$separator();
          t4 += H.S(t5);
        }
        needsSeparator = t3.needsSeparator$1(t5);
      }
      return t4.charCodeAt(0) == 0 ? t4 : t4;
    },
    split$1: function(_, path) {
      var parsed = X.ParsedPath_ParsedPath$parse(path, this.style),
        t1 = parsed.parts,
        t2 = H.getTypeArgumentByIndex(t1, 0);
      t2 = P.List_List$from(new H.WhereIterable(t1, new M.Context_split_closure(), [t2]), true, t2);
      parsed.parts = t2;
      t1 = parsed.root;
      if (t1 != null)
        C.JSArray_methods.insert$2(t2, 0, t1);
      return parsed.parts;
    },
    canonicalize$1: function(path) {
      var t1, parsed;
      path = this.absolute$1(path);
      t1 = this.style;
      if (t1 != $.$get$Style_windows() && !this._needsNormalization$1(path))
        return path;
      parsed = X.ParsedPath_ParsedPath$parse(path, t1);
      parsed.normalize$1$canonicalize(true);
      return parsed.toString$0(0);
    },
    normalize$1: function(path) {
      var parsed;
      if (!this._needsNormalization$1(path))
        return path;
      parsed = X.ParsedPath_ParsedPath$parse(path, this.style);
      parsed.normalize$0();
      return parsed.toString$0(0);
    },
    _needsNormalization$1: function(path) {
      var t1, root, t2, i, start, previous, t3, previousPrevious, codeUnit, t4;
      path.toString;
      t1 = this.style;
      root = t1.rootLength$1(path);
      if (root !== 0) {
        if (t1 === $.$get$Style_windows())
          for (t2 = J.getInterceptor$s(path), i = 0; i < root; ++i)
            if (t2._codeUnitAt$1(path, i) === 47)
              return true;
        start = root;
        previous = 47;
      } else {
        start = 0;
        previous = null;
      }
      for (t2 = new H.CodeUnits(path).__internal$_string, t3 = t2.length, i = start, previousPrevious = null; i < t3; ++i, previousPrevious = previous, previous = codeUnit) {
        codeUnit = C.JSString_methods.codeUnitAt$1(t2, i);
        if (t1.isSeparator$1(codeUnit)) {
          if (t1 === $.$get$Style_windows() && codeUnit === 47)
            return true;
          if (previous != null && t1.isSeparator$1(previous))
            return true;
          if (previous === 46)
            t4 = previousPrevious == null || previousPrevious === 46 || t1.isSeparator$1(previousPrevious);
          else
            t4 = false;
          if (t4)
            return true;
        }
      }
      if (previous == null)
        return true;
      if (t1.isSeparator$1(previous))
        return true;
      if (previous === 46)
        t1 = previousPrevious == null || t1.isSeparator$1(previousPrevious) || previousPrevious === 46;
      else
        t1 = false;
      if (t1)
        return true;
      return false;
    },
    relative$2$from: function(path, from) {
      var fromParsed, pathParsed, t2, t3, _this = this,
        _s26_ = 'Unable to find a path to "',
        t1 = from == null;
      if (t1 && _this.style.rootLength$1(path) <= 0)
        return _this.normalize$1(path);
      if (t1) {
        t1 = _this._context$_current;
        from = t1 != null ? t1 : D.current();
      } else
        from = _this.absolute$1(from);
      t1 = _this.style;
      if (t1.rootLength$1(from) <= 0 && t1.rootLength$1(path) > 0)
        return _this.normalize$1(path);
      if (t1.rootLength$1(path) <= 0 || t1.isRootRelative$1(path))
        path = _this.absolute$1(path);
      if (t1.rootLength$1(path) <= 0 && t1.rootLength$1(from) > 0)
        throw H.wrapException(X.PathException$(_s26_ + H.S(path) + '" from "' + H.S(from) + '".'));
      fromParsed = X.ParsedPath_ParsedPath$parse(from, t1);
      fromParsed.normalize$0();
      pathParsed = X.ParsedPath_ParsedPath$parse(path, t1);
      pathParsed.normalize$0();
      t2 = fromParsed.parts;
      if (t2.length !== 0 && J.$eq$(t2[0], "."))
        return pathParsed.toString$0(0);
      t2 = fromParsed.root;
      t3 = pathParsed.root;
      if (t2 != t3)
        t2 = t2 == null || t3 == null || !t1.pathsEqual$2(t2, t3);
      else
        t2 = false;
      if (t2)
        return pathParsed.toString$0(0);
      while (true) {
        t2 = fromParsed.parts;
        if (t2.length !== 0) {
          t3 = pathParsed.parts;
          t2 = t3.length !== 0 && t1.pathsEqual$2(t2[0], t3[0]);
        } else
          t2 = false;
        if (!t2)
          break;
        C.JSArray_methods.removeAt$1(fromParsed.parts, 0);
        C.JSArray_methods.removeAt$1(fromParsed.separators, 1);
        C.JSArray_methods.removeAt$1(pathParsed.parts, 0);
        C.JSArray_methods.removeAt$1(pathParsed.separators, 1);
      }
      t2 = fromParsed.parts;
      if (t2.length !== 0 && J.$eq$(t2[0], ".."))
        throw H.wrapException(X.PathException$(_s26_ + H.S(path) + '" from "' + H.S(from) + '".'));
      t2 = P.String;
      C.JSArray_methods.insertAll$2(pathParsed.parts, 0, P.List_List$filled(fromParsed.parts.length, "..", t2));
      t3 = pathParsed.separators;
      t3[0] = "";
      C.JSArray_methods.insertAll$2(t3, 1, P.List_List$filled(fromParsed.parts.length, t1.get$separator(), t2));
      t1 = pathParsed.parts;
      t2 = t1.length;
      if (t2 === 0)
        return ".";
      if (t2 > 1 && J.$eq$(C.JSArray_methods.get$last(t1), ".")) {
        C.JSArray_methods.removeLast$0(pathParsed.parts);
        t1 = pathParsed.separators;
        C.JSArray_methods.removeLast$0(t1);
        C.JSArray_methods.removeLast$0(t1);
        C.JSArray_methods.add$1(t1, "");
      }
      pathParsed.root = "";
      pathParsed.removeTrailingSeparators$0();
      return pathParsed.toString$0(0);
    },
    relative$1: function(path) {
      return this.relative$2$from(path, null);
    },
    _isWithinOrEquals$2: function($parent, child) {
      var relative, childIsRootRelative, parentIsRootRelative, result, exception, _this = this,
        t1 = _this.style,
        parentIsAbsolute = t1.rootLength$1($parent) > 0,
        childIsAbsolute = t1.rootLength$1(child) > 0;
      if (parentIsAbsolute && !childIsAbsolute) {
        child = _this.absolute$1(child);
        if (t1.isRootRelative$1($parent))
          $parent = _this.absolute$1($parent);
      } else if (childIsAbsolute && !parentIsAbsolute) {
        $parent = _this.absolute$1($parent);
        if (t1.isRootRelative$1(child))
          child = _this.absolute$1(child);
      } else if (childIsAbsolute && parentIsAbsolute) {
        childIsRootRelative = t1.isRootRelative$1(child);
        parentIsRootRelative = t1.isRootRelative$1($parent);
        if (childIsRootRelative && !parentIsRootRelative)
          child = _this.absolute$1(child);
        else if (parentIsRootRelative && !childIsRootRelative)
          $parent = _this.absolute$1($parent);
      }
      result = _this._isWithinOrEqualsFast$2($parent, child);
      if (result !== C._PathRelation_inconclusive)
        return result;
      relative = null;
      try {
        relative = _this.relative$2$from(child, $parent);
      } catch (exception) {
        if (H.unwrapException(exception) instanceof X.PathException)
          return C._PathRelation_different;
        else
          throw exception;
      }
      if (t1.rootLength$1(relative) > 0)
        return C._PathRelation_different;
      if (J.$eq$(relative, "."))
        return C._PathRelation_equal;
      if (J.$eq$(relative, ".."))
        return C._PathRelation_different;
      return J.get$length$asx(relative) >= 3 && J.startsWith$1$s(relative, "..") && t1.isSeparator$1(J.codeUnitAt$1$s(relative, 2)) ? C._PathRelation_different : C._PathRelation_within;
    },
    _isWithinOrEqualsFast$2: function($parent, child) {
      var t1, parentRootLength, childRootLength, t2, t3, i, childIndex, parentIndex, lastCodeUnit, lastParentSeparator, parentCodeUnit, childCodeUnit, parentIndex0, t4, direction, _this = this;
      if ($parent === ".")
        $parent = "";
      t1 = _this.style;
      parentRootLength = t1.rootLength$1($parent);
      childRootLength = t1.rootLength$1(child);
      if (parentRootLength !== childRootLength)
        return C._PathRelation_different;
      for (t2 = J.getInterceptor$s($parent), t3 = J.getInterceptor$s(child), i = 0; i < parentRootLength; ++i)
        if (!t1.codeUnitsEqual$2(t2._codeUnitAt$1($parent, i), t3._codeUnitAt$1(child, i)))
          return C._PathRelation_different;
      t2 = $parent.length;
      childIndex = childRootLength;
      parentIndex = parentRootLength;
      lastCodeUnit = 47;
      lastParentSeparator = null;
      while (true) {
        if (!(parentIndex < t2 && childIndex < child.length))
          break;
        c$0: {
          parentCodeUnit = C.JSString_methods.codeUnitAt$1($parent, parentIndex);
          childCodeUnit = t3.codeUnitAt$1(child, childIndex);
          if (t1.codeUnitsEqual$2(parentCodeUnit, childCodeUnit)) {
            if (t1.isSeparator$1(parentCodeUnit))
              lastParentSeparator = parentIndex;
            ++parentIndex;
            ++childIndex;
            lastCodeUnit = parentCodeUnit;
            break c$0;
          }
          if (t1.isSeparator$1(parentCodeUnit) && t1.isSeparator$1(lastCodeUnit)) {
            parentIndex0 = parentIndex + 1;
            lastParentSeparator = parentIndex;
            parentIndex = parentIndex0;
            break c$0;
          } else if (t1.isSeparator$1(childCodeUnit) && t1.isSeparator$1(lastCodeUnit)) {
            ++childIndex;
            break c$0;
          }
          if (parentCodeUnit === 46 && t1.isSeparator$1(lastCodeUnit)) {
            ++parentIndex;
            if (parentIndex === t2)
              break;
            parentCodeUnit = C.JSString_methods.codeUnitAt$1($parent, parentIndex);
            if (t1.isSeparator$1(parentCodeUnit)) {
              parentIndex0 = parentIndex + 1;
              lastParentSeparator = parentIndex;
              parentIndex = parentIndex0;
              break c$0;
            }
            if (parentCodeUnit === 46) {
              ++parentIndex;
              if (parentIndex === t2 || t1.isSeparator$1(C.JSString_methods.codeUnitAt$1($parent, parentIndex)))
                return C._PathRelation_inconclusive;
            }
          }
          if (childCodeUnit === 46 && t1.isSeparator$1(lastCodeUnit)) {
            ++childIndex;
            t4 = child.length;
            if (childIndex === t4)
              break;
            childCodeUnit = C.JSString_methods.codeUnitAt$1(child, childIndex);
            if (t1.isSeparator$1(childCodeUnit)) {
              ++childIndex;
              break c$0;
            }
            if (childCodeUnit === 46) {
              ++childIndex;
              if (childIndex === t4 || t1.isSeparator$1(C.JSString_methods.codeUnitAt$1(child, childIndex)))
                return C._PathRelation_inconclusive;
            }
          }
          if (_this._pathDirection$2(child, childIndex) !== C._PathDirection_988)
            return C._PathRelation_inconclusive;
          if (_this._pathDirection$2($parent, parentIndex) !== C._PathDirection_988)
            return C._PathRelation_inconclusive;
          return C._PathRelation_different;
        }
      }
      if (childIndex === child.length) {
        if (parentIndex === t2 || t1.isSeparator$1(C.JSString_methods.codeUnitAt$1($parent, parentIndex)))
          lastParentSeparator = parentIndex;
        else if (lastParentSeparator == null)
          lastParentSeparator = Math.max(0, parentRootLength - 1);
        direction = _this._pathDirection$2($parent, lastParentSeparator);
        if (direction === C._PathDirection_8Gl)
          return C._PathRelation_equal;
        return direction === C._PathDirection_ZGD ? C._PathRelation_inconclusive : C._PathRelation_different;
      }
      direction = _this._pathDirection$2(child, childIndex);
      if (direction === C._PathDirection_8Gl)
        return C._PathRelation_equal;
      if (direction === C._PathDirection_ZGD)
        return C._PathRelation_inconclusive;
      return t1.isSeparator$1(C.JSString_methods.codeUnitAt$1(child, childIndex)) || t1.isSeparator$1(lastCodeUnit) ? C._PathRelation_within : C._PathRelation_different;
    },
    _pathDirection$2: function(path, index) {
      var t1, t2, i, depth, reachedRoot, i0, t3;
      for (t1 = path.length, t2 = this.style, i = index, depth = 0, reachedRoot = false; i < t1;) {
        while (true) {
          if (!(i < t1 && t2.isSeparator$1(C.JSString_methods.codeUnitAt$1(path, i))))
            break;
          ++i;
        }
        if (i === t1)
          break;
        i0 = i;
        while (true) {
          if (!(i0 < t1 && !t2.isSeparator$1(C.JSString_methods.codeUnitAt$1(path, i0))))
            break;
          ++i0;
        }
        t3 = i0 - i;
        if (!(t3 === 1 && C.JSString_methods.codeUnitAt$1(path, i) === 46))
          if (t3 === 2 && C.JSString_methods.codeUnitAt$1(path, i) === 46 && C.JSString_methods.codeUnitAt$1(path, i + 1) === 46) {
            --depth;
            if (depth < 0)
              break;
            if (depth === 0)
              reachedRoot = true;
          } else
            ++depth;
        if (i0 === t1)
          break;
        i = i0 + 1;
      }
      if (depth < 0)
        return C._PathDirection_ZGD;
      if (depth === 0)
        return C._PathDirection_8Gl;
      if (reachedRoot)
        return C._PathDirection_FIw;
      return C._PathDirection_988;
    },
    hash$1: function(path) {
      var result, parsed, _this = this;
      path = _this.absolute$1(path);
      result = _this._hashFast$1(path);
      if (result != null)
        return result;
      parsed = X.ParsedPath_ParsedPath$parse(path, _this.style);
      parsed.normalize$0();
      return _this._hashFast$1(parsed.toString$0(0));
    },
    _hashFast$1: function(path) {
      var t1, t2, hash, beginning, wasSeparator, i, codeUnit, t3, next;
      for (t1 = path.length, t2 = this.style, hash = 4603, beginning = true, wasSeparator = true, i = 0; i < t1; ++i) {
        codeUnit = t2.canonicalizeCodeUnit$1(C.JSString_methods._codeUnitAt$1(path, i));
        if (t2.isSeparator$1(codeUnit)) {
          wasSeparator = true;
          continue;
        }
        if (codeUnit === 46 && wasSeparator) {
          t3 = i + 1;
          if (t3 === t1)
            break;
          next = C.JSString_methods._codeUnitAt$1(path, t3);
          if (t2.isSeparator$1(next))
            continue;
          if (!beginning)
            if (next === 46) {
              t3 = i + 2;
              t3 = t3 === t1 || t2.isSeparator$1(C.JSString_methods._codeUnitAt$1(path, t3));
            } else
              t3 = false;
          else
            t3 = false;
          if (t3)
            return;
        }
        hash = ((hash & 67108863) * 33 ^ codeUnit) >>> 0;
        beginning = false;
        wasSeparator = false;
      }
      return hash;
    },
    withoutExtension$1: function(path) {
      var i,
        parsed = X.ParsedPath_ParsedPath$parse(path, this.style);
      for (i = parsed.parts.length - 1; i >= 0; --i)
        if (J.get$length$asx(parsed.parts[i]) !== 0) {
          parsed.parts[i] = parsed._splitExtension$0()[0];
          break;
        }
      return parsed.toString$0(0);
    },
    toUri$1: function(path) {
      var t2,
        t1 = this.style;
      if (t1.rootLength$1(path) <= 0)
        return t1.relativePathToUri$1(path);
      else {
        t2 = this._context$_current;
        return t1.absolutePathToUri$1(this.join$2(0, t2 != null ? t2 : D.current(), path));
      }
    },
    prettyUri$1: function(uri) {
      var path, rel, _this = this,
        typedUri = M._parseUri(uri);
      if (typedUri.get$scheme() === "file" && _this.style == $.$get$Style_url())
        return typedUri.toString$0(0);
      else if (typedUri.get$scheme() !== "file" && typedUri.get$scheme() !== "" && _this.style != $.$get$Style_url())
        return typedUri.toString$0(0);
      path = _this.normalize$1(_this.style.pathFromUri$1(M._parseUri(typedUri)));
      rel = _this.relative$1(path);
      return _this.split$1(0, rel).length > _this.split$1(0, path).length ? path : rel;
    }
  };
  M.Context_join_closure.prototype = {
    call$1: function(part) {
      return part != null;
    }
  };
  M.Context_joinAll_closure.prototype = {
    call$1: function(part) {
      return part !== "";
    }
  };
  M.Context_split_closure.prototype = {
    call$1: function(part) {
      return part.length !== 0;
    }
  };
  M._validateArgList_closure.prototype = {
    call$1: function(arg) {
      return arg == null ? "null" : '"' + arg + '"';
    }
  };
  M._PathDirection.prototype = {
    toString$0: function(_) {
      return this.name;
    }
  };
  M._PathRelation.prototype = {
    toString$0: function(_) {
      return this.name;
    }
  };
  B.InternalStyle.prototype = {
    getRoot$1: function(path) {
      var $length = this.rootLength$1(path);
      if ($length > 0)
        return J.substring$2$s(path, 0, $length);
      return this.isRootRelative$1(path) ? path[0] : null;
    },
    relativePathToUri$1: function(path) {
      var segments = M.Context_Context(this).split$1(0, path);
      if (this.isSeparator$1(J.codeUnitAt$1$s(path, path.length - 1)))
        C.JSArray_methods.add$1(segments, "");
      return P._Uri__Uri(null, null, segments, null);
    },
    codeUnitsEqual$2: function(codeUnit1, codeUnit2) {
      return codeUnit1 === codeUnit2;
    },
    pathsEqual$2: function(path1, path2) {
      return path1 == path2;
    },
    canonicalizeCodeUnit$1: function(codeUnit) {
      return codeUnit;
    },
    canonicalizePart$1: function(part) {
      return part;
    }
  };
  X.ParsedPath.prototype = {
    get$basename: function() {
      var _this = this,
        t1 = P.String,
        copy = new X.ParsedPath(_this.style, _this.root, _this.isRootRelative, P.List_List$from(_this.parts, true, t1), P.List_List$from(_this.separators, true, t1));
      copy.removeTrailingSeparators$0();
      t1 = copy.parts;
      if (t1.length === 0) {
        t1 = _this.root;
        return t1 == null ? "" : t1;
      }
      return C.JSArray_methods.get$last(t1);
    },
    get$hasTrailingSeparator: function() {
      var t1 = this.parts;
      if (t1.length !== 0)
        t1 = J.$eq$(C.JSArray_methods.get$last(t1), "") || !J.$eq$(C.JSArray_methods.get$last(this.separators), "");
      else
        t1 = false;
      return t1;
    },
    removeTrailingSeparators$0: function() {
      var t1, t2, _this = this;
      while (true) {
        t1 = _this.parts;
        if (!(t1.length !== 0 && J.$eq$(C.JSArray_methods.get$last(t1), "")))
          break;
        C.JSArray_methods.removeLast$0(_this.parts);
        C.JSArray_methods.removeLast$0(_this.separators);
      }
      t1 = _this.separators;
      t2 = t1.length;
      if (t2 !== 0)
        t1[t2 - 1] = "";
    },
    normalize$1$canonicalize: function(canonicalize) {
      var t2, t3, t4, leadingDoubles, _i, part, t5, newSeparators, _this = this,
        t1 = P.String,
        newParts = H.setRuntimeTypeInfo([], [t1]);
      for (t2 = _this.parts, t3 = t2.length, t4 = _this.style, leadingDoubles = 0, _i = 0; _i < t2.length; t2.length === t3 || (0, H.throwConcurrentModificationError)(t2), ++_i) {
        part = t2[_i];
        t5 = J.getInterceptor$(part);
        if (!(t5.$eq(part, ".") || t5.$eq(part, "")))
          if (t5.$eq(part, ".."))
            if (newParts.length !== 0)
              newParts.pop();
            else
              ++leadingDoubles;
          else
            newParts.push(canonicalize ? t4.canonicalizePart$1(part) : part);
      }
      if (_this.root == null)
        C.JSArray_methods.insertAll$2(newParts, 0, P.List_List$filled(leadingDoubles, "..", t1));
      if (newParts.length === 0 && _this.root == null)
        newParts.push(".");
      newSeparators = P.List_List$generate(newParts.length, new X.ParsedPath_normalize_closure(_this), true, t1);
      t1 = _this.root;
      C.JSArray_methods.insert$2(newSeparators, 0, t1 != null && newParts.length !== 0 && t4.needsSeparator$1(t1) ? t4.get$separator() : "");
      _this.parts = newParts;
      _this.separators = newSeparators;
      t1 = _this.root;
      if (t1 != null && t4 === $.$get$Style_windows()) {
        if (canonicalize)
          t1 = _this.root = t1.toLowerCase();
        t1.toString;
        _this.root = H.stringReplaceAllUnchecked(t1, "/", "\\");
      }
      _this.removeTrailingSeparators$0();
    },
    normalize$0: function() {
      return this.normalize$1$canonicalize(false);
    },
    toString$0: function(_) {
      var i, _this = this,
        t1 = _this.root;
      t1 = t1 != null ? t1 : "";
      for (i = 0; i < _this.parts.length; ++i)
        t1 = t1 + H.S(_this.separators[i]) + H.S(_this.parts[i]);
      t1 += H.S(C.JSArray_methods.get$last(_this.separators));
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    _splitExtension$0: function() {
      var lastDot,
        file = C.JSArray_methods.lastWhere$2$orElse(this.parts, new X.ParsedPath__splitExtension_closure(), new X.ParsedPath__splitExtension_closure0());
      if (file == null)
        return H.setRuntimeTypeInfo(["", ""], [P.String]);
      if (file === "..")
        return H.setRuntimeTypeInfo(["..", ""], [P.String]);
      lastDot = C.JSString_methods.lastIndexOf$1(file, ".");
      if (lastDot <= 0)
        return H.setRuntimeTypeInfo([file, ""], [P.String]);
      return H.setRuntimeTypeInfo([C.JSString_methods.substring$2(file, 0, lastDot), C.JSString_methods.substring$1(file, lastDot)], [P.String]);
    }
  };
  X.ParsedPath_normalize_closure.prototype = {
    call$1: function(_) {
      return this.$this.style.get$separator();
    },
    $signature: 20
  };
  X.ParsedPath__splitExtension_closure.prototype = {
    call$1: function(p) {
      return p !== "";
    }
  };
  X.ParsedPath__splitExtension_closure0.prototype = {
    call$0: function() {
      return;
    }
  };
  X.PathException.prototype = {
    toString$0: function(_) {
      return "PathException: " + this.message;
    },
    $isException: 1,
    get$message: function(receiver) {
      return this.message;
    }
  };
  K.PathMap.prototype = {
    $asMap: function($V) {
      return [P.String, $V];
    }
  };
  K.PathMap__create_closure.prototype = {
    call$2: function(path1, path2) {
      if (path1 == null)
        return path2 == null;
      if (path2 == null)
        return false;
      return this._box_0.context._isWithinOrEquals$2(path1, path2) === C._PathRelation_equal;
    },
    "call*": "call$2",
    $requiredArgCount: 2
  };
  K.PathMap__create_closure0.prototype = {
    call$1: function(path) {
      return path == null ? 0 : this._box_0.context.hash$1(path);
    }
  };
  K.PathMap__create_closure1.prototype = {
    call$1: function(path) {
      return typeof path === "string" || path == null;
    },
    $signature: 19
  };
  O.Style.prototype = {
    toString$0: function(_) {
      return this.get$name();
    }
  };
  E.PosixStyle.prototype = {
    containsSeparator$1: function(path) {
      return C.JSString_methods.contains$1(path, "/");
    },
    isSeparator$1: function(codeUnit) {
      return codeUnit === 47;
    },
    needsSeparator$1: function(path) {
      var t1 = path.length;
      return t1 !== 0 && J.codeUnitAt$1$s(path, t1 - 1) !== 47;
    },
    rootLength$2$withDrive: function(path, withDrive) {
      if (path.length !== 0 && J._codeUnitAt$1$s(path, 0) === 47)
        return 1;
      return 0;
    },
    rootLength$1: function(path) {
      return this.rootLength$2$withDrive(path, false);
    },
    isRootRelative$1: function(path) {
      return false;
    },
    pathFromUri$1: function(uri) {
      var t1;
      if (uri.get$scheme() === "" || uri.get$scheme() === "file") {
        t1 = uri.get$path(uri);
        return P._Uri__uriDecode(t1, 0, t1.length, C.C_Utf8Codec, false);
      }
      throw H.wrapException(P.ArgumentError$("Uri " + uri.toString$0(0) + " must have scheme 'file:'."));
    },
    absolutePathToUri$1: function(path) {
      var parsed = X.ParsedPath_ParsedPath$parse(path, this),
        t1 = parsed.parts;
      if (t1.length === 0)
        C.JSArray_methods.addAll$1(t1, H.setRuntimeTypeInfo(["", ""], [P.String]));
      else if (parsed.get$hasTrailingSeparator())
        C.JSArray_methods.add$1(parsed.parts, "");
      return P._Uri__Uri(null, null, parsed.parts, "file");
    },
    get$name: function() {
      return "posix";
    },
    get$separator: function() {
      return "/";
    }
  };
  F.UrlStyle.prototype = {
    containsSeparator$1: function(path) {
      return C.JSString_methods.contains$1(path, "/");
    },
    isSeparator$1: function(codeUnit) {
      return codeUnit === 47;
    },
    needsSeparator$1: function(path) {
      var t1 = path.length;
      if (t1 === 0)
        return false;
      if (J.getInterceptor$s(path).codeUnitAt$1(path, t1 - 1) !== 47)
        return true;
      return C.JSString_methods.endsWith$1(path, "://") && this.rootLength$1(path) === t1;
    },
    rootLength$2$withDrive: function(path, withDrive) {
      var i, codeUnit, index, t2,
        t1 = path.length;
      if (t1 === 0)
        return 0;
      if (J.getInterceptor$s(path)._codeUnitAt$1(path, 0) === 47)
        return 1;
      for (i = 0; i < t1; ++i) {
        codeUnit = C.JSString_methods._codeUnitAt$1(path, i);
        if (codeUnit === 47)
          return 0;
        if (codeUnit === 58) {
          if (i === 0)
            return 0;
          index = C.JSString_methods.indexOf$2(path, "/", C.JSString_methods.startsWith$2(path, "//", i + 1) ? i + 3 : i);
          if (index <= 0)
            return t1;
          if (!withDrive || t1 < index + 3)
            return index;
          if (!C.JSString_methods.startsWith$1(path, "file://"))
            return index;
          if (!B.isDriveLetter(path, index + 1))
            return index;
          t2 = index + 3;
          return t1 === t2 ? t2 : index + 4;
        }
      }
      return 0;
    },
    rootLength$1: function(path) {
      return this.rootLength$2$withDrive(path, false);
    },
    isRootRelative$1: function(path) {
      return path.length !== 0 && J._codeUnitAt$1$s(path, 0) === 47;
    },
    pathFromUri$1: function(uri) {
      return J.toString$0$(uri);
    },
    relativePathToUri$1: function(path) {
      return P.Uri_parse(path);
    },
    absolutePathToUri$1: function(path) {
      return P.Uri_parse(path);
    },
    get$name: function() {
      return "url";
    },
    get$separator: function() {
      return "/";
    }
  };
  L.WindowsStyle.prototype = {
    containsSeparator$1: function(path) {
      return C.JSString_methods.contains$1(path, "/");
    },
    isSeparator$1: function(codeUnit) {
      return codeUnit === 47 || codeUnit === 92;
    },
    needsSeparator$1: function(path) {
      var t1 = path.length;
      if (t1 === 0)
        return false;
      t1 = J.codeUnitAt$1$s(path, t1 - 1);
      return !(t1 === 47 || t1 === 92);
    },
    rootLength$2$withDrive: function(path, withDrive) {
      var t2, index,
        t1 = path.length;
      if (t1 === 0)
        return 0;
      t2 = J.getInterceptor$s(path)._codeUnitAt$1(path, 0);
      if (t2 === 47)
        return 1;
      if (t2 === 92) {
        if (t1 < 2 || C.JSString_methods._codeUnitAt$1(path, 1) !== 92)
          return 1;
        index = C.JSString_methods.indexOf$2(path, "\\", 2);
        if (index > 0) {
          index = C.JSString_methods.indexOf$2(path, "\\", index + 1);
          if (index > 0)
            return index;
        }
        return t1;
      }
      if (t1 < 3)
        return 0;
      if (!B.isAlphabetic(t2))
        return 0;
      if (C.JSString_methods._codeUnitAt$1(path, 1) !== 58)
        return 0;
      t1 = C.JSString_methods._codeUnitAt$1(path, 2);
      if (!(t1 === 47 || t1 === 92))
        return 0;
      return 3;
    },
    rootLength$1: function(path) {
      return this.rootLength$2$withDrive(path, false);
    },
    isRootRelative$1: function(path) {
      return this.rootLength$1(path) === 1;
    },
    pathFromUri$1: function(uri) {
      var path, t1;
      if (uri.get$scheme() !== "" && uri.get$scheme() !== "file")
        throw H.wrapException(P.ArgumentError$("Uri " + uri.toString$0(0) + " must have scheme 'file:'."));
      path = uri.get$path(uri);
      if (uri.get$host() === "") {
        if (path.length >= 3 && C.JSString_methods.startsWith$1(path, "/") && B.isDriveLetter(path, 1))
          path = C.JSString_methods.replaceFirst$2(path, "/", "");
      } else
        path = "\\\\" + H.S(uri.get$host()) + path;
      t1 = H.stringReplaceAllUnchecked(path, "/", "\\");
      return P._Uri__uriDecode(t1, 0, t1.length, C.C_Utf8Codec, false);
    },
    absolutePathToUri$1: function(path) {
      var rootParts, t2,
        parsed = X.ParsedPath_ParsedPath$parse(path, this),
        t1 = parsed.root;
      if (J.startsWith$1$s(t1, "\\\\")) {
        t1 = H.setRuntimeTypeInfo(t1.split("\\"), [P.String]);
        rootParts = new H.WhereIterable(t1, new L.WindowsStyle_absolutePathToUri_closure(), [H.getTypeArgumentByIndex(t1, 0)]);
        C.JSArray_methods.insert$2(parsed.parts, 0, rootParts.get$last(rootParts));
        if (parsed.get$hasTrailingSeparator())
          C.JSArray_methods.add$1(parsed.parts, "");
        return P._Uri__Uri(rootParts.get$first(rootParts), null, parsed.parts, "file");
      } else {
        if (parsed.parts.length === 0 || parsed.get$hasTrailingSeparator())
          C.JSArray_methods.add$1(parsed.parts, "");
        t1 = parsed.parts;
        t2 = parsed.root;
        t2.toString;
        t2 = H.stringReplaceAllUnchecked(t2, "/", "");
        C.JSArray_methods.insert$2(t1, 0, H.stringReplaceAllUnchecked(t2, "\\", ""));
        return P._Uri__Uri(null, null, parsed.parts, "file");
      }
    },
    codeUnitsEqual$2: function(codeUnit1, codeUnit2) {
      var upperCase1;
      if (codeUnit1 === codeUnit2)
        return true;
      if (codeUnit1 === 47)
        return codeUnit2 === 92;
      if (codeUnit1 === 92)
        return codeUnit2 === 47;
      if ((codeUnit1 ^ codeUnit2) !== 32)
        return false;
      upperCase1 = codeUnit1 | 32;
      return upperCase1 >= 97 && upperCase1 <= 122;
    },
    pathsEqual$2: function(path1, path2) {
      var t1, t2, i;
      if (path1 == path2)
        return true;
      t1 = path1.length;
      if (t1 !== path2.length)
        return false;
      for (t2 = J.getInterceptor$s(path2), i = 0; i < t1; ++i)
        if (!this.codeUnitsEqual$2(C.JSString_methods._codeUnitAt$1(path1, i), t2._codeUnitAt$1(path2, i)))
          return false;
      return true;
    },
    canonicalizeCodeUnit$1: function(codeUnit) {
      if (codeUnit === 47)
        return 92;
      if (codeUnit < 65)
        return codeUnit;
      if (codeUnit > 90)
        return codeUnit;
      return codeUnit | 32;
    },
    canonicalizePart$1: function(part) {
      return part.toLowerCase();
    },
    get$name: function() {
      return "windows";
    },
    get$separator: function() {
      return "\\";
    }
  };
  L.WindowsStyle_absolutePathToUri_closure.prototype = {
    call$1: function(part) {
      return part !== "";
    }
  };
  F.CssMediaQuery.prototype = {
    merge$1: function(other) {
      var _i, t8, negativeFeatures, features, type, modifier, fewerFeatures, fewerFeatures0, moreFeatures, _this = this, _null = null, _s3_ = "all",
        t1 = _this.modifier,
        ourModifier = t1 == null ? _null : t1.toLowerCase(),
        t2 = _this.type,
        t3 = t2 == null,
        ourType = t3 ? _null : t2.toLowerCase(),
        t4 = other.modifier,
        theirModifier = t4 == null ? _null : t4.toLowerCase(),
        t5 = other.type,
        t6 = t5 == null,
        theirType = t6 ? _null : t5.toLowerCase(),
        t7 = ourType == null;
      if (t7 && theirType == null) {
        t1 = P.String;
        t2 = H.setRuntimeTypeInfo([], [t1]);
        for (t3 = _this.features, t4 = t3.length, _i = 0; _i < t4; ++_i)
          t2.push(t3[_i]);
        for (t3 = other.features, t4 = t3.length, _i = 0; _i < t4; ++_i)
          t2.push(t3[_i]);
        return new F.MediaQuerySuccessfulMergeResult(new F.CssMediaQuery(_null, _null, P.List_List$unmodifiable(t2, t1)));
      }
      t8 = ourModifier === "not";
      if (t8 !== (theirModifier === "not")) {
        if (ourType == theirType) {
          negativeFeatures = t8 ? _this.features : other.features;
          if (C.JSArray_methods.every$1(negativeFeatures, C.JSArray_methods.get$contains(t8 ? other.features : _this.features)))
            return C._SingletonCssMediaQueryMergeResult_empty;
          else
            return C._SingletonCssMediaQueryMergeResult_unrepresentable;
        } else if (t3 || B.equalsIgnoreCase(t2, _s3_) || t6 || B.equalsIgnoreCase(t5, _s3_))
          return C._SingletonCssMediaQueryMergeResult_unrepresentable;
        if (t8) {
          features = other.features;
          type = theirType;
          modifier = theirModifier;
        } else {
          features = _this.features;
          type = ourType;
          modifier = ourModifier;
        }
      } else if (t8) {
        if (ourType != theirType)
          return C._SingletonCssMediaQueryMergeResult_unrepresentable;
        fewerFeatures = _this.features;
        fewerFeatures0 = other.features;
        t3 = fewerFeatures.length > fewerFeatures0.length;
        moreFeatures = t3 ? fewerFeatures : fewerFeatures0;
        if (t3)
          fewerFeatures = fewerFeatures0;
        if (!C.JSArray_methods.every$1(fewerFeatures, C.JSArray_methods.get$contains(moreFeatures)))
          return C._SingletonCssMediaQueryMergeResult_unrepresentable;
        features = moreFeatures;
        type = ourType;
        modifier = ourModifier;
      } else if (t3 || B.equalsIgnoreCase(t2, _s3_)) {
        type = (t6 || B.equalsIgnoreCase(t5, _s3_)) && t7 ? _null : theirType;
        t3 = H.setRuntimeTypeInfo([], [P.String]);
        for (t6 = _this.features, t7 = t6.length, _i = 0; _i < t7; ++_i)
          t3.push(t6[_i]);
        for (t6 = other.features, t7 = t6.length, _i = 0; _i < t7; ++_i)
          t3.push(t6[_i]);
        features = t3;
        modifier = theirModifier;
      } else {
        if (t6 || B.equalsIgnoreCase(t5, _s3_)) {
          t3 = H.setRuntimeTypeInfo([], [P.String]);
          for (t6 = _this.features, t7 = t6.length, _i = 0; _i < t7; ++_i)
            t3.push(t6[_i]);
          for (t6 = other.features, t7 = t6.length, _i = 0; _i < t7; ++_i)
            t3.push(t6[_i]);
          features = t3;
          modifier = ourModifier;
        } else {
          if (ourType != theirType)
            return C._SingletonCssMediaQueryMergeResult_empty;
          else {
            modifier = ourModifier == null ? theirModifier : ourModifier;
            t3 = H.setRuntimeTypeInfo([], [P.String]);
            for (t6 = _this.features, t7 = t6.length, _i = 0; _i < t7; ++_i)
              t3.push(t6[_i]);
            for (t6 = other.features, t7 = t6.length, _i = 0; _i < t7; ++_i)
              t3.push(t6[_i]);
          }
          features = t3;
        }
        type = ourType;
      }
      t2 = type == ourType ? t2 : t5;
      return new F.MediaQuerySuccessfulMergeResult(F.CssMediaQuery$(t2, features, modifier == ourModifier ? t1 : t4));
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return other instanceof F.CssMediaQuery && other.modifier == this.modifier && other.type == this.type && C.C_ListEquality.equals$2(other.features, this.features);
    },
    get$hashCode: function(_) {
      return J.get$hashCode$(this.modifier) ^ J.get$hashCode$(this.type) ^ C.C_ListEquality.hash$1(this.features);
    },
    toString$0: function(_) {
      var t2, _this = this,
        t1 = _this.modifier;
      t1 = t1 != null ? t1 + " " : "";
      t2 = _this.type;
      if (t2 != null) {
        t1 += t2;
        if (_this.features.length !== 0)
          t1 += " and ";
      }
      t1 += C.JSArray_methods.join$1(_this.features, " and ");
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    }
  };
  F._SingletonCssMediaQueryMergeResult.prototype = {
    toString$0: function(_) {
      return this._media_query$_name;
    }
  };
  F.MediaQuerySuccessfulMergeResult.prototype = {};
  U.ModifiableCssAtRule.prototype = {
    accept$1$1: function(visitor) {
      return visitor.visitCssAtRule$1(this);
    },
    accept$1: function(visitor) {
      return this.accept$1$1(visitor, null);
    },
    copyWithoutChildren$0: function() {
      var _this = this,
        t1 = B.ModifiableCssNode,
        t2 = H.setRuntimeTypeInfo([], [t1]);
      return new U.ModifiableCssAtRule(_this.name, _this.value, _this.isChildless, _this.span, new P.UnmodifiableListView(t2, [t1]), t2);
    },
    addChild$1: function(child) {
      this.super$ModifiableCssParentNode$addChild(child);
    },
    $isCssAtRule: 1,
    get$isChildless: function() {
      return this.isChildless;
    },
    get$span: function() {
      return this.span;
    }
  };
  R.ModifiableCssComment.prototype = {
    accept$1$1: function(visitor) {
      return visitor.visitCssComment$1(this);
    },
    accept$1: function(visitor) {
      return this.accept$1$1(visitor, null);
    },
    $isCssComment: 1,
    get$span: function() {
      return this.span;
    }
  };
  L.ModifiableCssDeclaration.prototype = {
    accept$1$1: function(visitor) {
      return visitor.visitCssDeclaration$1(this);
    },
    accept$1: function(visitor) {
      return this.accept$1$1(visitor, null);
    },
    get$span: function() {
      return this.span;
    }
  };
  F.ModifiableCssImport.prototype = {
    accept$1$1: function(visitor) {
      return visitor.visitCssImport$1(this);
    },
    accept$1: function(visitor) {
      return this.accept$1$1(visitor, null);
    },
    $isCssImport: 1,
    get$span: function() {
      return this.span;
    }
  };
  U.ModifiableCssKeyframeBlock.prototype = {
    accept$1$1: function(visitor) {
      return visitor.visitCssKeyframeBlock$1(this);
    },
    accept$1: function(visitor) {
      return this.accept$1$1(visitor, null);
    },
    copyWithoutChildren$0: function() {
      var t1 = B.ModifiableCssNode,
        t2 = H.setRuntimeTypeInfo([], [t1]);
      return new U.ModifiableCssKeyframeBlock(this.selector, this.span, new P.UnmodifiableListView(t2, [t1]), t2);
    },
    get$span: function() {
      return this.span;
    }
  };
  G.ModifiableCssMediaRule.prototype = {
    accept$1$1: function(visitor) {
      return visitor.visitCssMediaRule$1(this);
    },
    accept$1: function(visitor) {
      return this.accept$1$1(visitor, null);
    },
    copyWithoutChildren$0: function() {
      return G.ModifiableCssMediaRule$(this.queries, this.span);
    },
    $isCssMediaRule: 1,
    get$span: function() {
      return this.span;
    }
  };
  B.ModifiableCssNode.prototype = {
    get$hasFollowingSibling: function() {
      var siblings, i, t2,
        t1 = this._parent;
      if (t1 == null)
        return false;
      siblings = t1.children;
      for (i = this._indexInParent + 1, t1 = siblings._collection$_source, t2 = J.getInterceptor$asx(t1); i < t2.get$length(t1); ++i)
        if (!this._node0$_isInvisible$1(t2.elementAt$1(t1, i)))
          return true;
      return false;
    },
    _node0$_isInvisible$1: function(node) {
      if (!!J.getInterceptor$(node).$isCssParentNode) {
        if (!!node.$isCssAtRule)
          return false;
        if (!!node.$isCssStyleRule && node.selector.value.get$isInvisible())
          return true;
        return J.every$1$ax(node.get$children(), this.get$_node0$_isInvisible());
      } else
        return false;
    },
    get$isGroupEnd: function() {
      return this.isGroupEnd;
    }
  };
  B.ModifiableCssParentNode.prototype = {
    get$isChildless: function() {
      return false;
    },
    addChild$1: function(child) {
      var t1;
      child._parent = this;
      t1 = this._children;
      child._indexInParent = t1.length;
      t1.push(child);
    },
    $isCssParentNode: 1,
    get$children: function() {
      return this.children;
    }
  };
  X.ModifiableCssStyleRule.prototype = {
    accept$1$1: function(visitor) {
      return visitor.visitCssStyleRule$1(this);
    },
    accept$1: function(visitor) {
      return this.accept$1$1(visitor, null);
    },
    copyWithoutChildren$0: function() {
      return X.ModifiableCssStyleRule$(this.selector, this.span, this.originalSelector);
    },
    $isCssStyleRule: 1,
    get$span: function() {
      return this.span;
    }
  };
  V.ModifiableCssStylesheet.prototype = {
    accept$1$1: function(visitor) {
      return visitor.visitCssStylesheet$1(this);
    },
    accept$1: function(visitor) {
      return this.accept$1$1(visitor, null);
    },
    copyWithoutChildren$0: function() {
      var t1 = B.ModifiableCssNode,
        t2 = H.setRuntimeTypeInfo([], [t1]);
      return new V.ModifiableCssStylesheet(this.span, new P.UnmodifiableListView(t2, [t1]), t2);
    },
    $isCssStylesheet: 1,
    get$span: function() {
      return this.span;
    }
  };
  B.ModifiableCssSupportsRule.prototype = {
    accept$1$1: function(visitor) {
      return visitor.visitCssSupportsRule$1(this);
    },
    accept$1: function(visitor) {
      return this.accept$1$1(visitor, null);
    },
    copyWithoutChildren$0: function() {
      var t1 = B.ModifiableCssNode,
        t2 = H.setRuntimeTypeInfo([], [t1]);
      return new B.ModifiableCssSupportsRule(this.condition, this.span, new P.UnmodifiableListView(t2, [t1]), t2);
    },
    $isCssSupportsRule: 1,
    get$span: function() {
      return this.span;
    }
  };
  F.ModifiableCssValue.prototype = {
    toString$0: function(_) {
      return J.toString$0$(this.value);
    },
    $isCssValue: 1,
    $isAstNode: 1,
    get$value: function() {
      return this.value;
    },
    get$span: function() {
      return this.span;
    }
  };
  B.CssNode.prototype = {
    toString$0: function(_) {
      return N.serialize(this, true, null, true, null, false, null, true).css;
    }
  };
  B.CssParentNode.prototype = {};
  X.CssStyleRule.prototype = {};
  V.CssStylesheet.prototype = {
    get$isGroupEnd: function() {
      return false;
    },
    get$isChildless: function() {
      return false;
    },
    accept$1$1: function(visitor) {
      return visitor.visitCssStylesheet$1(this);
    },
    accept$1: function(visitor) {
      return this.accept$1$1(visitor, null);
    },
    get$children: function() {
      return this.children;
    },
    get$span: function() {
      return this.span;
    }
  };
  F.CssValue.prototype = {
    toString$0: function(_) {
      return J.toString$0$(this.value);
    },
    $isAstNode: 1,
    get$value: function() {
      return this.value;
    },
    get$span: function() {
      return this.span;
    }
  };
  B.AstNode.prototype = {};
  Z.Argument.prototype = {
    toString$0: function(_) {
      var t1 = this.defaultValue,
        t2 = this.name;
      return t1 == null ? t2 : t2 + ": " + t1.toString$0(0);
    },
    $isAstNode: 1,
    get$span: function() {
      return this.span;
    }
  };
  B.ArgumentDeclaration.prototype = {
    get$originalRestArgument: function() {
      var t1, text;
      if (this.restArgument == null)
        return;
      t1 = this.span;
      text = P.String_String$fromCharCodes(C.NativeUint32List_methods.sublist$2(t1.file._decodedChars, t1._start, t1._end), 0, null);
      return C.JSString_methods.substring$2(C.JSString_methods.substring$1(text, C.JSString_methods.lastIndexOf$1(text, "$")), 0, C.JSString_methods.indexOf$1(text, "."));
    },
    verify$2: function(positional, names) {
      var t1, t2, t3, namedUsed, i, argument, t4, unknownNames, _this = this,
        _s8_ = "argument";
      for (t1 = _this.$arguments, t2 = t1.length, t3 = names._baseMap, namedUsed = 0, i = 0; i < t2; ++i) {
        argument = t1[i];
        if (i < positional) {
          t4 = argument.name;
          if (t3.containsKey$1(t4))
            throw H.wrapException(E.SassScriptException$("Argument " + H.S(_this._originalArgumentName$1(t4)) + " was passed both by position and by name."));
        } else {
          t4 = argument.name;
          if (t3.containsKey$1(t4))
            ++namedUsed;
          else if (argument.defaultValue == null)
            throw H.wrapException(E.SassScriptException$("Missing argument " + H.S(_this._originalArgumentName$1(t4)) + "."));
        }
      }
      if (_this.restArgument != null)
        return;
      if (positional > t2) {
        t1 = "Only " + t2 + " ";
        throw H.wrapException(E.SassScriptException$(t1 + (names.get$isEmpty(names) ? "" : "positional ") + B.pluralize(_s8_, t2, null) + " allowed, but " + positional + " " + B.pluralize("was", positional, "were") + " passed."));
      }
      if (namedUsed < t3.get$length(t3)) {
        unknownNames = P.LinkedHashSet_LinkedHashSet$of(names, P.String);
        t2 = P.Object;
        unknownNames.removeAll$1(new H.MappedListIterable(t1, new B.ArgumentDeclaration_verify_closure(), [H.getTypeArgumentByIndex(t1, 0), t2]));
        throw H.wrapException(E.SassScriptException$("No " + B.pluralize(_s8_, unknownNames._collection$_length, null) + " named " + H.S(B.toSentence(unknownNames.map$1$1(0, new B.ArgumentDeclaration_verify_closure0(), t2), "or")) + "."));
      }
    },
    _originalArgumentName$1: function($name) {
      var t1, t2, _i, argument, t3, text, end;
      if ($name === this.restArgument)
        return this.get$originalRestArgument();
      for (t1 = this.$arguments, t2 = t1.length, _i = 0; _i < t2; ++_i) {
        argument = t1[_i];
        if (argument.name === $name) {
          if (argument.defaultValue == null) {
            t1 = argument.span;
            t2 = t1._start;
            t3 = t1.file._decodedChars;
            t3 = P.String_String$fromCharCodes(new Uint32Array(t3.subarray(t2, H._checkValidRange(t2, t1._end, t3.length))), 0, null);
            t1 = t3;
          } else {
            t1 = argument.span;
            t2 = t1._start;
            t3 = t1.file._decodedChars;
            text = P.String_String$fromCharCodes(new Uint32Array(t3.subarray(t2, H._checkValidRange(t2, t1._end, t3.length))), 0, null);
            t3 = C.JSString_methods.substring$2(text, 0, C.JSString_methods.indexOf$1(text, ":"));
            end = B._lastNonWhitespace(t3, false);
            t1 = end == null ? "" : C.JSString_methods.substring$2(t3, 0, end + 1);
          }
          return t1;
        }
      }
      throw H.wrapException(P.ArgumentError$('This declaration has no argument named "$' + $name + '".'));
    },
    matches$2: function(positional, names) {
      var t1, t2, t3, namedUsed, i, argument;
      for (t1 = this.$arguments, t2 = t1.length, t3 = names._baseMap, namedUsed = 0, i = 0; i < t2; ++i) {
        argument = t1[i];
        if (i < positional) {
          if (t3.containsKey$1(argument.name))
            return false;
        } else if (t3.containsKey$1(argument.name))
          ++namedUsed;
        else if (argument.defaultValue == null)
          return false;
      }
      if (this.restArgument != null)
        return true;
      if (positional > t2)
        return false;
      if (namedUsed < t3.get$length(t3))
        return false;
      return true;
    },
    toString$0: function(_) {
      var t2, t3, _i,
        t1 = H.setRuntimeTypeInfo([], [P.String]);
      for (t2 = this.$arguments, t3 = t2.length, _i = 0; _i < t3; ++_i)
        t1.push(J.toString$0$(t2[_i]));
      t2 = this.restArgument;
      if (t2 != null)
        t1.push(t2 + "...");
      return C.JSArray_methods.join$1(t1, ", ");
    },
    $isAstNode: 1,
    get$span: function() {
      return this.span;
    }
  };
  B.ArgumentDeclaration_verify_closure.prototype = {
    call$1: function(argument) {
      return argument.name;
    }
  };
  B.ArgumentDeclaration_verify_closure0.prototype = {
    call$1: function($name) {
      return "$" + H.S($name);
    }
  };
  X.ArgumentInvocation.prototype = {
    get$isEmpty: function(_) {
      var t1;
      if (this.positional.length === 0) {
        t1 = this.named;
        t1 = t1.get$isEmpty(t1) && this.rest == null;
      } else
        t1 = false;
      return t1;
    },
    toString$0: function(_) {
      var t2, t3, _i, t4, _this = this,
        t1 = H.setRuntimeTypeInfo([], [P.Object]);
      for (t2 = _this.positional, t3 = t2.length, _i = 0; _i < t3; ++_i)
        t1.push(t2[_i]);
      for (t2 = _this.named, t3 = t2.get$keys(), t3 = t3.get$iterator(t3); t3.moveNext$0();) {
        t4 = t3.get$current(t3);
        t1.push(H.S(t4) + ": " + H.S(t2.$index(0, t4)));
      }
      t2 = _this.rest;
      if (t2 != null)
        t1.push(t2.toString$0(0) + "...");
      t2 = _this.keywordRest;
      if (t2 != null)
        t1.push(t2.toString$0(0) + "...");
      return "(" + C.JSArray_methods.join$1(t1, ", ") + ")";
    },
    $isAstNode: 1,
    get$span: function() {
      return this.span;
    }
  };
  V.AtRootQuery.prototype = {
    excludes$1: function(node) {
      var _this = this;
      if (_this._all)
        return !_this.include;
      if (_this._at_root_query$_rule && !!J.getInterceptor$(node).$isCssStyleRule)
        return !_this.include;
      return _this.names.contains$1(0, _this._nameFor$1(node)) !== _this.include;
    },
    _nameFor$1: function(node) {
      var t1 = J.getInterceptor$(node);
      if (!!t1.$isCssMediaRule)
        return "media";
      if (!!t1.$isCssSupportsRule)
        return "supports";
      if (!!t1.$isCssAtRule)
        return node.name.get$value().toLowerCase();
      return;
    }
  };
  T.Expression.prototype = {$isAstNode: 1};
  V.BinaryOperationExpression.prototype = {
    get$span: function() {
      var right,
        left = this.left;
      for (; left instanceof V.BinaryOperationExpression;)
        left = left.left;
      right = this.right;
      for (; right instanceof V.BinaryOperationExpression;)
        right = right.right;
      return B.spanForList(H.setRuntimeTypeInfo([left, right], [B.AstNode]));
    },
    accept$1$1: function(visitor) {
      return visitor.visitBinaryOperationExpression$1(this);
    },
    accept$1: function(visitor) {
      return this.accept$1$1(visitor, null);
    },
    toString$0: function(_) {
      var t2, right, rightNeedsParens, _this = this,
        left = _this.left,
        leftNeedsParens = left instanceof V.BinaryOperationExpression && left.operator.precedence < _this.operator.precedence,
        t1 = leftNeedsParens ? H.Primitives_stringFromCharCode(40) : "";
      t1 += H.S(left);
      if (leftNeedsParens)
        t1 += H.Primitives_stringFromCharCode(41);
      t2 = _this.operator;
      t1 = t1 + H.Primitives_stringFromCharCode(32) + t2.operator + H.Primitives_stringFromCharCode(32);
      right = _this.right;
      rightNeedsParens = right instanceof V.BinaryOperationExpression && right.operator.precedence <= t2.precedence;
      if (rightNeedsParens)
        t1 += H.Primitives_stringFromCharCode(40);
      t1 += H.S(right);
      if (rightNeedsParens)
        t1 += H.Primitives_stringFromCharCode(41);
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    $isAstNode: 1,
    $isExpression: 1
  };
  V.BinaryOperator.prototype = {
    toString$0: function(_) {
      return this.name;
    }
  };
  Z.BooleanExpression.prototype = {
    accept$1$1: function(visitor) {
      return visitor.visitBooleanExpression$1(this);
    },
    accept$1: function(visitor) {
      return this.accept$1$1(visitor, null);
    },
    toString$0: function(_) {
      return String(this.value);
    },
    $isAstNode: 1,
    $isExpression: 1,
    get$span: function() {
      return this.span;
    }
  };
  K.ColorExpression.prototype = {
    get$span: function() {
      return this.value.originalSpan;
    },
    accept$1$1: function(visitor) {
      return visitor.visitColorExpression$1(this);
    },
    accept$1: function(visitor) {
      return this.accept$1$1(visitor, null);
    },
    toString$0: function(_) {
      return N.serializeValue(this.value, true, true);
    },
    $isAstNode: 1,
    $isExpression: 1
  };
  F.FunctionExpression.prototype = {
    accept$1$1: function(visitor) {
      return visitor.visitFunctionExpression$1(this);
    },
    accept$1: function(visitor) {
      return this.accept$1$1(visitor, null);
    },
    toString$0: function(_) {
      var t1 = this.namespace;
      t1 = t1 != null ? t1 + "." : "";
      t1 += this.name.toString$0(0) + this.$arguments.toString$0(0);
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    $isAstNode: 1,
    $isExpression: 1,
    get$span: function() {
      return this.span;
    }
  };
  L.IfExpression.prototype = {
    accept$1$1: function(visitor) {
      return visitor.visitIfExpression$1(this);
    },
    accept$1: function(visitor) {
      return this.accept$1$1(visitor, null);
    },
    toString$0: function(_) {
      return "if" + this.$arguments.toString$0(0);
    },
    $isAstNode: 1,
    $isExpression: 1,
    get$span: function() {
      return this.span;
    }
  };
  D.ListExpression.prototype = {
    accept$1$1: function(visitor) {
      return visitor.visitListExpression$1(this);
    },
    accept$1: function(visitor) {
      return this.accept$1$1(visitor, null);
    },
    toString$0: function(_) {
      var _this = this,
        t1 = _this.hasBrackets,
        t2 = t1 ? H.Primitives_stringFromCharCode(91) : "",
        t3 = _this.contents,
        t4 = _this.separator === C.ListSeparator_comma ? ", " : " ";
      t4 = t2 + new H.MappedListIterable(t3, new D.ListExpression_toString_closure(_this), [H.getTypeArgumentByIndex(t3, 0), P.String]).join$1(0, t4);
      t1 = t1 ? t4 + H.Primitives_stringFromCharCode(93) : t4;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    _list0$_elementNeedsParens$1: function(expression) {
      var t2,
        t1 = J.getInterceptor$(expression);
      if (!!t1.$isListExpression) {
        if (expression.contents.length < 2)
          return false;
        if (expression.hasBrackets)
          return false;
        t1 = this.separator;
        t2 = t1 === C.ListSeparator_comma;
        return t2 ? t2 : t1 !== C.ListSeparator_undecided;
      }
      if (this.separator !== C.ListSeparator_space)
        return false;
      if (!!t1.$isUnaryOperationExpression) {
        t1 = expression.operator;
        return t1 === C.UnaryOperator_j2w || t1 === C.UnaryOperator_U4G;
      }
      return false;
    },
    $isAstNode: 1,
    $isExpression: 1,
    get$span: function() {
      return this.span;
    }
  };
  D.ListExpression_toString_closure.prototype = {
    call$1: function(element) {
      return this.$this._list0$_elementNeedsParens$1(element) ? "(" + H.S(element) + ")" : J.toString$0$(element);
    }
  };
  A.MapExpression.prototype = {
    accept$1$1: function(visitor) {
      return visitor.visitMapExpression$1(this);
    },
    accept$1: function(visitor) {
      return this.accept$1$1(visitor, null);
    },
    toString$0: function(_) {
      var t1 = this.pairs;
      return "(" + new H.MappedListIterable(t1, new A.MapExpression_toString_closure(), [H.getTypeArgumentByIndex(t1, 0), P.String]).join$1(0, ", ") + ")";
    },
    $isAstNode: 1,
    $isExpression: 1,
    get$span: function() {
      return this.span;
    }
  };
  A.MapExpression_toString_closure.prototype = {
    call$1: function(pair) {
      return H.S(pair.item1) + ": " + H.S(pair.item2);
    }
  };
  O.NullExpression.prototype = {
    accept$1$1: function(visitor) {
      return visitor.visitNullExpression$1(this);
    },
    accept$1: function(visitor) {
      return this.accept$1$1(visitor, null);
    },
    toString$0: function(_) {
      return "null";
    },
    $isAstNode: 1,
    $isExpression: 1,
    get$span: function() {
      return this.span;
    }
  };
  T.NumberExpression.prototype = {
    accept$1$1: function(visitor) {
      return visitor.visitNumberExpression$1(this);
    },
    accept$1: function(visitor) {
      return this.accept$1$1(visitor, null);
    },
    toString$0: function(_) {
      var t1 = H.S(this.value),
        t2 = this.unit;
      return t1 + (t2 == null ? "" : t2);
    },
    $isAstNode: 1,
    $isExpression: 1,
    get$span: function() {
      return this.span;
    }
  };
  T.ParenthesizedExpression.prototype = {
    accept$1$1: function(visitor) {
      return visitor.visitParenthesizedExpression$1(this);
    },
    accept$1: function(visitor) {
      return this.accept$1$1(visitor, null);
    },
    toString$0: function(_) {
      return J.toString$0$(this.expression);
    },
    $isAstNode: 1,
    $isExpression: 1,
    get$span: function() {
      return this.span;
    }
  };
  T.SelectorExpression.prototype = {
    accept$1$1: function(visitor) {
      return visitor.visitSelectorExpression$1(this);
    },
    accept$1: function(visitor) {
      return this.accept$1$1(visitor, null);
    },
    toString$0: function(_) {
      return "&";
    },
    $isAstNode: 1,
    $isExpression: 1,
    get$span: function() {
      return this.span;
    }
  };
  D.StringExpression.prototype = {
    get$span: function() {
      return this.text.span;
    },
    accept$1$1: function(visitor) {
      return visitor.visitStringExpression$1(this);
    },
    accept$1: function(visitor) {
      return this.accept$1$1(visitor, null);
    },
    asInterpolation$1$static: function($static) {
      var quote, t1, t2, buffer, t3, t4, t5, _i, value, t6, t7, i, codeUnit, next, t8, _this = this;
      if (!_this.hasQuotes)
        return _this.text;
      quote = _this._bestQuote$0();
      t1 = new P.StringBuffer("");
      t2 = [];
      buffer = new Z.InterpolationBuffer(t1, t2);
      t1._contents += H.Primitives_stringFromCharCode(quote);
      for (t3 = _this.text, t4 = t3.contents, t5 = t4.length, _i = 0; _i < t5; ++_i) {
        value = t4[_i];
        if (!!J.getInterceptor$(value).$isExpression) {
          buffer._flushText$0();
          t2.push(value);
        } else if (typeof value === "string")
          for (t6 = value.length, t7 = t6 - 1, i = 0; i < t6; ++i) {
            codeUnit = C.JSString_methods._codeUnitAt$1(value, i);
            if (codeUnit === 10 || codeUnit === 13 || codeUnit === 12) {
              t1._contents += H.Primitives_stringFromCharCode(92);
              t1._contents += H.Primitives_stringFromCharCode(97);
              if (i !== t7) {
                next = C.JSString_methods._codeUnitAt$1(value, i + 1);
                if (next === 32 || next === 9 || next === 10 || next === 13 || next === 12 || T.isHex(next))
                  t1._contents += H.Primitives_stringFromCharCode(32);
              }
            } else {
              if (codeUnit !== quote)
                if (codeUnit !== 92)
                  t8 = $static && codeUnit === 35 && i < t7 && C.JSString_methods._codeUnitAt$1(value, i + 1) === 123;
                else
                  t8 = true;
              else
                t8 = true;
              if (t8)
                t1._contents += H.Primitives_stringFromCharCode(92);
              t1._contents += H.Primitives_stringFromCharCode(codeUnit);
            }
          }
      }
      t1._contents += H.Primitives_stringFromCharCode(quote);
      return buffer.interpolation$1(t3.span);
    },
    asInterpolation$0: function() {
      return this.asInterpolation$1$static(false);
    },
    _bestQuote$0: function() {
      var t1, t2, containsDoubleQuote, _i, value, t3, i, codeUnit;
      for (t1 = this.text.contents, t2 = t1.length, containsDoubleQuote = false, _i = 0; _i < t2; ++_i) {
        value = t1[_i];
        if (typeof value === "string")
          for (t3 = value.length, i = 0; i < t3; ++i) {
            codeUnit = C.JSString_methods._codeUnitAt$1(value, i);
            if (codeUnit === 39)
              return 34;
            if (codeUnit === 34)
              containsDoubleQuote = true;
          }
      }
      return containsDoubleQuote ? 39 : 34;
    },
    toString$0: function(_) {
      return this.asInterpolation$0().toString$0(0);
    },
    $isAstNode: 1,
    $isExpression: 1
  };
  X.UnaryOperationExpression.prototype = {
    accept$1$1: function(visitor) {
      return visitor.visitUnaryOperationExpression$1(this);
    },
    accept$1: function(visitor) {
      return this.accept$1$1(visitor, null);
    },
    toString$0: function(_) {
      var t1 = this.operator,
        t2 = t1.operator;
      t1 = t1 === C.UnaryOperator_not_not ? t2 + H.Primitives_stringFromCharCode(32) : t2;
      t1 += H.S(this.operand);
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    $isAstNode: 1,
    $isExpression: 1,
    get$span: function() {
      return this.span;
    }
  };
  X.UnaryOperator.prototype = {
    toString$0: function(_) {
      return this.name;
    }
  };
  F.ValueExpression.prototype = {
    accept$1$1: function(visitor) {
      return visitor.visitValueExpression$1(this);
    },
    accept$1: function(visitor) {
      return this.accept$1$1(visitor, null);
    },
    toString$0: function(_) {
      return J.toString$0$(this.value);
    },
    $isAstNode: 1,
    $isExpression: 1,
    get$span: function() {
      return this.span;
    }
  };
  S.VariableExpression.prototype = {
    accept$1$1: function(visitor) {
      return visitor.visitVariableExpression$1(this);
    },
    accept$1: function(visitor) {
      return this.accept$1$1(visitor, null);
    },
    toString$0: function(_) {
      var t1 = this.namespace;
      t1 = t1 != null ? "$" + (t1 + ".") : "$";
      t1 += this.name;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    $isAstNode: 1,
    $isExpression: 1,
    get$span: function() {
      return this.span;
    }
  };
  F.Import.prototype = {$isAstNode: 1};
  B.DynamicImport.prototype = {
    toString$0: function(_) {
      return new D.StringExpression(X.Interpolation$(H.setRuntimeTypeInfo([this.url], [P.Object]), null), true).asInterpolation$1$static(true).get$asPlain();
    },
    $isAstNode: 1,
    $isImport: 1,
    get$span: function() {
      return this.span;
    }
  };
  Q.StaticImport.prototype = {
    toString$0: function(_) {
      var t1 = this.url.toString$0(0),
        t2 = this.supports;
      if (t2 != null)
        t1 += " supports(" + t2.toString$0(0) + ")";
      t2 = this.media;
      if (t2 != null)
        t1 += " " + t2.toString$0(0);
      t1 += H.Primitives_stringFromCharCode(59);
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    $isAstNode: 1,
    $isImport: 1,
    get$span: function() {
      return this.span;
    }
  };
  X.Interpolation.prototype = {
    get$asPlain: function() {
      var first,
        t1 = this.contents,
        t2 = t1.length;
      if (t2 === 0)
        return "";
      if (t2 > 1)
        return;
      first = C.JSArray_methods.get$first(t1);
      return typeof first === "string" ? first : null;
    },
    Interpolation$2: function(contents, span) {
      var t1, t2, i, t3, t4,
        _s8_ = "contents";
      for (t1 = this.contents, t2 = t1.length, i = 0; i < t2; ++i) {
        t3 = t1[i];
        t4 = typeof t3 === "string";
        if (!t4 && !J.getInterceptor$(t3).$isExpression)
          throw H.wrapException(P.ArgumentError$value(t1, _s8_, "May only contains Strings or Expressions."));
        if (i !== 0) {
          t3 = t1[i - 1];
          t3 = typeof t3 === "string" && t4;
        } else
          t3 = false;
        if (t3)
          throw H.wrapException(P.ArgumentError$value(t1, _s8_, "May not contain adjacent Strings."));
      }
    },
    toString$0: function(_) {
      var t1 = this.contents;
      return new H.MappedListIterable(t1, new X.Interpolation_toString_closure(), [H.getTypeArgumentByIndex(t1, 0), P.String]).join$0(0);
    },
    $isAstNode: 1,
    get$span: function() {
      return this.span;
    }
  };
  X.Interpolation_toString_closure.prototype = {
    call$1: function(value) {
      return typeof value === "string" ? value : "#{" + H.S(value) + "}";
    },
    $signature: 21
  };
  B.SassNode.prototype = {};
  O.Statement.prototype = {$isAstNode: 1};
  V.AtRootRule.prototype = {
    accept$1$1: function(visitor) {
      return visitor.visitAtRootRule$1(this);
    },
    accept$1: function(visitor) {
      return this.accept$1$1(visitor, null);
    },
    toString$0: function(_) {
      var buffer = new P.StringBuffer("@at-root "),
        t1 = this.query;
      if (t1 != null)
        buffer._contents = "@at-root " + (t1.toString$0(0) + " ");
      t1 = this.children;
      return buffer.toString$0(0) + " {" + (t1 && C.JSArray_methods).join$1(t1, " ") + "}";
    },
    get$span: function() {
      return this.span;
    }
  };
  U.AtRule.prototype = {
    accept$1$1: function(visitor) {
      return visitor.visitAtRule$1(this);
    },
    accept$1: function(visitor) {
      return this.accept$1$1(visitor, null);
    },
    toString$0: function(_) {
      var t1 = "@" + this.name.toString$0(0),
        buffer = new P.StringBuffer(t1),
        t2 = this.value;
      if (t2 != null)
        buffer._contents = t1 + (" " + t2.toString$0(0));
      t1 = this.children;
      return t1 == null ? buffer.toString$0(0) + ";" : buffer.toString$0(0) + " {" + C.JSArray_methods.join$1(t1, " ") + "}";
    },
    get$span: function() {
      return this.span;
    }
  };
  M.CallableDeclaration.prototype = {
    get$span: function() {
      return this.span;
    }
  };
  Y.ContentBlock.prototype = {
    accept$1$1: function(visitor) {
      return visitor.visitContentBlock$1(this);
    },
    accept$1: function(visitor) {
      return this.accept$1$1(visitor, null);
    },
    toString$0: function(_) {
      var t2,
        t1 = this.$arguments;
      t1 = t1.$arguments.length === 0 && t1.restArgument == null ? "" : " using (" + t1.toString$0(0) + ")";
      t2 = this.children;
      return t1 + (" {" + (t2 && C.JSArray_methods).join$1(t2, " ") + "}");
    }
  };
  Q.ContentRule.prototype = {
    accept$1$1: function(visitor) {
      return visitor.visitContentRule$1(this);
    },
    accept$1: function(visitor) {
      return this.accept$1$1(visitor, null);
    },
    toString$0: function(_) {
      var t1 = this.$arguments;
      return t1.get$isEmpty(t1) ? "@content;" : "@content(" + t1.toString$0(0) + ");";
    },
    $isAstNode: 1,
    $isStatement: 1,
    get$span: function() {
      return this.span;
    }
  };
  Q.DebugRule.prototype = {
    accept$1$1: function(visitor) {
      return visitor.visitDebugRule$1(this);
    },
    accept$1: function(visitor) {
      return this.accept$1$1(visitor, null);
    },
    toString$0: function(_) {
      return "@debug " + H.S(this.expression) + ";";
    },
    $isAstNode: 1,
    $isStatement: 1,
    get$span: function() {
      return this.span;
    }
  };
  L.Declaration.prototype = {
    accept$1$1: function(visitor) {
      return visitor.visitDeclaration$1(this);
    },
    accept$1: function(visitor) {
      return this.accept$1$1(visitor, null);
    },
    toString$0: function(_) {
      return H.S(this.name) + ": " + H.S(this.value) + ";";
    },
    get$span: function() {
      return this.span;
    }
  };
  V.EachRule.prototype = {
    accept$1$1: function(visitor) {
      return visitor.visitEachRule$1(this);
    },
    accept$1: function(visitor) {
      return this.accept$1$1(visitor, null);
    },
    toString$0: function(_) {
      var t1 = this.variables,
        t2 = this.children;
      return "@each " + new H.MappedListIterable(t1, new V.EachRule_toString_closure(), [H.getTypeArgumentByIndex(t1, 0), P.String]).join$1(0, ", ") + " in " + H.S(this.list) + " {" + (t2 && C.JSArray_methods).join$1(t2, " ") + "}";
    },
    get$span: function() {
      return this.span;
    }
  };
  V.EachRule_toString_closure.prototype = {
    call$1: function(variable) {
      return C.JSString_methods.$add("$", variable);
    }
  };
  D.ErrorRule.prototype = {
    accept$1$1: function(visitor) {
      return visitor.visitErrorRule$1(this);
    },
    accept$1: function(visitor) {
      return this.accept$1$1(visitor, null);
    },
    toString$0: function(_) {
      return "@error " + H.S(this.expression) + ";";
    },
    $isAstNode: 1,
    $isStatement: 1,
    get$span: function() {
      return this.span;
    }
  };
  X.ExtendRule.prototype = {
    accept$1$1: function(visitor) {
      return visitor.visitExtendRule$1(this);
    },
    accept$1: function(visitor) {
      return this.accept$1$1(visitor, null);
    },
    toString$0: function(_) {
      return "@extend " + this.selector.toString$0(0);
    },
    $isAstNode: 1,
    $isStatement: 1,
    get$span: function() {
      return this.span;
    }
  };
  B.ForRule.prototype = {
    accept$1$1: function(visitor) {
      return visitor.visitForRule$1(this);
    },
    accept$1: function(visitor) {
      return this.accept$1$1(visitor, null);
    },
    toString$0: function(_) {
      var _this = this,
        t1 = "@for $" + _this.variable + " from " + H.S(_this.from) + " ",
        t2 = _this.children;
      return t1 + (_this.isExclusive ? "to" : "through") + " " + H.S(_this.to) + " {" + (t2 && C.JSArray_methods).join$1(t2, " ") + "}";
    },
    get$span: function() {
      return this.span;
    }
  };
  L.ForwardRule.prototype = {
    accept$1$1: function(visitor) {
      return visitor.visitForwardRule$1(this);
    },
    accept$1: function(visitor) {
      return this.accept$1$1(visitor, null);
    },
    toString$0: function(_) {
      var _this = this,
        t1 = "@forward " + H.S(new D.StringExpression(X.Interpolation$(H.setRuntimeTypeInfo([J.toString$0$(_this.url)], [P.Object]), null), true).asInterpolation$1$static(true).get$asPlain()),
        t2 = _this.shownMixinsAndFunctions;
      if (t2 != null)
        t1 = t1 + " show " + _this._forward_rule$_memberList$2(t2, _this.shownVariables);
      else {
        t2 = _this.hiddenMixinsAndFunctions;
        if (t2 != null)
          t1 = t1 + " hide " + _this._forward_rule$_memberList$2(t2, _this.hiddenVariables);
      }
      t2 = _this.prefix;
      t1 = (t2 != null ? t1 + (" as " + t2 + "*") : t1) + ";";
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    _forward_rule$_memberList$2: function(mixinsAndFunctions, variables) {
      var t1 = this.shownVariables._base.map$1$1(0, new L.ForwardRule__memberList_closure(), P.String);
      return this.shownMixinsAndFunctions._base.followedBy$1(0, t1).join$1(0, ", ");
    },
    $isAstNode: 1,
    $isStatement: 1,
    get$span: function() {
      return this.span;
    }
  };
  L.ForwardRule__memberList_closure.prototype = {
    call$1: function($name) {
      return "$" + H.S($name);
    }
  };
  M.FunctionRule.prototype = {
    accept$1$1: function(visitor) {
      return visitor.visitFunctionRule$1(this);
    },
    accept$1: function(visitor) {
      return this.accept$1$1(visitor, null);
    },
    toString$0: function(_) {
      var t1 = this.children;
      return "@function " + H.S(this.name) + "(" + this.$arguments.toString$0(0) + ") {" + (t1 && C.JSArray_methods).join$1(t1, " ") + "}";
    }
  };
  V.IfRule.prototype = {
    accept$1$1: function(visitor) {
      return visitor.visitIfRule$1(this);
    },
    accept$1: function(visitor) {
      return this.accept$1$1(visitor, null);
    },
    toString$0: function(_) {
      var t2, t1 = {};
      t1.first = true;
      t2 = this.clauses;
      return new H.MappedListIterable(t2, new V.IfRule_toString_closure(t1), [H.getTypeArgumentByIndex(t2, 0), P.String]).join$1(0, " ");
    },
    $isAstNode: 1,
    $isStatement: 1,
    get$span: function() {
      return this.span;
    }
  };
  V.IfRule_toString_closure.prototype = {
    call$1: function(clause) {
      var t1 = this._box_0,
        $name = t1.first ? "if" : "else";
      t1.first = false;
      return "@" + $name + " " + H.S(clause.expression) + " {" + C.JSArray_methods.join$1(clause.children, " ") + "}";
    }
  };
  V.IfClause.prototype = {
    toString$0: function(_) {
      var t1 = this.expression;
      t1 = t1 == null ? "@else" : "@if " + t1.toString$0(0);
      return t1 + (" {" + C.JSArray_methods.join$1(this.children, " ") + "}");
    }
  };
  V.IfClause$__closure.prototype = {
    call$1: function(child) {
      var t1 = J.getInterceptor$(child);
      return !!t1.$isVariableDeclaration || !!t1.$isFunctionRule || !!t1.$isMixinRule;
    }
  };
  B.ImportRule.prototype = {
    accept$1$1: function(visitor) {
      return visitor.visitImportRule$1(this);
    },
    accept$1: function(visitor) {
      return this.accept$1$1(visitor, null);
    },
    toString$0: function(_) {
      return "@import " + C.JSArray_methods.join$1(this.imports, ", ") + ";";
    },
    $isAstNode: 1,
    $isStatement: 1,
    get$span: function() {
      return this.span;
    }
  };
  A.IncludeRule.prototype = {
    accept$1$1: function(visitor) {
      return visitor.visitIncludeRule$1(this);
    },
    accept$1: function(visitor) {
      return this.accept$1$1(visitor, null);
    },
    toString$0: function(_) {
      var t2, _this = this,
        t1 = _this.namespace;
      t1 = t1 != null ? "@include " + (t1 + ".") : "@include ";
      t1 += _this.name;
      t2 = _this.$arguments;
      if (!t2.get$isEmpty(t2))
        t1 += "(" + t2.toString$0(0) + ")";
      t2 = _this.content;
      t1 += t2 == null ? ";" : " " + t2.toString$0(0);
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    $isAstNode: 1,
    $isStatement: 1,
    get$span: function() {
      return this.span;
    }
  };
  L.LoudComment.prototype = {
    get$span: function() {
      return this.text.span;
    },
    accept$1$1: function(visitor) {
      return visitor.visitLoudComment$1(this);
    },
    accept$1: function(visitor) {
      return this.accept$1$1(visitor, null);
    },
    toString$0: function(_) {
      return this.text.toString$0(0);
    },
    $isAstNode: 1,
    $isStatement: 1
  };
  G.MediaRule.prototype = {
    accept$1$1: function(visitor) {
      return visitor.visitMediaRule$1(this);
    },
    accept$1: function(visitor) {
      return this.accept$1$1(visitor, null);
    },
    toString$0: function(_) {
      var t1 = this.children;
      return "@media " + this.query.toString$0(0) + " {" + (t1 && C.JSArray_methods).join$1(t1, " ") + "}";
    },
    get$span: function() {
      return this.span;
    }
  };
  T.MixinRule.prototype = {
    accept$1$1: function(visitor) {
      return visitor.visitMixinRule$1(this);
    },
    accept$1: function(visitor) {
      return this.accept$1$1(visitor, null);
    },
    toString$0: function(_) {
      var t1 = "@mixin " + H.S(this.name),
        t2 = this.$arguments;
      if (!(t2.$arguments.length === 0 && t2.restArgument == null))
        t1 += "(" + t2.toString$0(0) + ")";
      t2 = this.children;
      t2 = t1 + (" {" + (t2 && C.JSArray_methods).join$1(t2, " ") + "}");
      return t2.charCodeAt(0) == 0 ? t2 : t2;
    }
  };
  M.ParentStatement.prototype = {$isAstNode: 1, $isStatement: 1};
  M.ParentStatement_closure.prototype = {
    call$1: function(child) {
      var t1 = J.getInterceptor$(child);
      return !!t1.$isVariableDeclaration || !!t1.$isFunctionRule || !!t1.$isMixinRule;
    }
  };
  B.ReturnRule.prototype = {
    accept$1$1: function(visitor) {
      return visitor.visitReturnRule$1(this);
    },
    accept$1: function(visitor) {
      return this.accept$1$1(visitor, null);
    },
    toString$0: function(_) {
      return "@return " + H.S(this.expression) + ";";
    },
    $isAstNode: 1,
    $isStatement: 1,
    get$span: function() {
      return this.span;
    }
  };
  B.SilentComment.prototype = {
    accept$1$1: function(visitor) {
      return visitor.visitSilentComment$1(this);
    },
    accept$1: function(visitor) {
      return this.accept$1$1(visitor, null);
    },
    toString$0: function(_) {
      return this.text;
    },
    $isAstNode: 1,
    $isStatement: 1,
    get$span: function() {
      return this.span;
    }
  };
  X.StyleRule.prototype = {
    accept$1$1: function(visitor) {
      return visitor.visitStyleRule$1(this);
    },
    accept$1: function(visitor) {
      return this.accept$1$1(visitor, null);
    },
    toString$0: function(_) {
      var t1 = this.children;
      return this.selector.toString$0(0) + " {" + (t1 && C.JSArray_methods).join$1(t1, " ") + "}";
    },
    get$span: function() {
      return this.span;
    }
  };
  V.Stylesheet.prototype = {
    Stylesheet$3$plainCss: function(children, span, plainCss) {
      var t1, t2, t3, t4, _i, child, t5;
      for (t1 = this.children, t2 = t1.length, t3 = this._forwards, t4 = this._uses, _i = 0; _i < t2; ++_i) {
        child = t1[_i];
        t5 = J.getInterceptor$(child);
        if (!!t5.$isUseRule)
          t4.push(child);
        else if (!!t5.$isForwardRule)
          t3.push(child);
        else if (!t5.$isSilentComment && !t5.$isLoudComment && !t5.$isVariableDeclaration)
          break;
      }
    },
    accept$1$1: function(visitor) {
      return visitor.visitStylesheet$1(this);
    },
    accept$1: function(visitor) {
      return this.accept$1$1(visitor, null);
    },
    toString$0: function(_) {
      var t1 = this.children;
      return (t1 && C.JSArray_methods).join$1(t1, " ");
    },
    get$span: function() {
      return this.span;
    }
  };
  B.SupportsRule.prototype = {
    accept$1$1: function(visitor) {
      return visitor.visitSupportsRule$1(this);
    },
    accept$1: function(visitor) {
      return this.accept$1$1(visitor, null);
    },
    toString$0: function(_) {
      var t1 = this.children;
      return "@supports " + this.condition.toString$0(0) + " {" + (t1 && C.JSArray_methods).join$1(t1, " ") + "}";
    },
    get$span: function() {
      return this.span;
    }
  };
  T.UseRule.prototype = {
    accept$1$1: function(visitor) {
      return visitor.visitUseRule$1(this);
    },
    accept$1: function(visitor) {
      return this.accept$1$1(visitor, null);
    },
    toString$0: function(_) {
      var t1 = "@use " + H.S(new D.StringExpression(X.Interpolation$(H.setRuntimeTypeInfo([J.toString$0$(this.url)], [P.Object]), null), true).asInterpolation$1$static(true).get$asPlain()) + " as ",
        t2 = this.namespace;
      return t1 + (t2 == null ? "*" : t2) + ";";
    },
    $isAstNode: 1,
    $isStatement: 1,
    get$span: function() {
      return this.span;
    }
  };
  Z.VariableDeclaration.prototype = {
    accept$1$1: function(visitor) {
      return visitor.visitVariableDeclaration$1(this);
    },
    accept$1: function(visitor) {
      return this.accept$1$1(visitor, null);
    },
    toString$0: function(_) {
      var t1 = this.namespace;
      t1 = t1 != null ? "$" + (t1 + ".") : "$";
      t1 += this.name + ": " + H.S(this.expression) + ";";
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    $isAstNode: 1,
    $isStatement: 1,
    get$span: function() {
      return this.span;
    }
  };
  Y.WarnRule.prototype = {
    accept$1$1: function(visitor) {
      return visitor.visitWarnRule$1(this);
    },
    accept$1: function(visitor) {
      return this.accept$1$1(visitor, null);
    },
    toString$0: function(_) {
      return "@warn " + H.S(this.expression) + ";";
    },
    $isAstNode: 1,
    $isStatement: 1,
    get$span: function() {
      return this.span;
    }
  };
  G.WhileRule.prototype = {
    accept$1$1: function(visitor) {
      return visitor.visitWhileRule$1(this);
    },
    accept$1: function(visitor) {
      return this.accept$1$1(visitor, null);
    },
    toString$0: function(_) {
      var t1 = this.children;
      return "@while " + H.S(this.condition) + " {" + (t1 && C.JSArray_methods).join$1(t1, " ") + "}";
    },
    get$span: function() {
      return this.span;
    }
  };
  N.SupportsCondition.prototype = {};
  L.SupportsDeclaration.prototype = {
    toString$0: function(_) {
      return "(" + H.S(this.name) + ": " + H.S(this.value) + ")";
    },
    $isAstNode: 1,
    get$span: function() {
      return this.span;
    }
  };
  X.SupportsInterpolation.prototype = {
    toString$0: function(_) {
      return "#{" + H.S(this.expression) + "}";
    },
    $isAstNode: 1,
    get$span: function() {
      return this.span;
    }
  };
  M.SupportsNegation.prototype = {
    toString$0: function(_) {
      var t1 = this.condition;
      if (!!t1.$isSupportsNegation || !!t1.$isSupportsOperation)
        return "not (" + t1.toString$0(0) + ")";
      else
        return "not " + t1.toString$0(0);
    },
    $isAstNode: 1,
    get$span: function() {
      return this.span;
    }
  };
  U.SupportsOperation.prototype = {
    toString$0: function(_) {
      var _this = this;
      return _this._operation$_parenthesize$1(_this.left) + " " + _this.operator + " " + _this._operation$_parenthesize$1(_this.right);
    },
    _operation$_parenthesize$1: function(condition) {
      var t1;
      if (!condition.$isSupportsNegation)
        t1 = !!condition.$isSupportsOperation && condition.operator === this.operator;
      else
        t1 = true;
      return t1 ? "(" + condition.toString$0(0) + ")" : condition.toString$0(0);
    },
    $isAstNode: 1,
    get$span: function() {
      return this.span;
    }
  };
  T.Selector.prototype = {
    get$isInvisible: function() {
      return false;
    },
    toString$0: function(_) {
      var visitor = N._SerializeVisitor$(null, true, null, true, false, null, true);
      this.accept$1(visitor);
      return visitor._buffer.toString$0(0);
    }
  };
  N.AttributeSelector.prototype = {
    accept$1$1: function(visitor) {
      var t2, _this = this,
        t1 = visitor._buffer;
      t1.writeCharCode$1(91);
      t1.write$1(0, _this.name);
      t2 = _this.op;
      if (t2 != null) {
        t1.write$1(0, t2);
        t2 = _this.value;
        if (G.Parser_isIdentifier(t2) && !J.startsWith$1$s(t2, "--")) {
          t1.write$1(0, t2);
          t2 = _this.modifier;
          if (t2 != null)
            t1.writeCharCode$1(32);
        } else {
          visitor._visitQuotedString$1(t2);
          t2 = _this.modifier;
          if (t2 != null)
            if (visitor._style !== C.OutputStyle_compressed)
              t1.writeCharCode$1(32);
        }
        if (t2 != null)
          t1.write$1(0, t2);
      }
      t1.writeCharCode$1(93);
      return;
    },
    accept$1: function(visitor) {
      return this.accept$1$1(visitor, null);
    },
    $eq: function(_, other) {
      var _this = this;
      if (other == null)
        return false;
      return other instanceof N.AttributeSelector && other.name.$eq(0, _this.name) && other.op == _this.op && other.value == _this.value && other.modifier == _this.modifier;
    },
    get$hashCode: function(_) {
      var _this = this,
        t1 = _this.name;
      return (C.JSString_methods.get$hashCode(t1.name) ^ J.get$hashCode$(t1.namespace) ^ J.get$hashCode$(_this.op) ^ J.get$hashCode$(_this.value) ^ J.get$hashCode$(_this.modifier)) >>> 0;
    }
  };
  N.AttributeOperator.prototype = {
    toString$0: function(_) {
      return this._attribute$_text;
    }
  };
  X.ClassSelector.prototype = {
    $eq: function(_, other) {
      if (other == null)
        return false;
      return other instanceof X.ClassSelector && other.name === this.name;
    },
    accept$1$1: function(visitor) {
      var t1 = visitor._buffer;
      t1.writeCharCode$1(46);
      t1.write$1(0, this.name);
      return;
    },
    accept$1: function(visitor) {
      return this.accept$1$1(visitor, null);
    },
    addSuffix$1: function(suffix) {
      return new X.ClassSelector(this.name + suffix);
    },
    get$hashCode: function(_) {
      return C.JSString_methods.get$hashCode(this.name);
    }
  };
  S.ComplexSelector.prototype = {
    get$minSpecificity: function() {
      if (this._minSpecificity == null)
        this._computeSpecificity$0();
      return this._minSpecificity;
    },
    get$maxSpecificity: function() {
      if (this._maxSpecificity == null)
        this._computeSpecificity$0();
      return this._maxSpecificity;
    },
    get$isInvisible: function() {
      var t1 = this._complex$_isInvisible;
      if (t1 != null)
        return t1;
      return this._complex$_isInvisible = C.JSArray_methods.any$1(this.components, new S.ComplexSelector_isInvisible_closure());
    },
    accept$1$1: function(visitor) {
      return visitor.visitComplexSelector$1(this);
    },
    accept$1: function(visitor) {
      return this.accept$1$1(visitor, null);
    },
    _computeSpecificity$0: function() {
      var t1, t2, component, t3, _this = this,
        _i = _this._maxSpecificity = _this._minSpecificity = 0;
      for (t1 = _this.components, t2 = t1.length; _i < t2; ++_i) {
        component = t1[_i];
        if (component instanceof X.CompoundSelector) {
          t3 = _this._minSpecificity;
          if (component._compound$_minSpecificity == null)
            component._compound$_computeSpecificity$0();
          _this._minSpecificity = t3 + component._compound$_minSpecificity;
          t3 = _this._maxSpecificity;
          if (component._compound$_maxSpecificity == null)
            component._compound$_computeSpecificity$0();
          _this._maxSpecificity = t3 + component._compound$_maxSpecificity;
        }
      }
    },
    get$hashCode: function(_) {
      return C.C_ListEquality.hash$1(this.components);
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return other instanceof S.ComplexSelector && C.C_ListEquality.equals$2(this.components, other.components);
    }
  };
  S.ComplexSelector_isInvisible_closure.prototype = {
    call$1: function(component) {
      return component instanceof X.CompoundSelector && component.get$isInvisible();
    }
  };
  S.ComplexSelectorComponent.prototype = {};
  S.Combinator.prototype = {
    toString$0: function(_) {
      return this._complex$_text;
    },
    $isComplexSelectorComponent: 1
  };
  X.CompoundSelector.prototype = {
    get$isInvisible: function() {
      return C.JSArray_methods.any$1(this.components, new X.CompoundSelector_isInvisible_closure());
    },
    accept$1$1: function(visitor) {
      return visitor.visitCompoundSelector$1(this);
    },
    accept$1: function(visitor) {
      return this.accept$1$1(visitor, null);
    },
    _compound$_computeSpecificity$0: function() {
      var t1, t2, simple, _this = this,
        _i = _this._compound$_maxSpecificity = _this._compound$_minSpecificity = 0;
      for (t1 = _this.components, t2 = t1.length; _i < t2; ++_i) {
        simple = t1[_i];
        _this._compound$_minSpecificity = _this._compound$_minSpecificity + simple.get$minSpecificity();
        _this._compound$_maxSpecificity = _this._compound$_maxSpecificity + simple.get$maxSpecificity();
      }
    },
    get$hashCode: function(_) {
      return C.C_ListEquality.hash$1(this.components);
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return other instanceof X.CompoundSelector && C.C_ListEquality.equals$2(this.components, other.components);
    },
    $isComplexSelectorComponent: 1
  };
  X.CompoundSelector_isInvisible_closure.prototype = {
    call$1: function(component) {
      return component.get$isInvisible();
    }
  };
  N.IDSelector.prototype = {
    get$minSpecificity: function() {
      return H.intTypeCast(Math.pow(M.SimpleSelector.prototype.get$minSpecificity.call(this), 2));
    },
    accept$1$1: function(visitor) {
      var t1 = visitor._buffer;
      t1.writeCharCode$1(35);
      t1.write$1(0, this.name);
      return;
    },
    accept$1: function(visitor) {
      return this.accept$1$1(visitor, null);
    },
    addSuffix$1: function(suffix) {
      return new N.IDSelector(this.name + suffix);
    },
    unify$1: function(compound) {
      if (C.JSArray_methods.any$1(compound, new N.IDSelector_unify_closure(this)))
        return;
      return this.super$SimpleSelector$unify(compound);
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return other instanceof N.IDSelector && other.name === this.name;
    },
    get$hashCode: function(_) {
      return C.JSString_methods.get$hashCode(this.name);
    }
  };
  N.IDSelector_unify_closure.prototype = {
    call$1: function(simple) {
      var t1;
      if (simple instanceof N.IDSelector) {
        t1 = simple.name;
        t1 = this.$this.name !== t1;
      } else
        t1 = false;
      return t1;
    }
  };
  D.SelectorList.prototype = {
    get$isInvisible: function() {
      return C.JSArray_methods.every$1(this.components, new D.SelectorList_isInvisible_closure());
    },
    get$asSassList: function() {
      var t1 = this.components;
      return D.SassList$(new H.MappedListIterable(t1, new D.SelectorList_asSassList_closure(), [H.getTypeArgumentByIndex(t1, 0), F.Value]), C.ListSeparator_comma, false);
    },
    accept$1$1: function(visitor) {
      return visitor.visitSelectorList$1(this);
    },
    accept$1: function(visitor) {
      return this.accept$1$1(visitor, null);
    },
    unify$1: function(other) {
      var t1 = this.components,
        t2 = S.ComplexSelector,
        contents = P.List_List$from(new H.ExpandIterable(t1, new D.SelectorList_unify_closure(other), [H.getTypeArgumentByIndex(t1, 0), t2]), true, t2);
      return contents.length === 0 ? null : D.SelectorList$(contents);
    },
    resolveParentSelectors$2$implicitParent: function($parent, implicitParent) {
      var t1, _this = this;
      if ($parent == null) {
        if (!C.JSArray_methods.any$1(_this.components, _this.get$_complexContainsParentSelector()))
          return _this;
        throw H.wrapException(E.SassScriptException$('Top-level selectors may not contain the parent selector "&".'));
      }
      t1 = _this.components;
      return D.SelectorList$(B.flattenVertically(new H.MappedListIterable(t1, new D.SelectorList_resolveParentSelectors_closure(_this, implicitParent, $parent), [H.getTypeArgumentByIndex(t1, 0), [P.Iterable, S.ComplexSelector]]), S.ComplexSelector));
    },
    resolveParentSelectors$1: function($parent) {
      return this.resolveParentSelectors$2$implicitParent($parent, true);
    },
    _complexContainsParentSelector$1: function(complex) {
      return C.JSArray_methods.any$1(complex.components, new D.SelectorList__complexContainsParentSelector_closure());
    },
    _resolveParentSelectorsCompound$2: function(compound, $parent) {
      var resolvedMembers0, parentSelector, t1,
        resolvedMembers = compound.components,
        containsSelectorPseudo = C.JSArray_methods.any$1(resolvedMembers, new D.SelectorList__resolveParentSelectorsCompound_closure());
      if (!containsSelectorPseudo && !(C.JSArray_methods.get$first(resolvedMembers) instanceof M.ParentSelector))
        return;
      resolvedMembers0 = containsSelectorPseudo ? new H.MappedListIterable(resolvedMembers, new D.SelectorList__resolveParentSelectorsCompound_closure0($parent), [H.getTypeArgumentByIndex(resolvedMembers, 0), M.SimpleSelector]) : resolvedMembers;
      parentSelector = C.JSArray_methods.get$first(resolvedMembers);
      if (parentSelector instanceof M.ParentSelector) {
        if (resolvedMembers.length === 1 && parentSelector.suffix == null)
          return $parent.components;
      } else
        return H.setRuntimeTypeInfo([S.ComplexSelector$(H.setRuntimeTypeInfo([X.CompoundSelector$(resolvedMembers0)], [S.ComplexSelectorComponent]), false)], [S.ComplexSelector]);
      t1 = $parent.components;
      return new H.MappedListIterable(t1, new D.SelectorList__resolveParentSelectorsCompound_closure1(compound, resolvedMembers0), [H.getTypeArgumentByIndex(t1, 0), S.ComplexSelector]);
    },
    get$hashCode: function(_) {
      return C.C_ListEquality.hash$1(this.components);
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return other instanceof D.SelectorList && C.C_ListEquality.equals$2(this.components, other.components);
    }
  };
  D.SelectorList_isInvisible_closure.prototype = {
    call$1: function(complex) {
      return complex.get$isInvisible();
    }
  };
  D.SelectorList_asSassList_closure.prototype = {
    call$1: function(complex) {
      var t1 = complex.components;
      return D.SassList$(new H.MappedListIterable(t1, new D.SelectorList_asSassList__closure(), [H.getTypeArgumentByIndex(t1, 0), F.Value]), C.ListSeparator_space, false);
    }
  };
  D.SelectorList_asSassList__closure.prototype = {
    call$1: function(component) {
      return new D.SassString(J.toString$0$(component), false);
    }
  };
  D.SelectorList_unify_closure.prototype = {
    call$1: function(complex1) {
      var t1 = this.other.components;
      return new H.ExpandIterable(t1, new D.SelectorList_unify__closure(complex1), [H.getTypeArgumentByIndex(t1, 0), S.ComplexSelector]);
    }
  };
  D.SelectorList_unify__closure.prototype = {
    call$1: function(complex2) {
      var unified = Y.unifyComplex(H.setRuntimeTypeInfo([this.complex1.components, complex2.components], [[P.List, S.ComplexSelectorComponent]]));
      if (unified == null)
        return C.List_empty7;
      return J.map$1$1$ax(unified, new D.SelectorList_unify___closure(), S.ComplexSelector);
    }
  };
  D.SelectorList_unify___closure.prototype = {
    call$1: function(complex) {
      return S.ComplexSelector$(complex, false);
    }
  };
  D.SelectorList_resolveParentSelectors_closure.prototype = {
    call$1: function(complex) {
      var t2, t3, newComplexes, t4, t5, t6, t7, _i, component, resolved, t8, _i0, previousLineBreaks, newComplexes0, t9, i, newComplex, i0, lineBreak, t10, t11, t12, t13, t14, t15, _i1, _this = this, _box_0 = {},
        t1 = _this.$this;
      if (!t1._complexContainsParentSelector$1(complex)) {
        if (!_this.implicitParent)
          return H.setRuntimeTypeInfo([complex], [S.ComplexSelector]);
        t1 = _this.parent.components;
        return new H.MappedListIterable(t1, new D.SelectorList_resolveParentSelectors__closure(complex), [H.getTypeArgumentByIndex(t1, 0), S.ComplexSelector]);
      }
      t2 = [S.ComplexSelectorComponent];
      t3 = [[P.List, S.ComplexSelectorComponent]];
      newComplexes = H.setRuntimeTypeInfo([H.setRuntimeTypeInfo([], t2)], t3);
      t4 = [P.bool];
      _box_0.lineBreaks = H.setRuntimeTypeInfo([false], t4);
      for (t5 = complex.components, t6 = t5.length, t7 = _this.parent, _i = 0; _i < t6; ++_i) {
        component = t5[_i];
        if (component instanceof X.CompoundSelector) {
          resolved = t1._resolveParentSelectorsCompound$2(component, t7);
          if (resolved == null) {
            for (t8 = newComplexes.length, _i0 = 0; _i0 < newComplexes.length; newComplexes.length === t8 || (0, H.throwConcurrentModificationError)(newComplexes), ++_i0)
              newComplexes[_i0].push(component);
            continue;
          }
          previousLineBreaks = _box_0.lineBreaks;
          newComplexes0 = H.setRuntimeTypeInfo([], t3);
          _box_0.lineBreaks = H.setRuntimeTypeInfo([], t4);
          for (t8 = newComplexes.length, t9 = J.getInterceptor$ax(resolved), i = 0, _i0 = 0; _i0 < newComplexes.length; newComplexes.length === t8 || (0, H.throwConcurrentModificationError)(newComplexes), ++_i0, i = i0) {
            newComplex = newComplexes[_i0];
            i0 = i + 1;
            lineBreak = previousLineBreaks[i];
            for (t10 = t9.get$iterator(resolved), t11 = !lineBreak; t10.moveNext$0();) {
              t12 = t10.get$current(t10);
              t13 = H.setRuntimeTypeInfo([], t2);
              for (t14 = C.JSArray_methods.get$iterator(newComplex); t14.moveNext$0();)
                t13.push(t14.get$current(t14));
              for (t14 = t12.components, t15 = t14.length, _i1 = 0; _i1 < t15; ++_i1)
                t13.push(t14[_i1]);
              newComplexes0.push(t13);
              t13 = _box_0.lineBreaks;
              t13.push(!t11 || t12.lineBreak);
            }
          }
          newComplexes = newComplexes0;
        } else
          for (t8 = newComplexes.length, _i0 = 0; _i0 < newComplexes.length; newComplexes.length === t8 || (0, H.throwConcurrentModificationError)(newComplexes), ++_i0)
            newComplexes[_i0].push(component);
      }
      _box_0.i = 0;
      return new H.MappedListIterable(newComplexes, new D.SelectorList_resolveParentSelectors__closure0(_box_0), [H.getTypeArgumentByIndex(newComplexes, 0), S.ComplexSelector]);
    }
  };
  D.SelectorList_resolveParentSelectors__closure.prototype = {
    call$1: function(parentComplex) {
      var t2, t3, _i, t4,
        t1 = H.setRuntimeTypeInfo([], [S.ComplexSelectorComponent]);
      for (t2 = parentComplex.components, t3 = t2.length, _i = 0; _i < t3; ++_i)
        t1.push(t2[_i]);
      for (t2 = this.complex, t3 = t2.components, t4 = t3.length, _i = 0; _i < t4; ++_i)
        t1.push(t3[_i]);
      return S.ComplexSelector$(t1, t2.lineBreak || parentComplex.lineBreak);
    }
  };
  D.SelectorList_resolveParentSelectors__closure0.prototype = {
    call$1: function(newComplex) {
      var t1 = this._box_0;
      return S.ComplexSelector$(newComplex, t1.lineBreaks[t1.i++]);
    }
  };
  D.SelectorList__complexContainsParentSelector_closure.prototype = {
    call$1: function(component) {
      return component instanceof X.CompoundSelector && C.JSArray_methods.any$1(component.components, new D.SelectorList__complexContainsParentSelector__closure());
    }
  };
  D.SelectorList__complexContainsParentSelector__closure.prototype = {
    call$1: function(simple) {
      var t1 = J.getInterceptor$(simple);
      if (!t1.$isParentSelector)
        if (!!t1.$isPseudoSelector) {
          t1 = simple.selector;
          t1 = t1 != null && C.JSArray_methods.any$1(t1.components, t1.get$_complexContainsParentSelector());
        } else
          t1 = false;
      else
        t1 = true;
      return t1;
    }
  };
  D.SelectorList__resolveParentSelectorsCompound_closure.prototype = {
    call$1: function(simple) {
      var t1;
      if (simple instanceof D.PseudoSelector) {
        t1 = simple.selector;
        t1 = t1 != null && C.JSArray_methods.any$1(t1.components, t1.get$_complexContainsParentSelector());
      } else
        t1 = false;
      return t1;
    }
  };
  D.SelectorList__resolveParentSelectorsCompound_closure0.prototype = {
    call$1: function(simple) {
      var t1, t2, t3;
      if (simple instanceof D.PseudoSelector) {
        t1 = simple.selector;
        if (t1 == null)
          return simple;
        if (!C.JSArray_methods.any$1(t1.components, t1.get$_complexContainsParentSelector()))
          return simple;
        t1 = t1.resolveParentSelectors$2$implicitParent(this.parent, false);
        t2 = simple.name;
        t3 = simple.isClass;
        return D.PseudoSelector$(t2, simple.argument, !t3, t1);
      } else
        return simple;
    }
  };
  D.SelectorList__resolveParentSelectorsCompound_closure1.prototype = {
    call$1: function(complex) {
      var suffix, t2, t3, t4, last, _i,
        t1 = complex.components,
        lastComponent = C.JSArray_methods.get$last(t1);
      if (!(lastComponent instanceof X.CompoundSelector))
        throw H.wrapException(E.SassScriptException$('Parent "' + H.S(complex) + '" is incompatible with this selector.'));
      suffix = H.interceptedTypeCast(C.JSArray_methods.get$first(this.compound.components), "$isParentSelector").suffix;
      t2 = [M.SimpleSelector];
      if (suffix != null) {
        t2 = H.setRuntimeTypeInfo([], t2);
        for (t3 = lastComponent.components, t4 = H.SubListIterable$(t3, 0, t3.length - 1, H.getTypeArgumentByIndex(t3, 0)), t4 = new H.ListIterator(t4, t4.get$length(t4)); t4.moveNext$0();)
          t2.push(t4.__internal$_current);
        t2.push(C.JSArray_methods.get$last(t3).addSuffix$1(suffix));
        for (t3 = J.skip$1$ax(this.resolvedMembers, 1), t3 = new H.ListIterator(t3, t3.get$length(t3)); t3.moveNext$0();)
          t2.push(t3.__internal$_current);
        last = X.CompoundSelector$(t2);
      } else {
        t2 = H.setRuntimeTypeInfo([], t2);
        for (t3 = lastComponent.components, t4 = t3.length, _i = 0; _i < t4; ++_i)
          t2.push(t3[_i]);
        for (t3 = J.skip$1$ax(this.resolvedMembers, 1), t3 = new H.ListIterator(t3, t3.get$length(t3)); t3.moveNext$0();)
          t2.push(t3.__internal$_current);
        last = X.CompoundSelector$(t2);
      }
      t2 = H.setRuntimeTypeInfo([], [S.ComplexSelectorComponent]);
      for (t1 = H.SubListIterable$(t1, 0, t1.length - 1, H.getTypeArgumentByIndex(t1, 0)), t1 = new H.ListIterator(t1, t1.get$length(t1)); t1.moveNext$0();)
        t2.push(t1.__internal$_current);
      t2.push(last);
      return S.ComplexSelector$(t2, complex.lineBreak);
    }
  };
  M.ParentSelector.prototype = {
    accept$1$1: function(visitor) {
      var t2,
        t1 = visitor._buffer;
      t1.writeCharCode$1(38);
      t2 = this.suffix;
      if (t2 != null)
        t1.write$1(0, t2);
      return;
    },
    accept$1: function(visitor) {
      return this.accept$1$1(visitor, null);
    },
    unify$1: function(compound) {
      return H.throwExpression(P.UnsupportedError$("& doesn't support unification."));
    }
  };
  N.PlaceholderSelector.prototype = {
    get$isInvisible: function() {
      return true;
    },
    accept$1$1: function(visitor) {
      var t1 = visitor._buffer;
      t1.writeCharCode$1(37);
      t1.write$1(0, this.name);
      return;
    },
    accept$1: function(visitor) {
      return this.accept$1$1(visitor, null);
    },
    addSuffix$1: function(suffix) {
      return new N.PlaceholderSelector(this.name + suffix);
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return other instanceof N.PlaceholderSelector && other.name === this.name;
    },
    get$hashCode: function(_) {
      return C.JSString_methods.get$hashCode(this.name);
    }
  };
  D.PseudoSelector.prototype = {
    get$minSpecificity: function() {
      if (this._pseudo$_minSpecificity == null)
        this._pseudo$_computeSpecificity$0();
      return this._pseudo$_minSpecificity;
    },
    get$maxSpecificity: function() {
      if (this._pseudo$_maxSpecificity == null)
        this._pseudo$_computeSpecificity$0();
      return this._pseudo$_maxSpecificity;
    },
    get$isInvisible: function() {
      var t1 = this.selector;
      if (t1 == null)
        return false;
      return this.name !== "not" && t1.get$isInvisible();
    },
    addSuffix$1: function(suffix) {
      var _this = this;
      if (_this.argument != null || _this.selector != null)
        _this.super$SimpleSelector$addSuffix(suffix);
      return D.PseudoSelector$(_this.name + suffix, null, !_this.isClass, null);
    },
    unify$1: function(compound) {
      var result, t1, t2, addedThis, _i, simple, _this = this;
      if (compound.length === 1 && C.JSArray_methods.get$first(compound) instanceof N.UniversalSelector)
        return C.JSArray_methods.get$first(compound).unify$1(H.setRuntimeTypeInfo([_this], [M.SimpleSelector]));
      if (C.JSArray_methods.contains$1(compound, _this))
        return compound;
      result = H.setRuntimeTypeInfo([], [M.SimpleSelector]);
      for (t1 = compound.length, t2 = !_this.isClass, addedThis = false, _i = 0; _i < compound.length; compound.length === t1 || (0, H.throwConcurrentModificationError)(compound), ++_i) {
        simple = compound[_i];
        if (simple instanceof D.PseudoSelector && !simple.isClass) {
          if (t2)
            return;
          result.push(_this);
          addedThis = true;
        }
        result.push(simple);
      }
      if (!addedThis)
        result.push(_this);
      return result;
    },
    _pseudo$_computeSpecificity$0: function() {
      var t1, _i, t2, complex, t3, t4, _this = this;
      if (!_this.isClass) {
        _this._pseudo$_maxSpecificity = _this._pseudo$_minSpecificity = 1;
        return;
      }
      t1 = _this.selector;
      if (t1 == null) {
        _this._pseudo$_minSpecificity = M.SimpleSelector.prototype.get$minSpecificity.call(_this);
        _this._pseudo$_maxSpecificity = M.SimpleSelector.prototype.get$maxSpecificity.call(_this);
        return;
      }
      if (_this.name === "not") {
        _i = _this._pseudo$_maxSpecificity = _this._pseudo$_minSpecificity = 0;
        for (t1 = t1.components, t2 = t1.length; _i < t2; ++_i) {
          complex = t1[_i];
          t3 = _this._pseudo$_minSpecificity;
          if (complex._minSpecificity == null)
            complex._computeSpecificity$0();
          t4 = complex._minSpecificity;
          _this._pseudo$_minSpecificity = Math.max(H.checkNum(t3), H.checkNum(t4));
          t4 = _this._pseudo$_maxSpecificity;
          if (complex._maxSpecificity == null)
            complex._computeSpecificity$0();
          t3 = complex._maxSpecificity;
          _this._pseudo$_maxSpecificity = Math.max(H.checkNum(t4), H.checkNum(t3));
        }
      } else {
        _this._pseudo$_minSpecificity = H.intTypeCast(Math.pow(M.SimpleSelector.prototype.get$minSpecificity.call(_this), 3));
        _i = _this._pseudo$_maxSpecificity = 0;
        for (t1 = t1.components, t2 = t1.length; _i < t2; ++_i) {
          complex = t1[_i];
          t3 = _this._pseudo$_minSpecificity;
          if (complex._minSpecificity == null)
            complex._computeSpecificity$0();
          t4 = complex._minSpecificity;
          _this._pseudo$_minSpecificity = Math.min(H.checkNum(t3), H.checkNum(t4));
          t4 = _this._pseudo$_maxSpecificity;
          if (complex._maxSpecificity == null)
            complex._computeSpecificity$0();
          t3 = complex._maxSpecificity;
          _this._pseudo$_maxSpecificity = Math.max(H.checkNum(t4), H.checkNum(t3));
        }
      }
    },
    accept$1$1: function(visitor) {
      return visitor.visitPseudoSelector$1(this);
    },
    accept$1: function(visitor) {
      return this.accept$1$1(visitor, null);
    },
    $eq: function(_, other) {
      var _this = this;
      if (other == null)
        return false;
      return other instanceof D.PseudoSelector && other.name === _this.name && other.isClass === _this.isClass && other.argument == _this.argument && J.$eq$(other.selector, _this.selector);
    },
    get$hashCode: function(_) {
      var _this = this;
      return (C.JSString_methods.get$hashCode(_this.name) ^ C.JSBool_methods.get$hashCode(!_this.isClass) ^ J.get$hashCode$(_this.argument) ^ J.get$hashCode$(_this.selector)) >>> 0;
    }
  };
  D.QualifiedName.prototype = {
    $eq: function(_, other) {
      if (other == null)
        return false;
      return other instanceof D.QualifiedName && other.name === this.name && other.namespace == this.namespace;
    },
    get$hashCode: function(_) {
      return C.JSString_methods.get$hashCode(this.name) ^ J.get$hashCode$(this.namespace);
    },
    toString$0: function(_) {
      var t1 = this.namespace,
        t2 = this.name;
      return t1 == null ? t2 : t1 + "|" + t2;
    }
  };
  M.SimpleSelector.prototype = {
    get$minSpecificity: function() {
      return 1000;
    },
    get$maxSpecificity: function() {
      return this.get$minSpecificity();
    },
    addSuffix$1: function(suffix) {
      return H.throwExpression(E.SassScriptException$('Invalid parent selector "' + this.toString$0(0) + '"'));
    },
    unify$1: function(compound) {
      var result, t1, addedThis, _i, simple, _this = this;
      if (compound.length === 1 && C.JSArray_methods.get$first(compound) instanceof N.UniversalSelector)
        return C.JSArray_methods.get$first(compound).unify$1(H.setRuntimeTypeInfo([_this], [M.SimpleSelector]));
      if (C.JSArray_methods.contains$1(compound, _this))
        return compound;
      result = H.setRuntimeTypeInfo([], [M.SimpleSelector]);
      for (t1 = compound.length, addedThis = false, _i = 0; _i < compound.length; compound.length === t1 || (0, H.throwConcurrentModificationError)(compound), ++_i) {
        simple = compound[_i];
        if (!addedThis && simple instanceof D.PseudoSelector) {
          result.push(_this);
          addedThis = true;
        }
        result.push(simple);
      }
      if (!addedThis)
        result.push(_this);
      return result;
    }
  };
  F.TypeSelector.prototype = {
    get$minSpecificity: function() {
      return 1;
    },
    accept$1$1: function(visitor) {
      visitor._buffer.write$1(0, this.name);
      return;
    },
    accept$1: function(visitor) {
      return this.accept$1$1(visitor, null);
    },
    addSuffix$1: function(suffix) {
      var t1 = this.name;
      return new F.TypeSelector(new D.QualifiedName(t1.name + suffix, t1.namespace));
    },
    unify$1: function(compound) {
      var unified, t1, t2, _i;
      if (C.JSArray_methods.get$first(compound) instanceof N.UniversalSelector || C.JSArray_methods.get$first(compound) instanceof F.TypeSelector) {
        unified = Y.unifyUniversalAndElement(this, C.JSArray_methods.get$first(compound));
        if (unified == null)
          return;
        t1 = H.setRuntimeTypeInfo([], [M.SimpleSelector]);
        t1.push(unified);
        for (t2 = H.SubListIterable$(compound, 1, null, H.getTypeArgumentByIndex(compound, 0)), t2 = new H.ListIterator(t2, t2.get$length(t2)); t2.moveNext$0();)
          t1.push(t2.__internal$_current);
        return t1;
      } else {
        t1 = H.setRuntimeTypeInfo([], [M.SimpleSelector]);
        t1.push(this);
        for (t2 = compound.length, _i = 0; _i < compound.length; compound.length === t2 || (0, H.throwConcurrentModificationError)(compound), ++_i)
          t1.push(compound[_i]);
        return t1;
      }
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return other instanceof F.TypeSelector && other.name.$eq(0, this.name);
    },
    get$hashCode: function(_) {
      var t1 = this.name;
      return C.JSString_methods.get$hashCode(t1.name) ^ J.get$hashCode$(t1.namespace);
    }
  };
  N.UniversalSelector.prototype = {
    get$minSpecificity: function() {
      return 0;
    },
    accept$1$1: function(visitor) {
      var t2,
        t1 = this.namespace;
      if (t1 != null) {
        t2 = visitor._buffer;
        t2.write$1(0, t1);
        t2.writeCharCode$1(124);
      }
      visitor._buffer.writeCharCode$1(42);
      return;
    },
    accept$1: function(visitor) {
      return this.accept$1$1(visitor, null);
    },
    unify$1: function(compound) {
      var unified, t1, t2, _i, _this = this;
      if (C.JSArray_methods.get$first(compound) instanceof N.UniversalSelector || C.JSArray_methods.get$first(compound) instanceof F.TypeSelector) {
        unified = Y.unifyUniversalAndElement(_this, C.JSArray_methods.get$first(compound));
        if (unified == null)
          return;
        t1 = H.setRuntimeTypeInfo([], [M.SimpleSelector]);
        t1.push(unified);
        for (t2 = H.SubListIterable$(compound, 1, null, H.getTypeArgumentByIndex(compound, 0)), t2 = new H.ListIterator(t2, t2.get$length(t2)); t2.moveNext$0();)
          t1.push(t2.__internal$_current);
        return t1;
      }
      t1 = _this.namespace;
      if (t1 != null && t1 !== "*") {
        t1 = H.setRuntimeTypeInfo([], [M.SimpleSelector]);
        t1.push(_this);
        for (t2 = compound.length, _i = 0; _i < compound.length; compound.length === t2 || (0, H.throwConcurrentModificationError)(compound), ++_i)
          t1.push(compound[_i]);
        return t1;
      }
      if (compound.length !== 0)
        return compound;
      return H.setRuntimeTypeInfo([_this], [M.SimpleSelector]);
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return other instanceof N.UniversalSelector && other.namespace == this.namespace;
    },
    get$hashCode: function(_) {
      return J.get$hashCode$(this.namespace);
    }
  };
  X._compileStylesheet_closure0.prototype = {
    call$1: function(url) {
      var t1, t2, _null = null;
      if (url === "")
        t1 = J.toString$0$(P.Uri_Uri$dataFromString(P.String_String$fromCharCodes(C.NativeUint32List_methods.sublist$2(this.stylesheet.span.file._decodedChars, 0, _null), 0, _null), C.C_Utf8Codec, _null));
      else {
        t1 = P.Uri_parse(url);
        t2 = this.importCache._async_import_cache$_resultsCache.$index(0, t1);
        t2 = t2 == null ? _null : t2.get$sourceMapUrl();
        t1 = J.toString$0$(t2 == null ? t1 : t2);
      }
      return t1;
    }
  };
  X.CompileResult.prototype = {};
  Q.AsyncEnvironment.prototype = {
    closure$0: function() {
      var t4, t5, t6, _this = this,
        t1 = _this._async_environment$_globalModules,
        t2 = _this._async_environment$_forwardedModules,
        t3 = _this._async_environment$_variables;
      t3 = H.setRuntimeTypeInfo(t3.slice(0), [H.getTypeArgumentByIndex(t3, 0)]);
      t4 = _this._async_environment$_variableNodes;
      if (t4 == null)
        t4 = null;
      else
        t4 = H.setRuntimeTypeInfo(t4.slice(0), [H.getTypeArgumentByIndex(t4, 0)]);
      t5 = _this._async_environment$_functions;
      t5 = H.setRuntimeTypeInfo(t5.slice(0), [H.getTypeArgumentByIndex(t5, 0)]);
      t6 = _this._async_environment$_mixins;
      t6 = H.setRuntimeTypeInfo(t6.slice(0), [H.getTypeArgumentByIndex(t6, 0)]);
      return Q.AsyncEnvironment$_(_this._async_environment$_modules, t1, t2, _this._async_environment$_allModules, t3, t4, t5, t6, _this._async_environment$_content);
    },
    global$0: function() {
      var t4, t5, t6, _this = this,
        t1 = [G.Module, B.AsyncCallable],
        t2 = H.setRuntimeTypeInfo([], [t1]),
        t3 = _this._async_environment$_variables;
      t3 = H.setRuntimeTypeInfo(t3.slice(0), [H.getTypeArgumentByIndex(t3, 0)]);
      t4 = _this._async_environment$_variableNodes;
      if (t4 == null)
        t4 = null;
      else
        t4 = H.setRuntimeTypeInfo(t4.slice(0), [H.getTypeArgumentByIndex(t4, 0)]);
      t5 = _this._async_environment$_functions;
      t5 = H.setRuntimeTypeInfo(t5.slice(0), [H.getTypeArgumentByIndex(t5, 0)]);
      t6 = _this._async_environment$_mixins;
      t6 = H.setRuntimeTypeInfo(t6.slice(0), [H.getTypeArgumentByIndex(t6, 0)]);
      return Q.AsyncEnvironment$_(P.LinkedHashMap_LinkedHashMap$_empty(P.String, t1), null, null, t2, t3, t4, t5, t6, _this._async_environment$_content);
    },
    addModule$2$namespace: function(module, namespace) {
      var t1, t2, _this = this;
      if (namespace == null) {
        t1 = _this._async_environment$_globalModules;
        (t1 == null ? _this._async_environment$_globalModules = P.LinkedHashSet_LinkedHashSet([G.Module, B.AsyncCallable]) : t1).add$1(0, module);
        _this._async_environment$_allModules.push(module);
        for (t1 = J.get$iterator$ax(C.JSArray_methods.get$first(_this._async_environment$_variables).get$keys()); t1.moveNext$0();) {
          t2 = t1.get$current(t1);
          if (module.get$variables().containsKey$1(t2))
            throw H.wrapException(E.SassScriptException$('This module and the new module both define a variable named "$' + H.S(t2) + '".'));
        }
      } else {
        t1 = _this._async_environment$_modules;
        if (t1.containsKey$1(namespace))
          throw H.wrapException(E.SassScriptException$("There's already a module with namespace \"" + namespace + '".'));
        t1.$indexSet(0, namespace, module);
        _this._async_environment$_allModules.push(module);
      }
    },
    forwardModule$2: function(module, rule) {
      var view, t1, t2, t3, t4, t5, _i, other, _this = this;
      if (_this._async_environment$_forwardedModules == null)
        _this._async_environment$_forwardedModules = H.setRuntimeTypeInfo([], [[G.Module, B.AsyncCallable]]);
      view = R.ForwardedModuleView$(module, rule, B.AsyncCallable);
      for (t1 = _this._async_environment$_forwardedModules, t2 = t1.length, t3 = view.variables, t4 = view.functions, t5 = view.mixins, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
        other = t1[_i];
        _this._async_environment$_assertNoConflicts$4(t3, other.variables, "variable", other);
        _this._async_environment$_assertNoConflicts$4(t4, other.functions, "function", other);
        _this._async_environment$_assertNoConflicts$4(t5, other.mixins, "mixin", other);
      }
      _this._async_environment$_allModules.push(module);
      _this._async_environment$_forwardedModules.push(view);
    },
    _async_environment$_assertNoConflicts$4: function(newMembers, oldMembers, type, oldModule) {
      var larger, smaller, t1, $name;
      if (newMembers.get$length(newMembers) < oldMembers.get$length(oldMembers)) {
        larger = oldMembers;
        smaller = newMembers;
      } else {
        larger = newMembers;
        smaller = oldMembers;
      }
      for (t1 = J.get$iterator$ax(smaller.get$keys()); t1.moveNext$0();) {
        $name = t1.get$current(t1);
        if (larger.containsKey$1($name)) {
          if (type === "variable")
            $name = "$" + H.S($name);
          throw H.wrapException(E.SassScriptException$("Module " + H.S(D.prettyUri(oldModule.get$url())) + " and the new module both forward a " + type + " named " + H.S($name) + "."));
        }
      }
    },
    importForwards$1: function(module) {
      var t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, _i, forwarded, t12, t13, index, _this = this,
        t1 = module._async_environment$_environment._async_environment$_forwardedModules;
      if (t1 == null)
        t1 = C.List_empty12;
      t2 = t1.length;
      t3 = _this._async_environment$_mixinIndices;
      t4 = _this._async_environment$_mixins;
      t5 = _this._async_environment$_functionIndices;
      t6 = _this._async_environment$_functions;
      t7 = _this._async_environment$_variableIndices;
      t8 = _this._async_environment$_variableNodes;
      t9 = t8 != null;
      t10 = _this._async_environment$_variables;
      t11 = [G.Module, B.AsyncCallable];
      _i = 0;
      for (; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
        forwarded = t1[_i];
        t12 = _this._async_environment$_globalModules;
        (t12 == null ? _this._async_environment$_globalModules = P.LinkedHashSet_LinkedHashSet$_empty(t11) : t12).add$1(0, forwarded);
        for (t12 = J.get$iterator$ax(forwarded.variables.get$keys()); t12.moveNext$0();) {
          t13 = t12.get$current(t12);
          index = t7.remove$1(0, t13);
          if (index == null)
            index = _this._async_environment$_variableIndex$1(t13);
          if (index != null) {
            J.remove$1$ax(t10[index], t13);
            if (t9)
              J.remove$1$ax(t8[index], t13);
          }
        }
        for (t12 = J.get$iterator$ax(forwarded.functions.get$keys()); t12.moveNext$0();) {
          t13 = t12.get$current(t12);
          index = t5.remove$1(0, t13);
          if (index == null)
            index = _this._async_environment$_functionIndex$1(t13);
          if (index != null)
            J.remove$1$ax(t6[index], t13);
        }
        for (t12 = J.get$iterator$ax(forwarded.mixins.get$keys()); t12.moveNext$0();) {
          t13 = t12.get$current(t12);
          index = t3.remove$1(0, t13);
          if (index == null)
            index = _this._async_environment$_mixinIndex$1(t13);
          if (index != null)
            J.remove$1$ax(t4[index], t13);
        }
      }
    },
    getVariable$2$namespace: function($name, namespace) {
      var t1, index, _this = this;
      if (namespace != null)
        return _this._async_environment$_getModule$1(namespace).get$variables().$index(0, $name);
      if (_this._async_environment$_lastVariableName === $name) {
        t1 = J.$index$asx(_this._async_environment$_variables[_this._async_environment$_lastVariableIndex], $name);
        return t1 == null ? _this._async_environment$_getVariableFromGlobalModule$1($name) : t1;
      }
      t1 = _this._async_environment$_variableIndices;
      index = t1.$index(0, $name);
      if (index != null) {
        _this._async_environment$_lastVariableName = $name;
        _this._async_environment$_lastVariableIndex = index;
        t1 = J.$index$asx(_this._async_environment$_variables[index], $name);
        return t1 == null ? _this._async_environment$_getVariableFromGlobalModule$1($name) : t1;
      }
      index = _this._async_environment$_variableIndex$1($name);
      if (index == null)
        return _this._async_environment$_getVariableFromGlobalModule$1($name);
      _this._async_environment$_lastVariableName = $name;
      _this._async_environment$_lastVariableIndex = index;
      t1.$indexSet(0, $name, index);
      t1 = J.$index$asx(_this._async_environment$_variables[index], $name);
      return t1 == null ? _this._async_environment$_getVariableFromGlobalModule$1($name) : t1;
    },
    getVariable$1: function($name) {
      return this.getVariable$2$namespace($name, null);
    },
    _async_environment$_getVariableFromGlobalModule$1: function($name) {
      return this._async_environment$_fromOneModule$2("variable", new Q.AsyncEnvironment__getVariableFromGlobalModule_closure($name));
    },
    getVariableNode$2$namespace: function($name, namespace) {
      var t1, index, _this = this;
      if (namespace != null)
        return _this._async_environment$_getModule$1(namespace).get$variableNodes().$index(0, $name);
      if (_this._async_environment$_lastVariableName === $name) {
        t1 = J.$index$asx(_this._async_environment$_variableNodes[_this._async_environment$_lastVariableIndex], $name);
        return t1 == null ? _this._async_environment$_getVariableNodeFromGlobalModule$1($name) : t1;
      }
      t1 = _this._async_environment$_variableIndices;
      index = t1.$index(0, $name);
      if (index != null) {
        _this._async_environment$_lastVariableName = $name;
        _this._async_environment$_lastVariableIndex = index;
        t1 = J.$index$asx(_this._async_environment$_variableNodes[index], $name);
        return t1 == null ? _this._async_environment$_getVariableNodeFromGlobalModule$1($name) : t1;
      }
      index = _this._async_environment$_variableIndex$1($name);
      if (index == null)
        return _this._async_environment$_getVariableNodeFromGlobalModule$1($name);
      _this._async_environment$_lastVariableName = $name;
      _this._async_environment$_lastVariableIndex = index;
      t1.$indexSet(0, $name, index);
      t1 = J.$index$asx(_this._async_environment$_variableNodes[index], $name);
      return t1 == null ? _this._async_environment$_getVariableNodeFromGlobalModule$1($name) : t1;
    },
    _async_environment$_getVariableNodeFromGlobalModule$1: function($name) {
      var t1, value;
      this._async_environment$_lastVariableName = $name;
      this._async_environment$_lastVariableIndex = 0;
      t1 = this._async_environment$_globalModules;
      if (t1 == null)
        return;
      for (t1 = P._LinkedHashSetIterator$(t1, t1._collection$_modifications); t1.moveNext$0();) {
        value = t1._collection$_current.get$variableNodes().$index(0, $name);
        if (value != null)
          return value;
      }
      return;
    },
    globalVariableExists$2$namespace: function($name, namespace) {
      if (namespace != null)
        return this._async_environment$_getModule$1(namespace).get$variables().containsKey$1($name);
      if (C.JSArray_methods.get$first(this._async_environment$_variables).containsKey$1($name))
        return true;
      return this._async_environment$_getVariableFromGlobalModule$1($name) != null;
    },
    globalVariableExists$1: function($name) {
      return this.globalVariableExists$2$namespace($name, null);
    },
    _async_environment$_variableIndex$1: function($name) {
      var t1, i;
      for (t1 = this._async_environment$_variables, i = t1.length - 1; i >= 0; --i)
        if (t1[i].containsKey$1($name))
          return i;
      return;
    },
    setVariable$5$global$namespace: function($name, value, nodeWithSpan, global, namespace) {
      var t1, moduleWithName, index, _this = this;
      if (namespace != null) {
        _this._async_environment$_getModule$1(namespace).setVariable$3($name, value, nodeWithSpan);
        return;
      }
      if (global || _this._async_environment$_variables.length === 1) {
        _this._async_environment$_variableIndices.putIfAbsent$2($name, new Q.AsyncEnvironment_setVariable_closure(_this, $name));
        t1 = _this._async_environment$_variables;
        if (!C.JSArray_methods.get$first(t1).containsKey$1($name) && _this._async_environment$_globalModules != null) {
          moduleWithName = _this._async_environment$_fromOneModule$2("variable", new Q.AsyncEnvironment_setVariable_closure0($name));
          if (moduleWithName != null) {
            moduleWithName.setVariable$3($name, value, nodeWithSpan);
            return;
          }
        }
        J.$indexSet$ax(C.JSArray_methods.get$first(t1), $name, value);
        t1 = _this._async_environment$_variableNodes;
        if (t1 != null)
          J.$indexSet$ax(C.JSArray_methods.get$first(t1), $name, nodeWithSpan);
        return;
      }
      index = _this._async_environment$_lastVariableName === $name ? _this._async_environment$_lastVariableIndex : _this._async_environment$_variableIndices.putIfAbsent$2($name, new Q.AsyncEnvironment_setVariable_closure1(_this, $name));
      if (!_this._async_environment$_inSemiGlobalScope && index === 0) {
        index = _this._async_environment$_variables.length - 1;
        _this._async_environment$_variableIndices.$indexSet(0, $name, index);
      }
      _this._async_environment$_lastVariableName = $name;
      _this._async_environment$_lastVariableIndex = index;
      J.$indexSet$ax(_this._async_environment$_variables[index], $name, value);
      t1 = _this._async_environment$_variableNodes;
      if (t1 != null)
        J.$indexSet$ax(t1[index], $name, nodeWithSpan);
    },
    setLocalVariable$3: function($name, value, nodeWithSpan) {
      var index, _this = this,
        t1 = _this._async_environment$_variables,
        t2 = t1.length;
      _this._async_environment$_lastVariableName = $name;
      index = _this._async_environment$_lastVariableIndex = t2 - 1;
      _this._async_environment$_variableIndices.$indexSet(0, $name, index);
      J.$indexSet$ax(t1[index], $name, value);
      t1 = _this._async_environment$_variableNodes;
      if (t1 != null)
        J.$indexSet$ax(t1[index], $name, nodeWithSpan);
    },
    getFunction$2$namespace: function($name, namespace) {
      var t1, index, _this = this;
      if (namespace != null) {
        t1 = _this._async_environment$_getModule$1(namespace);
        return t1.get$functions(t1).$index(0, $name);
      }
      t1 = _this._async_environment$_functionIndices;
      index = t1.$index(0, $name);
      if (index != null) {
        t1 = J.$index$asx(_this._async_environment$_functions[index], $name);
        return t1 == null ? _this._async_environment$_getFunctionFromGlobalModule$1($name) : t1;
      }
      index = _this._async_environment$_functionIndex$1($name);
      if (index == null)
        return _this._async_environment$_getFunctionFromGlobalModule$1($name);
      t1.$indexSet(0, $name, index);
      t1 = J.$index$asx(_this._async_environment$_functions[index], $name);
      return t1 == null ? _this._async_environment$_getFunctionFromGlobalModule$1($name) : t1;
    },
    _async_environment$_getFunctionFromGlobalModule$1: function($name) {
      return this._async_environment$_fromOneModule$2("function", new Q.AsyncEnvironment__getFunctionFromGlobalModule_closure($name));
    },
    _async_environment$_functionIndex$1: function($name) {
      var t1, i;
      for (t1 = this._async_environment$_functions, i = t1.length - 1; i >= 0; --i)
        if (t1[i].containsKey$1($name))
          return i;
      return;
    },
    getMixin$2$namespace: function($name, namespace) {
      var t1, index, _this = this;
      if (namespace != null)
        return _this._async_environment$_getModule$1(namespace).get$mixins().$index(0, $name);
      t1 = _this._async_environment$_mixinIndices;
      index = t1.$index(0, $name);
      if (index != null) {
        t1 = J.$index$asx(_this._async_environment$_mixins[index], $name);
        return t1 == null ? _this._async_environment$_getMixinFromGlobalModule$1($name) : t1;
      }
      index = _this._async_environment$_mixinIndex$1($name);
      if (index == null)
        return _this._async_environment$_getMixinFromGlobalModule$1($name);
      t1.$indexSet(0, $name, index);
      t1 = J.$index$asx(_this._async_environment$_mixins[index], $name);
      return t1 == null ? _this._async_environment$_getMixinFromGlobalModule$1($name) : t1;
    },
    _async_environment$_getMixinFromGlobalModule$1: function($name) {
      return this._async_environment$_fromOneModule$2("mixin", new Q.AsyncEnvironment__getMixinFromGlobalModule_closure($name));
    },
    _async_environment$_mixinIndex$1: function($name) {
      var t1, i;
      for (t1 = this._async_environment$_mixins, i = t1.length - 1; i >= 0; --i)
        if (t1[i].containsKey$1($name))
          return i;
      return;
    },
    withContent$2: function($content, callback) {
      return this.withContent$body$AsyncEnvironment($content, callback);
    },
    withContent$body$AsyncEnvironment: function($content, callback) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$self = this, oldContent;
      var $async$withContent$2 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              oldContent = $async$self._async_environment$_content;
              $async$self._async_environment$_content = $content;
              $async$goto = 2;
              return P._asyncAwait(callback.call$0(), $async$withContent$2);
            case 2:
              // returning from await.
              $async$self._async_environment$_content = oldContent;
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$withContent$2, $async$completer);
    },
    asMixin$1: function(callback) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$self = this, oldInMixin;
      var $async$asMixin$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              oldInMixin = $async$self._async_environment$_inMixin;
              $async$self._async_environment$_inMixin = true;
              $async$goto = 2;
              return P._asyncAwait(callback.call$0(), $async$asMixin$1);
            case 2:
              // returning from await.
              $async$self._async_environment$_inMixin = oldInMixin;
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$asMixin$1, $async$completer);
    },
    scope$1$3$semiGlobal$when: function(callback, semiGlobal, when, $T) {
      return this.scope$body$AsyncEnvironment(callback, semiGlobal, when, $T, $T);
    },
    scope$1$2$when: function(callback, when, $T) {
      return this.scope$1$3$semiGlobal$when(callback, false, when, $T);
    },
    scope$1$1: function(callback, $T) {
      return this.scope$1$3$semiGlobal$when(callback, false, true, $T);
    },
    scope$1$2$semiGlobal: function(callback, semiGlobal, $T) {
      return this.scope$1$3$semiGlobal$when(callback, semiGlobal, true, $T);
    },
    scope$body$AsyncEnvironment: function(callback, semiGlobal, when, $T, $async$type) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter($async$type),
        $async$returnValue, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, wasInSemiGlobalScope, wasInSemiGlobalScope0, $name, name0, name1, t1, t2, t3, t4, t5;
      var $async$scope$1$3$semiGlobal$when = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$currentError = $async$result;
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = !when ? 3 : 4;
              break;
            case 3:
              // then
              wasInSemiGlobalScope = $async$self._async_environment$_inSemiGlobalScope;
              $async$self._async_environment$_inSemiGlobalScope = semiGlobal;
              $async$handler = 5;
              $async$goto = 8;
              return P._asyncAwait(callback.call$0(), $async$scope$1$3$semiGlobal$when);
            case 8:
              // returning from await.
              t1 = $async$result;
              $async$returnValue = t1;
              $async$next = [1];
              // goto finally
              $async$goto = 6;
              break;
              $async$next.push(7);
              // goto finally
              $async$goto = 6;
              break;
            case 5:
              // uncaught
              $async$next = [2];
            case 6:
              // finally
              $async$handler = 2;
              $async$self._async_environment$_inSemiGlobalScope = wasInSemiGlobalScope;
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 7:
              // after finally
            case 4:
              // join
              semiGlobal = semiGlobal && $async$self._async_environment$_inSemiGlobalScope;
              wasInSemiGlobalScope0 = $async$self._async_environment$_inSemiGlobalScope;
              $async$self._async_environment$_inSemiGlobalScope = semiGlobal;
              t1 = $async$self._async_environment$_variables;
              t2 = P.String;
              C.JSArray_methods.add$1(t1, P.LinkedHashMap_LinkedHashMap$_empty(t2, F.Value));
              t3 = $async$self._async_environment$_variableNodes;
              if (t3 != null)
                C.JSArray_methods.add$1(t3, P.LinkedHashMap_LinkedHashMap$_empty(t2, B.AstNode));
              t3 = $async$self._async_environment$_functions;
              t4 = B.AsyncCallable;
              C.JSArray_methods.add$1(t3, P.LinkedHashMap_LinkedHashMap$_empty(t2, t4));
              t5 = $async$self._async_environment$_mixins;
              C.JSArray_methods.add$1(t5, P.LinkedHashMap_LinkedHashMap$_empty(t2, t4));
              $async$handler = 9;
              $async$goto = 12;
              return P._asyncAwait(callback.call$0(), $async$scope$1$3$semiGlobal$when);
            case 12:
              // returning from await.
              t2 = $async$result;
              $async$returnValue = t2;
              $async$next = [1];
              // goto finally
              $async$goto = 10;
              break;
              $async$next.push(11);
              // goto finally
              $async$goto = 10;
              break;
            case 9:
              // uncaught
              $async$next = [2];
            case 10:
              // finally
              $async$handler = 2;
              $async$self._async_environment$_inSemiGlobalScope = wasInSemiGlobalScope0;
              $async$self._async_environment$_lastVariableIndex = $async$self._async_environment$_lastVariableName = null;
              for (t1 = J.get$iterator$ax(C.JSArray_methods.removeLast$0(t1).get$keys()), t2 = $async$self._async_environment$_variableIndices; t1.moveNext$0();) {
                $name = t1.get$current(t1);
                t2.remove$1(0, $name);
              }
              for (t1 = J.get$iterator$ax(C.JSArray_methods.removeLast$0(t3).get$keys()), t2 = $async$self._async_environment$_functionIndices; t1.moveNext$0();) {
                name0 = t1.get$current(t1);
                t2.remove$1(0, name0);
              }
              for (t1 = J.get$iterator$ax(C.JSArray_methods.removeLast$0(t5).get$keys()), t2 = $async$self._async_environment$_mixinIndices; t1.moveNext$0();) {
                name1 = t1.get$current(t1);
                t2.remove$1(0, name1);
              }
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 11:
              // after finally
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return P._asyncRethrow($async$currentError, $async$completer);
          }
      });
      return P._asyncStartSync($async$scope$1$3$semiGlobal$when, $async$completer);
    },
    _async_environment$_getModule$1: function(namespace) {
      var module = this._async_environment$_modules.$index(0, namespace);
      if (module != null)
        return module;
      throw H.wrapException(E.SassScriptException$('There is no module with the namespace "' + namespace + '".'));
    },
    _async_environment$_fromOneModule$1$2: function(type, callback) {
      var value, valueInModule,
        t1 = this._async_environment$_globalModules;
      if (t1 == null)
        return;
      for (t1 = P._LinkedHashSetIterator$(t1, t1._collection$_modifications), value = null; t1.moveNext$0(); value = valueInModule) {
        valueInModule = callback.call$1(t1._collection$_current);
        if (valueInModule != null && value != null)
          throw H.wrapException(E.SassScriptException$("This " + type + " is available from multiple global modules."));
      }
      return value;
    },
    _async_environment$_fromOneModule$2: function(type, callback) {
      return this._async_environment$_fromOneModule$1$2(type, callback, null);
    }
  };
  Q.AsyncEnvironment__getVariableFromGlobalModule_closure.prototype = {
    call$1: function(module) {
      return module.get$variables().$index(0, this.name);
    }
  };
  Q.AsyncEnvironment_setVariable_closure.prototype = {
    call$0: function() {
      var t1 = this.$this;
      t1._async_environment$_lastVariableName = this.name;
      return t1._async_environment$_lastVariableIndex = 0;
    }
  };
  Q.AsyncEnvironment_setVariable_closure0.prototype = {
    call$1: function(module) {
      return module.get$variables().containsKey$1(this.name) ? module : null;
    }
  };
  Q.AsyncEnvironment_setVariable_closure1.prototype = {
    call$0: function() {
      var t1 = this.$this,
        t2 = t1._async_environment$_variableIndex$1(this.name);
      return t2 == null ? t1._async_environment$_variables.length - 1 : t2;
    }
  };
  Q.AsyncEnvironment__getFunctionFromGlobalModule_closure.prototype = {
    call$1: function(module) {
      return module.get$functions(module).$index(0, this.name);
    }
  };
  Q.AsyncEnvironment__getMixinFromGlobalModule_closure.prototype = {
    call$1: function(module) {
      return module.get$mixins().$index(0, this.name);
    }
  };
  Q._EnvironmentModule0.prototype = {
    get$url: function() {
      return this.css.get$span().file.url;
    },
    setVariable$3: function($name, value, nodeWithSpan) {
      var t1, t2,
        module = this._async_environment$_modulesByVariable.$index(0, $name);
      if (module != null) {
        module.setVariable$3($name, value, nodeWithSpan);
        return;
      }
      t1 = this._async_environment$_environment;
      t2 = t1._async_environment$_variables;
      if (!C.JSArray_methods.get$first(t2).containsKey$1($name))
        throw H.wrapException(E.SassScriptException$("Undefined variable."));
      J.$indexSet$ax(C.JSArray_methods.get$first(t2), $name, value);
      t1 = t1._async_environment$_variableNodes;
      if (t1 != null)
        J.$indexSet$ax(C.JSArray_methods.get$first(t1), $name, nodeWithSpan);
      return;
    },
    cloneCss$0: function() {
      var newCssAndExtender, _this = this,
        t1 = _this.css;
      if (J.get$isEmpty$asx(t1.get$children()))
        return _this;
      newCssAndExtender = V.cloneCssStylesheet(t1, _this.extender);
      return Q._EnvironmentModule$_0(_this._async_environment$_environment, newCssAndExtender.item1, newCssAndExtender.item2, _this._async_environment$_modulesByVariable, _this.variables, _this.variableNodes, _this.functions, _this.mixins, _this.transitivelyContainsCss, _this.transitivelyContainsExtensions);
    },
    toString$0: function(_) {
      var t1 = this.css.get$span();
      return $.$get$context().prettyUri$1(t1.file.url);
    },
    $isModule: 1,
    $asModule: function() {
      return [B.AsyncCallable];
    },
    get$upstream: function() {
      return this.upstream;
    },
    get$variables: function() {
      return this.variables;
    },
    get$variableNodes: function() {
      return this.variableNodes;
    },
    get$functions: function(receiver) {
      return this.functions;
    },
    get$mixins: function() {
      return this.mixins;
    },
    get$extender: function() {
      return this.extender;
    },
    get$css: function(receiver) {
      return this.css;
    },
    get$transitivelyContainsCss: function() {
      return this.transitivelyContainsCss;
    },
    get$transitivelyContainsExtensions: function() {
      return this.transitivelyContainsExtensions;
    }
  };
  Q._EnvironmentModule__EnvironmentModule_closure5.prototype = {
    call$1: function(module) {
      return module.get$variables();
    }
  };
  Q._EnvironmentModule__EnvironmentModule_closure6.prototype = {
    call$1: function(module) {
      return module.get$variableNodes();
    }
  };
  Q._EnvironmentModule__EnvironmentModule_closure7.prototype = {
    call$1: function(module) {
      return module.get$functions(module);
    }
  };
  Q._EnvironmentModule__EnvironmentModule_closure8.prototype = {
    call$1: function(module) {
      return module.get$mixins();
    }
  };
  Q._EnvironmentModule__EnvironmentModule_closure9.prototype = {
    call$1: function(module) {
      return module.get$transitivelyContainsCss();
    }
  };
  Q._EnvironmentModule__EnvironmentModule_closure10.prototype = {
    call$1: function(module) {
      return module.get$transitivelyContainsExtensions();
    }
  };
  O.AsyncImportCache.prototype = {
    canonicalize$3: function(url, baseImporter, baseUrl) {
      return this.canonicalize$body$AsyncImportCache(url, baseImporter, baseUrl);
    },
    canonicalize$body$AsyncImportCache: function(url, baseImporter, baseUrl) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter([S.Tuple3, B.AsyncImporter, P.Uri, P.Uri]),
        $async$returnValue, $async$self = this, resolvedUrl, canonicalUrl, t1;
      var $async$canonicalize$3 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = baseImporter != null ? 3 : 4;
              break;
            case 3:
              // then
              resolvedUrl = baseUrl != null ? baseUrl.resolveUri$1(url) : url;
              $async$goto = 5;
              return P._asyncAwait($async$self._async_import_cache$_canonicalize$2(baseImporter, resolvedUrl), $async$canonicalize$3);
            case 5:
              // returning from await.
              canonicalUrl = $async$result;
              if (canonicalUrl != null) {
                t1 = P.Uri;
                $async$returnValue = new S.Tuple3(baseImporter, canonicalUrl, resolvedUrl, [B.AsyncImporter, t1, t1]);
                // goto return
                $async$goto = 1;
                break;
              }
            case 4:
              // join
              $async$goto = 6;
              return P._asyncAwait(B.putIfAbsentAsync($async$self._async_import_cache$_canonicalizeCache, url, new O.AsyncImportCache_canonicalize_closure($async$self, url), P.Uri, [S.Tuple3, B.AsyncImporter, P.Uri, P.Uri]), $async$canonicalize$3);
            case 6:
              // returning from await.
              $async$returnValue = $async$result;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$canonicalize$3, $async$completer);
    },
    _async_import_cache$_canonicalize$2: function(importer, url) {
      return this._canonicalize$body$AsyncImportCache(importer, url);
    },
    _canonicalize$body$AsyncImportCache: function(importer, url) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Uri),
        $async$returnValue, $async$self = this, result;
      var $async$_async_import_cache$_canonicalize$2 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              return P._asyncAwait(importer.canonicalize$1(url), $async$_async_import_cache$_canonicalize$2);
            case 3:
              // returning from await.
              result = $async$result;
              if ((result == null ? null : result.get$scheme()) === "")
                $async$self._async_import_cache$_logger.warn$2$deprecation("Importer " + importer.toString$0(0) + " canonicalized " + H.S(url) + " to " + H.S(result) + ".\nRelative canonical URLs are deprecated and will eventually be disallowed.\n", true);
              $async$returnValue = result;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$_async_import_cache$_canonicalize$2, $async$completer);
    },
    import$3: function(url, baseImporter, baseUrl) {
      return this.import$body$AsyncImportCache(url, baseImporter, baseUrl);
    },
    import$body$AsyncImportCache: function(url, baseImporter, baseUrl) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter([S.Tuple2, B.AsyncImporter, V.Stylesheet]),
        $async$returnValue, $async$self = this, t1, tuple, $async$temp1, $async$temp2;
      var $async$import$3 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              return P._asyncAwait($async$self.canonicalize$3(url, baseImporter, baseUrl), $async$import$3);
            case 3:
              // returning from await.
              tuple = $async$result;
              if (tuple == null) {
                // goto return
                $async$goto = 1;
                break;
              }
              t1 = tuple.item1;
              $async$temp1 = S;
              $async$temp2 = t1;
              $async$goto = 4;
              return P._asyncAwait($async$self.importCanonical$3(t1, tuple.item2, tuple.item3), $async$import$3);
            case 4:
              // returning from await.
              $async$returnValue = new $async$temp1.Tuple2($async$temp2, $async$result, [B.AsyncImporter, V.Stylesheet]);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$import$3, $async$completer);
    },
    importCanonical$3: function(importer, canonicalUrl, originalUrl) {
      return this.importCanonical$body$AsyncImportCache(importer, canonicalUrl, originalUrl);
    },
    importCanonical$body$AsyncImportCache: function(importer, canonicalUrl, originalUrl) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(V.Stylesheet),
        $async$returnValue, $async$self = this;
      var $async$importCanonical$3 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              return P._asyncAwait(B.putIfAbsentAsync($async$self._async_import_cache$_importCache, canonicalUrl, new O.AsyncImportCache_importCanonical_closure($async$self, importer, canonicalUrl, originalUrl), P.Uri, V.Stylesheet), $async$importCanonical$3);
            case 3:
              // returning from await.
              $async$returnValue = $async$result;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$importCanonical$3, $async$completer);
    },
    humanize$1: function(canonicalUrl) {
      var t1 = this._async_import_cache$_canonicalizeCache.get$values(),
        t2 = H.getRuntimeTypeArgument(t1, "Iterable", 0),
        t3 = P.Uri,
        url = Y.minBy(new H.MappedIterable(new H.WhereIterable(t1, new O.AsyncImportCache_humanize_closure(canonicalUrl), [t2]), new O.AsyncImportCache_humanize_closure0(), [t2, t3]), new O.AsyncImportCache_humanize_closure1(), t3, null);
      if (url == null)
        return canonicalUrl;
      t1 = $.$get$url();
      return url.resolve$1(X.ParsedPath_ParsedPath$parse(canonicalUrl.get$path(canonicalUrl), t1.style).get$basename());
    }
  };
  O.AsyncImportCache_canonicalize_closure.prototype = {
    call$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter([S.Tuple3, B.AsyncImporter, P.Uri, P.Uri]),
        $async$returnValue, $async$self = this, t1, t2, t3, t4, _i, importer, canonicalUrl;
      var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.$this, t2 = t1._async_import_cache$_importers, t3 = t2.length, t4 = $async$self.url, _i = 0;
            case 3:
              // for condition
              if (!(_i < t2.length)) {
                // goto after for
                $async$goto = 5;
                break;
              }
              importer = t2[_i];
              $async$goto = 6;
              return P._asyncAwait(t1._async_import_cache$_canonicalize$2(importer, t4), $async$call$0);
            case 6:
              // returning from await.
              canonicalUrl = $async$result;
              if (canonicalUrl != null) {
                t1 = P.Uri;
                $async$returnValue = new S.Tuple3(importer, canonicalUrl, t4, [B.AsyncImporter, t1, t1]);
                // goto return
                $async$goto = 1;
                break;
              }
            case 4:
              // for update
              t2.length === t3 || (0, H.throwConcurrentModificationError)(t2), ++_i;
              // goto for condition
              $async$goto = 3;
              break;
            case 5:
              // after for
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$0, $async$completer);
    }
  };
  O.AsyncImportCache_importCanonical_closure.prototype = {
    call$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(V.Stylesheet),
        $async$returnValue, $async$self = this, t2, t3, t4, t5, t1, result;
      var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.canonicalUrl;
              $async$goto = 3;
              return P._asyncAwait($async$self.importer.load$1(t1), $async$call$0);
            case 3:
              // returning from await.
              result = $async$result;
              if (result == null) {
                // goto return
                $async$goto = 1;
                break;
              }
              t2 = $async$self.$this;
              t2._async_import_cache$_resultsCache.$indexSet(0, t1, result);
              t3 = result.contents;
              t4 = result.syntax;
              t5 = $async$self.originalUrl;
              t1 = t5 == null ? t1 : t5.resolveUri$1(t1);
              $async$returnValue = V.Stylesheet_Stylesheet$parse(t3, t4, t2._async_import_cache$_logger, t1);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$0, $async$completer);
    }
  };
  O.AsyncImportCache_humanize_closure.prototype = {
    call$1: function(tuple) {
      var t1 = tuple == null ? null : tuple.item2;
      return J.$eq$(t1, this.canonicalUrl);
    }
  };
  O.AsyncImportCache_humanize_closure0.prototype = {
    call$1: function(tuple) {
      return tuple.item3;
    }
  };
  O.AsyncImportCache_humanize_closure1.prototype = {
    call$1: function(url) {
      return J.get$length$asx(J.get$path$x(url));
    },
    $signature: 10
  };
  D.Callable.prototype = {};
  B.AsyncCallable.prototype = {};
  S.AsyncBuiltInCallable.prototype = {
    callbackFor$2: function(positional, names) {
      var t1 = this._async_built_in$_overloads;
      return H.SubListIterable$(t1, 0, t1.length - 1, H.getTypeArgumentByIndex(t1, 0)).firstWhere$2$orElse(0, new S.AsyncBuiltInCallable_callbackFor_closure(positional, names), new S.AsyncBuiltInCallable_callbackFor_closure0(this));
    },
    $isAsyncCallable: 1,
    get$name: function() {
      return this.name;
    }
  };
  S.AsyncBuiltInCallable_callbackFor_closure.prototype = {
    call$1: function(overload) {
      return overload.item1.matches$2(this.positional, this.names);
    }
  };
  S.AsyncBuiltInCallable_callbackFor_closure0.prototype = {
    call$0: function() {
      return C.JSArray_methods.get$last(this.$this._async_built_in$_overloads);
    }
  };
  Q.BuiltInCallable.prototype = {
    callbackFor$2: function(positional, names) {
      var t1 = this._overloads;
      return H.SubListIterable$(t1, 0, t1.length - 1, H.getTypeArgumentByIndex(t1, 0)).firstWhere$2$orElse(0, new Q.BuiltInCallable_callbackFor_closure(positional, names), new Q.BuiltInCallable_callbackFor_closure0(this));
    },
    withName$1: function($name) {
      return new Q.BuiltInCallable($name, this._overloads);
    },
    $isCallable: 1,
    $isAsyncCallable: 1,
    $isAsyncBuiltInCallable: 1,
    get$name: function() {
      return this.name;
    }
  };
  Q.BuiltInCallable_callbackFor_closure.prototype = {
    call$1: function(overload) {
      return overload.item1.matches$2(this.positional, this.names);
    }
  };
  Q.BuiltInCallable_callbackFor_closure0.prototype = {
    call$0: function() {
      return C.JSArray_methods.get$last(this.$this._overloads);
    }
  };
  L.PlainCssCallable.prototype = {
    $eq: function(_, other) {
      if (other == null)
        return false;
      return other instanceof L.PlainCssCallable && this.name == other.name;
    },
    get$hashCode: function(_) {
      return J.get$hashCode$(this.name);
    },
    $isCallable: 1,
    $isAsyncCallable: 1,
    get$name: function() {
      return this.name;
    }
  };
  E.UserDefinedCallable.prototype = {
    get$name: function() {
      return this.declaration.name;
    },
    $isCallable: 1,
    $isAsyncCallable: 1
  };
  X.closure34.prototype = {
    call$2: function(_, color) {
      return color;
    }
  };
  X.closure35.prototype = {
    call$2: function($name, _) {
      return $name;
    }
  };
  U._compileStylesheet_closure.prototype = {
    call$1: function(url) {
      var t1, t2, _null = null;
      if (url === "")
        t1 = J.toString$0$(P.Uri_Uri$dataFromString(P.String_String$fromCharCodes(C.NativeUint32List_methods.sublist$2(this.stylesheet.span.file._decodedChars, 0, _null), 0, _null), C.C_Utf8Codec, _null));
      else {
        t1 = P.Uri_parse(url);
        t2 = this.importCache._resultsCache.$index(0, t1);
        t2 = t2 == null ? _null : t2.get$sourceMapUrl();
        t1 = J.toString$0$(t2 == null ? t1 : t2);
      }
      return t1;
    }
  };
  O.Environment.prototype = {
    closure$0: function() {
      var t4, t5, t6, _this = this,
        t1 = _this._globalModules,
        t2 = _this._forwardedModules,
        t3 = _this._variables;
      t3 = H.setRuntimeTypeInfo(t3.slice(0), [H.getTypeArgumentByIndex(t3, 0)]);
      t4 = _this._variableNodes;
      if (t4 == null)
        t4 = null;
      else
        t4 = H.setRuntimeTypeInfo(t4.slice(0), [H.getTypeArgumentByIndex(t4, 0)]);
      t5 = _this._functions;
      t5 = H.setRuntimeTypeInfo(t5.slice(0), [H.getTypeArgumentByIndex(t5, 0)]);
      t6 = _this._mixins;
      t6 = H.setRuntimeTypeInfo(t6.slice(0), [H.getTypeArgumentByIndex(t6, 0)]);
      return O.Environment$_(_this._environment$_modules, t1, t2, _this._allModules, t3, t4, t5, t6, _this._content);
    },
    global$0: function() {
      var t4, t5, t6, _this = this,
        t1 = [G.Module, D.Callable],
        t2 = H.setRuntimeTypeInfo([], [t1]),
        t3 = _this._variables;
      t3 = H.setRuntimeTypeInfo(t3.slice(0), [H.getTypeArgumentByIndex(t3, 0)]);
      t4 = _this._variableNodes;
      if (t4 == null)
        t4 = null;
      else
        t4 = H.setRuntimeTypeInfo(t4.slice(0), [H.getTypeArgumentByIndex(t4, 0)]);
      t5 = _this._functions;
      t5 = H.setRuntimeTypeInfo(t5.slice(0), [H.getTypeArgumentByIndex(t5, 0)]);
      t6 = _this._mixins;
      t6 = H.setRuntimeTypeInfo(t6.slice(0), [H.getTypeArgumentByIndex(t6, 0)]);
      return O.Environment$_(P.LinkedHashMap_LinkedHashMap$_empty(P.String, t1), null, null, t2, t3, t4, t5, t6, _this._content);
    },
    addModule$2$namespace: function(module, namespace) {
      var t1, t2, _this = this;
      if (namespace == null) {
        t1 = _this._globalModules;
        (t1 == null ? _this._globalModules = P.LinkedHashSet_LinkedHashSet([G.Module, D.Callable]) : t1).add$1(0, module);
        _this._allModules.push(module);
        for (t1 = J.get$iterator$ax(C.JSArray_methods.get$first(_this._variables).get$keys()); t1.moveNext$0();) {
          t2 = t1.get$current(t1);
          if (module.get$variables().containsKey$1(t2))
            throw H.wrapException(E.SassScriptException$('This module and the new module both define a variable named "$' + H.S(t2) + '".'));
        }
      } else {
        t1 = _this._environment$_modules;
        if (t1.containsKey$1(namespace))
          throw H.wrapException(E.SassScriptException$("There's already a module with namespace \"" + namespace + '".'));
        t1.$indexSet(0, namespace, module);
        _this._allModules.push(module);
      }
    },
    forwardModule$2: function(module, rule) {
      var view, t1, t2, t3, t4, t5, _i, other, _this = this;
      if (_this._forwardedModules == null)
        _this._forwardedModules = H.setRuntimeTypeInfo([], [[G.Module, D.Callable]]);
      view = R.ForwardedModuleView$(module, rule, D.Callable);
      for (t1 = _this._forwardedModules, t2 = t1.length, t3 = view.variables, t4 = view.functions, t5 = view.mixins, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
        other = t1[_i];
        _this._assertNoConflicts$4(t3, other.variables, "variable", other);
        _this._assertNoConflicts$4(t4, other.functions, "function", other);
        _this._assertNoConflicts$4(t5, other.mixins, "mixin", other);
      }
      _this._allModules.push(module);
      _this._forwardedModules.push(view);
    },
    _assertNoConflicts$4: function(newMembers, oldMembers, type, oldModule) {
      var larger, smaller, t1, $name;
      if (newMembers.get$length(newMembers) < oldMembers.get$length(oldMembers)) {
        larger = oldMembers;
        smaller = newMembers;
      } else {
        larger = newMembers;
        smaller = oldMembers;
      }
      for (t1 = J.get$iterator$ax(smaller.get$keys()); t1.moveNext$0();) {
        $name = t1.get$current(t1);
        if (larger.containsKey$1($name)) {
          if (type === "variable")
            $name = "$" + H.S($name);
          throw H.wrapException(E.SassScriptException$("Module " + H.S(D.prettyUri(oldModule.get$url())) + " and the new module both forward a " + type + " named " + H.S($name) + "."));
        }
      }
    },
    importForwards$1: function(module) {
      var t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, _i, forwarded, t12, t13, index, _this = this,
        t1 = module._environment._forwardedModules;
      if (t1 == null)
        t1 = C.List_empty2;
      t2 = t1.length;
      t3 = _this._mixinIndices;
      t4 = _this._mixins;
      t5 = _this._functionIndices;
      t6 = _this._functions;
      t7 = _this._variableIndices;
      t8 = _this._variableNodes;
      t9 = t8 != null;
      t10 = _this._variables;
      t11 = [G.Module, D.Callable];
      _i = 0;
      for (; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
        forwarded = t1[_i];
        t12 = _this._globalModules;
        (t12 == null ? _this._globalModules = P.LinkedHashSet_LinkedHashSet$_empty(t11) : t12).add$1(0, forwarded);
        for (t12 = J.get$iterator$ax(forwarded.variables.get$keys()); t12.moveNext$0();) {
          t13 = t12.get$current(t12);
          index = t7.remove$1(0, t13);
          if (index == null)
            index = _this._variableIndex$1(t13);
          if (index != null) {
            J.remove$1$ax(t10[index], t13);
            if (t9)
              J.remove$1$ax(t8[index], t13);
          }
        }
        for (t12 = J.get$iterator$ax(forwarded.functions.get$keys()); t12.moveNext$0();) {
          t13 = t12.get$current(t12);
          index = t5.remove$1(0, t13);
          if (index == null)
            index = _this._functionIndex$1(t13);
          if (index != null)
            J.remove$1$ax(t6[index], t13);
        }
        for (t12 = J.get$iterator$ax(forwarded.mixins.get$keys()); t12.moveNext$0();) {
          t13 = t12.get$current(t12);
          index = t3.remove$1(0, t13);
          if (index == null)
            index = _this._mixinIndex$1(t13);
          if (index != null)
            J.remove$1$ax(t4[index], t13);
        }
      }
    },
    getVariable$2$namespace: function($name, namespace) {
      var t1, index, _this = this;
      if (namespace != null)
        return _this._getModule$1(namespace).get$variables().$index(0, $name);
      if (_this._lastVariableName === $name) {
        t1 = J.$index$asx(_this._variables[_this._lastVariableIndex], $name);
        return t1 == null ? _this._getVariableFromGlobalModule$1($name) : t1;
      }
      t1 = _this._variableIndices;
      index = t1.$index(0, $name);
      if (index != null) {
        _this._lastVariableName = $name;
        _this._lastVariableIndex = index;
        t1 = J.$index$asx(_this._variables[index], $name);
        return t1 == null ? _this._getVariableFromGlobalModule$1($name) : t1;
      }
      index = _this._variableIndex$1($name);
      if (index == null)
        return _this._getVariableFromGlobalModule$1($name);
      _this._lastVariableName = $name;
      _this._lastVariableIndex = index;
      t1.$indexSet(0, $name, index);
      t1 = J.$index$asx(_this._variables[index], $name);
      return t1 == null ? _this._getVariableFromGlobalModule$1($name) : t1;
    },
    getVariable$1: function($name) {
      return this.getVariable$2$namespace($name, null);
    },
    _getVariableFromGlobalModule$1: function($name) {
      return this._fromOneModule$2("variable", new O.Environment__getVariableFromGlobalModule_closure($name));
    },
    getVariableNode$2$namespace: function($name, namespace) {
      var t1, index, _this = this;
      if (namespace != null)
        return _this._getModule$1(namespace).get$variableNodes().$index(0, $name);
      if (_this._lastVariableName === $name) {
        t1 = J.$index$asx(_this._variableNodes[_this._lastVariableIndex], $name);
        return t1 == null ? _this._getVariableNodeFromGlobalModule$1($name) : t1;
      }
      t1 = _this._variableIndices;
      index = t1.$index(0, $name);
      if (index != null) {
        _this._lastVariableName = $name;
        _this._lastVariableIndex = index;
        t1 = J.$index$asx(_this._variableNodes[index], $name);
        return t1 == null ? _this._getVariableNodeFromGlobalModule$1($name) : t1;
      }
      index = _this._variableIndex$1($name);
      if (index == null)
        return _this._getVariableNodeFromGlobalModule$1($name);
      _this._lastVariableName = $name;
      _this._lastVariableIndex = index;
      t1.$indexSet(0, $name, index);
      t1 = J.$index$asx(_this._variableNodes[index], $name);
      return t1 == null ? _this._getVariableNodeFromGlobalModule$1($name) : t1;
    },
    _getVariableNodeFromGlobalModule$1: function($name) {
      var t1, value;
      this._lastVariableName = $name;
      this._lastVariableIndex = 0;
      t1 = this._globalModules;
      if (t1 == null)
        return;
      for (t1 = P._LinkedHashSetIterator$(t1, t1._collection$_modifications); t1.moveNext$0();) {
        value = t1._collection$_current.get$variableNodes().$index(0, $name);
        if (value != null)
          return value;
      }
      return;
    },
    globalVariableExists$2$namespace: function($name, namespace) {
      if (namespace != null)
        return this._getModule$1(namespace).get$variables().containsKey$1($name);
      if (C.JSArray_methods.get$first(this._variables).containsKey$1($name))
        return true;
      return this._getVariableFromGlobalModule$1($name) != null;
    },
    globalVariableExists$1: function($name) {
      return this.globalVariableExists$2$namespace($name, null);
    },
    _variableIndex$1: function($name) {
      var t1, i;
      for (t1 = this._variables, i = t1.length - 1; i >= 0; --i)
        if (t1[i].containsKey$1($name))
          return i;
      return;
    },
    setVariable$5$global$namespace: function($name, value, nodeWithSpan, global, namespace) {
      var t1, moduleWithName, index, _this = this;
      if (namespace != null) {
        _this._getModule$1(namespace).setVariable$3($name, value, nodeWithSpan);
        return;
      }
      if (global || _this._variables.length === 1) {
        _this._variableIndices.putIfAbsent$2($name, new O.Environment_setVariable_closure(_this, $name));
        t1 = _this._variables;
        if (!C.JSArray_methods.get$first(t1).containsKey$1($name) && _this._globalModules != null) {
          moduleWithName = _this._fromOneModule$2("variable", new O.Environment_setVariable_closure0($name));
          if (moduleWithName != null) {
            moduleWithName.setVariable$3($name, value, nodeWithSpan);
            return;
          }
        }
        J.$indexSet$ax(C.JSArray_methods.get$first(t1), $name, value);
        t1 = _this._variableNodes;
        if (t1 != null)
          J.$indexSet$ax(C.JSArray_methods.get$first(t1), $name, nodeWithSpan);
        return;
      }
      index = _this._lastVariableName == $name ? _this._lastVariableIndex : _this._variableIndices.putIfAbsent$2($name, new O.Environment_setVariable_closure1(_this, $name));
      if (!_this._inSemiGlobalScope && index === 0) {
        index = _this._variables.length - 1;
        _this._variableIndices.$indexSet(0, $name, index);
      }
      _this._lastVariableName = $name;
      _this._lastVariableIndex = index;
      J.$indexSet$ax(_this._variables[index], $name, value);
      t1 = _this._variableNodes;
      if (t1 != null)
        J.$indexSet$ax(t1[index], $name, nodeWithSpan);
    },
    setVariable$4$global: function($name, value, nodeWithSpan, global) {
      return this.setVariable$5$global$namespace($name, value, nodeWithSpan, global, null);
    },
    setLocalVariable$3: function($name, value, nodeWithSpan) {
      var index, _this = this,
        t1 = _this._variables,
        t2 = t1.length;
      _this._lastVariableName = $name;
      index = _this._lastVariableIndex = t2 - 1;
      _this._variableIndices.$indexSet(0, $name, index);
      J.$indexSet$ax(t1[index], $name, value);
      t1 = _this._variableNodes;
      if (t1 != null)
        J.$indexSet$ax(t1[index], $name, nodeWithSpan);
    },
    getFunction$2$namespace: function($name, namespace) {
      var t1, index, _this = this;
      if (namespace != null) {
        t1 = _this._getModule$1(namespace);
        return t1.get$functions(t1).$index(0, $name);
      }
      t1 = _this._functionIndices;
      index = t1.$index(0, $name);
      if (index != null) {
        t1 = J.$index$asx(_this._functions[index], $name);
        return t1 == null ? _this._getFunctionFromGlobalModule$1($name) : t1;
      }
      index = _this._functionIndex$1($name);
      if (index == null)
        return _this._getFunctionFromGlobalModule$1($name);
      t1.$indexSet(0, $name, index);
      t1 = J.$index$asx(_this._functions[index], $name);
      return t1 == null ? _this._getFunctionFromGlobalModule$1($name) : t1;
    },
    _getFunctionFromGlobalModule$1: function($name) {
      return this._fromOneModule$2("function", new O.Environment__getFunctionFromGlobalModule_closure($name));
    },
    _functionIndex$1: function($name) {
      var t1, i;
      for (t1 = this._functions, i = t1.length - 1; i >= 0; --i)
        if (t1[i].containsKey$1($name))
          return i;
      return;
    },
    getMixin$2$namespace: function($name, namespace) {
      var t1, index, _this = this;
      if (namespace != null)
        return _this._getModule$1(namespace).get$mixins().$index(0, $name);
      t1 = _this._mixinIndices;
      index = t1.$index(0, $name);
      if (index != null) {
        t1 = J.$index$asx(_this._mixins[index], $name);
        return t1 == null ? _this._getMixinFromGlobalModule$1($name) : t1;
      }
      index = _this._mixinIndex$1($name);
      if (index == null)
        return _this._getMixinFromGlobalModule$1($name);
      t1.$indexSet(0, $name, index);
      t1 = J.$index$asx(_this._mixins[index], $name);
      return t1 == null ? _this._getMixinFromGlobalModule$1($name) : t1;
    },
    _getMixinFromGlobalModule$1: function($name) {
      return this._fromOneModule$2("mixin", new O.Environment__getMixinFromGlobalModule_closure($name));
    },
    _mixinIndex$1: function($name) {
      var t1, i;
      for (t1 = this._mixins, i = t1.length - 1; i >= 0; --i)
        if (t1[i].containsKey$1($name))
          return i;
      return;
    },
    scope$1$3$semiGlobal$when: function(callback, semiGlobal, when) {
      var wasInSemiGlobalScope, wasInSemiGlobalScope0, $name, name0, name1, t1, t2, t3, t4, t5, _this = this;
      if (!when) {
        wasInSemiGlobalScope = _this._inSemiGlobalScope;
        _this._inSemiGlobalScope = semiGlobal;
        try {
          t1 = callback.call$0();
          return t1;
        } finally {
          _this._inSemiGlobalScope = wasInSemiGlobalScope;
        }
      }
      semiGlobal = semiGlobal && _this._inSemiGlobalScope;
      wasInSemiGlobalScope0 = _this._inSemiGlobalScope;
      _this._inSemiGlobalScope = semiGlobal;
      t1 = _this._variables;
      t2 = P.String;
      C.JSArray_methods.add$1(t1, P.LinkedHashMap_LinkedHashMap$_empty(t2, F.Value));
      t3 = _this._variableNodes;
      if (t3 != null)
        C.JSArray_methods.add$1(t3, P.LinkedHashMap_LinkedHashMap$_empty(t2, B.AstNode));
      t3 = _this._functions;
      t4 = D.Callable;
      C.JSArray_methods.add$1(t3, P.LinkedHashMap_LinkedHashMap$_empty(t2, t4));
      t5 = _this._mixins;
      C.JSArray_methods.add$1(t5, P.LinkedHashMap_LinkedHashMap$_empty(t2, t4));
      try {
        t2 = callback.call$0();
        return t2;
      } finally {
        _this._inSemiGlobalScope = wasInSemiGlobalScope0;
        _this._lastVariableIndex = _this._lastVariableName = null;
        for (t1 = J.get$iterator$ax(C.JSArray_methods.removeLast$0(t1).get$keys()), t2 = _this._variableIndices; t1.moveNext$0();) {
          $name = t1.get$current(t1);
          t2.remove$1(0, $name);
        }
        for (t1 = J.get$iterator$ax(C.JSArray_methods.removeLast$0(t3).get$keys()), t2 = _this._functionIndices; t1.moveNext$0();) {
          name0 = t1.get$current(t1);
          t2.remove$1(0, name0);
        }
        for (t1 = J.get$iterator$ax(C.JSArray_methods.removeLast$0(t5).get$keys()), t2 = _this._mixinIndices; t1.moveNext$0();) {
          name1 = t1.get$current(t1);
          t2.remove$1(0, name1);
        }
      }
    },
    scope$1$2$when: function(callback, when, $T) {
      return this.scope$1$3$semiGlobal$when(callback, false, when, $T);
    },
    scope$1$1: function(callback, $T) {
      return this.scope$1$3$semiGlobal$when(callback, false, true, $T);
    },
    scope$1$2$semiGlobal: function(callback, semiGlobal, $T) {
      return this.scope$1$3$semiGlobal$when(callback, semiGlobal, true, $T);
    },
    _getModule$1: function(namespace) {
      var module = this._environment$_modules.$index(0, namespace);
      if (module != null)
        return module;
      throw H.wrapException(E.SassScriptException$('There is no module with the namespace "' + namespace + '".'));
    },
    _fromOneModule$1$2: function(type, callback) {
      var value, valueInModule,
        t1 = this._globalModules;
      if (t1 == null)
        return;
      for (t1 = P._LinkedHashSetIterator$(t1, t1._collection$_modifications), value = null; t1.moveNext$0(); value = valueInModule) {
        valueInModule = callback.call$1(t1._collection$_current);
        if (valueInModule != null && value != null)
          throw H.wrapException(E.SassScriptException$("This " + type + " is available from multiple global modules."));
      }
      return value;
    },
    _fromOneModule$2: function(type, callback) {
      return this._fromOneModule$1$2(type, callback, null);
    }
  };
  O.Environment__getVariableFromGlobalModule_closure.prototype = {
    call$1: function(module) {
      return module.get$variables().$index(0, this.name);
    }
  };
  O.Environment_setVariable_closure.prototype = {
    call$0: function() {
      var t1 = this.$this;
      t1._lastVariableName = this.name;
      return t1._lastVariableIndex = 0;
    }
  };
  O.Environment_setVariable_closure0.prototype = {
    call$1: function(module) {
      return module.get$variables().containsKey$1(this.name) ? module : null;
    }
  };
  O.Environment_setVariable_closure1.prototype = {
    call$0: function() {
      var t1 = this.$this,
        t2 = t1._variableIndex$1(this.name);
      return t2 == null ? t1._variables.length - 1 : t2;
    }
  };
  O.Environment__getFunctionFromGlobalModule_closure.prototype = {
    call$1: function(module) {
      return module.get$functions(module).$index(0, this.name);
    }
  };
  O.Environment__getMixinFromGlobalModule_closure.prototype = {
    call$1: function(module) {
      return module.get$mixins().$index(0, this.name);
    }
  };
  O._EnvironmentModule.prototype = {
    get$url: function() {
      return this.css.get$span().file.url;
    },
    setVariable$3: function($name, value, nodeWithSpan) {
      var t1, t2,
        module = this._modulesByVariable.$index(0, $name);
      if (module != null) {
        module.setVariable$3($name, value, nodeWithSpan);
        return;
      }
      t1 = this._environment;
      t2 = t1._variables;
      if (!C.JSArray_methods.get$first(t2).containsKey$1($name))
        throw H.wrapException(E.SassScriptException$("Undefined variable."));
      J.$indexSet$ax(C.JSArray_methods.get$first(t2), $name, value);
      t1 = t1._variableNodes;
      if (t1 != null)
        J.$indexSet$ax(C.JSArray_methods.get$first(t1), $name, nodeWithSpan);
      return;
    },
    cloneCss$0: function() {
      var newCssAndExtender, _this = this,
        t1 = _this.css;
      if (J.get$isEmpty$asx(t1.get$children()))
        return _this;
      newCssAndExtender = V.cloneCssStylesheet(t1, _this.extender);
      return O._EnvironmentModule$_(_this._environment, newCssAndExtender.item1, newCssAndExtender.item2, _this._modulesByVariable, _this.variables, _this.variableNodes, _this.functions, _this.mixins, _this.transitivelyContainsCss, _this.transitivelyContainsExtensions);
    },
    toString$0: function(_) {
      var t1 = this.css.get$span();
      return $.$get$context().prettyUri$1(t1.file.url);
    },
    $isModule: 1,
    $asModule: function() {
      return [D.Callable];
    },
    get$upstream: function() {
      return this.upstream;
    },
    get$variables: function() {
      return this.variables;
    },
    get$variableNodes: function() {
      return this.variableNodes;
    },
    get$functions: function(receiver) {
      return this.functions;
    },
    get$mixins: function() {
      return this.mixins;
    },
    get$extender: function() {
      return this.extender;
    },
    get$css: function(receiver) {
      return this.css;
    },
    get$transitivelyContainsCss: function() {
      return this.transitivelyContainsCss;
    },
    get$transitivelyContainsExtensions: function() {
      return this.transitivelyContainsExtensions;
    }
  };
  O._EnvironmentModule__EnvironmentModule_closure.prototype = {
    call$1: function(module) {
      return module.get$variables();
    }
  };
  O._EnvironmentModule__EnvironmentModule_closure0.prototype = {
    call$1: function(module) {
      return module.get$variableNodes();
    }
  };
  O._EnvironmentModule__EnvironmentModule_closure1.prototype = {
    call$1: function(module) {
      return module.get$functions(module);
    }
  };
  O._EnvironmentModule__EnvironmentModule_closure2.prototype = {
    call$1: function(module) {
      return module.get$mixins();
    }
  };
  O._EnvironmentModule__EnvironmentModule_closure3.prototype = {
    call$1: function(module) {
      return module.get$transitivelyContainsCss();
    }
  };
  O._EnvironmentModule__EnvironmentModule_closure4.prototype = {
    call$1: function(module) {
      return module.get$transitivelyContainsExtensions();
    }
  };
  E.SassException.prototype = {
    get$trace: function() {
      var t1 = A.Frame;
      return new Y.Trace(P.List_List$unmodifiable(H.setRuntimeTypeInfo([B.frameForSpan(G.SourceSpanException.prototype.get$span.call(this), "root stylesheet", null)], [t1]), t1), new P._StringStackTrace(null));
    },
    get$span: function() {
      return G.SourceSpanException.prototype.get$span.call(this);
    },
    toString$1$color: function(_, color) {
      var t2, _i, frame, t3,
        buffer = new P.StringBuffer(""),
        t1 = "Error: " + H.S(this._span_exception$_message) + "\n";
      buffer._contents = t1;
      buffer._contents = t1 + G.SourceSpanException.prototype.get$span.call(this).highlight$1$color(color);
      for (t1 = this.get$trace().toString$0(0).split("\n"), t2 = t1.length, _i = 0; _i < t2; ++_i) {
        frame = t1[_i];
        if (J.get$length$asx(frame) === 0)
          continue;
        t3 = buffer._contents += "\n";
        buffer._contents = t3 + ("  " + H.S(frame));
      }
      t1 = buffer._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    toString$0: function($receiver) {
      return this.toString$1$color($receiver, null);
    },
    toCssString$0: function() {
      var stringMessage, rune,
        t1 = $._glyphs,
        t2 = $._glyphs = C.C_AsciiGlyphSet,
        t3 = this.toString$1$color(0, false),
        commentMessage = H.stringReplaceAllUnchecked(t3, "*/", "*\u2215");
      $._glyphs = t1 === C.C_AsciiGlyphSet ? t2 : C.C_UnicodeGlyphSet;
      stringMessage = new P.StringBuffer("");
      for (t1 = new P.RuneIterator(N.serializeValue(new D.SassString(this.toString$1$color(0, false), true), true, true)); t1.moveNext$0();) {
        rune = t1._currentCodePoint;
        if (rune > 255) {
          stringMessage._contents += H.Primitives_stringFromCharCode(92);
          stringMessage._contents += C.JSInt_methods.toRadixString$1(rune, 16);
          t2 = stringMessage._contents += H.Primitives_stringFromCharCode(32);
        } else
          t2 = stringMessage._contents += H.Primitives_stringFromCharCode(rune);
      }
      return "/* " + C.JSArray_methods.join$1(H.setRuntimeTypeInfo(commentMessage.split("\n"), [P.String]), "\n * ") + ' */\n\nbody::before {\n  font-family: "Source Code Pro", "SF Mono", Monaco, Inconsolata, "Fira Mono",\n      "Droid Sans Mono", monospace, monospace;\n  white-space: pre;\n  display: block;\n  padding: 1em;\n  margin-bottom: 1em;\n  border-bottom: 2px solid black;\n  content: ' + stringMessage.toString$0(0) + ";\n}";
    }
  };
  E.SassRuntimeException.prototype = {
    get$trace: function() {
      return this.trace;
    }
  };
  E.SassFormatException.prototype = {
    get$source: function() {
      return P.String_String$fromCharCodes(C.NativeUint32List_methods.sublist$2(G.SourceSpanException.prototype.get$span.call(this).file._decodedChars, 0, null), 0, null);
    }
  };
  E.SassScriptException.prototype = {
    toString$0: function(_) {
      return this.message + "\n\nBUG: This should include a source span!";
    },
    get$message: function(receiver) {
      return this.message;
    }
  };
  F.main_printError.prototype = {
    call$2: function(error, stackTrace) {
      var t1 = this._box_0;
      if (t1.printedError)
        $.$get$stderr().writeln$0();
      t1.printedError = true;
      t1 = $.$get$stderr();
      t1.writeln$1(error);
      if (stackTrace != null) {
        t1.writeln$0();
        t1.writeln$1(C.JSString_methods.trimRight$0(Y.Trace_Trace$from(stackTrace).get$terse().toString$0(0)));
      }
    }
  };
  F.main_closure0.prototype = {
    call$0: function() {
      var t1, exception;
      try {
        t1 = this.destination;
        if (t1 != null && !this._box_0.options.get$emitErrorCss())
          B.deleteFile(t1);
      } catch (exception) {
        if (!(H.unwrapException(exception) instanceof B.FileSystemException))
          throw exception;
      }
    }
  };
  D._writeSourceMap_closure.prototype = {
    call$1: function(url) {
      return J.toString$0$(this.options.sourceMapUrl$2(P.Uri_parse(url), this.destination));
    }
  };
  B.ExecutableOptions.prototype = {
    get$interactive: function() {
      var t2, invalidOptions, _i, option,
        t1 = this._interactive;
      if (t1 != null)
        return t1;
      t1 = this._options;
      t2 = H.boolTypeCast(t1.$index(0, "interactive"));
      this._interactive = t2;
      if (!t2)
        return false;
      invalidOptions = ["stdin", "indented", "load-path", "style", "source-map", "source-map-urls", "embed-sources", "embed-source-map", "update", "watch"];
      for (t2 = t1._parser.options._collection$_map, _i = 0; _i < 10; ++_i) {
        option = invalidOptions[_i];
        if (t2.$index(0, option) == null)
          H.throwExpression(P.ArgumentError$('Could not find an option named "' + option + '".'));
        if (t1._parsed.containsKey$1(option))
          throw H.wrapException(B.UsageException$("--" + option + " isn't allowed with --interactive."));
      }
      return true;
    },
    get$color: function() {
      var t1 = this._options;
      if (t1.wasParsed$1("color"))
        t1 = H.boolTypeCast(t1.$index(0, "color"));
      else {
        t1 = self.process.stdout.isTTY;
        if (t1 == null)
          t1 = false;
      }
      return t1;
    },
    get$emitErrorCss: function() {
      var t1 = H.boolTypeCast(this._options.$index(0, "error-css"));
      if (t1 == null) {
        this._ensureSources$0();
        t1 = this._sourcesToDestinations.get$values().any$1(0, new B.ExecutableOptions_emitErrorCss_closure());
      }
      return t1;
    },
    _ensureSources$0: function() {
      var t1, stdin, t2, t3, $directories, t4, colonArgs, positionalArgs, t5, t6, t7, message, target, source, destination, seen, i, t8, t9, _this = this, _null = null,
        _s18_ = 'Duplicate source "';
      if (_this._sourcesToDestinations != null)
        return;
      t1 = _this._options;
      stdin = H.boolTypeCast(t1.$index(0, "stdin"));
      t2 = t1.rest;
      if (t2.get$length(t2) === 0 && !stdin)
        B.ExecutableOptions__fail("Compile Sass to CSS.");
      t3 = P.String;
      $directories = P.LinkedHashSet_LinkedHashSet(t3);
      for (t4 = new H.ListIterator(t2, t2.get$length(t2)), colonArgs = false, positionalArgs = false; t4.moveNext$0();) {
        t5 = t4.__internal$_current;
        t6 = t5.length;
        if (t6 === 0)
          B.ExecutableOptions__fail('Invalid argument "".');
        if (H.stringContainsUnchecked(t5, ":", 0)) {
          if (t6 > 2) {
            t7 = J.getInterceptor$s(t5)._codeUnitAt$1(t5, 0);
            if (!(t7 >= 97 && t7 <= 122))
              t7 = t7 >= 65 && t7 <= 90;
            else
              t7 = true;
            t7 = t7 && C.JSString_methods._codeUnitAt$1(t5, 1) === 58;
          } else
            t7 = false;
          if (t7) {
            if (2 > t6)
              H.throwExpression(P.RangeError$range(2, 0, t6, _null, _null));
            t6 = H.stringContainsUnchecked(t5, ":", 2);
          } else
            t6 = true;
        } else
          t6 = false;
        if (t6)
          colonArgs = true;
        else if (B.dirExists(t5))
          $directories.add$1(0, t5);
        else
          positionalArgs = true;
      }
      if (positionalArgs || t2.get$length(t2) === 0) {
        if (colonArgs)
          B.ExecutableOptions__fail('Positional and ":" arguments may not both be used.');
        else if (stdin) {
          if (J.get$length$asx(t2._collection$_source) > 1)
            B.ExecutableOptions__fail("Only one argument is allowed with --stdin.");
          else if (H.boolTypeCast(t1.$index(0, "update")))
            B.ExecutableOptions__fail("--update is not allowed with --stdin.");
          else if (H.boolTypeCast(t1.$index(0, "watch")))
            B.ExecutableOptions__fail("--watch is not allowed with --stdin.");
          _this._sourcesToDestinations = H.ConstantMap_ConstantMap$from(P.LinkedHashMap__makeLiteral([null, t2.get$length(t2) === 0 ? _null : t2.get$first(t2)]), t3, t3);
        } else {
          t4 = t2._collection$_source;
          t5 = J.getInterceptor$asx(t4);
          if (t5.get$length(t4) > 2)
            B.ExecutableOptions__fail("Only two positional args may be passed.");
          else if ($directories._collection$_length !== 0) {
            message = 'Directory "' + H.S($directories.get$first($directories)) + '" may not be a positional arg.';
            target = t2.get$last(t2);
            B.ExecutableOptions__fail(J.$eq$($directories.get$first($directories), t2.get$first(t2)) && !B.fileExists(target) ? message + ('\nTo compile all CSS in "' + H.S($directories.get$first($directories)) + '" to "' + H.S(target) + '", use `sass ' + H.S($directories.get$first($directories)) + ":" + H.S(target) + "`.") : message);
          } else {
            source = J.$eq$(t2.get$first(t2), "-") ? _null : t2.get$first(t2);
            destination = t5.get$length(t4) === 1 ? _null : t2.get$last(t2);
            if (destination == null)
              if (H.boolTypeCast(t1.$index(0, "update")))
                B.ExecutableOptions__fail("--update is not allowed when printing to stdout.");
              else if (H.boolTypeCast(t1.$index(0, "watch")))
                B.ExecutableOptions__fail("--watch is not allowed when printing to stdout.");
            t1 = P.LinkedHashMap_LinkedHashMap$_literal([source, destination], t3, t3);
            t2 = K.PathMap__create(_null, t3);
            t2.addAll$1(0, t1);
            _this._sourcesToDestinations = new P.UnmodifiableMapView(new K.PathMap(t2, [t3]), [t3, t3]);
          }
        }
        _this._sourceDirectoriesToDestinations = C.Map_empty7;
        return;
      }
      if (stdin)
        B.ExecutableOptions__fail('--stdin may not be used with ":" arguments.');
      seen = P.LinkedHashSet_LinkedHashSet(t3);
      t1 = K.PathMap__create(_null, t3);
      t4 = [t3];
      t5 = K.PathMap__create(_null, t3);
      for (t2 = new H.ListIterator(t2, t2.get$length(t2)); t2.moveNext$0();) {
        t6 = t2.__internal$_current;
        if ($directories.contains$1(0, t6)) {
          if (!seen.add$1(0, t6))
            B.ExecutableOptions__fail(_s18_ + H.S(t6) + '".');
          t5.$indexSet(0, t6, t6);
          t1.addAll$1(0, _this._listSourceDirectory$2(t6, t6));
          continue;
        }
        for (t7 = t6.length, destination = _null, source = destination, i = 0; i < t7; ++i) {
          if (i === 1) {
            t8 = i - 1;
            if (t7 > t8 + 2) {
              t9 = C.JSString_methods.codeUnitAt$1(t6, t8);
              if (!(t9 >= 97 && t9 <= 122))
                t9 = t9 >= 65 && t9 <= 90;
              else
                t9 = true;
              t8 = t9 && C.JSString_methods.codeUnitAt$1(t6, t8 + 1) === 58;
            } else
              t8 = false;
          } else
            t8 = false;
          if (t8)
            continue;
          if (C.JSString_methods._codeUnitAt$1(t6, i) === 58)
            if (source == null) {
              source = C.JSString_methods.substring$2(t6, 0, i);
              destination = C.JSString_methods.substring$1(t6, i + 1);
            } else {
              if (i === source.length + 2) {
                t8 = i - 1;
                if (t7 > t8 + 2) {
                  t9 = C.JSString_methods.codeUnitAt$1(t6, t8);
                  if (!(t9 >= 97 && t9 <= 122))
                    t9 = t9 >= 65 && t9 <= 90;
                  else
                    t9 = true;
                  t8 = t9 && C.JSString_methods.codeUnitAt$1(t6, t8 + 1) === 58;
                } else
                  t8 = false;
                t8 = !t8;
              } else
                t8 = true;
              if (t8)
                B.ExecutableOptions__fail('"' + t6 + '" may only contain one ":".');
            }
        }
        if (!seen.add$1(0, source))
          B.ExecutableOptions__fail(_s18_ + H.S(source) + '".');
        if (source === "-")
          t1.$indexSet(0, _null, destination);
        else if (B.dirExists(source)) {
          t5.$indexSet(0, source, destination);
          t1.addAll$1(0, _this._listSourceDirectory$2(source, destination));
        } else
          t1.$indexSet(0, source, destination);
      }
      t2 = [t3, t3];
      _this._sourcesToDestinations = new P.UnmodifiableMapView(new K.PathMap(t1, t4), t2);
      _this._sourceDirectoriesToDestinations = new P.UnmodifiableMapView(new K.PathMap(t5, t4), t2);
    },
    _listSourceDirectory$2: function(source, destination) {
      var t2, t3, t4, _null = null,
        t1 = P.String;
      t1 = P.LinkedHashMap_LinkedHashMap$_empty(t1, t1);
      for (t2 = J.get$iterator$ax(B.listDir(source, true)); t2.moveNext$0();) {
        t3 = t2.get$current(t2);
        if (this._isEntrypoint$1(t3)) {
          t4 = $.$get$context();
          t1.$indexSet(0, t3, t4.join$8(0, destination, t4.withoutExtension$1(t4.relative$2$from(t3, source)) + ".css", _null, _null, _null, _null, _null, _null));
        }
      }
      return t1;
    },
    _isEntrypoint$1: function(path) {
      var extension,
        t1 = $.$get$context().style;
      if (J.startsWith$1$s(X.ParsedPath_ParsedPath$parse(path, t1).get$basename(), "_"))
        return false;
      extension = X.ParsedPath_ParsedPath$parse(path, t1)._splitExtension$0()[1];
      return extension === ".scss" || extension === ".sass";
    },
    get$emitSourceMap: function() {
      var t2, writeToStdout, _this = this,
        _s10_ = "source-map",
        _s15_ = "source-map-urls",
        _s13_ = "embed-sources",
        _s16_ = "embed-source-map",
        t1 = _this._options;
      if (!H.boolTypeCast(t1.$index(0, _s10_)))
        if (t1.wasParsed$1(_s15_))
          B.ExecutableOptions__fail("--source-map-urls isn't allowed with --no-source-map.");
        else if (t1.wasParsed$1(_s13_))
          B.ExecutableOptions__fail("--embed-sources isn't allowed with --no-source-map.");
        else if (t1.wasParsed$1(_s16_))
          B.ExecutableOptions__fail("--embed-source-map isn't allowed with --no-source-map.");
      _this._ensureSources$0();
      t2 = _this._sourcesToDestinations;
      if (t2.get$length(t2) === 1) {
        _this._ensureSources$0();
        t2 = _this._sourcesToDestinations.get$values();
        writeToStdout = t2.get$single(t2) == null;
      } else
        writeToStdout = false;
      if (!writeToStdout)
        return H.boolTypeCast(t1.$index(0, _s10_));
      if (J.$eq$(_this._ifParsed$1(_s15_), "relative"))
        B.ExecutableOptions__fail("--source-map-urls=relative isn't allowed when printing to stdout.");
      if (H.boolTypeCast(t1.$index(0, _s16_)))
        return H.boolTypeCast(t1.$index(0, _s10_));
      else if (J.$eq$(_this._ifParsed$1(_s10_), true))
        B.ExecutableOptions__fail("When printing to stdout, --source-map requires --embed-source-map.");
      else if (t1.wasParsed$1(_s15_))
        B.ExecutableOptions__fail("When printing to stdout, --source-map-urls requires --embed-source-map.");
      else if (H.boolTypeCast(t1.$index(0, _s13_)))
        B.ExecutableOptions__fail("When printing to stdout, --embed-sources requires --embed-source-map.");
      else
        return false;
    },
    sourceMapUrl$2: function(url, destination) {
      var t1, path;
      if (url.get$scheme().length !== 0 && url.get$scheme() !== "file")
        return url;
      t1 = $.$get$context();
      path = t1.style.pathFromUri$1(M._parseUri(url));
      return t1.toUri$1(J.$eq$(this._options.$index(0, "source-map-urls"), "relative") ? t1.relative$2$from(path, t1.dirname$1(destination)) : D.absolute(path));
    },
    _ifParsed$1: function($name) {
      var t1 = this._options;
      return t1.wasParsed$1($name) ? t1.$index(0, $name) : null;
    }
  };
  B.ExecutableOptions_closure.prototype = {
    call$0: function() {
      var t1 = P.String,
        t2 = G.Option,
        t3 = P.LinkedHashMap_LinkedHashMap$_empty(t1, t2),
        t4 = N.ArgParser,
        t5 = [],
        parser = new N.ArgParser(t3, new P.UnmodifiableMapView(t3, [t1, t2]), new P.UnmodifiableMapView(P.LinkedHashMap_LinkedHashMap$_empty(t1, t4), [t1, t4]), t5, true, null);
      parser.addOption$2$hide("precision", true);
      parser.addFlag$2$hide("async", true);
      t5.push(B.ExecutableOptions__separator("Input and Output"));
      parser.addFlag$2$help("stdin", "Read the stylesheet from stdin.");
      parser.addFlag$2$help("indented", "Use the indented syntax for input from stdin.");
      parser.addMultiOption$5$abbr$help$splitCommas$valueHelp("load-path", "I", "A path to use when resolving imports.\nMay be passed multiple times.", false, "PATH");
      t1 = [t1];
      parser.addOption$6$abbr$allowed$defaultsTo$help$valueHelp("style", "s", H.setRuntimeTypeInfo(["expanded", "compressed"], t1), "expanded", "Output style.", "NAME");
      parser.addFlag$3$defaultsTo$help("charset", true, "Emit a @charset or BOM for CSS with non-ASCII characters.");
      parser.addFlag$3$defaultsTo$help("error-css", null, "When an error occurs, emit a stylesheet describing it.\nDefaults to true when compiling to a file.");
      parser.addFlag$3$help$negatable("update", "Only compile out-of-date stylesheets.", false);
      t5.push(B.ExecutableOptions__separator("Source Maps"));
      parser.addFlag$3$defaultsTo$help("source-map", true, "Whether to generate source maps.");
      parser.addOption$4$allowed$defaultsTo$help("source-map-urls", H.setRuntimeTypeInfo(["relative", "absolute"], t1), "relative", "How to link from source maps to source files.");
      parser.addFlag$3$defaultsTo$help("embed-sources", false, "Embed source file contents in source maps.");
      parser.addFlag$3$defaultsTo$help("embed-source-map", false, "Embed source map contents in CSS.");
      t5.push(B.ExecutableOptions__separator("Other"));
      parser.addFlag$3$help$negatable("watch", "Watch stylesheets and recompile when they change.", false);
      parser.addFlag$2$help("poll", "Manually check for changes rather than using a native watcher.\nOnly valid with --watch.");
      parser.addFlag$2$help("stop-on-error", "Don't compile more files once an error is encountered.");
      parser.addFlag$4$abbr$help$negatable("interactive", "i", "Run an interactive SassScript shell.", false);
      parser.addFlag$3$abbr$help("color", "c", "Whether to use terminal colors for messages.");
      parser.addFlag$2$help("unicode", "Whether to use Unicode characters for messages.");
      parser.addFlag$3$abbr$help("quiet", "q", "Don't print warnings.");
      parser.addFlag$2$help("trace", "Print full Dart stack traces for exceptions.");
      parser.addFlag$4$abbr$help$negatable("help", "h", "Print this usage information.", false);
      parser.addFlag$3$help$negatable("version", "Print the version of Dart Sass.", false);
      return parser;
    }
  };
  B.ExecutableOptions_emitErrorCss_closure.prototype = {
    call$1: function(destination) {
      return destination != null;
    }
  };
  B.UsageException.prototype = {$isException: 1,
    get$message: function(receiver) {
      return this.message;
    }
  };
  A.watch_closure.prototype = {
    call$1: function(dir) {
      for (; !B.dirExists(dir);)
        dir = $.$get$context().dirname$1(dir);
      return this.dirWatcher.watch$1(0, dir);
    }
  };
  A._Watcher.prototype = {
    compile$3$ifModified: function(source, destination, ifModified) {
      return this.compile$body$_Watcher(source, destination, ifModified);
    },
    compile$2: function(source, destination) {
      return this.compile$3$ifModified(source, destination, false);
    },
    compile$body$_Watcher: function(source, destination, ifModified) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.bool),
        $async$returnValue, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, error, stackTrace, error0, stackTrace0, exception, t1, t2, $async$exception;
      var $async$compile$3$ifModified = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$currentError = $async$result;
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$handler = 4;
              $async$goto = 7;
              return P._asyncAwait(D.compileStylesheet($async$self._watch$_options, $async$self._graph, source, destination, ifModified), $async$compile$3$ifModified);
            case 7:
              // returning from await.
              $async$returnValue = true;
              // goto return
              $async$goto = 1;
              break;
              $async$handler = 2;
              // goto after finally
              $async$goto = 6;
              break;
            case 4:
              // catch
              $async$handler = 3;
              $async$exception = $async$currentError;
              t1 = H.unwrapException($async$exception);
              t2 = J.getInterceptor$(t1);
              if (!!t2.$isSassException) {
                error = t1;
                stackTrace = H.getTraceFromException($async$exception);
                t1 = $async$self._watch$_options;
                if (!t1.get$emitErrorCss())
                  $async$self._delete$1(destination);
                $async$self._printError$2(J.toString$1$color$(error, t1.get$color()), stackTrace);
                self.process.exitCode = 65;
                $async$returnValue = false;
                // goto return
                $async$goto = 1;
                break;
              } else if (!!t2.$isFileSystemException) {
                error0 = t1;
                stackTrace0 = H.getTraceFromException($async$exception);
                t1 = error0.path;
                $async$self._printError$2("Error reading " + H.S($.$get$context().relative$2$from(t1, null)) + ": " + error0.message + ".", stackTrace0);
                self.process.exitCode = 66;
                $async$returnValue = false;
                // goto return
                $async$goto = 1;
                break;
              } else
                throw $async$exception;
              // goto after finally
              $async$goto = 6;
              break;
            case 3:
              // uncaught
              // goto rethrow
              $async$goto = 2;
              break;
            case 6:
              // after finally
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return P._asyncRethrow($async$currentError, $async$completer);
          }
      });
      return P._asyncStartSync($async$compile$3$ifModified, $async$completer);
    },
    _delete$1: function(path) {
      var buffer, t1, exception;
      try {
        B.deleteFile(path);
        buffer = new P.StringBuffer("");
        t1 = this._watch$_options;
        if (t1.get$color())
          buffer._contents += "\x1b[33m";
        buffer._contents += "Deleted " + H.S(path) + ".";
        if (t1.get$color())
          buffer._contents += "\x1b[0m";
        P.print(buffer);
      } catch (exception) {
        if (!(H.unwrapException(exception) instanceof B.FileSystemException))
          throw exception;
      }
    },
    _printError$2: function(message, stackTrace) {
      var t2,
        t1 = $.$get$stderr();
      t1.writeln$1(message);
      t2 = this._watch$_options._options;
      if (H.boolTypeCast(t2.$index(0, "trace"))) {
        t1.writeln$0();
        t1.writeln$1(C.JSString_methods.trimRight$0(Y.Trace_Trace$from(stackTrace).get$terse().toString$0(0)));
      }
      if (!H.boolTypeCast(t2.$index(0, "stop-on-error")))
        t1.writeln$0();
    },
    watch$1: function(_, watcher) {
      return this.watch$body$_Watcher(_, watcher);
    },
    watch$body$_Watcher: function(_, watcher) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$returnValue, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, $event, extension, success, success0, success1, t2, t1;
      var $async$watch$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$currentError = $async$result;
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = watcher._group._controller;
              t1.toString;
              t1 = P._StreamIterator$($async$self._debounceEvents$1(new P._ControllerStream(t1, [H.getTypeArgumentByIndex(t1, 0)])));
              $async$handler = 3;
              t2 = $async$self._watch$_options._options;
            case 6:
              // for condition
              $async$goto = 8;
              return P._asyncAwait(t1.moveNext$0(), $async$watch$1);
            case 8:
              // returning from await.
              if (!$async$result) {
                // goto after for
                $async$goto = 7;
                break;
              }
              $event = t1.get$current(t1);
              extension = X.ParsedPath_ParsedPath$parse($event.path, $.$get$context().style)._splitExtension$0()[1];
              if (!J.$eq$(extension, ".sass") && !J.$eq$(extension, ".scss")) {
                // goto for condition
                $async$goto = 6;
                break;
              }
            case 9:
              // switch
              switch ($event.type) {
                case C.ChangeType_modify:
                  // goto case
                  $async$goto = 11;
                  break;
                case C.ChangeType_add:
                  // goto case
                  $async$goto = 12;
                  break;
                case C.ChangeType_remove:
                  // goto case
                  $async$goto = 13;
                  break;
                default:
                  // goto after switch
                  $async$goto = 10;
                  break;
              }
              break;
            case 11:
              // case
              $async$goto = 14;
              return P._asyncAwait($async$self._handleModify$1($event.path), $async$watch$1);
            case 14:
              // returning from await.
              success = $async$result;
              if (!success && H.boolTypeCast(t2.$index(0, "stop-on-error"))) {
                $async$next = [1];
                // goto finally
                $async$goto = 4;
                break;
              }
              // goto after switch
              $async$goto = 10;
              break;
            case 12:
              // case
              $async$goto = 15;
              return P._asyncAwait($async$self._handleAdd$1($event.path), $async$watch$1);
            case 15:
              // returning from await.
              success0 = $async$result;
              if (!success0 && H.boolTypeCast(t2.$index(0, "stop-on-error"))) {
                $async$next = [1];
                // goto finally
                $async$goto = 4;
                break;
              }
              // goto after switch
              $async$goto = 10;
              break;
            case 13:
              // case
              $async$goto = 16;
              return P._asyncAwait($async$self._handleRemove$1($event.path), $async$watch$1);
            case 16:
              // returning from await.
              success1 = $async$result;
              if (!success1 && H.boolTypeCast(t2.$index(0, "stop-on-error"))) {
                $async$next = [1];
                // goto finally
                $async$goto = 4;
                break;
              }
              // goto after switch
              $async$goto = 10;
              break;
            case 10:
              // after switch
              // goto for condition
              $async$goto = 6;
              break;
            case 7:
              // after for
              $async$next.push(5);
              // goto finally
              $async$goto = 4;
              break;
            case 3:
              // uncaught
              $async$next = [2];
            case 4:
              // finally
              $async$handler = 2;
              $async$goto = 17;
              return P._asyncAwait(t1.cancel$0(), $async$watch$1);
            case 17:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 5:
              // after finally
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return P._asyncRethrow($async$currentError, $async$completer);
          }
      });
      return P._asyncStartSync($async$watch$1, $async$completer);
    },
    _handleModify$1: function(path) {
      return this._handleModify$body$_Watcher(path);
    },
    _handleModify$body$_Watcher: function(path) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.bool),
        $async$returnValue, $async$self = this, t2, node, t1, url;
      var $async$_handleModify$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $.$get$context();
              url = t1.toUri$1(t1.canonicalize$1(path));
              t1 = $async$self._graph;
              t2 = t1._nodes;
              if (!t2.containsKey$1(url)) {
                $async$returnValue = $async$self._handleAdd$1(path);
                // goto return
                $async$goto = 1;
                break;
              }
              node = t2.$index(0, url);
              t1.reload$1(url);
              $async$goto = 3;
              return P._asyncAwait($async$self._recompileDownstream$1(H.setRuntimeTypeInfo([node], [M.StylesheetNode])), $async$_handleModify$1);
            case 3:
              // returning from await.
              $async$returnValue = $async$result;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$_handleModify$1, $async$completer);
    },
    _handleAdd$1: function(path) {
      return this._handleAdd$body$_Watcher(path);
    },
    _handleAdd$body$_Watcher: function(path) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.bool),
        $async$returnValue, $async$self = this, destination, t1, t2;
      var $async$_handleAdd$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              return P._asyncAwait($async$self._retryPotentialImports$1(path), $async$_handleAdd$1);
            case 3:
              // returning from await.
              if (!$async$result && H.boolTypeCast($async$self._watch$_options._options.$index(0, "stop-on-error"))) {
                $async$returnValue = false;
                // goto return
                $async$goto = 1;
                break;
              }
              destination = $async$self._destinationFor$1(path);
              if (destination == null) {
                $async$returnValue = true;
                // goto return
                $async$goto = 1;
                break;
              }
              t1 = D.absolute(".");
              t2 = $.$get$context();
              $async$self._graph.addCanonical$3(new F.FilesystemImporter(t1), t2.toUri$1(t2.canonicalize$1(path)), t2.toUri$1(path));
              $async$goto = 4;
              return P._asyncAwait($async$self.compile$2(path, destination), $async$_handleAdd$1);
            case 4:
              // returning from await.
              $async$returnValue = $async$result;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$_handleAdd$1, $async$completer);
    },
    _handleRemove$1: function(path) {
      return this._handleRemove$body$_Watcher(path);
    },
    _handleRemove$body$_Watcher: function(path) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.bool),
        $async$returnValue, $async$self = this, t2, destination, t1, url;
      var $async$_handleRemove$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $.$get$context();
              url = t1.toUri$1(t1.canonicalize$1(path));
              $async$goto = 3;
              return P._asyncAwait($async$self._retryPotentialImports$1(path), $async$_handleRemove$1);
            case 3:
              // returning from await.
              if (!$async$result && H.boolTypeCast($async$self._watch$_options._options.$index(0, "stop-on-error"))) {
                $async$returnValue = false;
                // goto return
                $async$goto = 1;
                break;
              }
              t1 = $async$self._graph;
              t2 = t1._nodes;
              if (!t2.containsKey$1(url)) {
                $async$returnValue = true;
                // goto return
                $async$goto = 1;
                break;
              }
              destination = $async$self._destinationFor$1(path);
              if (destination != null)
                $async$self._delete$1(destination);
              t2 = t2.$index(0, url)._downstream;
              t1.remove$1(0, url);
              $async$goto = 4;
              return P._asyncAwait($async$self._recompileDownstream$1(new L.UnmodifiableSetView(t2, [M.StylesheetNode])), $async$_handleRemove$1);
            case 4:
              // returning from await.
              $async$returnValue = $async$result;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$_handleRemove$1, $async$completer);
    },
    _debounceEvents$1: function(events) {
      var t1 = E.WatchEvent,
        t2 = T._debounceAggregate(P.Duration$(25, 0), H.instantiate1(T.debounce___collectToList$closure(), t1), t1, [P.List, t1]).bind$1(events);
      return new P._ExpandStream(new A._Watcher__debounceEvents_closure(), t2, [H.getRuntimeTypeArgument(t2, "Stream", 0), t1]);
    },
    _recompileDownstream$1: function(nodes) {
      return this._recompileDownstream$body$_Watcher(nodes);
    },
    _recompileDownstream$body$_Watcher: function(nodes) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.bool),
        $async$returnValue, $async$self = this, t2, allSucceeded, node, success, t1, seen, toRecompile;
      var $async$_recompileDownstream$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = M.StylesheetNode;
              seen = P.LinkedHashSet_LinkedHashSet(t1);
              toRecompile = P.ListQueue_ListQueue$of(nodes, t1);
              t1 = [t1], t2 = $async$self._watch$_options._options, allSucceeded = true;
            case 3:
              // for condition
              if (!!toRecompile.get$isEmpty(toRecompile)) {
                // goto after for
                $async$goto = 4;
                break;
              }
              node = toRecompile.removeFirst$0();
              if (!seen.add$1(0, node)) {
                // goto for condition
                $async$goto = 3;
                break;
              }
              $async$goto = 5;
              return P._asyncAwait($async$self._compileIfEntrypoint$1(node.canonicalUrl), $async$_recompileDownstream$1);
            case 5:
              // returning from await.
              success = $async$result;
              allSucceeded = allSucceeded && success;
              if (!success && H.boolTypeCast(t2.$index(0, "stop-on-error"))) {
                $async$returnValue = false;
                // goto return
                $async$goto = 1;
                break;
              }
              toRecompile.addAll$1(0, new L.UnmodifiableSetView(node._downstream, t1));
              // goto for condition
              $async$goto = 3;
              break;
            case 4:
              // after for
              $async$returnValue = allSucceeded;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$_recompileDownstream$1, $async$completer);
    },
    _compileIfEntrypoint$1: function(url) {
      return this._compileIfEntrypoint$body$_Watcher(url);
    },
    _compileIfEntrypoint$body$_Watcher: function(url) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.bool),
        $async$returnValue, $async$self = this, source, destination;
      var $async$_compileIfEntrypoint$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              if (url.get$scheme() !== "file") {
                $async$returnValue = true;
                // goto return
                $async$goto = 1;
                break;
              }
              source = $.$get$context().style.pathFromUri$1(M._parseUri(url));
              destination = $async$self._destinationFor$1(source);
              if (destination == null) {
                $async$returnValue = true;
                // goto return
                $async$goto = 1;
                break;
              }
              $async$goto = 3;
              return P._asyncAwait($async$self.compile$2(source, destination), $async$_compileIfEntrypoint$1);
            case 3:
              // returning from await.
              $async$returnValue = $async$result;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$_compileIfEntrypoint$1, $async$completer);
    },
    _destinationFor$1: function(source) {
      var destination, t2, t3, t4, _null = null,
        t1 = this._watch$_options;
      t1._ensureSources$0();
      destination = t1._sourcesToDestinations.$index(0, source);
      if (destination != null)
        return destination;
      t2 = $.$get$context();
      if (J.startsWith$1$s(X.ParsedPath_ParsedPath$parse(source, t2.style).get$basename(), "_"))
        return;
      for (t1._ensureSources$0(), t3 = t1._sourceDirectoriesToDestinations.get$keys(), t3 = t3.get$iterator(t3); t3.moveNext$0();) {
        t4 = t3.get$current(t3);
        if (t2._isWithinOrEquals$2(t4, source) === C._PathRelation_within) {
          t1._ensureSources$0();
          return t2.join$8(0, t1._sourceDirectoriesToDestinations.$index(0, t4), t2.withoutExtension$1(t2.relative$2$from(source, t4)) + ".css", _null, _null, _null, _null, _null, _null);
        }
      }
      return;
    },
    _retryPotentialImports$1: function(path) {
      return this._retryPotentialImports$body$_Watcher(path);
    },
    _retryPotentialImports$body$_Watcher: function(path) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.bool),
        $async$returnValue, $async$next = [], $async$self = this, node, url, newCanonicalUrl, t1, t2, t3, t4, t5, importChanged, t6, basename, exception, t7, $name, changed;
      var $async$_retryPotentialImports$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $name = $async$self._watch$_name$1(X.ParsedPath_ParsedPath$parse(path, $.$get$context().style).get$basename());
              changed = H.setRuntimeTypeInfo([], [M.StylesheetNode]);
              for (t1 = $async$self._graph, t2 = t1._nodes.get$values(), t2 = t2.get$iterator(t2), t3 = t1._transitiveModificationTimes, t1 = t1.importCache, t4 = t1._canonicalizeCache; t2.moveNext$0();) {
                node = t2.get$current(t2);
                for (t5 = node._upstream.get$keys(), t5 = t5.get$iterator(t5), importChanged = false; t5.moveNext$0();) {
                  url = t5.get$current(t5);
                  t6 = $.$get$url();
                  t6 = X.ParsedPath_ParsedPath$parse(J.get$path$x(url), t6.style).get$basename();
                  basename = $.$get$context().withoutExtension$1(t6);
                  if ((C.JSString_methods.startsWith$1(basename, "_") ? C.JSString_methods.substring$1(basename, 1) : basename) !== $name)
                    continue;
                  t3.clear$0(0);
                  t4.remove$1(0, url);
                  if (!importChanged) {
                    newCanonicalUrl = null;
                    try {
                      t6 = t1.canonicalize$3(url, node.importer, node.canonicalUrl);
                      newCanonicalUrl = t6 == null ? null : t6.item2;
                    } catch (exception) {
                      H.unwrapException(exception);
                    }
                    t6 = newCanonicalUrl;
                    t7 = node._upstream.$index(0, url);
                    importChanged = !J.$eq$(t6, t7 == null ? null : t7.canonicalUrl);
                  }
                }
                if (importChanged)
                  changed.push(node);
              }
              $async$goto = 3;
              return P._asyncAwait($async$self._recompileDownstream$1(changed), $async$_retryPotentialImports$1);
            case 3:
              // returning from await.
              $async$returnValue = $async$result;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$_retryPotentialImports$1, $async$completer);
    },
    _watch$_name$1: function(basename) {
      basename = $.$get$context().withoutExtension$1(basename);
      return C.JSString_methods.startsWith$1(basename, "_") ? C.JSString_methods.substring$1(basename, 1) : basename;
    }
  };
  A._Watcher__debounceEvents_closure.prototype = {
    call$1: function(buffer) {
      var t3, t4, t5, oldType,
        t1 = E.ChangeType,
        t2 = K.PathMap__create(null, t1);
      for (t3 = J.get$iterator$ax(buffer); t3.moveNext$0();) {
        t4 = t3.get$current(t3);
        t5 = t4.path;
        oldType = t2.$index(0, t5);
        if (oldType == null)
          t2.$indexSet(0, t5, t4.type);
        else if (t4.type === C.ChangeType_remove)
          t2.$indexSet(0, t5, C.ChangeType_remove);
        else if (oldType !== C.ChangeType_add)
          t2.$indexSet(0, t5, C.ChangeType_modify);
      }
      t3 = t2.get$keys();
      return H.MappedIterable_MappedIterable(t3, new A._Watcher__debounceEvents__closure(new K.PathMap(t2, [t1])), H.getRuntimeTypeArgument(t3, "Iterable", 0), E.WatchEvent);
    }
  };
  A._Watcher__debounceEvents__closure.prototype = {
    call$1: function(path) {
      return new E.WatchEvent(this.typeForPath._collection$_map.$index(0, path), path);
    }
  };
  T.EmptyExtender.prototype = {
    get$isEmpty: function(_) {
      return true;
    },
    get$simpleSelectors: function() {
      return C.C_EmptyUnmodifiableSet;
    },
    extensionsWhereTarget$1: function(callback) {
      return C.List_empty5;
    },
    addExtensions$1: function(extenders) {
      throw H.wrapException(P.UnsupportedError$("addExtensions() can't be called for a const Extender."));
    },
    clone$0: function() {
      return C.Tuple2_EmptyExtender_Map_empty;
    },
    $isExtender: 1
  };
  F.Extender.prototype = {
    get$isEmpty: function(_) {
      var t1 = this._extensions;
      return t1.get$isEmpty(t1);
    },
    get$simpleSelectors: function() {
      return new M.MapKeySet(this._selectors, [M.SimpleSelector]);
    },
    extensionsWhereTarget$1: function($async$callback) {
      var $async$self = this;
      return P._makeSyncStarIterable(function() {
        var callback = $async$callback;
        var $async$goto = 0, $async$handler = 1, $async$currentError, t1, t2, t3, t4;
        return function $async$extensionsWhereTarget$1($async$errorCode, $async$result) {
          if ($async$errorCode === 1) {
            $async$currentError = $async$result;
            $async$goto = $async$handler;
          }
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = $async$self._extensions, t2 = t1.get$keys(), t2 = t2.get$iterator(t2);
              case 2:
                // for condition
                if (!t2.moveNext$0()) {
                  // goto after for
                  $async$goto = 3;
                  break;
                }
                t3 = t2.get$current(t2);
                if (!callback.call$1(t3)) {
                  // goto for condition
                  $async$goto = 2;
                  break;
                }
                t3 = t1.$index(0, t3).get$values(), t3 = t3.get$iterator(t3);
              case 4:
                // for condition
                if (!t3.moveNext$0()) {
                  // goto after for
                  $async$goto = 5;
                  break;
                }
                t4 = t3.get$current(t3);
                $async$goto = t4 instanceof A.MergedExtension ? 6 : 8;
                break;
              case 6:
                // then
                t4 = t4.unmerge$0();
                $async$goto = 9;
                return P._IterationMarker_yieldStar(new H.WhereIterable(t4, new F.Extender_extensionsWhereTarget_closure(), [H.getTypeArgumentByIndex(t4, 0)]));
              case 9:
                // after yield
                // goto join
                $async$goto = 7;
                break;
              case 8:
                // else
                $async$goto = !t4.isOptional ? 10 : 11;
                break;
              case 10:
                // then
                $async$goto = 12;
                return t4;
              case 12:
                // after yield
              case 11:
                // join
              case 7:
                // join
                // goto for condition
                $async$goto = 4;
                break;
              case 5:
                // after for
                // goto for condition
                $async$goto = 2;
                break;
              case 3:
                // after for
                // implicit return
                return P._IterationMarker_endOfIteration();
              case 1:
                // rethrow
                return P._IterationMarker_uncaughtError($async$currentError);
            }
        };
      }, S.Extension);
    },
    addSelector$4: function(selector, selectorSpan, ruleSpan, mediaContext) {
      var error, t1, t2, t3, _i, exception, rule, _this = this,
        originalSelector = selector;
      if (!originalSelector.get$isInvisible())
        for (t1 = originalSelector.components, t2 = t1.length, t3 = _this._originals, _i = 0; _i < t2; ++_i)
          t3.add$1(0, t1[_i]);
      t1 = _this._extensions;
      if (t1.get$isNotEmpty(t1))
        try {
          selector = _this._extendList$3(originalSelector, t1, mediaContext);
        } catch (exception) {
          t1 = H.unwrapException(exception);
          if (t1 instanceof E.SassException) {
            error = t1;
            throw H.wrapException(E.SassException$("From " + error.get$span().message$1(0, "") + "\n" + H.S(error._span_exception$_message), selectorSpan));
          } else
            throw exception;
        }
      rule = X.ModifiableCssStyleRule$(new F.ModifiableCssValue(selector, selectorSpan, [D.SelectorList]), ruleSpan, originalSelector);
      if (mediaContext != null)
        _this._mediaContexts.$indexSet(0, rule, mediaContext);
      _this._registerSelector$2(selector, rule);
      return rule;
    },
    _registerSelector$2: function(list, rule) {
      var t1, t2, t3, _i, t4, t5, _i0, component, t6, t7, _i1, simple;
      for (t1 = list.components, t2 = t1.length, t3 = this._selectors, _i = 0; _i < t2; ++_i)
        for (t4 = t1[_i].components, t5 = t4.length, _i0 = 0; _i0 < t5; ++_i0) {
          component = t4[_i0];
          if (component instanceof X.CompoundSelector)
            for (t6 = component.components, t7 = t6.length, _i1 = 0; _i1 < t7; ++_i1) {
              simple = t6[_i1];
              J.add$1$ax(t3.putIfAbsent$2(simple, new F.Extender__registerSelector_closure()), rule);
              if (simple instanceof D.PseudoSelector && simple.selector != null)
                this._registerSelector$2(simple.selector, rule);
            }
        }
    },
    addExtension$4: function(extender, target, extend, mediaContext) {
      var t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, newExtensions, _i, complex, t12, state, existingState, t13, _i0, component, t14, t15, _i1, simple, newExtensionsByTarget, additionalExtensions, _this = this,
        rules = _this._selectors.$index(0, target),
        t1 = _this._extensionsByExtender,
        existingExtensions = t1.$index(0, target),
        sources = _this._extensions.putIfAbsent$2(target, new F.Extender_addExtension_closure());
      for (t2 = extender.value.components, t3 = t2.length, t4 = rules == null, t5 = _this._sourceSpecificity, t6 = extender.span, t7 = extend.span, t8 = extend.isOptional, t9 = existingExtensions != null, t10 = S.ComplexSelector, t11 = S.Extension, newExtensions = null, _i = 0; _i < t3; ++_i) {
        complex = t2[_i];
        if (complex._maxSpecificity == null)
          complex._computeSpecificity$0();
        t12 = complex._maxSpecificity;
        state = new S.Extension(complex, target, t12, t8, false, mediaContext, t6, t7);
        existingState = sources.$index(0, complex);
        if (existingState != null) {
          sources.$indexSet(0, complex, A.MergedExtension_merge(existingState, state));
          continue;
        }
        sources.$indexSet(0, complex, state);
        for (t12 = complex.components, t13 = t12.length, _i0 = 0; _i0 < t13; ++_i0) {
          component = t12[_i0];
          if (component instanceof X.CompoundSelector)
            for (t14 = component.components, t15 = t14.length, _i1 = 0; _i1 < t15; ++_i1) {
              simple = t14[_i1];
              J.add$1$ax(t1.putIfAbsent$2(simple, new F.Extender_addExtension_closure0()), state);
              t5.putIfAbsent$2(simple, new F.Extender_addExtension_closure1(complex));
            }
        }
        if (!t4 || t9) {
          if (newExtensions == null)
            newExtensions = P.LinkedHashMap_LinkedHashMap$_empty(t10, t11);
          newExtensions.$indexSet(0, complex, state);
        }
      }
      if (newExtensions == null)
        return;
      newExtensionsByTarget = P.LinkedHashMap_LinkedHashMap$_literal([target, newExtensions], M.SimpleSelector, [P.Map, S.ComplexSelector, S.Extension]);
      if (t9) {
        additionalExtensions = _this._extendExistingExtensions$2(existingExtensions, newExtensionsByTarget);
        if (additionalExtensions != null)
          B.mapAddAll2(newExtensionsByTarget, additionalExtensions);
      }
      if (!t4)
        _this._extendExistingStyleRules$2(rules, newExtensionsByTarget);
    },
    _extendExistingExtensions$2: function(extensions, newExtensions) {
      var extension, selectors, error, t1, t2, t3, t4, t5, t6, additionalExtensions, _i, sources, exception, containsExtension, t7, t8, first, _i0, complex, t9, t10, t11, t12, t13, t14, withExtender, existingExtension, _i1, component, _i2;
      for (t1 = J.toList$0$ax(extensions), t2 = t1.length, t3 = this._extensionsByExtender, t4 = M.SimpleSelector, t5 = [P.Map, S.ComplexSelector, S.Extension], t6 = this._extensions, additionalExtensions = null, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
        extension = t1[_i];
        sources = t6.$index(0, extension.target);
        selectors = null;
        try {
          selectors = this._extendComplex$3(extension.extender, newExtensions, extension.mediaContext);
          if (selectors == null)
            continue;
        } catch (exception) {
          t1 = H.unwrapException(exception);
          if (t1 instanceof E.SassException) {
            error = t1;
            throw H.wrapException(E.SassException$("From " + extension.extenderSpan.message$1(0, "") + "\n" + H.S(error._span_exception$_message), error.get$span()));
          } else
            throw exception;
        }
        containsExtension = J.$eq$(J.get$first$ax(selectors), extension.extender);
        for (t7 = selectors, t8 = t7.length, first = false, _i0 = 0; _i0 < t7.length; t7.length === t8 || (0, H.throwConcurrentModificationError)(t7), ++_i0) {
          complex = t7[_i0];
          if (containsExtension && first) {
            first = false;
            continue;
          }
          t9 = extension;
          t10 = t9.target;
          t11 = t9.extenderSpan;
          t12 = t9.span;
          t13 = t9.mediaContext;
          t14 = t9.specificity;
          t9 = t9.isOptional;
          if (t14 == null) {
            if (complex._maxSpecificity == null)
              complex._computeSpecificity$0();
            t14 = complex._maxSpecificity;
          }
          withExtender = new S.Extension(complex, t10, t14, t9, false, t13, t11, t12);
          existingExtension = sources.$index(0, complex);
          if (existingExtension != null)
            sources.$indexSet(0, complex, A.MergedExtension_merge(existingExtension, withExtender));
          else {
            sources.$indexSet(0, complex, withExtender);
            for (t9 = complex.components, t10 = t9.length, _i1 = 0; _i1 < t10; ++_i1) {
              component = t9[_i1];
              if (component instanceof X.CompoundSelector)
                for (t11 = component.components, t12 = t11.length, _i2 = 0; _i2 < t12; ++_i2)
                  J.add$1$ax(t3.putIfAbsent$2(t11[_i2], new F.Extender__extendExistingExtensions_closure()), withExtender);
            }
            if (newExtensions.containsKey$1(extension.target)) {
              if (additionalExtensions == null)
                additionalExtensions = P.LinkedHashMap_LinkedHashMap$_empty(t4, t5);
              additionalExtensions.putIfAbsent$2(extension.target, new F.Extender__extendExistingExtensions_closure0()).$indexSet(0, complex, withExtender);
            }
          }
        }
        if (!containsExtension)
          sources.remove$1(0, extension.extender);
      }
      return additionalExtensions;
    },
    _extendExistingStyleRules$2: function(rules, newExtensions) {
      var rule, error, t1, t2, oldValue, exception;
      for (t1 = rules.get$iterator(rules), t2 = this._mediaContexts; t1.moveNext$0();) {
        rule = t1.get$current(t1);
        oldValue = rule.selector.value;
        try {
          rule.selector.value = this._extendList$3(rule.selector.value, newExtensions, t2.$index(0, rule));
        } catch (exception) {
          t1 = H.unwrapException(exception);
          if (t1 instanceof E.SassException) {
            error = t1;
            throw H.wrapException(E.SassException$("From " + rule.selector.span.message$1(0, "") + "\n" + H.S(error._span_exception$_message), error.get$span()));
          } else
            throw exception;
        }
        if (oldValue == rule.selector.value)
          continue;
        this._registerSelector$2(rule.selector.value, rule);
      }
    },
    addExtensions$1: function(extenders) {
      var t1, t2, _box_0 = {};
      _box_0.newExtensions = _box_0.rulesToExtend = _box_0.extensionsToExtend = null;
      for (t1 = J.get$iterator$ax(extenders); t1.moveNext$0();) {
        t2 = t1.get$current(t1);
        if (t2.get$isEmpty(t2))
          continue;
        t2.get$_extensions().forEach$1(0, new F.Extender_addExtensions_closure(_box_0, this, t2));
      }
      t1 = _box_0.newExtensions;
      if (t1 == null)
        return;
      t2 = _box_0.extensionsToExtend;
      if (t2 != null)
        this._extendExistingExtensions$2(t2, t1);
      t1 = _box_0.rulesToExtend;
      if (t1 != null)
        this._extendExistingStyleRules$2(t1, _box_0.newExtensions);
    },
    _extendList$3: function(list, extensions, mediaQueryContext) {
      var t1, t2, t3, extended, i, complex, result, t4;
      for (t1 = list.components, t2 = t1.length, t3 = [S.ComplexSelector], extended = null, i = 0; i < t2; ++i) {
        complex = t1[i];
        result = this._extendComplex$3(complex, extensions, mediaQueryContext);
        if (result == null) {
          if (extended != null)
            extended.push(complex);
        } else {
          if (extended == null)
            if (i === 0)
              extended = H.setRuntimeTypeInfo([], t3);
            else {
              t4 = C.JSArray_methods.sublist$2(t1, 0, i);
              extended = H.setRuntimeTypeInfo(t4.slice(0), [H.getTypeArgumentByIndex(t4, 0)]);
            }
          C.JSArray_methods.addAll$1(extended, result);
        }
      }
      if (extended == null)
        return list;
      t1 = this._originals;
      return D.SelectorList$(J.where$1$ax(this._trim$2(extended, t1.get$contains(t1)), new F.Extender__extendList_closure()));
    },
    _extendComplex$3: function(complex, extensions, mediaQueryContext) {
      var t1, t2, t3, t4, t5, t6, t7, extendedNotExpanded, i, component, extended, result, t8,
        _s28_ = "components may not be empty.",
        _box_0 = {},
        isOriginal = this._originals.contains$1(0, complex);
      for (t1 = complex.components, t2 = t1.length, t3 = S.ComplexSelector, t4 = [t3], t5 = S.ComplexSelectorComponent, t6 = [t5], t7 = [P.List, S.ComplexSelector], extendedNotExpanded = null, i = 0; i < t2; ++i) {
        component = t1[i];
        if (component instanceof X.CompoundSelector) {
          extended = this._extendCompound$4$inOriginal(component, extensions, mediaQueryContext, isOriginal);
          if (extended == null) {
            if (extendedNotExpanded != null) {
              result = P.List_List$from(H.setRuntimeTypeInfo([component], t6), false, t5);
              result.fixed$length = Array;
              result.immutable$list = Array;
              t8 = result;
              if (t8.length === 0)
                H.throwExpression(P.ArgumentError$(_s28_));
              C.JSArray_methods.add$1(extendedNotExpanded, H.setRuntimeTypeInfo([new S.ComplexSelector(t8, false)], t4));
            }
          } else {
            if (extendedNotExpanded == null) {
              t8 = H.SubListIterable$(t1, 0, i, H.getTypeArgumentByIndex(t1, 0));
              extendedNotExpanded = new H.MappedListIterable(t8, new F.Extender__extendComplex_closure(complex), [H.getTypeArgumentByIndex(t8, 0), t7]).toList$0(0);
            }
            C.JSArray_methods.add$1(extendedNotExpanded, extended);
          }
        } else if (extendedNotExpanded != null) {
          result = P.List_List$from(H.setRuntimeTypeInfo([component], t6), false, t5);
          result.fixed$length = Array;
          result.immutable$list = Array;
          t8 = result;
          if (t8.length === 0)
            H.throwExpression(P.ArgumentError$(_s28_));
          C.JSArray_methods.add$1(extendedNotExpanded, H.setRuntimeTypeInfo([new S.ComplexSelector(t8, false)], t4));
        }
      }
      if (extendedNotExpanded == null)
        return;
      _box_0.first = true;
      t1 = J.expand$1$1$ax(Y.paths(extendedNotExpanded, t3), new F.Extender__extendComplex_closure0(_box_0, this, complex), t3);
      return P.List_List$from(t1, true, H.getRuntimeTypeArgument(t1, "Iterable", 0));
    },
    _extendCompound$4$inOriginal: function(compound, extensions, mediaQueryContext, inOriginal) {
      var t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, options, i, simple, extended, result, t13, t14, compound0, _this = this, _null = null,
        _s28_ = "components may not be empty.",
        _box_1 = {},
        t1 = _this._mode,
        targetsUsed = t1 === C.ExtendMode_normal || extensions.get$length(extensions) < 2 ? _null : P.LinkedHashSet_LinkedHashSet(M.SimpleSelector);
      for (t2 = compound.components, t3 = t2.length, t4 = [[P.List, S.Extension]], t5 = S.Extension, t6 = [t5], t7 = S.ComplexSelectorComponent, t8 = [t7], t9 = H.getTypeArgumentByIndex(t2, 0), t10 = M.SimpleSelector, t11 = _this._sourceSpecificity, t12 = [t10], options = _null, i = 0; i < t3; ++i) {
        simple = t2[i];
        extended = _this._extendSimple$4(simple, extensions, mediaQueryContext, targetsUsed);
        if (extended == null) {
          if (options != null) {
            result = P.List_List$from(H.setRuntimeTypeInfo([simple], t12), false, t10);
            result.fixed$length = Array;
            result.immutable$list = Array;
            t13 = result;
            if (t13.length === 0)
              H.throwExpression(P.ArgumentError$(_s28_));
            result = P.List_List$from(H.setRuntimeTypeInfo([new X.CompoundSelector(t13)], t8), false, t7);
            result.fixed$length = Array;
            result.immutable$list = Array;
            t13 = result;
            if (t13.length === 0)
              H.throwExpression(P.ArgumentError$(_s28_));
            t14 = t11.$index(0, simple);
            if (t14 == null)
              t14 = 0;
            options.push(H.setRuntimeTypeInfo([new S.Extension(new S.ComplexSelector(t13, false), _null, t14, true, true, _null, _null, _null)], t6));
          }
        } else {
          if (options == null) {
            options = H.setRuntimeTypeInfo([], t4);
            if (i !== 0) {
              result = P.List_List$from(H.SubListIterable$(t2, 0, i, t9), false, t10);
              result.fixed$length = Array;
              result.immutable$list = Array;
              t13 = result;
              compound0 = new X.CompoundSelector(t13);
              if (t13.length === 0)
                H.throwExpression(P.ArgumentError$(_s28_));
              result = P.List_List$from(H.setRuntimeTypeInfo([compound0], t8), false, t7);
              result.fixed$length = Array;
              result.immutable$list = Array;
              t13 = result;
              if (t13.length === 0)
                H.throwExpression(P.ArgumentError$(_s28_));
              t14 = _this._sourceSpecificityFor$1(compound0);
              options.push(H.setRuntimeTypeInfo([new S.Extension(new S.ComplexSelector(t13, false), _null, t14, true, true, _null, _null, _null)], t6));
            }
          }
          C.JSArray_methods.addAll$1(options, extended);
        }
      }
      if (options == null)
        return;
      if (targetsUsed != null && targetsUsed._collection$_length !== extensions.get$length(extensions))
        return;
      if (options.length === 1)
        return J.map$1$1$ax(C.JSArray_methods.get$first(options), new F.Extender__extendCompound_closure(mediaQueryContext), S.ComplexSelector).toList$0(0);
      _box_1.first = t1 !== C.ExtendMode_replace;
      t1 = J.map$1$1$ax(Y.paths(options, t5), new F.Extender__extendCompound_closure0(_box_1, _this, compound, mediaQueryContext), [P.List, S.ComplexSelector]).where$1(0, new F.Extender__extendCompound_closure1());
      t2 = S.ComplexSelector;
      return P.List_List$from(new H.ExpandIterable(t1, new F.Extender__extendCompound_closure2(), [H.getTypeArgumentByIndex(t1, 0), t2]), true, t2);
    },
    _extendSimple$4: function(simple, extensions, mediaQueryContext, targetsUsed) {
      var extended, result,
        t1 = new F.Extender__extendSimple_withoutPseudo(this, extensions, targetsUsed);
      if (simple instanceof D.PseudoSelector && simple.selector != null) {
        extended = this._extendPseudo$3(simple, extensions, mediaQueryContext);
        if (extended != null)
          return new H.MappedListIterable(extended, new F.Extender__extendSimple_closure(this, t1), [H.getTypeArgumentByIndex(extended, 0), [P.List, S.Extension]]);
      }
      result = t1.call$1(simple);
      return result == null ? null : H.setRuntimeTypeInfo([result], [[P.List, S.Extension]]);
    },
    _extensionForSimple$1: function(simple) {
      var t1 = S.ComplexSelector$(H.setRuntimeTypeInfo([X.CompoundSelector$(H.setRuntimeTypeInfo([simple], [M.SimpleSelector]))], [S.ComplexSelectorComponent]), false),
        t2 = this._sourceSpecificity.$index(0, simple);
      return S.Extension$oneOff(t1, true, t2 == null ? 0 : t2);
    },
    _extendPseudo$3: function(pseudo, extensions, mediaQueryContext) {
      var complexes, t2, result,
        t1 = pseudo.selector,
        extended = this._extendList$3(t1, extensions, mediaQueryContext);
      if (extended == t1)
        return;
      complexes = extended.components;
      t2 = pseudo.normalizedName === "not";
      if (t2 && !C.JSArray_methods.any$1(t1.components, new F.Extender__extendPseudo_closure()) && C.JSArray_methods.any$1(complexes, new F.Extender__extendPseudo_closure0()))
        complexes = new H.WhereIterable(complexes, new F.Extender__extendPseudo_closure1(), [H.getTypeArgumentByIndex(complexes, 0)]);
      complexes = J.expand$1$1$ax(complexes, new F.Extender__extendPseudo_closure2(pseudo), S.ComplexSelector);
      t1 = t2 && t1.components.length === 1;
      t2 = D.PseudoSelector;
      if (t1) {
        t1 = H.MappedIterable_MappedIterable(complexes, new F.Extender__extendPseudo_closure3(pseudo), H.getRuntimeTypeArgument(complexes, "Iterable", 0), t2);
        result = P.List_List$from(t1, true, H.getRuntimeTypeArgument(t1, "Iterable", 0));
        return result.length === 0 ? null : result;
      } else
        return H.setRuntimeTypeInfo([D.PseudoSelector$(pseudo.name, pseudo.argument, !pseudo.isClass, D.SelectorList$(complexes))], [t2]);
    },
    _trim$2: function(selectors, isOriginal) {
      var result, i, t1, numOriginals, _box_0, complex1, j, t2, t3, _i, component;
      if (selectors.length > 100)
        return selectors;
      result = Q.QueueList$(null, S.ComplexSelector);
      $label0$0:
        for (i = selectors.length - 1, t1 = H.getTypeArgumentByIndex(selectors, 0), numOriginals = 0; i >= 0; --i) {
          _box_0 = {};
          complex1 = selectors[i];
          if (isOriginal.call$1(complex1)) {
            for (j = 0; j < numOriginals; ++j)
              if (J.$eq$(result.$index(0, j), complex1)) {
                B.rotateSlice(result, 0, j + 1);
                continue $label0$0;
              }
            ++numOriginals;
            result.addFirst$1(complex1);
            continue $label0$0;
          }
          _box_0.maxSpecificity = 0;
          for (t2 = complex1.components, t3 = t2.length, _i = 0; _i < t3; ++_i) {
            component = t2[_i];
            if (component instanceof X.CompoundSelector)
              _box_0.maxSpecificity = Math.max(_box_0.maxSpecificity, this._sourceSpecificityFor$1(component));
          }
          if (result.any$1(result, new F.Extender__trim_closure(_box_0, complex1)))
            continue $label0$0;
          if (H.SubListIterable$(selectors, 0, i, t1).any$1(0, new F.Extender__trim_closure0(_box_0, complex1)))
            continue $label0$0;
          result.addFirst$1(complex1);
        }
      return result;
    },
    _sourceSpecificityFor$1: function(compound) {
      var t1, t2, t3, specificity, _i, t4;
      for (t1 = compound.components, t2 = t1.length, t3 = this._sourceSpecificity, specificity = 0, _i = 0; _i < t2; ++_i) {
        t4 = t3.$index(0, t1[_i]);
        specificity = Math.max(specificity, H.checkNum(t4 == null ? 0 : t4));
      }
      return specificity;
    },
    clone$0: function() {
      var t3, t4, _this = this,
        t1 = M.SimpleSelector,
        newSelectors = P.LinkedHashMap_LinkedHashMap$_empty(t1, [P.Set, X.ModifiableCssStyleRule]),
        t2 = X.CssStyleRule,
        newMediaContexts = new H.JsLinkedHashMap([t2, [P.List, F.CssMediaQuery]]),
        oldToNewRules = P.LinkedHashMap_LinkedHashMap$_empty(t2, X.ModifiableCssStyleRule);
      _this._selectors.forEach$1(0, new F.Extender_clone_closure(_this, newSelectors, oldToNewRules, newMediaContexts));
      t2 = S.ComplexSelector;
      t3 = S.Extension;
      t4 = B.copyMapOfMap(_this._extensions, t1, t2, t3);
      t3 = B.copyMapOfList(_this._extensionsByExtender, t1, t3);
      t1 = P._LinkedIdentityHashMap__LinkedIdentityHashMap$es6(t1, P.int);
      t1.addAll$1(0, _this._sourceSpecificity);
      t2 = new P._LinkedIdentityHashSet([t2]);
      t2.addAll$1(0, _this._originals);
      return new S.Tuple2(new F.Extender(newSelectors, t4, t3, newMediaContexts, t1, t2, C.ExtendMode_normal), oldToNewRules, [F.Extender, [P.Map, X.CssStyleRule, X.ModifiableCssStyleRule]]);
    },
    get$_extensions: function() {
      return this._extensions;
    }
  };
  F.Extender__extendOrReplace_closure.prototype = {
    call$1: function(complex) {
      return S.Extension$oneOff(H.interceptedTypeCast(complex, "$isComplexSelector"), false, null);
    },
    $signature: 47
  };
  F.Extender_extensionsWhereTarget_closure.prototype = {
    call$1: function(extension) {
      return !extension.isOptional;
    }
  };
  F.Extender__registerSelector_closure.prototype = {
    call$0: function() {
      return P.LinkedHashSet_LinkedHashSet(X.ModifiableCssStyleRule);
    }
  };
  F.Extender_addExtension_closure.prototype = {
    call$0: function() {
      return P.LinkedHashMap_LinkedHashMap$_empty(S.ComplexSelector, S.Extension);
    }
  };
  F.Extender_addExtension_closure0.prototype = {
    call$0: function() {
      return H.setRuntimeTypeInfo([], [S.Extension]);
    }
  };
  F.Extender_addExtension_closure1.prototype = {
    call$0: function() {
      return this.complex.get$maxSpecificity();
    }
  };
  F.Extender__extendExistingExtensions_closure.prototype = {
    call$0: function() {
      return H.setRuntimeTypeInfo([], [S.Extension]);
    }
  };
  F.Extender__extendExistingExtensions_closure0.prototype = {
    call$0: function() {
      return P.LinkedHashMap_LinkedHashMap$_empty(S.ComplexSelector, S.Extension);
    }
  };
  F.Extender_addExtensions_closure.prototype = {
    call$2: function(target, newSources) {
      var start, t1, extensionsForTarget, t2, t3, t4, rulesForTarget, t5, existingSources, _this = this;
      if (target instanceof N.PlaceholderSelector) {
        start = C.JSString_methods._codeUnitAt$1(target.name, 0);
        t1 = start === 45 || start === 95;
      } else
        t1 = false;
      if (t1)
        return;
      t1 = _this.$this;
      extensionsForTarget = t1._extensionsByExtender.$index(0, target);
      t2 = extensionsForTarget == null;
      if (!t2) {
        t3 = _this._box_0;
        t4 = t3.extensionsToExtend;
        C.JSArray_methods.addAll$1(t4 == null ? t3.extensionsToExtend = H.setRuntimeTypeInfo([], [S.Extension]) : t4, extensionsForTarget);
      }
      rulesForTarget = t1._selectors.$index(0, target);
      t3 = rulesForTarget != null;
      if (t3) {
        t4 = _this._box_0;
        t5 = t4.rulesToExtend;
        (t5 == null ? t4.rulesToExtend = P.LinkedHashSet_LinkedHashSet(X.ModifiableCssStyleRule) : t5).addAll$1(0, rulesForTarget);
      }
      t1 = t1._extensions;
      existingSources = t1.$index(0, target);
      if (existingSources == null) {
        t4 = _this.extender;
        t1.$indexSet(0, target, t4.get$_extensions().$index(0, target));
        if (!t2 || t3) {
          t1 = _this._box_0;
          t2 = t1.newExtensions;
          t1 = t2 == null ? t1.newExtensions = P.LinkedHashMap_LinkedHashMap$_empty(M.SimpleSelector, [P.Map, S.ComplexSelector, S.Extension]) : t2;
          t1.$indexSet(0, target, t4.get$_extensions().$index(0, target));
        }
      } else
        newSources.forEach$1(0, new F.Extender_addExtensions__closure(_this._box_0, existingSources, extensionsForTarget, rulesForTarget, target));
    }
  };
  F.Extender_addExtensions__closure.prototype = {
    call$2: function(extender, extension) {
      var t2, _this = this,
        t1 = _this.existingSources;
      if (t1.containsKey$1(extender))
        return;
      t1.$indexSet(0, extender, extension);
      if (_this.extensionsForTarget != null || _this.rulesForTarget != null) {
        t1 = _this._box_0;
        t2 = t1.newExtensions;
        t1 = t2 == null ? t1.newExtensions = P.LinkedHashMap_LinkedHashMap$_empty(M.SimpleSelector, [P.Map, S.ComplexSelector, S.Extension]) : t2;
        t1.putIfAbsent$2(_this.target, new F.Extender_addExtensions___closure()).putIfAbsent$2(extender, new F.Extender_addExtensions___closure0(extension));
      }
    }
  };
  F.Extender_addExtensions___closure.prototype = {
    call$0: function() {
      return P.LinkedHashMap_LinkedHashMap$_empty(S.ComplexSelector, S.Extension);
    }
  };
  F.Extender_addExtensions___closure0.prototype = {
    call$0: function() {
      return this.extension;
    }
  };
  F.Extender__extendList_closure.prototype = {
    call$1: function(complex) {
      return complex != null;
    }
  };
  F.Extender__extendComplex_closure.prototype = {
    call$1: function(component) {
      return H.setRuntimeTypeInfo([S.ComplexSelector$(H.setRuntimeTypeInfo([component], [S.ComplexSelectorComponent]), this.complex.lineBreak)], [S.ComplexSelector]);
    }
  };
  F.Extender__extendComplex_closure0.prototype = {
    call$1: function(path) {
      var t1 = Y.weave(J.map$1$1$ax(path, new F.Extender__extendComplex__closure(), [P.List, S.ComplexSelectorComponent]).toList$0(0));
      return new H.MappedListIterable(t1, new F.Extender__extendComplex__closure0(this._box_0, this.$this, this.complex, path), [H.getTypeArgumentByIndex(t1, 0), S.ComplexSelector]);
    }
  };
  F.Extender__extendComplex__closure.prototype = {
    call$1: function(complex) {
      return complex.components;
    }
  };
  F.Extender__extendComplex__closure0.prototype = {
    call$1: function(components) {
      var _this = this,
        t1 = _this.complex,
        outputComplex = S.ComplexSelector$(components, t1.lineBreak || J.any$1$ax(_this.path, new F.Extender__extendComplex___closure())),
        t2 = _this._box_0;
      if (t2.first && _this.$this._originals.contains$1(0, t1))
        _this.$this._originals.add$1(0, outputComplex);
      t2.first = false;
      return outputComplex;
    }
  };
  F.Extender__extendComplex___closure.prototype = {
    call$1: function(inputComplex) {
      return inputComplex.lineBreak;
    }
  };
  F.Extender__extendCompound_closure.prototype = {
    call$1: function(state) {
      state.assertCompatibleMediaContext$1(this.mediaQueryContext);
      return state.extender;
    }
  };
  F.Extender__extendCompound_closure0.prototype = {
    call$1: function(path) {
      var complexes, toUnify, originals, t3, specificity, _this = this, _box_0 = {},
        t1 = _this._box_1,
        t2 = [P.List, S.ComplexSelectorComponent];
      if (t1.first) {
        t1.first = false;
        complexes = H.setRuntimeTypeInfo([H.setRuntimeTypeInfo([X.CompoundSelector$(J.expand$1$1$ax(path, new F.Extender__extendCompound__closure(), M.SimpleSelector))], [S.ComplexSelectorComponent])], [t2]);
      } else {
        toUnify = Q.QueueList$(null, t2);
        for (t1 = J.get$iterator$ax(path), t2 = [M.SimpleSelector], originals = null; t1.moveNext$0();) {
          t3 = t1.get$current(t1);
          if (t3.isOriginal) {
            if (originals == null)
              originals = H.setRuntimeTypeInfo([], t2);
            C.JSArray_methods.addAll$1(originals, H.interceptedTypeCast(C.JSArray_methods.get$last(t3.extender.components), "$isCompoundSelector").components);
          } else
            toUnify._queue_list$_add$1(t3.extender.components);
        }
        if (originals != null)
          toUnify.addFirst$1(H.setRuntimeTypeInfo([X.CompoundSelector$(originals)], [S.ComplexSelectorComponent]));
        complexes = Y.unifyComplex(toUnify);
        if (complexes == null)
          return;
      }
      _box_0.lineBreak = false;
      specificity = _this.$this._sourceSpecificityFor$1(_this.compound);
      for (t1 = J.get$iterator$ax(path), t2 = _this.mediaQueryContext; t1.moveNext$0();) {
        t3 = t1.get$current(t1);
        t3.assertCompatibleMediaContext$1(t2);
        _box_0.lineBreak = _box_0.lineBreak || t3.extender.lineBreak;
        specificity = Math.max(specificity, H.checkNum(t3.specificity));
      }
      return J.map$1$1$ax(complexes, new F.Extender__extendCompound__closure0(_box_0), S.ComplexSelector).toList$0(0);
    }
  };
  F.Extender__extendCompound__closure.prototype = {
    call$1: function(state) {
      return H.interceptedTypeCast(C.JSArray_methods.get$last(state.extender.components), "$isCompoundSelector").components;
    }
  };
  F.Extender__extendCompound__closure0.prototype = {
    call$1: function(components) {
      return S.ComplexSelector$(components, this._box_0.lineBreak);
    }
  };
  F.Extender__extendCompound_closure1.prototype = {
    call$1: function(complexes) {
      return complexes != null;
    }
  };
  F.Extender__extendCompound_closure2.prototype = {
    call$1: function(l) {
      return l;
    }
  };
  F.Extender__extendSimple_withoutPseudo.prototype = {
    call$1: function(simple) {
      var t1, t2,
        extenders = this.extensions.$index(0, simple);
      if (extenders == null)
        return;
      t1 = this.targetsUsed;
      if (t1 != null)
        t1.add$1(0, simple);
      t1 = this.$this;
      if (t1._mode === C.ExtendMode_replace) {
        t1 = extenders.get$values();
        return P.List_List$from(t1, true, H.getRuntimeTypeArgument(t1, "Iterable", 0));
      }
      t2 = H.setRuntimeTypeInfo([], [S.Extension]);
      t2.push(t1._extensionForSimple$1(simple));
      for (t1 = extenders.get$values(), t1 = t1.get$iterator(t1); t1.moveNext$0();)
        t2.push(t1.get$current(t1));
      return t2;
    }
  };
  F.Extender__extendSimple_closure.prototype = {
    call$1: function(pseudo) {
      var t1 = this.withoutPseudo.call$1(pseudo);
      return t1 == null ? H.setRuntimeTypeInfo([this.$this._extensionForSimple$1(pseudo)], [S.Extension]) : t1;
    }
  };
  F.Extender__extendPseudo_closure.prototype = {
    call$1: function(complex) {
      return complex.components.length > 1;
    }
  };
  F.Extender__extendPseudo_closure0.prototype = {
    call$1: function(complex) {
      return complex.components.length === 1;
    }
  };
  F.Extender__extendPseudo_closure1.prototype = {
    call$1: function(complex) {
      return complex.components.length <= 1;
    }
  };
  F.Extender__extendPseudo_closure2.prototype = {
    call$1: function(complex) {
      var innerPseudo, t2,
        t1 = complex.components;
      if (t1.length !== 1)
        return H.setRuntimeTypeInfo([complex], [S.ComplexSelector]);
      if (!(C.JSArray_methods.get$first(t1) instanceof X.CompoundSelector))
        return H.setRuntimeTypeInfo([complex], [S.ComplexSelector]);
      t1 = H.interceptedTypeCast(C.JSArray_methods.get$first(t1), "$isCompoundSelector").components;
      if (t1.length !== 1)
        return H.setRuntimeTypeInfo([complex], [S.ComplexSelector]);
      if (!(C.JSArray_methods.get$first(t1) instanceof D.PseudoSelector))
        return H.setRuntimeTypeInfo([complex], [S.ComplexSelector]);
      innerPseudo = H.interceptedTypeCast(C.JSArray_methods.get$first(t1), "$isPseudoSelector");
      t1 = innerPseudo.selector;
      if (t1 == null)
        return H.setRuntimeTypeInfo([complex], [S.ComplexSelector]);
      t2 = this.pseudo;
      switch (t2.normalizedName) {
        case "not":
          if (innerPseudo.normalizedName !== "matches")
            return H.setRuntimeTypeInfo([], [S.ComplexSelector]);
          return t1.components;
        case "matches":
        case "any":
        case "current":
        case "nth-child":
        case "nth-last-child":
          if (innerPseudo.name !== t2.name)
            return H.setRuntimeTypeInfo([], [S.ComplexSelector]);
          if (innerPseudo.argument != t2.argument)
            return H.setRuntimeTypeInfo([], [S.ComplexSelector]);
          return t1.components;
        case "has":
        case "host":
        case "host-context":
        case "slotted":
          return H.setRuntimeTypeInfo([complex], [S.ComplexSelector]);
        default:
          return H.setRuntimeTypeInfo([], [S.ComplexSelector]);
      }
    }
  };
  F.Extender__extendPseudo_closure3.prototype = {
    call$1: function(complex) {
      var t1 = this.pseudo;
      return D.PseudoSelector$(t1.name, t1.argument, !t1.isClass, D.SelectorList$(H.setRuntimeTypeInfo([complex], [S.ComplexSelector])));
    }
  };
  F.Extender__trim_closure.prototype = {
    call$1: function(complex2) {
      return complex2.get$minSpecificity() >= this._box_0.maxSpecificity && Y.complexIsSuperselector(complex2.components, this.complex1.components);
    }
  };
  F.Extender__trim_closure0.prototype = {
    call$1: function(complex2) {
      return complex2.get$minSpecificity() >= this._box_0.maxSpecificity && Y.complexIsSuperselector(complex2.components, this.complex1.components);
    }
  };
  F.Extender_clone_closure.prototype = {
    call$2: function(simple, rules) {
      var t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, newRule, mediaContext, _this = this,
        newRules = P.LinkedHashSet_LinkedHashSet(X.ModifiableCssStyleRule);
      _this.newSelectors.$indexSet(0, simple, newRules);
      for (t1 = rules.get$iterator(rules), t2 = B.ModifiableCssNode, t3 = [t2], t2 = [t2], t4 = _this.oldToNewRules, t5 = _this.$this._mediaContexts, t6 = [D.SelectorList], t7 = _this.newMediaContexts; t1.moveNext$0();) {
        t8 = t1.get$current(t1);
        t9 = t8.selector;
        t10 = t9.value;
        t11 = t8.span;
        t12 = t8.originalSelector;
        if (t12 == null)
          t12 = t10;
        t13 = H.setRuntimeTypeInfo([], t3);
        newRule = new X.ModifiableCssStyleRule(new F.ModifiableCssValue(t10, t9.span, t6), t12, t11, new P.UnmodifiableListView(t13, t2), t13);
        newRules.add$1(0, newRule);
        t4.$indexSet(0, t8, newRule);
        mediaContext = t5.$index(0, t8);
        if (mediaContext != null)
          t7.$indexSet(0, newRule, mediaContext);
      }
    }
  };
  S.Extension.prototype = {
    assertCompatibleMediaContext$1: function(mediaContext) {
      var t1 = this.mediaContext;
      if (t1 == null)
        return;
      if (mediaContext != null && C.C_ListEquality.equals$2(t1, mediaContext))
        return;
      throw H.wrapException(E.SassException$("You may not @extend selectors across media queries.", this.span));
    },
    toString$0: function(_) {
      var t1 = H.S(this.extender) + " {@extend " + H.S(this.target);
      return t1 + (this.isOptional ? " !optional" : "") + "}";
    },
    get$target: function() {
      return this.target;
    }
  };
  Y.unifyComplex_closure.prototype = {
    call$1: function(complex) {
      var t1 = J.getInterceptor$asx(complex);
      return t1.sublist$2(complex, 0, t1.get$length(complex) - 1);
    }
  };
  Y._weaveParents_closure.prototype = {
    call$2: function(group1, group2) {
      var unified, t1;
      if (C.C_ListEquality.equals$2(group1, group2))
        return group1;
      if (!(J.get$first$ax(group1) instanceof X.CompoundSelector) || !(J.get$first$ax(group2) instanceof X.CompoundSelector))
        return;
      if (Y.complexIsParentSuperselector(group1, group2))
        return group2;
      if (Y.complexIsParentSuperselector(group2, group1))
        return group1;
      if (!Y._mustUnify(group1, group2))
        return;
      unified = Y.unifyComplex(H.setRuntimeTypeInfo([group1, group2], [[P.List, S.ComplexSelectorComponent]]));
      if (unified == null)
        return;
      t1 = J.getInterceptor$asx(unified);
      if (t1.get$length(unified) > 1)
        return;
      return t1.get$first(unified);
    }
  };
  Y._weaveParents_closure0.prototype = {
    call$1: function(sequence) {
      return Y.complexIsParentSuperselector(sequence.get$first(sequence), this.group);
    }
  };
  Y._weaveParents_closure1.prototype = {
    call$1: function(chunk) {
      return J.expand$1$1$ax(chunk, new Y._weaveParents__closure1(), S.ComplexSelectorComponent);
    }
  };
  Y._weaveParents__closure1.prototype = {
    call$1: function(group) {
      return group;
    }
  };
  Y._weaveParents_closure2.prototype = {
    call$1: function(sequence) {
      return sequence.get$length(sequence) === 0;
    }
  };
  Y._weaveParents_closure3.prototype = {
    call$1: function(chunk) {
      return J.expand$1$1$ax(chunk, new Y._weaveParents__closure0(), S.ComplexSelectorComponent);
    }
  };
  Y._weaveParents__closure0.prototype = {
    call$1: function(group) {
      return group;
    }
  };
  Y._weaveParents_closure4.prototype = {
    call$1: function(choice) {
      return J.get$isNotEmpty$asx(choice);
    }
  };
  Y._weaveParents_closure5.prototype = {
    call$1: function(path) {
      var t1 = J.expand$1$1$ax(path, new Y._weaveParents__closure(), S.ComplexSelectorComponent);
      return P.List_List$from(t1, true, H.getRuntimeTypeArgument(t1, "Iterable", 0));
    }
  };
  Y._weaveParents__closure.prototype = {
    call$1: function(group) {
      return group;
    }
  };
  Y._mustUnify_closure.prototype = {
    call$1: function(component) {
      return component instanceof X.CompoundSelector && C.JSArray_methods.any$1(component.components, new Y._mustUnify__closure(this.uniqueSelectors));
    }
  };
  Y._mustUnify__closure.prototype = {
    call$1: function(simple) {
      var t1 = J.getInterceptor$(simple);
      if (!t1.$isIDSelector)
        t1 = !!t1.$isPseudoSelector && !simple.isClass;
      else
        t1 = true;
      return t1 && this.uniqueSelectors.contains$1(0, simple);
    }
  };
  Y.paths_closure.prototype = {
    call$2: function(paths, choice) {
      var t1 = this.T;
      t1 = J.expand$1$1$ax(choice, new Y.paths__closure(paths, t1), [P.List, t1]);
      return P.List_List$from(t1, true, H.getRuntimeTypeArgument(t1, "Iterable", 0));
    }
  };
  Y.paths__closure.prototype = {
    call$1: function(option) {
      var t1 = this.T;
      return J.map$1$1$ax(this.paths, new Y.paths___closure(option, t1), [P.List, t1]);
    },
    $signature: function() {
      var t1 = this.T;
      return {func: 1, ret: [P.Iterable, [P.List, t1]], args: [t1]};
    }
  };
  Y.paths___closure.prototype = {
    call$1: function(path) {
      var t2,
        t1 = H.setRuntimeTypeInfo([], [this.T]);
      for (t2 = J.get$iterator$ax(path); t2.moveNext$0();)
        t1.push(t2.get$current(t2));
      t1.push(this.option);
      return t1;
    }
  };
  Y._hasRoot_closure.prototype = {
    call$1: function(simple) {
      return simple instanceof D.PseudoSelector && simple.isClass && simple.normalizedName === "root";
    }
  };
  Y.listIsSuperslector_closure.prototype = {
    call$1: function(complex1) {
      return C.JSArray_methods.any$1(this.list1, new Y.listIsSuperslector__closure(complex1));
    }
  };
  Y.listIsSuperslector__closure.prototype = {
    call$1: function(complex2) {
      return Y.complexIsSuperselector(complex2.components, this.complex1.components);
    }
  };
  Y._simpleIsSuperselectorOfCompound_closure.prototype = {
    call$1: function(theirSimple) {
      var t1 = this.simple;
      if (J.$eq$(t1, theirSimple))
        return true;
      if (theirSimple instanceof D.PseudoSelector && theirSimple.selector != null && $._subselectorPseudos.contains$1(0, theirSimple.normalizedName))
        return C.JSArray_methods.every$1(theirSimple.selector.components, new Y._simpleIsSuperselectorOfCompound__closure(t1));
      else
        return false;
    }
  };
  Y._simpleIsSuperselectorOfCompound__closure.prototype = {
    call$1: function(complex) {
      var t1 = complex.components;
      if (t1.length !== 1)
        return false;
      return C.JSArray_methods.contains$1(H.interceptedTypeCast(C.JSArray_methods.get$single(t1), "$isCompoundSelector").components, this.simple);
    }
  };
  Y._selectorPseudoIsSuperselector_closure.prototype = {
    call$1: function(pseudo2) {
      var t1 = pseudo2.selector;
      return Y.listIsSuperslector(this.pseudo1.selector.components, t1.components);
    }
  };
  Y._selectorPseudoIsSuperselector_closure0.prototype = {
    call$1: function(complex1) {
      var t1 = complex1.components,
        t2 = H.setRuntimeTypeInfo([], [S.ComplexSelectorComponent]),
        t3 = this.parents;
      if (t3 != null)
        for (t3 = t3.get$iterator(t3); t3.moveNext$0();)
          t2.push(t3.get$current(t3));
      t2.push(this.compound2);
      return Y.complexIsSuperselector(t1, t2);
    }
  };
  Y._selectorPseudoIsSuperselector_closure1.prototype = {
    call$1: function(pseudo2) {
      var t1 = pseudo2.selector;
      return Y.listIsSuperslector(this.pseudo1.selector.components, t1.components);
    }
  };
  Y._selectorPseudoIsSuperselector_closure2.prototype = {
    call$1: function(complex) {
      return C.JSArray_methods.any$1(this.compound2.components, new Y._selectorPseudoIsSuperselector__closure(complex, this.pseudo1));
    }
  };
  Y._selectorPseudoIsSuperselector__closure.prototype = {
    call$1: function(simple2) {
      var compound1, _this = this,
        t1 = J.getInterceptor$(simple2);
      if (!!t1.$isTypeSelector) {
        compound1 = C.JSArray_methods.get$last(_this.complex.components);
        return compound1 instanceof X.CompoundSelector && C.JSArray_methods.any$1(compound1.components, new Y._selectorPseudoIsSuperselector___closure(simple2));
      } else if (!!t1.$isIDSelector) {
        compound1 = C.JSArray_methods.get$last(_this.complex.components);
        return compound1 instanceof X.CompoundSelector && C.JSArray_methods.any$1(compound1.components, new Y._selectorPseudoIsSuperselector___closure0(simple2));
      } else if (!!t1.$isPseudoSelector && simple2.name === _this.pseudo1.name && simple2.selector != null)
        return Y.listIsSuperslector(simple2.selector.components, H.setRuntimeTypeInfo([_this.complex], [S.ComplexSelector]));
      else
        return false;
    }
  };
  Y._selectorPseudoIsSuperselector___closure.prototype = {
    call$1: function(simple1) {
      var t1;
      if (simple1 instanceof F.TypeSelector) {
        t1 = this.simple2.name.$eq(0, simple1.name);
        t1 = !t1;
      } else
        t1 = false;
      return t1;
    }
  };
  Y._selectorPseudoIsSuperselector___closure0.prototype = {
    call$1: function(simple1) {
      var t1;
      if (simple1 instanceof N.IDSelector) {
        t1 = simple1.name;
        t1 = this.simple2.name !== t1;
      } else
        t1 = false;
      return t1;
    }
  };
  Y._selectorPseudoIsSuperselector_closure3.prototype = {
    call$1: function(pseudo2) {
      return J.$eq$(this.pseudo1.selector, pseudo2.selector);
    }
  };
  Y._selectorPseudoIsSuperselector_closure4.prototype = {
    call$1: function(pseudo2) {
      var t1, t2;
      if (pseudo2 instanceof D.PseudoSelector) {
        t1 = this.pseudo1;
        if (pseudo2.name === t1.name)
          if (pseudo2.argument == t1.argument) {
            t2 = pseudo2.selector;
            t2 = Y.listIsSuperslector(t1.selector.components, t2.components);
            t1 = t2;
          } else
            t1 = false;
        else
          t1 = false;
      } else
        t1 = false;
      return t1;
    }
  };
  Y._selectorPseudosNamed_closure.prototype = {
    call$1: function(pseudo) {
      return pseudo.isClass && pseudo.selector != null && pseudo.name === this.name;
    }
  };
  A.MergedExtension.prototype = {
    unmerge$0: function() {
      var $async$self = this;
      return P._makeSyncStarIterable(function() {
        var $async$goto = 0, $async$handler = 1, $async$currentError, t1;
        return function $async$unmerge$0($async$errorCode, $async$result) {
          if ($async$errorCode === 1) {
            $async$currentError = $async$result;
            $async$goto = $async$handler;
          }
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = $async$self.left;
                $async$goto = !!t1.$isMergedExtension ? 2 : 4;
                break;
              case 2:
                // then
                $async$goto = 5;
                return P._IterationMarker_yieldStar(t1.unmerge$0());
              case 5:
                // after yield
                // goto join
                $async$goto = 3;
                break;
              case 4:
                // else
                $async$goto = 6;
                return t1;
              case 6:
                // after yield
              case 3:
                // join
                $async$goto = 7;
                return $async$self.right;
              case 7:
                // after yield
                // implicit return
                return P._IterationMarker_endOfIteration();
              case 1:
                // rethrow
                return P._IterationMarker_uncaughtError($async$currentError);
            }
        };
      }, S.Extension);
    }
  };
  L.ExtendMode.prototype = {
    toString$0: function(_) {
      return this.name;
    }
  };
  Y.closure37.prototype = {
    call$1: function($arguments) {
      var t1 = J.getInterceptor$asx($arguments);
      return t1.$index($arguments, 0).get$isTruthy() ? t1.$index($arguments, 1) : t1.$index($arguments, 2);
    },
    $signature: 0
  };
  K.closure81.prototype = {
    call$1: function($arguments) {
      return K._rgb("rgb", $arguments);
    },
    $signature: 0
  };
  K.closure82.prototype = {
    call$1: function($arguments) {
      return K._rgb("rgb", $arguments);
    },
    $signature: 0
  };
  K.closure83.prototype = {
    call$1: function($arguments) {
      return K._rgbTwoArg("rgb", $arguments);
    },
    $signature: 0
  };
  K.closure84.prototype = {
    call$1: function($arguments) {
      var parsed = K._parseChannels("rgb", H.setRuntimeTypeInfo(["$red", "$green", "$blue"], [P.String]), J.get$first$ax($arguments));
      return parsed instanceof D.SassString ? parsed : K._rgb("rgb", H.subtypeCast(parsed, "$isList", [F.Value], "$asList"));
    },
    $signature: 0
  };
  K.closure85.prototype = {
    call$1: function($arguments) {
      return K._rgb("rgba", $arguments);
    },
    $signature: 0
  };
  K.closure86.prototype = {
    call$1: function($arguments) {
      return K._rgb("rgba", $arguments);
    },
    $signature: 0
  };
  K.closure87.prototype = {
    call$1: function($arguments) {
      return K._rgbTwoArg("rgba", $arguments);
    },
    $signature: 0
  };
  K.closure88.prototype = {
    call$1: function($arguments) {
      var parsed = K._parseChannels("rgba", H.setRuntimeTypeInfo(["$red", "$green", "$blue"], [P.String]), J.get$first$ax($arguments));
      return parsed instanceof D.SassString ? parsed : K._rgb("rgba", H.subtypeCast(parsed, "$isList", [F.Value], "$asList"));
    },
    $signature: 0
  };
  K.closure89.prototype = {
    call$1: function($arguments) {
      var color, t2,
        t1 = J.getInterceptor$asx($arguments),
        weight = t1.$index($arguments, 1).assertNumber$1("weight");
      if (t1.$index($arguments, 0) instanceof T.SassNumber) {
        if (weight.value !== 100 || !weight.hasUnit$1("%"))
          throw H.wrapException("Only one argument may be passed to the plain-CSS invert() function.");
        return K._functionString("invert", t1.take$1($arguments, 1));
      }
      color = t1.$index($arguments, 0).assertColor$1("color");
      t1 = color.get$red();
      t2 = color.get$green();
      return K._mixColors(color.changeRgb$3$blue$green$red(255 - color.get$blue(), 255 - t2, 255 - t1), color, weight);
    },
    $signature: 0
  };
  K.closure90.prototype = {
    call$1: function($arguments) {
      return K._hsl("hsl", $arguments);
    },
    $signature: 0
  };
  K.closure91.prototype = {
    call$1: function($arguments) {
      return K._hsl("hsl", $arguments);
    },
    $signature: 0
  };
  K.closure92.prototype = {
    call$1: function($arguments) {
      var t1 = J.getInterceptor$asx($arguments);
      if (t1.$index($arguments, 0).get$isVar() || t1.$index($arguments, 1).get$isVar())
        return K._functionString("hsl", $arguments);
      else
        throw H.wrapException(E.SassScriptException$("Missing argument $lightness."));
    },
    $signature: 2
  };
  K.closure93.prototype = {
    call$1: function($arguments) {
      var parsed = K._parseChannels("hsl", H.setRuntimeTypeInfo(["$hue", "$saturation", "$lightness"], [P.String]), J.get$first$ax($arguments));
      return parsed instanceof D.SassString ? parsed : K._hsl("hsl", H.subtypeCast(parsed, "$isList", [F.Value], "$asList"));
    },
    $signature: 0
  };
  K.closure94.prototype = {
    call$1: function($arguments) {
      return K._hsl("hsla", $arguments);
    },
    $signature: 0
  };
  K.closure95.prototype = {
    call$1: function($arguments) {
      return K._hsl("hsla", $arguments);
    },
    $signature: 0
  };
  K.closure96.prototype = {
    call$1: function($arguments) {
      var t1 = J.getInterceptor$asx($arguments);
      if (t1.$index($arguments, 0).get$isVar() || t1.$index($arguments, 1).get$isVar())
        return K._functionString("hsla", $arguments);
      else
        throw H.wrapException(E.SassScriptException$("Missing argument $lightness."));
    },
    $signature: 2
  };
  K.closure97.prototype = {
    call$1: function($arguments) {
      var parsed = K._parseChannels("hsla", H.setRuntimeTypeInfo(["$hue", "$saturation", "$lightness"], [P.String]), J.get$first$ax($arguments));
      return parsed instanceof D.SassString ? parsed : K._hsl("hsla", H.subtypeCast(parsed, "$isList", [F.Value], "$asList"));
    },
    $signature: 0
  };
  K.closure98.prototype = {
    call$1: function($arguments) {
      var t1 = J.getInterceptor$asx($arguments);
      if (t1.$index($arguments, 0) instanceof T.SassNumber)
        return K._functionString("grayscale", $arguments);
      return t1.$index($arguments, 0).assertColor$1("color").changeHsl$1$saturation(0);
    },
    $signature: 0
  };
  K.closure99.prototype = {
    call$1: function($arguments) {
      var t1 = J.getInterceptor$asx($arguments),
        color = t1.$index($arguments, 0).assertColor$1("color"),
        amount = t1.$index($arguments, 1).assertNumber$1("amount");
      return color.changeHsl$1$lightness(C.JSNumber_methods.clamp$2(color.get$lightness() + amount.valueInRange$3(0, 100, "amount"), 0, 100));
    },
    $signature: 5
  };
  K.closure100.prototype = {
    call$1: function($arguments) {
      var t1 = J.getInterceptor$asx($arguments),
        color = t1.$index($arguments, 0).assertColor$1("color"),
        amount = t1.$index($arguments, 1).assertNumber$1("amount");
      return color.changeHsl$1$lightness(C.JSNumber_methods.clamp$2(color.get$lightness() - amount.valueInRange$3(0, 100, "amount"), 0, 100));
    },
    $signature: 5
  };
  K.closure101.prototype = {
    call$1: function($arguments) {
      return new D.SassString("saturate(" + N.serializeValue(J.$index$asx($arguments, 0).assertNumber$1("amount"), false, true) + ")", false);
    },
    $signature: 2
  };
  K.closure102.prototype = {
    call$1: function($arguments) {
      var t1 = J.getInterceptor$asx($arguments),
        color = t1.$index($arguments, 0).assertColor$1("color"),
        amount = t1.$index($arguments, 1).assertNumber$1("amount");
      return color.changeHsl$1$saturation(C.JSNumber_methods.clamp$2(color.get$saturation() + amount.valueInRange$3(0, 100, "amount"), 0, 100));
    },
    $signature: 5
  };
  K.closure103.prototype = {
    call$1: function($arguments) {
      var t1 = J.getInterceptor$asx($arguments),
        color = t1.$index($arguments, 0).assertColor$1("color"),
        amount = t1.$index($arguments, 1).assertNumber$1("amount");
      return color.changeHsl$1$saturation(C.JSNumber_methods.clamp$2(color.get$saturation() - amount.valueInRange$3(0, 100, "amount"), 0, 100));
    },
    $signature: 5
  };
  K.closure104.prototype = {
    call$1: function($arguments) {
      var color,
        argument = J.$index$asx($arguments, 0);
      if (argument instanceof D.SassString && !argument.hasQuotes && J.contains$1$asx(argument.text, $.$get$_microsoftFilterStart()))
        return K._functionString("alpha", $arguments);
      color = argument.assertColor$1("color");
      return new T.SassNumber(color.alpha, C.List_empty0, C.List_empty0, null);
    },
    $signature: 0
  };
  K.closure105.prototype = {
    call$1: function($arguments) {
      var t1,
        argList = J.$index$asx($arguments, 0).get$asList();
      if (argList.length !== 0 && C.JSArray_methods.every$1(argList, new K._closure17()))
        return K._functionString("alpha", $arguments);
      t1 = argList.length;
      if (t1 === 0)
        throw H.wrapException(E.SassScriptException$("Missing argument $color."));
      else
        throw H.wrapException(E.SassScriptException$("Only 1 argument allowed, but " + t1 + " were passed."));
    },
    $signature: 2
  };
  K._closure17.prototype = {
    call$1: function(argument) {
      return argument instanceof D.SassString && !argument.hasQuotes && J.contains$1$asx(argument.text, $.$get$_microsoftFilterStart());
    }
  };
  K.closure106.prototype = {
    call$1: function($arguments) {
      var color,
        t1 = J.getInterceptor$asx($arguments);
      if (t1.$index($arguments, 0) instanceof T.SassNumber)
        return K._functionString("opacity", $arguments);
      color = t1.$index($arguments, 0).assertColor$1("color");
      return new T.SassNumber(color.alpha, C.List_empty0, C.List_empty0, null);
    },
    $signature: 0
  };
  K.closure120.prototype = {
    call$1: function($arguments) {
      var result, color, t2,
        t1 = J.getInterceptor$asx($arguments),
        weight = t1.$index($arguments, 1).assertNumber$1("weight");
      if (t1.$index($arguments, 0) instanceof T.SassNumber) {
        if (weight.value !== 100 || !weight.hasUnit$1("%"))
          throw H.wrapException("Only one argument may be passed to the plain-CSS invert() function.");
        result = K._functionString("invert", t1.take$1($arguments, 1));
        N.warn("Passing a number to color.invert() is deprecated.\n\nRecommendation: " + result.toString$0(0), false);
        return result;
      }
      color = t1.$index($arguments, 0).assertColor$1("color");
      t1 = color.get$red();
      t2 = color.get$green();
      return K._mixColors(color.changeRgb$3$blue$green$red(255 - color.get$blue(), 255 - t2, 255 - t1), color, weight);
    },
    $signature: 0
  };
  K.closure121.prototype = {
    call$1: function($arguments) {
      var result,
        t1 = J.getInterceptor$asx($arguments);
      if (t1.$index($arguments, 0) instanceof T.SassNumber) {
        result = K._functionString("grayscale", t1.take$1($arguments, 1));
        N.warn("Passing a number to color.grayscale() is deprecated.\n\nRecommendation: " + result.toString$0(0), false);
        return result;
      }
      return t1.$index($arguments, 0).assertColor$1("color").changeHsl$1$saturation(0);
    },
    $signature: 0
  };
  K.closure122.prototype = {
    call$1: function($arguments) {
      var result, color,
        argument = J.$index$asx($arguments, 0);
      if (argument instanceof D.SassString && !argument.hasQuotes && J.contains$1$asx(argument.text, $.$get$_microsoftFilterStart())) {
        result = K._functionString("alpha", $arguments);
        N.warn("Using color.alpha() for a Microsoft filter is deprecated.\n\nRecommendation: " + result.toString$0(0), false);
        return result;
      }
      color = argument.assertColor$1("color");
      return new T.SassNumber(color.alpha, C.List_empty0, C.List_empty0, null);
    },
    $signature: 0
  };
  K.closure123.prototype = {
    call$1: function($arguments) {
      var result,
        t1 = J.getInterceptor$asx($arguments);
      if (C.JSArray_methods.every$1(t1.$index($arguments, 0).get$asList(), new K._closure18())) {
        result = K._functionString("alpha", $arguments);
        N.warn("Using color.alpha() for a Microsoft filter is deprecated.\n\nRecommendation: " + result.toString$0(0), false);
        return result;
      }
      throw H.wrapException(E.SassScriptException$("Only 1 argument allowed, but " + t1.get$length($arguments) + " were passed."));
    },
    $signature: 2
  };
  K._closure18.prototype = {
    call$1: function(argument) {
      return argument instanceof D.SassString && !argument.hasQuotes && J.contains$1$asx(argument.text, $.$get$_microsoftFilterStart());
    }
  };
  K.closure124.prototype = {
    call$1: function($arguments) {
      var result, color,
        t1 = J.getInterceptor$asx($arguments);
      if (t1.$index($arguments, 0) instanceof T.SassNumber) {
        result = K._functionString("opacity", $arguments);
        N.warn("Passing a number to color.opacity() is deprecated.\n\nRecommendation: " + result.toString$0(0), false);
        return result;
      }
      color = t1.$index($arguments, 0).assertColor$1("color");
      return new T.SassNumber(color.alpha, C.List_empty0, C.List_empty0, null);
    },
    $signature: 0
  };
  K.closure119.prototype = {
    call$1: function($arguments) {
      var t1 = J.get$first$ax($arguments).assertColor$1("color").get$red();
      return new T.SassNumber(t1, C.List_empty0, C.List_empty0, null);
    },
    $signature: 4
  };
  K.closure118.prototype = {
    call$1: function($arguments) {
      var t1 = J.get$first$ax($arguments).assertColor$1("color").get$green();
      return new T.SassNumber(t1, C.List_empty0, C.List_empty0, null);
    },
    $signature: 4
  };
  K.closure117.prototype = {
    call$1: function($arguments) {
      var t1 = J.get$first$ax($arguments).assertColor$1("color").get$blue();
      return new T.SassNumber(t1, C.List_empty0, C.List_empty0, null);
    },
    $signature: 4
  };
  K.closure116.prototype = {
    call$1: function($arguments) {
      var t1 = J.getInterceptor$asx($arguments);
      return K._mixColors(t1.$index($arguments, 0).assertColor$1("color1"), t1.$index($arguments, 1).assertColor$1("color2"), t1.$index($arguments, 2).assertNumber$1("weight"));
    },
    $signature: 5
  };
  K.closure115.prototype = {
    call$1: function($arguments) {
      var t1 = J.get$first$ax($arguments).assertColor$1("color").get$hue(),
        t2 = P.String,
        t3 = H.setRuntimeTypeInfo(["deg"], [t2]);
      t2 = P.List_List$unmodifiable(t3, t2);
      return new T.SassNumber(t1, t2, C.List_empty0, null);
    },
    $signature: 4
  };
  K.closure114.prototype = {
    call$1: function($arguments) {
      var t1 = J.get$first$ax($arguments).assertColor$1("color").get$saturation(),
        t2 = P.String,
        t3 = H.setRuntimeTypeInfo(["%"], [t2]);
      t2 = P.List_List$unmodifiable(t3, t2);
      return new T.SassNumber(t1, t2, C.List_empty0, null);
    },
    $signature: 4
  };
  K.closure113.prototype = {
    call$1: function($arguments) {
      var t1 = J.get$first$ax($arguments).assertColor$1("color").get$lightness(),
        t2 = P.String,
        t3 = H.setRuntimeTypeInfo(["%"], [t2]);
      t2 = P.List_List$unmodifiable(t3, t2);
      return new T.SassNumber(t1, t2, C.List_empty0, null);
    },
    $signature: 4
  };
  K.closure112.prototype = {
    call$1: function($arguments) {
      var t1 = J.getInterceptor$asx($arguments),
        color = t1.$index($arguments, 0).assertColor$1("color"),
        degrees = t1.$index($arguments, 1).assertNumber$1("degrees");
      return color.changeHsl$1$hue(color.get$hue() + degrees.value);
    },
    $signature: 5
  };
  K.closure111.prototype = {
    call$1: function($arguments) {
      var color = J.$index$asx($arguments, 0).assertColor$1("color");
      return color.changeHsl$1$hue(color.get$hue() + 180);
    },
    $signature: 5
  };
  K.closure109.prototype = {
    call$1: function($arguments) {
      var keywords, t2, red, green, blue, hue, saturation, lightness, alpha, hasRgb, hasHsl, t3, t4, t5, _null = null,
        t1 = J.getInterceptor$asx($arguments),
        color = t1.$index($arguments, 0).assertColor$1("color"),
        argumentList = H.interceptedTypeCast(t1.$index($arguments, 1), "$isSassArgumentList");
      if (argumentList._list$_contents.length !== 0)
        throw H.wrapException(E.SassScriptException$("Only one positional argument is allowed. All other arguments must be passed by name."));
      argumentList._wereKeywordsAccessed = true;
      keywords = P.LinkedHashMap_LinkedHashMap$of(argumentList._keywords, P.String, F.Value);
      t1 = new K.closure_getInRange0(keywords);
      t2 = t1.call$3("red", -255, 255);
      red = t2 == null ? _null : T.fuzzyRound(t2);
      t2 = t1.call$3("green", -255, 255);
      green = t2 == null ? _null : T.fuzzyRound(t2);
      t2 = t1.call$3("blue", -255, 255);
      blue = t2 == null ? _null : T.fuzzyRound(t2);
      t2 = keywords.remove$1(0, "hue");
      t2 = t2 == null ? _null : t2.assertNumber$1("hue");
      hue = t2 == null ? _null : t2.value;
      saturation = t1.call$3("saturation", -100, 100);
      lightness = t1.call$3("lightness", -100, 100);
      alpha = t1.call$3("alpha", -1, 1);
      if (keywords.get$isNotEmpty(keywords))
        throw H.wrapException(E.SassScriptException$("No " + B.pluralize("argument", keywords.get$length(keywords), _null) + " named " + H.S(B.toSentence(keywords.get$keys().map$1$1(0, new K._closure16(), P.Object), "or")) + "."));
      t1 = red == null;
      hasRgb = !t1 || green != null || blue != null;
      t2 = hue == null;
      hasHsl = !t2 || saturation != null || lightness != null;
      if (hasRgb) {
        if (hasHsl)
          throw H.wrapException(E.SassScriptException$("RGB parameters may not be passed along with HSL parameters."));
        t2 = color.get$red();
        t2 = H.intTypeCast(C.JSInt_methods.clamp$2(t2 + (t1 ? 0 : red), 0, 255));
        t3 = color.get$green();
        t1 = H.intTypeCast(C.JSInt_methods.clamp$2(t3 + (green == null ? 0 : green), 0, 255));
        t3 = color.get$blue();
        t3 = H.intTypeCast(C.JSInt_methods.clamp$2(t3 + (blue == null ? 0 : blue), 0, 255));
        t4 = alpha == null ? 0 : alpha;
        return color.changeRgb$4$alpha$blue$green$red(C.JSNumber_methods.clamp$2(color.alpha + t4, 0, 1), t3, t1, t2);
      } else if (hasHsl) {
        t1 = color.get$hue();
        t2 = t2 ? 0 : hue;
        t3 = color.get$saturation();
        t3 = C.JSNumber_methods.clamp$2(t3 + (saturation == null ? 0 : saturation), 0, 100);
        t4 = color.get$lightness();
        t4 = C.JSNumber_methods.clamp$2(t4 + (lightness == null ? 0 : lightness), 0, 100);
        t5 = alpha == null ? 0 : alpha;
        return color.changeHsl$4$alpha$hue$lightness$saturation(C.JSNumber_methods.clamp$2(color.alpha + t5, 0, 1), t1 + t2, t4, t3);
      } else if (alpha != null)
        return color.changeAlpha$1(C.JSNumber_methods.clamp$2(color.alpha + alpha, 0, 1));
      else
        return color;
    },
    $signature: 5
  };
  K.closure_getInRange0.prototype = {
    call$3: function($name, min, max) {
      var t1 = this.keywords.remove$1(0, $name);
      t1 = t1 == null ? null : t1.assertNumber$1($name);
      return t1 == null ? null : t1.valueInRange$3(min, max, $name);
    }
  };
  K._closure16.prototype = {
    call$1: function($name) {
      return "$" + H.S($name);
    }
  };
  K.closure108.prototype = {
    call$1: function($arguments) {
      var keywords, t2, red, green, blue, saturation, lightness, alpha, hasRgb, hasHsl, t3, t4,
        t1 = J.getInterceptor$asx($arguments),
        color = t1.$index($arguments, 0).assertColor$1("color"),
        argumentList = H.interceptedTypeCast(t1.$index($arguments, 1), "$isSassArgumentList");
      if (argumentList._list$_contents.length !== 0)
        throw H.wrapException(E.SassScriptException$("Only one positional argument is allowed. All other arguments must be passed by name."));
      argumentList._wereKeywordsAccessed = true;
      keywords = P.LinkedHashMap_LinkedHashMap$of(argumentList._keywords, P.String, F.Value);
      t1 = new K.closure_getScale(keywords);
      t2 = new K.closure_scaleValue();
      red = t1.call$1("red");
      green = t1.call$1("green");
      blue = t1.call$1("blue");
      saturation = t1.call$1("saturation");
      lightness = t1.call$1("lightness");
      alpha = t1.call$1("alpha");
      if (keywords.get$isNotEmpty(keywords))
        throw H.wrapException(E.SassScriptException$("No " + B.pluralize("argument", keywords.get$length(keywords), null) + " named " + H.S(B.toSentence(keywords.get$keys().map$1$1(0, new K._closure15(), P.Object), "or")) + "."));
      hasRgb = red != null || green != null || blue != null;
      hasHsl = saturation != null || lightness != null;
      if (hasRgb) {
        if (hasHsl)
          throw H.wrapException(E.SassScriptException$("RGB parameters may not be passed along with HSL parameters."));
        t1 = T.fuzzyRound(t2.call$3(color.get$red(), red, 255));
        t3 = T.fuzzyRound(t2.call$3(color.get$green(), green, 255));
        t4 = T.fuzzyRound(t2.call$3(color.get$blue(), blue, 255));
        return color.changeRgb$4$alpha$blue$green$red(t2.call$3(color.alpha, alpha, 1), t4, t3, t1);
      } else if (hasHsl) {
        t1 = t2.call$3(color.get$saturation(), saturation, 100);
        t3 = t2.call$3(color.get$lightness(), lightness, 100);
        return color.changeHsl$3$alpha$lightness$saturation(t2.call$3(color.alpha, alpha, 1), t3, t1);
      } else if (alpha != null)
        return color.changeAlpha$1(t2.call$3(color.alpha, alpha, 1));
      else
        return color;
    },
    $signature: 5
  };
  K.closure_getScale.prototype = {
    call$1: function($name) {
      var number,
        value = this.keywords.remove$1(0, $name);
      if (value == null)
        return;
      number = value.assertNumber$1($name);
      number.assertUnit$2("%", $name);
      return number.valueInRange$3(-100, 100, $name) / 100;
    }
  };
  K.closure_scaleValue.prototype = {
    call$3: function(current, scale, max) {
      if (scale == null)
        return current;
      return current + (scale > 0 ? max - current : current) * scale;
    }
  };
  K._closure15.prototype = {
    call$1: function($name) {
      return "$" + H.S($name);
    }
  };
  K.closure107.prototype = {
    call$1: function($arguments) {
      var keywords, t2, red, green, blue, hue, saturation, lightness, alpha, hasRgb, hasHsl, _null = null,
        t1 = J.getInterceptor$asx($arguments),
        color = t1.$index($arguments, 0).assertColor$1("color"),
        argumentList = H.interceptedTypeCast(t1.$index($arguments, 1), "$isSassArgumentList");
      if (argumentList._list$_contents.length !== 0)
        throw H.wrapException(E.SassScriptException$("Only one positional argument is allowed. All other arguments must be passed by name."));
      argumentList._wereKeywordsAccessed = true;
      keywords = P.LinkedHashMap_LinkedHashMap$of(argumentList._keywords, P.String, F.Value);
      t1 = new K.closure_getInRange(keywords);
      t2 = t1.call$3("red", 0, 255);
      red = t2 == null ? _null : T.fuzzyRound(t2);
      t2 = t1.call$3("green", 0, 255);
      green = t2 == null ? _null : T.fuzzyRound(t2);
      t2 = t1.call$3("blue", 0, 255);
      blue = t2 == null ? _null : T.fuzzyRound(t2);
      t2 = keywords.remove$1(0, "hue");
      t2 = t2 == null ? _null : t2.assertNumber$1("hue");
      hue = t2 == null ? _null : t2.value;
      saturation = t1.call$3("saturation", 0, 100);
      lightness = t1.call$3("lightness", 0, 100);
      alpha = t1.call$3("alpha", 0, 1);
      if (keywords.get$isNotEmpty(keywords))
        throw H.wrapException(E.SassScriptException$("No " + B.pluralize("argument", keywords.get$length(keywords), _null) + " named " + H.S(B.toSentence(keywords.get$keys().map$1$1(0, new K._closure14(), P.Object), "or")) + "."));
      hasRgb = red != null || green != null || blue != null;
      hasHsl = hue != null || saturation != null || lightness != null;
      if (hasRgb) {
        if (hasHsl)
          throw H.wrapException(E.SassScriptException$("RGB parameters may not be passed along with HSL parameters."));
        return color.changeRgb$4$alpha$blue$green$red(alpha, blue, green, red);
      } else if (hasHsl)
        return color.changeHsl$4$alpha$hue$lightness$saturation(alpha, hue, lightness, saturation);
      else if (alpha != null)
        return color.changeAlpha$1(alpha);
      else
        return color;
    },
    $signature: 5
  };
  K.closure_getInRange.prototype = {
    call$3: function($name, min, max) {
      var t1 = this.keywords.remove$1(0, $name);
      t1 = t1 == null ? null : t1.assertNumber$1($name);
      return t1 == null ? null : t1.valueInRange$3(min, max, $name);
    }
  };
  K._closure14.prototype = {
    call$1: function($name) {
      return "$" + H.S($name);
    }
  };
  K.closure110.prototype = {
    call$1: function($arguments) {
      var color = J.$index$asx($arguments, 0).assertColor$1("color"),
        t1 = new K.closure_hexString();
      return new D.SassString("#" + H.S(t1.call$1(T.fuzzyRound(color.alpha * 255))) + H.S(t1.call$1(color.get$red())) + H.S(t1.call$1(color.get$green())) + H.S(t1.call$1(color.get$blue())), false);
    },
    $signature: 2
  };
  K.closure_hexString.prototype = {
    call$1: function(component) {
      return C.JSString_methods.padLeft$2(J.toRadixString$1$n(component, 16), 2, "0").toUpperCase();
    },
    $signature: 20
  };
  K._functionString_closure.prototype = {
    call$1: function(argument) {
      argument.toString;
      return N.serializeValue(argument, false, true);
    }
  };
  K._removedColorFunction_closure.prototype = {
    call$1: function($arguments) {
      var t1 = this.name,
        t2 = J.getInterceptor$asx($arguments),
        t3 = "The function " + t1 + "() isn't in the new module system.\n\nRecommendation: color.adjust(" + H.S(t2.$index($arguments, 0)) + ", $" + this.argument + ": ";
      throw H.wrapException(E.SassScriptException$(t3 + (this.negative ? "-" : "") + H.S(t2.$index($arguments, 1)) + ")\n\nMore info: https://sass-lang.com/documentation/functions/color#" + t1));
    },
    $signature: 48
  };
  K._parseChannels_closure.prototype = {
    call$1: function(value) {
      return value.get$isVar();
    }
  };
  D.closure80.prototype = {
    call$1: function($arguments) {
      var t1 = J.$index$asx($arguments, 0).get$asList().length;
      return new T.SassNumber(t1, C.List_empty0, C.List_empty0, null);
    },
    $signature: 4
  };
  D.closure79.prototype = {
    call$1: function($arguments) {
      var t1 = J.getInterceptor$asx($arguments),
        list = t1.$index($arguments, 0),
        index = t1.$index($arguments, 1);
      return list.get$asList()[list.sassIndexToListIndex$2(index, "n")];
    },
    $signature: 0
  };
  D.closure78.prototype = {
    call$1: function($arguments) {
      var t1 = J.getInterceptor$asx($arguments),
        list = t1.$index($arguments, 0),
        index = t1.$index($arguments, 1),
        value = t1.$index($arguments, 2),
        t2 = list.get$asList(),
        newList = H.setRuntimeTypeInfo(t2.slice(0), [H.getTypeArgumentByIndex(t2, 0)]);
      newList[list.sassIndexToListIndex$2(index, "n")] = value;
      return t1.$index($arguments, 0).changeListContents$1(newList);
    },
    $signature: 6
  };
  D.closure77.prototype = {
    call$1: function($arguments) {
      var separator, bracketed, t2, t3, _i,
        t1 = J.getInterceptor$asx($arguments),
        list1 = t1.$index($arguments, 0),
        list2 = t1.$index($arguments, 1),
        separatorParam = t1.$index($arguments, 2).assertString$1("separator"),
        bracketedParam = t1.$index($arguments, 3);
      t1 = separatorParam.text;
      if (t1 === "auto")
        if (list1.get$separator() !== C.ListSeparator_undecided)
          separator = list1.get$separator();
        else
          separator = list2.get$separator() !== C.ListSeparator_undecided ? list2.get$separator() : C.ListSeparator_space;
      else if (t1 === "space")
        separator = C.ListSeparator_space;
      else {
        if (t1 !== "comma")
          throw H.wrapException(E.SassScriptException$('$separator: Must be "space", "comma", or "auto".'));
        separator = C.ListSeparator_comma;
      }
      bracketed = bracketedParam instanceof D.SassString && bracketedParam.text === "auto" ? list1.get$hasBrackets() : bracketedParam.get$isTruthy();
      t1 = H.setRuntimeTypeInfo([], [F.Value]);
      for (t2 = list1.get$asList(), t3 = t2.length, _i = 0; _i < t2.length; t2.length === t3 || (0, H.throwConcurrentModificationError)(t2), ++_i)
        t1.push(t2[_i]);
      for (t2 = list2.get$asList(), t3 = t2.length, _i = 0; _i < t2.length; t2.length === t3 || (0, H.throwConcurrentModificationError)(t2), ++_i)
        t1.push(t2[_i]);
      return D.SassList$(t1, separator, bracketed);
    },
    $signature: 6
  };
  D.closure76.prototype = {
    call$1: function($arguments) {
      var separator, t2, t3, _i,
        t1 = J.getInterceptor$asx($arguments),
        list = t1.$index($arguments, 0),
        value = t1.$index($arguments, 1);
      t1 = t1.$index($arguments, 2).assertString$1("separator").text;
      if (t1 === "auto")
        separator = list.get$separator() === C.ListSeparator_undecided ? C.ListSeparator_space : list.get$separator();
      else if (t1 === "space")
        separator = C.ListSeparator_space;
      else {
        if (t1 !== "comma")
          throw H.wrapException(E.SassScriptException$('$separator: Must be "space", "comma", or "auto".'));
        separator = C.ListSeparator_comma;
      }
      t1 = H.setRuntimeTypeInfo([], [F.Value]);
      for (t2 = list.get$asList(), t3 = t2.length, _i = 0; _i < t2.length; t2.length === t3 || (0, H.throwConcurrentModificationError)(t2), ++_i)
        t1.push(t2[_i]);
      t1.push(value);
      return list.changeListContents$2$separator(t1, separator);
    },
    $signature: 6
  };
  D.closure75.prototype = {
    call$1: function($arguments) {
      var results, t2, result, _box_0 = {},
        t1 = J.$index$asx($arguments, 0).get$asList(),
        lists = new H.MappedListIterable(t1, new D._closure11(), [H.getTypeArgumentByIndex(t1, 0), [P.List, F.Value]]).toList$0(0);
      if (lists.length === 0)
        return C.SassList_lmy;
      _box_0.i = 0;
      results = H.setRuntimeTypeInfo([], [D.SassList]);
      for (t1 = F.Value, t2 = [H.getTypeArgumentByIndex(lists, 0), t1]; C.JSArray_methods.every$1(lists, new D._closure12(_box_0));) {
        result = P.List_List$from(new H.MappedListIterable(lists, new D._closure13(_box_0), t2), false, t1);
        result.fixed$length = Array;
        result.immutable$list = Array;
        results.push(new D.SassList(result, C.ListSeparator_space, false));
        ++_box_0.i;
      }
      return D.SassList$(results, C.ListSeparator_comma, false);
    },
    $signature: 6
  };
  D._closure11.prototype = {
    call$1: function(list) {
      return list.get$asList();
    }
  };
  D._closure12.prototype = {
    call$1: function(list) {
      return this._box_0.i !== J.get$length$asx(list);
    }
  };
  D._closure13.prototype = {
    call$1: function(list) {
      return J.$index$asx(list, this._box_0.i);
    },
    $signature: 0
  };
  D.closure74.prototype = {
    call$1: function($arguments) {
      var t1 = J.getInterceptor$asx($arguments),
        index = C.JSArray_methods.indexOf$1(t1.$index($arguments, 0).get$asList(), t1.$index($arguments, 1));
      if (index === -1)
        t1 = C.C_SassNull;
      else
        t1 = new T.SassNumber(index + 1, C.List_empty0, C.List_empty0, null);
      return t1;
    },
    $signature: 0
  };
  D.closure72.prototype = {
    call$1: function($arguments) {
      return J.$index$asx($arguments, 0).get$separator() === C.ListSeparator_comma ? new D.SassString("comma", false) : new D.SassString("space", false);
    },
    $signature: 2
  };
  D.closure73.prototype = {
    call$1: function($arguments) {
      return J.$index$asx($arguments, 0).get$hasBrackets() ? C.SassBoolean_true : C.SassBoolean_false;
    },
    $signature: 3
  };
  A.closure71.prototype = {
    call$1: function($arguments) {
      var t1 = J.getInterceptor$asx($arguments);
      t1 = t1.$index($arguments, 0).assertMap$1("map").contents.$index(0, t1.$index($arguments, 1));
      return t1 == null ? C.C_SassNull : t1;
    },
    $signature: 0
  };
  A.closure70.prototype = {
    call$1: function($arguments) {
      var t2, t3, t4,
        t1 = J.getInterceptor$asx($arguments),
        map1 = t1.$index($arguments, 0).assertMap$1("map1"),
        map2 = t1.$index($arguments, 1).assertMap$1("map2");
      t1 = F.Value;
      t2 = P.LinkedHashMap_LinkedHashMap$_empty(t1, t1);
      for (t3 = map1.contents.get$entries(), t3 = t3.get$iterator(t3); t3.moveNext$0();) {
        t4 = t3.get$current(t3);
        t2.$indexSet(0, t4.key, t4.value);
      }
      for (t3 = map2.contents.get$entries(), t3 = t3.get$iterator(t3); t3.moveNext$0();) {
        t4 = t3.get$current(t3);
        t2.$indexSet(0, t4.key, t4.value);
      }
      return new A.SassMap(H.ConstantMap_ConstantMap$from(t2, t1, t1));
    },
    $signature: 9
  };
  A.closure68.prototype = {
    call$1: function($arguments) {
      return J.$index$asx($arguments, 0).assertMap$1("map");
    },
    $signature: 9
  };
  A.closure69.prototype = {
    call$1: function($arguments) {
      var t4, _i, mutableMap,
        t1 = J.getInterceptor$asx($arguments),
        map = t1.$index($arguments, 0).assertMap$1("map"),
        t2 = F.Value,
        t3 = H.setRuntimeTypeInfo([], [t2]);
      t3.push(t1.$index($arguments, 1));
      for (t1 = t1.$index($arguments, 2).get$asList(), t4 = t1.length, _i = 0; _i < t1.length; t1.length === t4 || (0, H.throwConcurrentModificationError)(t1), ++_i)
        t3.push(t1[_i]);
      mutableMap = P.LinkedHashMap_LinkedHashMap$of(map.contents, t2, t2);
      for (t1 = t3.length, _i = 0; _i < t3.length; t3.length === t1 || (0, H.throwConcurrentModificationError)(t3), ++_i)
        mutableMap.remove$1(0, t3[_i]);
      return new A.SassMap(H.ConstantMap_ConstantMap$from(mutableMap, t2, t2));
    },
    $signature: 9
  };
  A.closure67.prototype = {
    call$1: function($arguments) {
      return D.SassList$(J.$index$asx($arguments, 0).assertMap$1("map").contents.get$keys(), C.ListSeparator_comma, false);
    },
    $signature: 6
  };
  A.closure66.prototype = {
    call$1: function($arguments) {
      return D.SassList$(J.$index$asx($arguments, 0).assertMap$1("map").contents.get$values(), C.ListSeparator_comma, false);
    },
    $signature: 6
  };
  A.closure65.prototype = {
    call$1: function($arguments) {
      var t1 = J.getInterceptor$asx($arguments);
      return t1.$index($arguments, 0).assertMap$1("map").contents.containsKey$1(t1.$index($arguments, 1)) ? C.SassBoolean_true : C.SassBoolean_false;
    },
    $signature: 3
  };
  K.closure57.prototype = {
    call$1: function($arguments) {
      var t1, t2,
        number = J.$index$asx($arguments, 0).assertNumber$1("number");
      number.assertNoUnits$1("number");
      t1 = P.String;
      t2 = H.setRuntimeTypeInfo(["%"], [t1]);
      t1 = P.List_List$unmodifiable(t2, t1);
      return new T.SassNumber(number.value * 100, t1, C.List_empty0, null);
    },
    $signature: 4
  };
  K.closure64.prototype = {
    call$1: function(value) {
      return J.ceil$0$n(value);
    },
    $signature: 24
  };
  K.closure63.prototype = {
    call$1: function(value) {
      return J.floor$0$n(value);
    },
    $signature: 24
  };
  K.closure62.prototype = {
    call$1: function(value) {
      return Math.abs(value);
    },
    $signature: 77
  };
  K.closure61.prototype = {
    call$1: function($arguments) {
      var t1, t2, max, _i, number;
      for (t1 = J.$index$asx($arguments, 0).get$asList(), t2 = t1.length, max = null, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
        number = t1[_i].assertNumber$0();
        if (max == null || max.lessThan$1(number).value)
          max = number;
      }
      if (max != null)
        return max;
      throw H.wrapException(E.SassScriptException$("At least one argument must be passed."));
    },
    $signature: 4
  };
  K.closure60.prototype = {
    call$1: function($arguments) {
      var t1, t2, min, _i, number;
      for (t1 = J.$index$asx($arguments, 0).get$asList(), t2 = t1.length, min = null, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
        number = t1[_i].assertNumber$0();
        if (min == null || min.greaterThan$1(number).value)
          min = number;
      }
      if (min != null)
        return min;
      throw H.wrapException(E.SassScriptException$("At least one argument must be passed."));
    },
    $signature: 4
  };
  K.closure59.prototype = {
    call$1: function($arguments) {
      var limit,
        t1 = J.getInterceptor$asx($arguments);
      if (J.$eq$(t1.$index($arguments, 0), C.C_SassNull)) {
        t1 = $.$get$_random0().nextDouble$0();
        return new T.SassNumber(t1, C.List_empty0, C.List_empty0, null);
      }
      limit = t1.$index($arguments, 0).assertNumber$1("limit").assertInt$1("limit");
      if (limit < 1)
        throw H.wrapException(E.SassScriptException$("$limit: Must be greater than 0, was " + limit + "."));
      t1 = $.$get$_random0().nextInt$1(limit);
      return new T.SassNumber(t1 + 1, C.List_empty0, C.List_empty0, null);
    },
    $signature: 4
  };
  K.closure58.prototype = {
    call$1: function($arguments) {
      return new D.SassString(J.$index$asx($arguments, 0).assertNumber$1("number").get$unitString(), true);
    },
    $signature: 2
  };
  K.closure56.prototype = {
    call$1: function($arguments) {
      var number = J.$index$asx($arguments, 0).assertNumber$1("number");
      return !(number.numeratorUnits.length !== 0 || number.denominatorUnits.length !== 0) ? C.SassBoolean_true : C.SassBoolean_false;
    },
    $signature: 3
  };
  K.closure55.prototype = {
    call$1: function($arguments) {
      var t1 = J.getInterceptor$asx($arguments);
      return t1.$index($arguments, 0).assertNumber$1("number1").isComparableTo$1(t1.$index($arguments, 1).assertNumber$1("number2")) ? C.SassBoolean_true : C.SassBoolean_false;
    },
    $signature: 3
  };
  K._numberFunction_closure.prototype = {
    call$1: function($arguments) {
      var number = J.$index$asx($arguments, 0).assertNumber$1("number");
      return T.SassNumber$withUnits(this.transform.call$1(number.value), number.denominatorUnits, number.numeratorUnits);
    },
    $signature: 4
  };
  Q.closure125.prototype = {
    call$1: function($arguments) {
      return $._features.contains$1(0, J.$index$asx($arguments, 0).assertString$1("feature").text) ? C.SassBoolean_true : C.SassBoolean_false;
    },
    $signature: 3
  };
  Q.closure126.prototype = {
    call$1: function($arguments) {
      return new D.SassString(J.toString$0$(J.get$first$ax($arguments)), false);
    },
    $signature: 2
  };
  Q.closure127.prototype = {
    call$1: function($arguments) {
      var t1 = J.getInterceptor$(J.$index$asx($arguments, 0));
      if (!!t1.$isSassArgumentList)
        return new D.SassString("arglist", false);
      if (!!t1.$isSassBoolean)
        return new D.SassString("bool", false);
      if (!!t1.$isSassColor)
        return new D.SassString("color", false);
      if (!!t1.$isSassList)
        return new D.SassString("list", false);
      if (!!t1.$isSassMap)
        return new D.SassString("map", false);
      if (!!t1.$isSassNull)
        return new D.SassString("null", false);
      if (!!t1.$isSassNumber)
        return new D.SassString("number", false);
      if (!!t1.$isSassFunction)
        return new D.SassString("function", false);
      return new D.SassString("string", false);
    },
    $signature: 2
  };
  Q.closure128.prototype = {
    call$1: function($arguments) {
      var t1,
        argumentList = J.$index$asx($arguments, 0);
      if (argumentList instanceof D.SassArgumentList) {
        argumentList._wereKeywordsAccessed = true;
        t1 = F.Value;
        return new A.SassMap(H.ConstantMap_ConstantMap$from(Y.mapMap(argumentList._keywords, new Q._closure19(), null, P.String, t1, t1, t1), t1, t1));
      } else
        throw H.wrapException("$args: " + H.S(argumentList) + " is not an argument list.");
    },
    $signature: 9
  };
  Q._closure19.prototype = {
    call$2: function(key, _) {
      return new D.SassString(key, false);
    }
  };
  T.closure51.prototype = {
    call$1: function($arguments) {
      var selectors = J.$index$asx($arguments, 0).get$asList();
      if (selectors.length === 0)
        throw H.wrapException(E.SassScriptException$("$selectors: At least one selector must be passed."));
      return new H.MappedListIterable(selectors, new T._closure8(), [H.getTypeArgumentByIndex(selectors, 0), D.SelectorList]).reduce$1(0, new T._closure9()).get$asSassList();
    },
    $signature: 6
  };
  T._closure8.prototype = {
    call$1: function(selector) {
      return selector.assertSelector$1$allowParent(true);
    }
  };
  T._closure9.prototype = {
    call$2: function($parent, child) {
      return child.resolveParentSelectors$1($parent);
    }
  };
  T.closure50.prototype = {
    call$1: function($arguments) {
      var selectors = J.$index$asx($arguments, 0).get$asList();
      if (selectors.length === 0)
        throw H.wrapException(E.SassScriptException$("$selectors: At least one selector must be passed."));
      return new H.MappedListIterable(selectors, new T._closure6(), [H.getTypeArgumentByIndex(selectors, 0), D.SelectorList]).reduce$1(0, new T._closure7()).get$asSassList();
    },
    $signature: 6
  };
  T._closure6.prototype = {
    call$1: function(selector) {
      return selector.assertSelector$0();
    }
  };
  T._closure7.prototype = {
    call$2: function($parent, child) {
      var t1 = child.components;
      return D.SelectorList$(new H.MappedListIterable(t1, new T.__closure($parent), [H.getTypeArgumentByIndex(t1, 0), S.ComplexSelector])).resolveParentSelectors$1($parent);
    }
  };
  T.__closure.prototype = {
    call$1: function(complex) {
      var newCompound, t2,
        t1 = complex.components,
        compound = C.JSArray_methods.get$first(t1);
      if (compound instanceof X.CompoundSelector) {
        newCompound = T._prependParent(compound);
        if (newCompound == null)
          throw H.wrapException(E.SassScriptException$("Can't append " + H.S(complex) + " to " + H.S(this.parent) + "."));
        t2 = H.setRuntimeTypeInfo([], [S.ComplexSelectorComponent]);
        t2.push(newCompound);
        for (t1 = H.SubListIterable$(t1, 1, null, H.getTypeArgumentByIndex(t1, 0)), t1 = new H.ListIterator(t1, t1.get$length(t1)); t1.moveNext$0();)
          t2.push(t1.__internal$_current);
        return S.ComplexSelector$(t2, false);
      } else
        throw H.wrapException(E.SassScriptException$("Can't append " + H.S(complex) + " to " + H.S(this.parent) + "."));
    }
  };
  T.closure49.prototype = {
    call$1: function($arguments) {
      var t1 = J.getInterceptor$asx($arguments),
        selector = t1.$index($arguments, 0).assertSelector$1$name("selector"),
        target = t1.$index($arguments, 1).assertSelector$1$name("extendee");
      return F.Extender__extendOrReplace(selector, t1.$index($arguments, 2).assertSelector$1$name("extender"), target, C.ExtendMode_allTargets).get$asSassList();
    },
    $signature: 6
  };
  T.closure48.prototype = {
    call$1: function($arguments) {
      var t1 = J.getInterceptor$asx($arguments),
        selector = t1.$index($arguments, 0).assertSelector$1$name("selector"),
        target = t1.$index($arguments, 1).assertSelector$1$name("original");
      return F.Extender__extendOrReplace(selector, t1.$index($arguments, 2).assertSelector$1$name("replacement"), target, C.ExtendMode_replace).get$asSassList();
    },
    $signature: 6
  };
  T.closure47.prototype = {
    call$1: function($arguments) {
      var t1 = J.getInterceptor$asx($arguments),
        result = t1.$index($arguments, 0).assertSelector$1$name("selector1").unify$1(t1.$index($arguments, 1).assertSelector$1$name("selector2"));
      return result == null ? C.C_SassNull : result.get$asSassList();
    },
    $signature: 0
  };
  T.closure54.prototype = {
    call$1: function($arguments) {
      var t1 = J.getInterceptor$asx($arguments),
        selector1 = t1.$index($arguments, 0).assertSelector$1$name("super"),
        selector2 = t1.$index($arguments, 1).assertSelector$1$name("sub");
      return Y.listIsSuperslector(selector1.components, selector2.components) ? C.SassBoolean_true : C.SassBoolean_false;
    },
    $signature: 3
  };
  T.closure53.prototype = {
    call$1: function($arguments) {
      var t1 = J.$index$asx($arguments, 0).assertCompoundSelector$1$name("selector").components;
      return D.SassList$(new H.MappedListIterable(t1, new T._closure10(), [H.getTypeArgumentByIndex(t1, 0), F.Value]), C.ListSeparator_comma, false);
    },
    $signature: 6
  };
  T._closure10.prototype = {
    call$1: function(simple) {
      return new D.SassString(J.toString$0$(simple), false);
    }
  };
  T.closure52.prototype = {
    call$1: function($arguments) {
      return J.$index$asx($arguments, 0).assertSelector$1$name("selector").get$asSassList();
    },
    $signature: 6
  };
  D.closure46.prototype = {
    call$1: function($arguments) {
      var string = J.$index$asx($arguments, 0).assertString$1("string");
      if (!string.hasQuotes)
        return string;
      return new D.SassString(string.text, false);
    },
    $signature: 2
  };
  D.closure45.prototype = {
    call$1: function($arguments) {
      var string = J.$index$asx($arguments, 0).assertString$1("string");
      if (string.hasQuotes)
        return string;
      return new D.SassString(string.text, true);
    },
    $signature: 2
  };
  D.closure41.prototype = {
    call$1: function($arguments) {
      var t1 = J.$index$asx($arguments, 0).assertString$1("string").get$sassLength();
      return new T.SassNumber(t1, C.List_empty0, C.List_empty0, null);
    },
    $signature: 4
  };
  D.closure40.prototype = {
    call$1: function($arguments) {
      var indexInt, codeUnitIndex, _s5_ = "index",
        t1 = J.getInterceptor$asx($arguments),
        string = t1.$index($arguments, 0).assertString$1("string"),
        insert = t1.$index($arguments, 1).assertString$1("insert"),
        index = t1.$index($arguments, 2).assertNumber$1(_s5_);
      index.assertNoUnits$1(_s5_);
      indexInt = index.assertInt$1(_s5_);
      if (indexInt < 0)
        indexInt = string.get$sassLength() + indexInt + 2;
      t1 = string.text;
      codeUnitIndex = B.codepointIndexToCodeUnitIndex(t1, D._codepointForIndex(indexInt, string.get$sassLength(), false));
      return new D.SassString(J.replaceRange$3$asx(t1, codeUnitIndex, codeUnitIndex, insert.text), string.hasQuotes);
    },
    $signature: 2
  };
  D.closure39.prototype = {
    call$1: function($arguments) {
      var codepointIndex,
        t1 = J.getInterceptor$asx($arguments),
        t2 = t1.$index($arguments, 0).assertString$1("string").text,
        codeUnitIndex = J.indexOf$1$asx(t2, t1.$index($arguments, 1).assertString$1("substring").text);
      if (codeUnitIndex === -1)
        return C.C_SassNull;
      codepointIndex = B.codeUnitIndexToCodepointIndex(t2, codeUnitIndex);
      return new T.SassNumber(codepointIndex + 1, C.List_empty0, C.List_empty0, null);
    },
    $signature: 0
  };
  D.closure38.prototype = {
    call$1: function($arguments) {
      var lengthInCodepoints, endInt, startCodepoint, endCodepoint,
        t1 = J.getInterceptor$asx($arguments),
        string = t1.$index($arguments, 0).assertString$1("string"),
        start = t1.$index($arguments, 1).assertNumber$1("start-at"),
        end = t1.$index($arguments, 2).assertNumber$1("end-at");
      start.assertNoUnits$1("start");
      end.assertNoUnits$1("end");
      lengthInCodepoints = string.get$sassLength();
      endInt = end.assertInt$0();
      if (endInt === 0)
        return string.hasQuotes ? $.$get$_emptyQuoted() : $.$get$_emptyUnquoted();
      startCodepoint = D._codepointForIndex(start.assertInt$0(), lengthInCodepoints, false);
      endCodepoint = D._codepointForIndex(endInt, lengthInCodepoints, true);
      if (endCodepoint === lengthInCodepoints)
        --endCodepoint;
      if (endCodepoint < startCodepoint)
        return string.hasQuotes ? $.$get$_emptyQuoted() : $.$get$_emptyUnquoted();
      t1 = string.text;
      return new D.SassString(J.substring$2$s(t1, B.codepointIndexToCodeUnitIndex(t1, startCodepoint), B.codepointIndexToCodeUnitIndex(t1, endCodepoint + 1)), string.hasQuotes);
    },
    $signature: 2
  };
  D.closure44.prototype = {
    call$1: function($arguments) {
      var t1, t2, t3, i, t4, t5,
        string = J.$index$asx($arguments, 0).assertString$1("string");
      for (t1 = string.text, t2 = t1.length, t3 = J.getInterceptor$s(t1), i = 0, t4 = ""; i < t2; ++i) {
        t5 = t3._codeUnitAt$1(t1, i);
        t4 += H.Primitives_stringFromCharCode(t5 >= 97 && t5 <= 122 ? t5 & 4294967263 : t5);
      }
      return new D.SassString(t4.charCodeAt(0) == 0 ? t4 : t4, string.hasQuotes);
    },
    $signature: 2
  };
  D.closure43.prototype = {
    call$1: function($arguments) {
      var t1, t2, t3, i, t4, t5,
        string = J.$index$asx($arguments, 0).assertString$1("string");
      for (t1 = string.text, t2 = t1.length, t3 = J.getInterceptor$s(t1), i = 0, t4 = ""; i < t2; ++i) {
        t5 = t3._codeUnitAt$1(t1, i);
        t4 += H.Primitives_stringFromCharCode(t5 >= 65 && t5 <= 90 ? t5 | 32 : t5);
      }
      return new D.SassString(t4.charCodeAt(0) == 0 ? t4 : t4, string.hasQuotes);
    },
    $signature: 2
  };
  D.closure42.prototype = {
    call$1: function($arguments) {
      var t1 = $.$get$_previousUniqueId() + ($.$get$_random().nextInt$1(36) + 1);
      $._previousUniqueId = t1;
      if (t1 > Math.pow(36, 6))
        $._previousUniqueId = C.JSInt_methods.$mod($.$get$_previousUniqueId(), H.intTypeCast(Math.pow(36, 6)));
      return new D.SassString("u" + C.JSString_methods.padLeft$2(J.toRadixString$1$n($.$get$_previousUniqueId(), 36), 6, "0"), false);
    },
    $signature: 2
  };
  R.ImportCache.prototype = {
    canonicalize$3: function(url, baseImporter, baseUrl) {
      var resolvedUrl, canonicalUrl, t1;
      if (baseImporter != null) {
        resolvedUrl = baseUrl != null ? baseUrl.resolveUri$1(url) : url;
        canonicalUrl = this._canonicalize$2(baseImporter, resolvedUrl);
        if (canonicalUrl != null) {
          t1 = P.Uri;
          return new S.Tuple3(baseImporter, canonicalUrl, resolvedUrl, [M.Importer, t1, t1]);
        }
      }
      return this._canonicalizeCache.putIfAbsent$2(url, new R.ImportCache_canonicalize_closure(this, url));
    },
    _canonicalize$2: function(importer, url) {
      var result = importer.canonicalize$1(url);
      if ((result == null ? null : result.get$scheme()) === "")
        this._import_cache$_logger.warn$2$deprecation("Importer " + importer.toString$0(0) + " canonicalized " + H.S(url) + " to " + H.S(result) + ".\nRelative canonical URLs are deprecated and will eventually be disallowed.\n", true);
      return result;
    },
    import$3: function(url, baseImporter, baseUrl) {
      var t1,
        tuple = this.canonicalize$3(url, baseImporter, baseUrl);
      if (tuple == null)
        return;
      t1 = tuple.item1;
      return new S.Tuple2(t1, this.importCanonical$3(t1, tuple.item2, tuple.item3), [M.Importer, V.Stylesheet]);
    },
    importCanonical$3: function(importer, canonicalUrl, originalUrl) {
      return this._import_cache$_importCache.putIfAbsent$2(canonicalUrl, new R.ImportCache_importCanonical_closure(this, importer, canonicalUrl, originalUrl));
    },
    importCanonical$2: function(importer, canonicalUrl) {
      return this.importCanonical$3(importer, canonicalUrl, null);
    },
    humanize$1: function(canonicalUrl) {
      var t1 = this._canonicalizeCache.get$values(),
        t2 = H.getRuntimeTypeArgument(t1, "Iterable", 0),
        t3 = P.Uri,
        url = Y.minBy(new H.MappedIterable(new H.WhereIterable(t1, new R.ImportCache_humanize_closure(canonicalUrl), [t2]), new R.ImportCache_humanize_closure0(), [t2, t3]), new R.ImportCache_humanize_closure1(), t3, null);
      if (url == null)
        return canonicalUrl;
      t1 = $.$get$url();
      return url.resolve$1(X.ParsedPath_ParsedPath$parse(canonicalUrl.get$path(canonicalUrl), t1.style).get$basename());
    },
    clearImport$1: function(canonicalUrl) {
      this._resultsCache.remove$1(0, canonicalUrl);
      this._import_cache$_importCache.remove$1(0, canonicalUrl);
    }
  };
  R.ImportCache_canonicalize_closure.prototype = {
    call$0: function() {
      var t1, t2, t3, t4, _i, importer, canonicalUrl;
      for (t1 = this.$this, t2 = t1._importers, t3 = t2.length, t4 = this.url, _i = 0; _i < t2.length; t2.length === t3 || (0, H.throwConcurrentModificationError)(t2), ++_i) {
        importer = t2[_i];
        canonicalUrl = t1._canonicalize$2(importer, t4);
        if (canonicalUrl != null) {
          t1 = P.Uri;
          return new S.Tuple3(importer, canonicalUrl, t4, [M.Importer, t1, t1]);
        }
      }
      return;
    }
  };
  R.ImportCache_importCanonical_closure.prototype = {
    call$0: function() {
      var t3, _this = this,
        t1 = _this.canonicalUrl,
        result = _this.importer.load$1(t1),
        t2 = _this.$this;
      t2._resultsCache.$indexSet(0, t1, result);
      t3 = _this.originalUrl;
      t1 = t3 == null ? t1 : t3.resolveUri$1(t1);
      return V.Stylesheet_Stylesheet$parse(result.contents, result.syntax, t2._import_cache$_logger, t1);
    }
  };
  R.ImportCache_humanize_closure.prototype = {
    call$1: function(tuple) {
      var t1 = tuple == null ? null : tuple.item2;
      return J.$eq$(t1, this.canonicalUrl);
    }
  };
  R.ImportCache_humanize_closure0.prototype = {
    call$1: function(tuple) {
      return tuple.item3;
    }
  };
  R.ImportCache_humanize_closure1.prototype = {
    call$1: function(url) {
      return J.get$length$asx(J.get$path$x(url));
    },
    $signature: 10
  };
  M.Importer.prototype = {
    modificationTime$1: function(url) {
      return new P.DateTime(Date.now(), false);
    }
  };
  B.AsyncImporter.prototype = {};
  F.FilesystemImporter.prototype = {
    canonicalize$1: function(url) {
      var t1, resolved;
      if (url.get$scheme() !== "file" && url.get$scheme() !== "")
        return;
      t1 = $.$get$context();
      resolved = B.resolveImportPath(D.join(this._loadPath, t1.style.pathFromUri$1(M._parseUri(url)), null));
      return resolved == null ? null : t1.toUri$1(t1.canonicalize$1(resolved));
    },
    load$1: function(url) {
      var t3,
        t1 = $.$get$context(),
        path = t1.style.pathFromUri$1(M._parseUri(url)),
        t2 = B.readFile(path);
      t1 = J.$eq$(J.get$platform$x(self.process), "win32") || J.$eq$(J.get$platform$x(self.process), "darwin") ? t1.toUri$1(F.realCasePath(path)) : url;
      t3 = M.Syntax_forPath(path);
      if ((t1 == null ? null : t1.get$scheme()) === "")
        H.throwExpression(P.ArgumentError$value(t1, "sourceMapUrl", "must be absolute"));
      return new E.ImporterResult(t2, t1, t3);
    },
    modificationTime$1: function(url) {
      return B.modificationTime($.$get$context().style.pathFromUri$1(M._parseUri(url)));
    },
    toString$0: function(_) {
      return this._loadPath;
    }
  };
  F.NodeImporter.prototype = {
    load$2: function(url, previous) {
      var result, previousString, t1, t2, t3, t4, _i, value, _this = this,
        parsed = P.Uri_parse(url);
      if (parsed.get$scheme() === "" || parsed.get$scheme() === "file") {
        result = _this._resolveRelativePath$2($.$get$context().style.pathFromUri$1(M._parseUri(parsed)), previous);
        if (result != null)
          return result;
      }
      previousString = previous.get$scheme() === "file" ? $.$get$context().style.pathFromUri$1(M._parseUri(previous)) : previous.toString$0(0);
      for (t1 = _this._implementation$_importers, t2 = t1.length, t3 = _this._implementation$_context, t4 = [P.Object], _i = 0; _i < t2; ++_i) {
        value = J.apply$2$x(t1[_i], t3, H.setRuntimeTypeInfo([url, previousString], t4));
        if (value != null)
          return _this._handleImportResult$3(url, previous, value);
      }
      return _this._resolveLoadPathFromUrl$2(parsed, previous);
    },
    loadAsync$2: function(url, previous) {
      return this.loadAsync$body$NodeImporter(url, previous);
    },
    loadAsync$body$NodeImporter: function(url, previous) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter([S.Tuple2, P.String, P.String]),
        $async$returnValue, $async$self = this, result, previousString, t1, t2, _i, value, parsed;
      var $async$loadAsync$2 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              parsed = P.Uri_parse(url);
              if (parsed.get$scheme() === "" || parsed.get$scheme() === "file") {
                result = $async$self._resolveRelativePath$2($.$get$context().style.pathFromUri$1(M._parseUri(parsed)), previous);
                if (result != null) {
                  $async$returnValue = result;
                  // goto return
                  $async$goto = 1;
                  break;
                }
              }
              previousString = previous.get$scheme() === "file" ? $.$get$context().style.pathFromUri$1(M._parseUri(previous)) : previous.toString$0(0);
              t1 = $async$self._implementation$_importers, t2 = t1.length, _i = 0;
            case 3:
              // for condition
              if (!(_i < t2)) {
                // goto after for
                $async$goto = 5;
                break;
              }
              $async$goto = 6;
              return P._asyncAwait($async$self._callImporterAsync$3(t1[_i], url, previousString), $async$loadAsync$2);
            case 6:
              // returning from await.
              value = $async$result;
              if (value != null) {
                $async$returnValue = $async$self._handleImportResult$3(url, previous, value);
                // goto return
                $async$goto = 1;
                break;
              }
            case 4:
              // for update
              ++_i;
              // goto for condition
              $async$goto = 3;
              break;
            case 5:
              // after for
              $async$returnValue = $async$self._resolveLoadPathFromUrl$2(parsed, previous);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$loadAsync$2, $async$completer);
    },
    _resolveRelativePath$2: function(path, previous) {
      var result,
        t1 = $.$get$context(),
        t2 = t1.style;
      if (t2.rootLength$1(path) > 0)
        return this._tryPath$1(path);
      if (previous.get$scheme() === "file") {
        result = this._tryPath$1(D.join(t1.dirname$1(t2.pathFromUri$1(M._parseUri(previous))), path, null));
        if (result != null)
          return result;
      }
      return;
    },
    _resolveLoadPathFromUrl$2: function(url, previous) {
      return url.get$scheme() === "" || url.get$scheme() === "file" ? this._resolveLoadPath$2($.$get$context().style.pathFromUri$1(M._parseUri(url)), previous) : null;
    },
    _resolveLoadPath$2: function(path, previous) {
      var t1, t2, t3, _i, includePath, t4, resolved, result, _null = null,
        cwdResult = this._tryPath$1(D.absolute(path));
      if (cwdResult != null)
        return cwdResult;
      for (t1 = this._includePaths, t2 = t1.length, t3 = P.String, t3 = [t3, t3], _i = 0; _i < t2; ++_i) {
        includePath = t1[_i];
        t4 = $.$get$context();
        resolved = B.resolveImportPath(t4.absolute$7(t4.join$8(0, includePath, path, _null, _null, _null, _null, _null, _null), _null, _null, _null, _null, _null, _null));
        result = resolved == null ? _null : new S.Tuple2(B.readFile(resolved), J.toString$0$(t4.toUri$1(resolved)), t3);
        if (result != null)
          return result;
      }
      return;
    },
    _tryPath$1: function(path) {
      var t1,
        resolved = B.resolveImportPath(path);
      if (resolved == null)
        t1 = null;
      else {
        t1 = P.String;
        t1 = new S.Tuple2(B.readFile(resolved), J.toString$0$($.$get$context().toUri$1(resolved)), [t1, t1]);
      }
      return t1;
    },
    _handleImportResult$3: function(url, previous, value) {
      var t1, resolved, t2;
      if (value instanceof self.Error)
        throw H.wrapException(value);
      t1 = J.getInterceptor$(value);
      if (!t1.$isNodeImporterResult)
        return;
      if (t1.get$file(value) != null) {
        resolved = this._resolveRelativePath$2(t1.get$file(value), previous);
        if (resolved == null)
          resolved = this._resolveLoadPath$2(t1.get$file(value), previous);
        if (resolved != null)
          return resolved;
        throw H.wrapException("Can't find stylesheet to import.");
      } else {
        t1 = t1.get$contents(value);
        if (t1 == null)
          t1 = "";
        t2 = P.String;
        return new S.Tuple2(t1, url, [t2, t2]);
      }
    },
    _callImporterAsync$3: function(importer, url, previousString) {
      return this._callImporterAsync$body$NodeImporter(importer, url, previousString);
    },
    _callImporterAsync$body$NodeImporter: function(importer, url, previousString) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Object),
        $async$returnValue, $async$self = this, t1, t2, result;
      var $async$_callImporterAsync$3 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = P.Object;
              t2 = new P._Future($.Zone__current, [t1]);
              result = J.apply$2$x(importer, $async$self._implementation$_context, H.setRuntimeTypeInfo([url, previousString, P.allowInterop(new P._AsyncCompleter(t2, [t1]).get$complete())], [t1]));
              $async$goto = H.boolTypeCast($.$get$_isUndefined().call$1(result)) ? 3 : 4;
              break;
            case 3:
              // then
              $async$goto = 5;
              return P._asyncAwait(t2, $async$_callImporterAsync$3);
            case 5:
              // returning from await.
              $async$returnValue = $async$result;
              // goto return
              $async$goto = 1;
              break;
            case 4:
              // join
              $async$returnValue = result;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$_callImporterAsync$3, $async$completer);
    }
  };
  E.ImporterResult.prototype = {
    get$sourceMapUrl: function() {
      var t1 = this._sourceMapUrl;
      return t1 == null ? P.Uri_Uri$dataFromString(this.contents, C.C_Utf8Codec, null) : t1;
    }
  };
  B.resolveImportPath_closure.prototype = {
    call$0: function() {
      return B._exactlyOne(B._tryPath($.$get$context().withoutExtension$1(this.path) + ".import" + this.extension));
    }
  };
  B.resolveImportPath_closure0.prototype = {
    call$0: function() {
      return B._exactlyOne(B._tryPathWithExtensions(H.S(this.path) + ".import"));
    }
  };
  B._tryPathAsDirectory_closure.prototype = {
    call$0: function() {
      return B._exactlyOne(B._tryPathWithExtensions(D.join(this.path, "index.import", null)));
    }
  };
  B._exactlyOne_closure.prototype = {
    call$1: function(path) {
      var t1 = $.$get$context();
      return C.JSString_methods.$add("  ", t1.prettyUri$1(t1.toUri$1(path)));
    }
  };
  Z.InterpolationBuffer.prototype = {
    add$1: function(_, expression) {
      this._flushText$0();
      this._interpolation_buffer$_contents.push(expression);
    },
    addInterpolation$1: function(interpolation) {
      var first, t1, t2, _this = this,
        toAdd = interpolation.contents;
      if (toAdd.length === 0)
        return;
      first = C.JSArray_methods.get$first(toAdd);
      if (typeof first === "string") {
        _this._interpolation_buffer$_text._contents += first;
        toAdd = H.SubListIterable$(toAdd, 1, null, H.getTypeArgumentByIndex(toAdd, 0));
      }
      _this._flushText$0();
      t1 = _this._interpolation_buffer$_contents;
      C.JSArray_methods.addAll$1(t1, toAdd);
      t2 = C.JSArray_methods.get$last(t1);
      if (typeof t2 === "string")
        _this._interpolation_buffer$_text._contents += H.S(t1.pop());
    },
    _flushText$0: function() {
      var t1 = this._interpolation_buffer$_text,
        t2 = t1._contents;
      if (t2.length === 0)
        return;
      this._interpolation_buffer$_contents.push(t2.charCodeAt(0) == 0 ? t2 : t2);
      t1._contents = "";
    },
    interpolation$1: function(span) {
      var t2, t3, _i,
        t1 = H.setRuntimeTypeInfo([], [P.Object]);
      for (t2 = this._interpolation_buffer$_contents, t3 = t2.length, _i = 0; _i < t2.length; t2.length === t3 || (0, H.throwConcurrentModificationError)(t2), ++_i)
        t1.push(t2[_i]);
      t2 = this._interpolation_buffer$_text._contents;
      if (t2.length !== 0)
        t1.push(t2.charCodeAt(0) == 0 ? t2 : t2);
      return X.Interpolation$(t1, span);
    },
    toString$0: function(_) {
      var t1, t2, _i, t3, element;
      for (t1 = this._interpolation_buffer$_contents, t2 = t1.length, _i = 0, t3 = ""; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
        element = t1[_i];
        t3 = typeof element === "string" ? t3 + element : t3 + "#{" + H.S(element) + H.Primitives_stringFromCharCode(125);
      }
      t1 = t3 + this._interpolation_buffer$_text.toString$0(0);
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    }
  };
  F.realCasePath_closure.prototype = {
    call$1: function(realPath) {
      return B.equalsIgnoreCase(X.ParsedPath_ParsedPath$parse(realPath, $.$get$context().style).get$basename(), this.basename);
    }
  };
  B._FS.prototype = {};
  B._Stat.prototype = {};
  B._Date.prototype = {};
  B._Stderr.prototype = {};
  B._Stdin.prototype = {};
  B._SystemError.prototype = {};
  B._Process.prototype = {};
  B.FileSystemException.prototype = {
    toString$0: function(_) {
      var t1 = $.$get$context();
      return H.S(t1.prettyUri$1(t1.toUri$1(this.path))) + ": " + this.message;
    },
    get$message: function(receiver) {
      return this.message;
    },
    get$path: function(receiver) {
      return this.path;
    }
  };
  B.Stderr.prototype = {
    writeln$1: function(object) {
      J.write$1$x(this._stderr, H.S(object == null ? "" : object) + "\n");
    },
    writeln$0: function() {
      return this.writeln$1(null);
    }
  };
  B._readFile_closure.prototype = {
    call$0: function() {
      return J.readFileSync$2$x(self.fs, this.path, this.encoding);
    }
  };
  B.writeFile_closure.prototype = {
    call$0: function() {
      return J.writeFileSync$2$x(self.fs, this.path, this.contents);
    }
  };
  B.deleteFile_closure.prototype = {
    call$0: function() {
      return J.unlinkSync$1$x(self.fs, this.path);
    }
  };
  B.readStdin_closure.prototype = {
    call$1: function(result) {
      this._box_0.contents = result;
      this.completer.complete$1(result);
    }
  };
  B.readStdin_closure0.prototype = {
    call$1: function(chunk) {
      this.sink.add$1(0, H.subtypeCast(chunk, "$isList", [P.int], "$asList"));
    },
    call$0: function() {
      return this.call$1(null);
    },
    "call*": "call$1",
    $requiredArgCount: 0,
    $defaultValues: function() {
      return [null];
    },
    $signature: 11
  };
  B.readStdin_closure1.prototype = {
    call$1: function(_) {
      this.sink.close$0(0);
    },
    call$0: function() {
      return this.call$1(null);
    },
    "call*": "call$1",
    $requiredArgCount: 0,
    $defaultValues: function() {
      return [null];
    },
    $signature: 11
  };
  B.readStdin_closure2.prototype = {
    call$1: function(e) {
      var t1 = $.$get$stderr();
      t1.writeln$1("Failed to read from stdin");
      t1.writeln$1(e);
      this.completer.completeError$1(e);
    },
    call$0: function() {
      return this.call$1(null);
    },
    "call*": "call$1",
    $requiredArgCount: 0,
    $defaultValues: function() {
      return [null];
    },
    $signature: 11
  };
  B.ensureDir_closure.prototype = {
    call$0: function() {
      var error, systemError, exception, t1;
      try {
        J.mkdirSync$1$x(self.fs, this.path);
      } catch (exception) {
        error = H.unwrapException(exception);
        systemError = H.interceptedTypeCast(error, "$is_SystemError");
        if (J.$eq$(J.get$code$x(systemError), "EEXIST"))
          return;
        if (!J.$eq$(J.get$code$x(systemError), "ENOENT"))
          throw exception;
        t1 = this.path;
        B.ensureDir($.$get$context().dirname$1(t1));
        J.mkdirSync$1$x(self.fs, t1);
      }
    }
  };
  B.listDir_closure.prototype = {
    call$0: function() {
      var t1 = this.path;
      if (!this.recursive)
        return J.map$1$1$ax(J.readdirSync$1$x(self.fs, t1), new B.listDir__closure(t1), P.String).where$1(0, new B.listDir__closure0());
      else
        return new B.listDir_closure_list().call$1(t1);
    }
  };
  B.listDir__closure.prototype = {
    call$1: function(child) {
      return D.join(this.path, H.stringTypeCast(child), null);
    },
    $signature: 21
  };
  B.listDir__closure0.prototype = {
    call$1: function(child) {
      return !B.dirExists(child);
    }
  };
  B.listDir_closure_list.prototype = {
    call$1: function($parent) {
      return J.expand$1$1$ax(J.readdirSync$1$x(self.fs, $parent), new B.listDir__list_closure($parent, this), P.String);
    }
  };
  B.listDir__list_closure.prototype = {
    call$1: function(child) {
      var path = D.join(this.parent, H.stringTypeCast(child), null);
      return B.dirExists(path) ? this.list.call$1(path) : H.setRuntimeTypeInfo([path], [P.String]);
    },
    $signature: 38
  };
  B.modificationTime_closure.prototype = {
    call$0: function() {
      var t2,
        t1 = J.getTime$0$x(J.get$mtime$x(J.statSync$1$x(self.fs, this.path)));
      if (Math.abs(t1) <= 864e13)
        t2 = false;
      else
        t2 = true;
      if (t2)
        H.throwExpression(P.ArgumentError$("DateTime is outside valid range: " + H.S(t1)));
      return new P.DateTime(t1, false);
    }
  };
  B.watchDir_closure.prototype = {
    call$2: function(path, _) {
      var t1 = this._box_0.controller;
      return t1 == null ? null : t1.add$1(0, new E.WatchEvent(C.ChangeType_add, path));
    },
    call$1: function(path) {
      return this.call$2(path, null);
    },
    "call*": "call$2",
    $defaultValues: function() {
      return [null];
    }
  };
  B.watchDir_closure0.prototype = {
    call$2: function(path, _) {
      var t1 = this._box_0.controller;
      return t1 == null ? null : t1.add$1(0, new E.WatchEvent(C.ChangeType_modify, path));
    },
    call$1: function(path) {
      return this.call$2(path, null);
    },
    "call*": "call$2",
    $defaultValues: function() {
      return [null];
    }
  };
  B.watchDir_closure1.prototype = {
    call$1: function(path) {
      var t1 = this._box_0.controller;
      return t1 == null ? null : t1.add$1(0, new E.WatchEvent(C.ChangeType_remove, path));
    }
  };
  B.watchDir_closure2.prototype = {
    call$1: function(error) {
      var t1 = this._box_0.controller;
      return t1 == null ? null : t1.addError$1(error);
    },
    $signature: 29
  };
  B.watchDir_closure3.prototype = {
    call$0: function() {
      var controller = P.StreamController_StreamController(new B.watchDir__closure(this.watcher), null, null, null, false, E.WatchEvent);
      this._box_0.controller = controller;
      this.completer.complete$1(new P._ControllerStream(controller, [H.getTypeArgumentByIndex(controller, 0)]));
    },
    "call*": "call$0",
    $requiredArgCount: 0
  };
  B.watchDir__closure.prototype = {
    call$0: function() {
      J.close$0$x(this.watcher);
    },
    "call*": "call$0",
    $requiredArgCount: 0
  };
  F._QuietLogger.prototype = {
    warn$4$deprecation$span$trace: function(message, deprecation, span, trace) {
    },
    warn$2$span: function(message, span) {
      return this.warn$4$deprecation$span$trace(message, false, span, null);
    },
    warn$2$deprecation: function(message, deprecation) {
      return this.warn$4$deprecation$span$trace(message, deprecation, null, null);
    },
    warn$3$deprecation$span: function(message, deprecation, span) {
      return this.warn$4$deprecation$span$trace(message, deprecation, span, null);
    },
    warn$2$trace: function(message, trace) {
      return this.warn$4$deprecation$span$trace(message, false, null, trace);
    },
    debug$2: function(message, span) {
    }
  };
  S.StderrLogger.prototype = {
    warn$4$deprecation$span$trace: function(message, deprecation, span, trace) {
      var t2, t3,
        t1 = this.color;
      if (t1) {
        t2 = $.$get$stderr();
        t3 = t2._stderr;
        J.write$1$x(t3, "\x1b[33m\x1b[1m");
        if (deprecation)
          J.write$1$x(t3, "Deprecation ");
        J.write$1$x(t3, "Warning\x1b[0m");
      } else {
        if (deprecation)
          J.write$1$x($.$get$stderr()._stderr, "DEPRECATION ");
        t2 = $.$get$stderr();
        J.write$1$x(t2._stderr, "WARNING");
      }
      if (span == null)
        t2.writeln$1(": " + H.S(message));
      else if (trace != null)
        t2.writeln$1(": " + H.S(message) + "\n\n" + span.highlight$1$color(t1));
      else
        t2.writeln$1(" on " + span.message$2$color(0, C.JSString_methods.$add("\n", message), t1));
      if (trace != null)
        t2.writeln$1(B.indent(C.JSString_methods.trimRight$0(trace.toString$0(0)), 4));
      t2.writeln$0();
    },
    warn$2$span: function(message, span) {
      return this.warn$4$deprecation$span$trace(message, false, span, null);
    },
    warn$2$deprecation: function(message, deprecation) {
      return this.warn$4$deprecation$span$trace(message, deprecation, null, null);
    },
    warn$3$deprecation$span: function(message, deprecation, span) {
      return this.warn$4$deprecation$span$trace(message, deprecation, span, null);
    },
    warn$2$trace: function(message, trace) {
      return this.warn$4$deprecation$span$trace(message, false, null, trace);
    },
    debug$2: function(message, span) {
      var url, t3, t4,
        t1 = span.file,
        t2 = span._start;
      if (Y.FileLocation$_(t1, t2).file.url == null)
        url = "-";
      else {
        t3 = Y.FileLocation$_(t1, t2);
        url = $.$get$context().prettyUri$1(t3.file.url);
      }
      t3 = $.$get$stderr();
      t4 = H.S(url) + ":";
      t2 = Y.FileLocation$_(t1, t2);
      t2 = t4 + (t2.file.getLine$1(t2.offset) + 1) + " ";
      t4 = t3._stderr;
      J.write$1$x(t4, t2);
      J.write$1$x(t4, this.color ? "\x1b[1mDebug\x1b[0m" : "DEBUG");
      t3.writeln$1(": " + H.S(message));
    }
  };
  T.TrackingLogger.prototype = {
    warn$4$deprecation$span$trace: function(message, deprecation, span, trace) {
      this._emittedWarning = true;
      this._tracking$_logger.warn$4$deprecation$span$trace(message, deprecation, span, trace);
    },
    warn$2$span: function(message, span) {
      return this.warn$4$deprecation$span$trace(message, false, span, null);
    },
    warn$2$deprecation: function(message, deprecation) {
      return this.warn$4$deprecation$span$trace(message, deprecation, null, null);
    },
    warn$3$deprecation$span: function(message, deprecation, span) {
      return this.warn$4$deprecation$span$trace(message, deprecation, span, null);
    },
    warn$2$trace: function(message, trace) {
      return this.warn$4$deprecation$span$trace(message, false, null, trace);
    },
    debug$2: function(message, span) {
      this._emittedDebug = true;
      this._tracking$_logger.debug$2(message, span);
    }
  };
  G.Module.prototype = {};
  Q.BuiltInModule.prototype = {
    get$upstream: function() {
      return C.List_empty6;
    },
    get$variables: function() {
      return C.Map_empty4;
    },
    get$variableNodes: function() {
      return C.Map_empty3;
    },
    get$mixins: function() {
      return C.Map_empty2;
    },
    get$extender: function() {
      return C.C_EmptyExtender;
    },
    get$css: function(_) {
      return new V.CssStylesheet(C.List_empty3, Y.SourceFile$decoded(C.List_empty4, this.url).span$2(0, 0));
    },
    get$transitivelyContainsCss: function() {
      return false;
    },
    get$transitivelyContainsExtensions: function() {
      return false;
    },
    setVariable$3: function($name, value, nodeWithSpan) {
      throw H.wrapException(E.SassScriptException$("Undefined variable."));
    },
    cloneCss$0: function() {
      return this;
    },
    $isModule: 1,
    get$url: function() {
      return this.url;
    },
    get$functions: function(receiver) {
      return this.functions;
    }
  };
  R.ForwardedModuleView.prototype = {
    get$url: function() {
      return this._forwarded_view$_inner.get$url();
    },
    get$upstream: function() {
      return this._forwarded_view$_inner.get$upstream();
    },
    get$extender: function() {
      return this._forwarded_view$_inner.get$extender();
    },
    get$css: function(_) {
      var t1 = this._forwarded_view$_inner;
      return t1.get$css(t1);
    },
    get$transitivelyContainsCss: function() {
      return this._forwarded_view$_inner.get$transitivelyContainsCss();
    },
    get$transitivelyContainsExtensions: function() {
      return this._forwarded_view$_inner.get$transitivelyContainsExtensions();
    },
    setVariable$3: function($name, value, nodeWithSpan) {
      var _s19_ = "Undefined variable.",
        t1 = this._rule,
        t2 = t1.shownVariables;
      if (t2 != null && !t2._base.contains$1(0, $name))
        throw H.wrapException(E.SassScriptException$(_s19_));
      else {
        t2 = t1.hiddenVariables;
        if (t2 != null && t2._base.contains$1(0, $name))
          throw H.wrapException(E.SassScriptException$(_s19_));
      }
      t1 = t1.prefix;
      if (t1 != null) {
        if (!B.startsWithIgnoreSeparator($name, t1))
          throw H.wrapException(E.SassScriptException$(_s19_));
        $name = J.substring$1$s($name, t1.length);
      }
      return this._forwarded_view$_inner.setVariable$3($name, value, nodeWithSpan);
    },
    cloneCss$0: function() {
      return R.ForwardedModuleView$(this._forwarded_view$_inner.cloneCss$0(), this._rule, H.getTypeArgumentByIndex(this, 0));
    },
    $isModule: 1,
    get$variables: function() {
      return this.variables;
    },
    get$variableNodes: function() {
      return this.variableNodes;
    },
    get$functions: function(receiver) {
      return this.functions;
    },
    get$mixins: function() {
      return this.mixins;
    }
  };
  B.main_closure.prototype = {
    call$1: function(args) {
      return F.main(P.List_List$from(H.subtypeCast(args, "$isList", [P.Object], "$asList"), true, P.String));
    },
    $signature: 10
  };
  B._render_closure.prototype = {
    call$0: function() {
      var error, exception;
      try {
        this.callback.call$2(null, B._renderSync(this.options));
      } catch (exception) {
        error = H.unwrapException(exception);
        this.callback.call$2(H.interceptedTypeCast(error, "$isJSError"), null);
      }
    },
    "call*": "call$0",
    $requiredArgCount: 0
  };
  B._render_closure0.prototype = {
    call$1: function(result) {
      this.callback.call$2(null, result);
    }
  };
  B._render_closure1.prototype = {
    call$2: function(error, stackTrace) {
      var _null = null,
        t1 = J.getInterceptor$(error),
        t2 = this.callback;
      if (!!t1.$isSassException)
        t2.call$2(B._wrapException(error), _null);
      else
        t2.call$2(B._newRenderError(t1.toString$0(error), _null, _null, _null, 3), _null);
    },
    "call*": "call$2",
    $requiredArgCount: 2,
    $signature: 12
  };
  B._parseFunctions_closure.prototype = {
    call$2: function(signature, callback) {
      var error, t1, exception, _this = this, tuple = null;
      try {
        t1 = S.SpanScanner$(signature, null);
        tuple = new L.ScssParser(P.LinkedHashMap_LinkedHashMap$_empty(P.String, Z.VariableDeclaration), t1, C.StderrLogger_false).parseSignature$0();
      } catch (exception) {
        t1 = H.unwrapException(exception);
        if (t1 instanceof E.SassFormatException) {
          error = t1;
          throw H.wrapException(E.SassFormatException$('Invalid signature "' + H.S(signature) + '": ' + H.S(error._span_exception$_message), error.get$span()));
        } else
          throw exception;
      }
      t1 = _this.options;
      if (J.get$fiber$x(t1) != null)
        _this.result.push(Q.BuiltInCallable$parsed(tuple.item1, tuple.item2, new B._parseFunctions__closure(t1, callback)));
      else {
        t1 = _this.result;
        if (!_this.asynch)
          t1.push(Q.BuiltInCallable$parsed(tuple.item1, tuple.item2, new B._parseFunctions__closure0(callback)));
        else
          t1.push(S.AsyncBuiltInCallable$parsed(tuple.item1, tuple.item2, new B._parseFunctions__closure1(callback)));
      }
    },
    $signature: 39
  };
  B._parseFunctions__closure.prototype = {
    call$1: function($arguments) {
      var result,
        t1 = this.options,
        t2 = J.getInterceptor$x(t1),
        fiber = J.get$current$x(t2.get$fiber(t1)),
        t3 = P.Object,
        t4 = H.setRuntimeTypeInfo([], [t3]);
      for (t3 = J.map$1$1$ax($arguments, F.value0__wrapValue$closure(), t3), t3 = t3.get$iterator(t3); t3.moveNext$0();)
        t4.push(t3.get$current(t3));
      t4.push(P.allowInterop(new B._parseFunctions___closure0(fiber)));
      result = P.Function_apply(H.interceptedTypeCast(this.callback, "$isFunction"), t4);
      return F.unwrapValue(H.boolTypeCast($.$get$_isUndefined().call$1(result)) ? J.yield$0$x(t2.get$fiber(t1)) : result);
    },
    $signature: 0
  };
  B._parseFunctions___closure0.prototype = {
    call$1: function(result) {
      P.scheduleMicrotask(new B._parseFunctions____closure(this.fiber, result));
    },
    call$0: function() {
      return this.call$1(null);
    },
    "call*": "call$1",
    $requiredArgCount: 0,
    $defaultValues: function() {
      return [null];
    },
    $signature: 11
  };
  B._parseFunctions____closure.prototype = {
    call$0: function() {
      return J.run$1$x(this.fiber, this.result);
    },
    "call*": "call$0",
    $requiredArgCount: 0
  };
  B._parseFunctions__closure0.prototype = {
    call$1: function($arguments) {
      return F.unwrapValue(P.Function_apply(H.interceptedTypeCast(this.callback, "$isFunction"), J.map$1$1$ax($arguments, F.value0__wrapValue$closure(), P.Object).toList$0(0)));
    },
    $signature: 0
  };
  B._parseFunctions__closure1.prototype = {
    call$1: function($arguments) {
      return this.$call$body$_parseFunctions__closure($arguments);
    },
    $call$body$_parseFunctions__closure: function($arguments) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(F.Value),
        $async$returnValue, $async$self = this, result, t1, completer, t2, $async$temp1;
      var $async$call$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = P.Object;
              completer = new P._AsyncCompleter(new P._Future($.Zone__current, [t1]), [t1]);
              t2 = H.setRuntimeTypeInfo([], [t1]);
              for (t1 = J.map$1$1$ax($arguments, F.value0__wrapValue$closure(), t1), t1 = t1.get$iterator(t1); t1.moveNext$0();)
                t2.push(t1.get$current(t1));
              t2.push(P.allowInterop(new B._parseFunctions___closure(completer)));
              result = P.Function_apply(H.interceptedTypeCast($async$self.callback, "$isFunction"), t2);
              $async$temp1 = F;
              $async$goto = H.boolTypeCast($.$get$_isUndefined().call$1(result)) ? 3 : 5;
              break;
            case 3:
              // then
              $async$goto = 6;
              return P._asyncAwait(completer.future, $async$call$1);
            case 6:
              // returning from await.
              // goto join
              $async$goto = 4;
              break;
            case 5:
              // else
              $async$result = result;
            case 4:
              // join
              $async$returnValue = $async$temp1.unwrapValue($async$result);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$1, $async$completer);
    }
  };
  B._parseFunctions___closure.prototype = {
    call$1: function(result) {
      return this.completer.complete$1(result);
    },
    call$0: function() {
      return this.call$1(null);
    },
    "call*": "call$1",
    $requiredArgCount: 0,
    $defaultValues: function() {
      return [null];
    },
    $signature: 40
  };
  B._parseImporter_closure.prototype = {
    call$1: function(importer) {
      return H.interceptedTypeCast(P.allowInteropCaptureThis(new B._parseImporter__closure(this.options, importer)), "$isJSFunction");
    }
  };
  B._parseImporter__closure.prototype = {
    call$4: function(thisArg, url, previous, _) {
      var t1 = this.options,
        t2 = J.getInterceptor$x(t1),
        result = J.apply$2$x(this.importer, thisArg, H.setRuntimeTypeInfo([url, previous, P.allowInterop(new B._parseImporter___closure(J.get$current$x(t2.get$fiber(t1))))], [P.Object]));
      if (H.boolTypeCast($.$get$_isUndefined().call$1(result)))
        return J.yield$0$x(t2.get$fiber(t1));
      return result;
    },
    call$3: function(thisArg, url, previous) {
      return this.call$4(thisArg, url, previous, null);
    },
    "call*": "call$4",
    $requiredArgCount: 3,
    $defaultValues: function() {
      return [null];
    }
  };
  B._parseImporter___closure.prototype = {
    call$1: function(result) {
      P.scheduleMicrotask(new B._parseImporter____closure(this.fiber, result));
    },
    $signature: 17
  };
  B._parseImporter____closure.prototype = {
    call$0: function() {
      return J.run$1$x(this.fiber, this.result);
    },
    "call*": "call$0",
    $requiredArgCount: 0
  };
  Y.Chokidar.prototype = {};
  Y.ChokidarOptions.prototype = {};
  Y.ChokidarWatcher.prototype = {};
  V.JSError.prototype = {};
  D.Exports.prototype = {};
  E.FiberClass.prototype = {};
  E.Fiber.prototype = {};
  F.JSFunction.prototype = {};
  F.NodeImporterResult.prototype = {};
  Z.RenderContext.prototype = {};
  L.RenderContextOptions.prototype = {};
  R.RenderOptions.prototype = {};
  U.RenderResult.prototype = {};
  U.RenderResultStats.prototype = {};
  G.Types.prototype = {};
  B.forwardToString_closure.prototype = {
    call$1: function(thisArg) {
      return J.toString$0$(thisArg);
    },
    $signature: 31
  };
  B.createClass_closure.prototype = {
    call$2: function($name, body) {
      this.$prototype[$name] = P.allowInteropCaptureThis(body);
    }
  };
  Z.closure36.prototype = {
    call$0: function() {
      var $constructor = P.allowInterop(new Z._closure4());
      B.injectSuperclass(C.SassBoolean_true, $constructor);
      B.forwardToString($constructor);
      $constructor.prototype.getValue = P.allowInteropCaptureThis(new Z._closure5());
      $constructor.TRUE = C.SassBoolean_true;
      $constructor.FALSE = C.SassBoolean_false;
      return $constructor;
    }
  };
  Z._closure4.prototype = {
    call$1: function(_) {
      throw H.wrapException("new sass.types.Boolean() isn't allowed.\nUse sass.types.Boolean.TRUE or sass.types.Boolean.FALSE instead.");
    },
    call$0: function() {
      return this.call$1(null);
    },
    "call*": "call$1",
    $requiredArgCount: 0,
    $defaultValues: function() {
      return [null];
    },
    $signature: 11
  };
  Z._closure5.prototype = {
    call$1: function(thisArg) {
      return thisArg === C.SassBoolean_true;
    },
    $signature: 19
  };
  K._NodeSassColor.prototype = {};
  K.closure24.prototype = {
    call$6: function(thisArg, redOrArgb, green, blue, alpha, dartValue) {
      var red, t1, t2, t3, t4;
      if (dartValue != null) {
        J.set$dartValue$x(thisArg, dartValue);
        return;
      }
      if (green == null) {
        H.intTypeCast(redOrArgb);
        alpha = C.JSInt_methods._shrOtherPositive$1(redOrArgb, 24) / 255;
        red = C.JSInt_methods.$mod(C.JSInt_methods._shrOtherPositive$1(redOrArgb, 16), 256);
        green = C.JSInt_methods.$mod(C.JSInt_methods._shrOtherPositive$1(redOrArgb, 8), 256);
        blue = C.JSInt_methods.$mod(redOrArgb, 256);
      } else
        red = redOrArgb;
      t1 = C.JSNumber_methods.round$0(J.clamp$2$n(red, 0, 255));
      t2 = C.JSNumber_methods.round$0(C.JSNumber_methods.clamp$2(green, 0, 255));
      t3 = C.JSNumber_methods.round$0(J.clamp$2$n(blue, 0, 255));
      t4 = alpha == null ? null : C.JSNumber_methods.clamp$2(alpha, 0, 1);
      J.set$dartValue$x(thisArg, K.SassColor$rgb(t1, t2, t3, t4 == null ? 1 : t4, null));
    },
    call$2: function(thisArg, redOrArgb) {
      return this.call$6(thisArg, redOrArgb, null, null, null, null);
    },
    call$3: function(thisArg, redOrArgb, green) {
      return this.call$6(thisArg, redOrArgb, green, null, null, null);
    },
    call$4: function(thisArg, redOrArgb, green, blue) {
      return this.call$6(thisArg, redOrArgb, green, blue, null, null);
    },
    call$5: function(thisArg, redOrArgb, green, blue, alpha) {
      return this.call$6(thisArg, redOrArgb, green, blue, alpha, null);
    },
    "call*": "call$6",
    $requiredArgCount: 2,
    $defaultValues: function() {
      return [null, null, null, null];
    }
  };
  K.closure25.prototype = {
    call$1: function(thisArg) {
      return J.get$dartValue$x(thisArg).get$red();
    }
  };
  K.closure26.prototype = {
    call$1: function(thisArg) {
      return J.get$dartValue$x(thisArg).get$green();
    }
  };
  K.closure27.prototype = {
    call$1: function(thisArg) {
      return J.get$dartValue$x(thisArg).get$blue();
    }
  };
  K.closure28.prototype = {
    call$1: function(thisArg) {
      return J.get$dartValue$x(thisArg).alpha;
    }
  };
  K.closure29.prototype = {
    call$2: function(thisArg, value) {
      var t1 = J.getInterceptor$x(thisArg);
      t1.set$dartValue(thisArg, t1.get$dartValue(thisArg).changeRgb$1$red(C.JSNumber_methods.round$0(J.clamp$2$n(value, 0, 255))));
    },
    "call*": "call$2",
    $requiredArgCount: 2
  };
  K.closure30.prototype = {
    call$2: function(thisArg, value) {
      var t1 = J.getInterceptor$x(thisArg);
      t1.set$dartValue(thisArg, t1.get$dartValue(thisArg).changeRgb$1$green(C.JSNumber_methods.round$0(J.clamp$2$n(value, 0, 255))));
    },
    "call*": "call$2",
    $requiredArgCount: 2
  };
  K.closure31.prototype = {
    call$2: function(thisArg, value) {
      var t1 = J.getInterceptor$x(thisArg);
      t1.set$dartValue(thisArg, t1.get$dartValue(thisArg).changeRgb$1$blue(C.JSNumber_methods.round$0(J.clamp$2$n(value, 0, 255))));
    },
    "call*": "call$2",
    $requiredArgCount: 2
  };
  K.closure32.prototype = {
    call$2: function(thisArg, value) {
      var t1 = J.getInterceptor$x(thisArg);
      t1.set$dartValue(thisArg, t1.get$dartValue(thisArg).changeRgb$1$alpha(J.clamp$2$n(value, 0, 1)));
    },
    "call*": "call$2",
    $requiredArgCount: 2
  };
  K.closure33.prototype = {
    call$1: function(thisArg) {
      return J.toString$0$(J.get$dartValue$x(thisArg));
    }
  };
  D._NodeSassList.prototype = {};
  D.closure17.prototype = {
    call$4: function(thisArg, $length, commaSeparator, dartValue) {
      var t1;
      if (dartValue == null) {
        t1 = P.Iterable_Iterable$generate($length, new D._closure3(), F.Value);
        t1 = D.SassList$(t1, commaSeparator !== false ? C.ListSeparator_comma : C.ListSeparator_space, false);
      } else
        t1 = dartValue;
      J.set$dartValue$x(thisArg, t1);
    },
    call$2: function(thisArg, $length) {
      return this.call$4(thisArg, $length, null, null);
    },
    call$3: function(thisArg, $length, commaSeparator) {
      return this.call$4(thisArg, $length, commaSeparator, null);
    },
    "call*": "call$4",
    $requiredArgCount: 2,
    $defaultValues: function() {
      return [null, null];
    }
  };
  D._closure3.prototype = {
    call$1: function(_) {
      return C.C_SassNull;
    },
    $signature: 30
  };
  D.closure18.prototype = {
    call$2: function(thisArg, index) {
      return F.wrapValue(J.get$dartValue$x(thisArg)._list$_contents[index]);
    },
    "call*": "call$2",
    $requiredArgCount: 2
  };
  D.closure19.prototype = {
    call$3: function(thisArg, index, value) {
      var t1 = J.getInterceptor$x(thisArg),
        t2 = t1.get$dartValue(thisArg)._list$_contents,
        mutable = H.setRuntimeTypeInfo(t2.slice(0), [H.getTypeArgumentByIndex(t2, 0)]);
      mutable[index] = F.unwrapValue(value);
      t1.set$dartValue(thisArg, t1.get$dartValue(thisArg).changeListContents$1(mutable));
    },
    "call*": "call$3",
    $requiredArgCount: 3
  };
  D.closure20.prototype = {
    call$1: function(thisArg) {
      return J.get$dartValue$x(thisArg).separator === C.ListSeparator_comma;
    }
  };
  D.closure21.prototype = {
    call$2: function(thisArg, isComma) {
      var t1 = J.getInterceptor$x(thisArg),
        t2 = t1.get$dartValue(thisArg)._list$_contents,
        t3 = isComma ? C.ListSeparator_comma : C.ListSeparator_space;
      t1.set$dartValue(thisArg, D.SassList$(t2, t3, t1.get$dartValue(thisArg).hasBrackets));
    },
    "call*": "call$2",
    $requiredArgCount: 2
  };
  D.closure22.prototype = {
    call$1: function(thisArg) {
      return J.get$dartValue$x(thisArg)._list$_contents.length;
    }
  };
  D.closure23.prototype = {
    call$1: function(thisArg) {
      return J.toString$0$(J.get$dartValue$x(thisArg));
    }
  };
  A._NodeSassMap.prototype = {};
  A.closure10.prototype = {
    call$3: function(thisArg, $length, dartValue) {
      var t1, t2, t3, map;
      if (dartValue == null) {
        t1 = F.Value;
        t2 = P.Iterable_Iterable$generate($length, new A._closure1(), t1);
        t3 = P.Iterable_Iterable$generate($length, new A._closure2(), t1);
        map = P.LinkedHashMap_LinkedHashMap(null, null, null, t1, t1);
        P.MapBase__fillMapWithIterables(map, t2, t3);
        t1 = new A.SassMap(H.ConstantMap_ConstantMap$from(map, t1, t1));
      } else
        t1 = dartValue;
      J.set$dartValue$x(thisArg, t1);
    },
    call$2: function(thisArg, $length) {
      return this.call$3(thisArg, $length, null);
    },
    "call*": "call$3",
    $requiredArgCount: 2,
    $defaultValues: function() {
      return [null];
    }
  };
  A._closure1.prototype = {
    call$1: function(i) {
      return new T.SassNumber(i, C.List_empty0, C.List_empty0, null);
    },
    $signature: 42
  };
  A._closure2.prototype = {
    call$1: function(_) {
      return C.C_SassNull;
    },
    $signature: 30
  };
  A.closure11.prototype = {
    call$2: function(thisArg, index) {
      return F.wrapValue(J.get$dartValue$x(thisArg).contents.get$keys().elementAt$1(0, index));
    },
    "call*": "call$2",
    $requiredArgCount: 2
  };
  A.closure12.prototype = {
    call$2: function(thisArg, index) {
      return F.wrapValue(J.get$dartValue$x(thisArg).contents.get$values().elementAt$1(0, index));
    },
    "call*": "call$2",
    $requiredArgCount: 2
  };
  A.closure13.prototype = {
    call$1: function(thisArg) {
      var t1 = J.get$dartValue$x(thisArg).contents;
      return t1.get$length(t1);
    }
  };
  A.closure14.prototype = {
    call$3: function(thisArg, index, key) {
      var newKey, t2, newMap, t3, i, t4,
        t1 = J.getInterceptor$x(thisArg),
        oldMap = t1.get$dartValue(thisArg).contents;
      P.RangeError_checkValidIndex(index, oldMap, "index");
      newKey = F.unwrapValue(key);
      t2 = F.Value;
      newMap = P.LinkedHashMap_LinkedHashMap$_empty(t2, t2);
      for (t3 = t1.get$dartValue(thisArg).contents.get$keys(), t3 = t3.get$iterator(t3), i = 0; t3.moveNext$0();) {
        t4 = t3.get$current(t3);
        if (i === index)
          newMap.$indexSet(0, newKey, oldMap.$index(0, t4));
        else {
          if (newKey.$eq(0, t4))
            throw H.wrapException(P.ArgumentError$value(key, "key", "is already in the map"));
          newMap.$indexSet(0, t4, oldMap.$index(0, t4));
        }
        ++i;
      }
      t1.set$dartValue(thisArg, new A.SassMap(H.ConstantMap_ConstantMap$from(newMap, t2, t2)));
    },
    "call*": "call$3",
    $requiredArgCount: 3
  };
  A.closure15.prototype = {
    call$3: function(thisArg, index, value) {
      var t4, t5,
        t1 = J.getInterceptor$x(thisArg),
        key = t1.get$dartValue(thisArg).contents.get$keys().elementAt$1(0, index),
        t2 = F.Value,
        t3 = P.LinkedHashMap_LinkedHashMap$_empty(t2, t2);
      for (t4 = t1.get$dartValue(thisArg).contents.get$entries(), t4 = t4.get$iterator(t4); t4.moveNext$0();) {
        t5 = t4.get$current(t4);
        t3.$indexSet(0, t5.key, t5.value);
      }
      t3.$indexSet(0, key, F.unwrapValue(value));
      t1.set$dartValue(thisArg, new A.SassMap(H.ConstantMap_ConstantMap$from(t3, t2, t2)));
    },
    "call*": "call$3",
    $requiredArgCount: 3
  };
  A.closure16.prototype = {
    call$1: function(thisArg) {
      return J.toString$0$(J.get$dartValue$x(thisArg));
    }
  };
  O.closure9.prototype = {
    call$0: function() {
      var $constructor = P.allowInterop(new O._closure());
      B.injectSuperclass(C.C_SassNull, $constructor);
      B.forwardToString($constructor);
      $constructor.NULL = C.C_SassNull;
      C.C_SassNull.toString = P.allowInterop(new O._closure0());
      return $constructor;
    }
  };
  O._closure.prototype = {
    call$1: function(_) {
      throw H.wrapException("new sass.types.Null() isn't allowed. Use sass.types.Null.NULL instead.");
    },
    call$0: function() {
      return this.call$1(null);
    },
    "call*": "call$1",
    $requiredArgCount: 0,
    $defaultValues: function() {
      return [null];
    },
    $signature: 11
  };
  O._closure0.prototype = {
    call$0: function() {
      return "null";
    },
    "call*": "call$0",
    $requiredArgCount: 0
  };
  T._NodeSassNumber.prototype = {};
  T.closure3.prototype = {
    call$4: function(thisArg, value, unit, dartValue) {
      J.set$dartValue$x(thisArg, dartValue == null ? T._parseNumber(value, unit) : dartValue);
    },
    call$2: function(thisArg, value) {
      return this.call$4(thisArg, value, null, null);
    },
    call$3: function(thisArg, value, unit) {
      return this.call$4(thisArg, value, unit, null);
    },
    "call*": "call$4",
    $requiredArgCount: 2,
    $defaultValues: function() {
      return [null, null];
    }
  };
  T.closure4.prototype = {
    call$1: function(thisArg) {
      return J.get$dartValue$x(thisArg).value;
    }
  };
  T.closure5.prototype = {
    call$2: function(thisArg, value) {
      var t1 = J.getInterceptor$x(thisArg),
        t2 = t1.get$dartValue(thisArg).numeratorUnits;
      t1.set$dartValue(thisArg, T.SassNumber$withUnits(value, t1.get$dartValue(thisArg).denominatorUnits, t2));
    },
    "call*": "call$2",
    $requiredArgCount: 2
  };
  T.closure6.prototype = {
    call$1: function(thisArg) {
      var t1 = J.getInterceptor$x(thisArg),
        t2 = C.JSArray_methods.join$1(t1.get$dartValue(thisArg).numeratorUnits, "*");
      return t2 + (t1.get$dartValue(thisArg).denominatorUnits.length === 0 ? "" : "/") + C.JSArray_methods.join$1(t1.get$dartValue(thisArg).denominatorUnits, "*");
    }
  };
  T.closure7.prototype = {
    call$2: function(thisArg, unit) {
      var t1 = J.getInterceptor$x(thisArg);
      t1.set$dartValue(thisArg, T._parseNumber(t1.get$dartValue(thisArg).value, unit));
    },
    "call*": "call$2",
    $requiredArgCount: 2
  };
  T.closure8.prototype = {
    call$1: function(thisArg) {
      return J.toString$0$(J.get$dartValue$x(thisArg));
    }
  };
  T._parseNumber_closure.prototype = {
    call$1: function(unit) {
      return unit.length === 0;
    }
  };
  T._parseNumber_closure0.prototype = {
    call$1: function(unit) {
      return unit.length === 0;
    }
  };
  D._NodeSassString.prototype = {};
  D.closure.prototype = {
    call$3: function(thisArg, value, dartValue) {
      J.set$dartValue$x(thisArg, dartValue == null ? new D.SassString(value, false) : dartValue);
    },
    call$2: function(thisArg, value) {
      return this.call$3(thisArg, value, null);
    },
    "call*": "call$3",
    $requiredArgCount: 2,
    $defaultValues: function() {
      return [null];
    }
  };
  D.closure0.prototype = {
    call$1: function(thisArg) {
      return J.get$dartValue$x(thisArg).text;
    }
  };
  D.closure1.prototype = {
    call$2: function(thisArg, value) {
      J.set$dartValue$x(thisArg, new D.SassString(value, false));
    },
    "call*": "call$2",
    $requiredArgCount: 2
  };
  D.closure2.prototype = {
    call$1: function(thisArg) {
      return J.toString$0$(J.get$dartValue$x(thisArg));
    }
  };
  V.AtRootQueryParser.prototype = {
    parse$0: function() {
      return this.wrapSpanFormatException$1(new V.AtRootQueryParser_parse_closure(this));
    }
  };
  V.AtRootQueryParser_parse_closure.prototype = {
    call$0: function() {
      var include, atRules,
        t1 = this.$this,
        t2 = t1.scanner;
      t2.expectChar$1(40);
      t1.whitespace$0();
      include = t1.scanIdentifier$1("with");
      if (!include)
        t1.expectIdentifier$2$name("without", '"with" or "without"');
      t1.whitespace$0();
      t2.expectChar$1(58);
      t1.whitespace$0();
      atRules = P.LinkedHashSet_LinkedHashSet(P.String);
      do {
        atRules.add$1(0, t1.identifier$0().toLowerCase());
        t1.whitespace$0();
      } while (t1.lookingAtIdentifier$0());
      t2.expectChar$1(41);
      t2.expectDone$0();
      return new V.AtRootQuery(include, atRules, atRules.contains$1(0, "all"), atRules.contains$1(0, "rule"));
    }
  };
  Q.closure129.prototype = {
    call$1: function($function) {
      return $function.name;
    }
  };
  Q.CssParser.prototype = {
    get$plainCss: function() {
      return true;
    },
    silentComment$0: function() {
      var t1 = this.scanner,
        t2 = t1._string_scanner$_position;
      this.super$Parser$silentComment();
      this.error$2("Silent comments aren't allowed in plain CSS.", t1.spanFrom$1(new S._SpanScannerState(t1, t2)));
    },
    atRule$2$root: function(child, root) {
      var $name, urlStart, next, url, urlSpan, queries, t2, t3, t4, t5, t6, _this = this,
        t1 = _this.scanner,
        start = new S._SpanScannerState(t1, t1._string_scanner$_position);
      t1.expectChar$1(64);
      $name = _this.interpolatedIdentifier$0();
      _this.whitespace$0();
      switch ($name.get$asPlain()) {
        case "at-root":
        case "content":
        case "debug":
        case "each":
        case "error":
        case "extend":
        case "for":
        case "function":
        case "if":
        case "include":
        case "mixin":
        case "return":
        case "warn":
        case "while":
          _this.almostAnyValue$0();
          _this.error$2("This at-rule isn't allowed in plain CSS.", t1.spanFrom$1(start));
          break;
        case "charset":
          _this.string$0();
          if (!root)
            _this.error$2("This at-rule is not allowed here.", t1.spanFrom$1(start));
          return;
        case "import":
          urlStart = new S._SpanScannerState(t1, t1._string_scanner$_position);
          next = t1.peekChar$0();
          url = next === 117 || next === 85 ? _this.dynamicUrl$0() : new D.StringExpression(_this.interpolatedString$0().asInterpolation$1$static(true), false);
          urlSpan = t1.spanFrom$1(urlStart);
          _this.whitespace$0();
          queries = _this.tryImportQueries$0();
          _this.expectStatementSeparator$1("@import rule");
          t2 = X.Interpolation$(H.setRuntimeTypeInfo([url], [P.Object]), urlSpan);
          t3 = t1.spanFrom$1(urlStart);
          t4 = queries == null;
          t5 = t4 ? null : queries.item1;
          t4 = t4 ? null : queries.item2;
          t6 = F.Import;
          t3 = H.setRuntimeTypeInfo([new Q.StaticImport(t2, t5, t4, t3)], [t6]);
          t1 = t1.spanFrom$1(start);
          return new B.ImportRule(P.List_List$unmodifiable(t3, t6), t1);
        case "media":
          return _this.mediaRule$1(start);
        case "-moz-document":
          return _this.mozDocumentRule$2(start, $name);
        case "supports":
          return _this.supportsRule$1(start);
        default:
          return _this.unknownAtRule$2(start, $name);
      }
    },
    identifierLike$0: function() {
      var t2, $arguments, _this = this,
        t1 = _this.scanner,
        start = new S._SpanScannerState(t1, t1._string_scanner$_position),
        identifier = _this.interpolatedIdentifier$0(),
        plain = identifier.get$asPlain(),
        specialFunction = _this.trySpecialFunction$2(plain.toLowerCase(), start);
      if (specialFunction != null)
        return specialFunction;
      t2 = t1._string_scanner$_position;
      if (!t1.scanChar$1(40))
        return new D.StringExpression(identifier, false);
      $arguments = H.setRuntimeTypeInfo([], [T.Expression]);
      if (!t1.scanChar$1(41)) {
        do {
          _this.whitespace$0();
          $arguments.push(_this.expression$1$singleEquals(true));
          _this.whitespace$0();
        } while (t1.scanChar$1(44));
        t1.expectChar$1(41);
      }
      if ($.$get$_disallowedFunctionNames().contains$1(0, plain))
        _this.error$2("This function isn't allowed in plain CSS.", t1.spanFrom$1(start));
      return new F.FunctionExpression(null, X.Interpolation$(H.setRuntimeTypeInfo([new D.StringExpression(identifier, false)], [P.Object]), identifier.span), X.ArgumentInvocation$($arguments, C.Map_empty5, t1.spanFrom$1(new S._SpanScannerState(t1, t2)), null, null), t1.spanFrom$1(start));
    }
  };
  E.KeyframeSelectorParser.prototype = {
    parse$0: function() {
      return this.wrapSpanFormatException$1(new E.KeyframeSelectorParser_parse_closure(this));
    },
    _percentage$0: function() {
      var t3, next,
        t1 = this.scanner,
        t2 = t1.scanChar$1(43) ? H.Primitives_stringFromCharCode(43) : "",
        second = t1.peekChar$0();
      if (!T.isDigit(second) && second !== 46)
        t1.error$1("Expected number.");
      while (true) {
        t3 = t1.peekChar$0();
        if (!(t3 != null && t3 >= 48 && t3 <= 57))
          break;
        t2 += H.Primitives_stringFromCharCode(t1.readChar$0());
      }
      if (t1.peekChar$0() === 46) {
        t2 += H.Primitives_stringFromCharCode(t1.readChar$0());
        while (true) {
          t3 = t1.peekChar$0();
          if (!(t3 != null && t3 >= 48 && t3 <= 57))
            break;
          t2 += H.Primitives_stringFromCharCode(t1.readChar$0());
        }
      }
      if (this.scanIdentifier$1("e")) {
        t2 += t1.readChar$0();
        next = t1.peekChar$0();
        if (next === 43 || next === 45)
          t2 += t1.readChar$0();
        if (!T.isDigit(t1.peekChar$0()))
          t1.error$1("Expected digit.");
        while (true) {
          t3 = t1.peekChar$0();
          if (!(t3 != null && t3 >= 48 && t3 <= 57))
            break;
          t2 += H.Primitives_stringFromCharCode(t1.readChar$0());
        }
      }
      t1.expectChar$1(37);
      t2 += H.Primitives_stringFromCharCode(37);
      return t2.charCodeAt(0) == 0 ? t2 : t2;
    }
  };
  E.KeyframeSelectorParser_parse_closure.prototype = {
    call$0: function() {
      var selectors = H.setRuntimeTypeInfo([], [P.String]),
        t1 = this.$this,
        t2 = t1.scanner;
      do {
        t1.whitespace$0();
        if (t1.lookingAtIdentifier$0())
          if (t1.scanIdentifier$1("from"))
            selectors.push("from");
          else {
            t1.expectIdentifier$2$name("to", '"to" or "from"');
            selectors.push("to");
          }
        else
          selectors.push(t1._percentage$0());
        t1.whitespace$0();
      } while (t2.scanChar$1(44));
      t2.expectDone$0();
      return selectors;
    }
  };
  F.MediaQueryParser.prototype = {
    parse$0: function() {
      return this.wrapSpanFormatException$1(new F.MediaQueryParser_parse_closure(this));
    },
    _mediaQuery$0: function() {
      var identifier1, identifier2, type, modifier, t2, features, _this = this, _null = null,
        t1 = _this.scanner;
      if (t1.peekChar$0() !== 40) {
        identifier1 = _this.identifier$0();
        _this.whitespace$0();
        if (!_this.lookingAtIdentifier$0())
          return F.CssMediaQuery$(identifier1, _null, _null);
        identifier2 = _this.identifier$0();
        _this.whitespace$0();
        if (B.equalsIgnoreCase(identifier2, "and")) {
          type = identifier1;
          modifier = _null;
        } else {
          if (_this.scanIdentifier$1("and"))
            _this.whitespace$0();
          else
            return F.CssMediaQuery$(identifier2, _null, identifier1);
          type = identifier2;
          modifier = identifier1;
        }
      } else {
        type = _null;
        modifier = type;
      }
      t2 = P.String;
      features = H.setRuntimeTypeInfo([], [t2]);
      do {
        _this.whitespace$0();
        t1.expectChar$1(40);
        features.push("(" + _this.declarationValue$0() + ")");
        t1.expectChar$1(41);
        _this.whitespace$0();
      } while (_this.scanIdentifier$1("and"));
      if (type == null)
        return new F.CssMediaQuery(_null, _null, P.List_List$unmodifiable(features, t2));
      else
        return F.CssMediaQuery$(type, features, modifier);
    }
  };
  F.MediaQueryParser_parse_closure.prototype = {
    call$0: function() {
      var queries = H.setRuntimeTypeInfo([], [F.CssMediaQuery]),
        t1 = this.$this,
        t2 = t1.scanner;
      do {
        t1.whitespace$0();
        queries.push(t1._mediaQuery$0());
      } while (t2.scanChar$1(44));
      t2.expectDone$0();
      return queries;
    }
  };
  G.Parser.prototype = {
    _parseIdentifier$0: function() {
      return this.wrapSpanFormatException$1(new G.Parser__parseIdentifier_closure(this));
    },
    _isVariableDeclarationLike$0: function() {
      var _this = this,
        t1 = _this.scanner;
      if (!t1.scanChar$1(36))
        return false;
      if (!_this.lookingAtIdentifier$0())
        return false;
      _this.identifier$0();
      _this.whitespace$0();
      return t1.scanChar$1(58);
    },
    whitespace$0: function() {
      do
        this.whitespaceWithoutComments$0();
      while (this.scanComment$0());
    },
    whitespaceWithoutComments$0: function() {
      var t3,
        t1 = this.scanner,
        t2 = t1.string.length;
      while (true) {
        if (t1._string_scanner$_position !== t2) {
          t3 = t1.peekChar$0();
          t3 = t3 === 32 || t3 === 9 || t3 === 10 || t3 === 13 || t3 === 12;
        } else
          t3 = false;
        if (!t3)
          break;
        t1.readChar$0();
      }
    },
    spaces$0: function() {
      var t3,
        t1 = this.scanner,
        t2 = t1.string.length;
      while (true) {
        if (t1._string_scanner$_position !== t2) {
          t3 = t1.peekChar$0();
          t3 = t3 === 32 || t3 === 9;
        } else
          t3 = false;
        if (!t3)
          break;
        t1.readChar$0();
      }
    },
    scanComment$0: function() {
      var next,
        t1 = this.scanner;
      if (t1.peekChar$0() !== 47)
        return false;
      next = t1.peekChar$1(1);
      if (next === 47) {
        this.silentComment$0();
        return true;
      } else if (next === 42) {
        this.loudComment$0();
        return true;
      } else
        return false;
    },
    silentComment$0: function() {
      var t2, t3,
        t1 = this.scanner;
      t1.expect$1("//");
      t2 = t1.string.length;
      while (true) {
        if (t1._string_scanner$_position !== t2) {
          t3 = t1.peekChar$0();
          t3 = !(t3 === 10 || t3 === 13 || t3 === 12);
        } else
          t3 = false;
        if (!t3)
          break;
        t1.readChar$0();
      }
    },
    loudComment$0: function() {
      var next,
        t1 = this.scanner;
      t1.expect$1("/*");
      for (; true;) {
        if (t1.readChar$0() !== 42)
          continue;
        do
          next = t1.readChar$0();
        while (next === 42);
        if (next === 47)
          break;
      }
    },
    identifier$2$normalize$unit: function(normalize, unit) {
      var t1, first,
        _s20_ = "Expected identifier.",
        text = new P.StringBuffer("");
      for (t1 = this.scanner; t1.scanChar$1(45);)
        text._contents += H.Primitives_stringFromCharCode(45);
      first = t1.peekChar$0();
      if (first == null)
        t1.error$1(_s20_);
      else if (normalize && first === 95) {
        t1.readChar$0();
        text._contents += H.Primitives_stringFromCharCode(45);
      } else if (first === 95 || T.isAlphabetic0(first) || first >= 128)
        text._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
      else if (first === 92)
        text._contents += H.S(this.escape$1$identifierStart(true));
      else
        t1.error$1(_s20_);
      this._identifierBody$3$normalize$unit(text, normalize, unit);
      t1 = text._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    identifier$0: function() {
      return this.identifier$2$normalize$unit(false, false);
    },
    identifier$1$normalize: function(normalize) {
      return this.identifier$2$normalize$unit(normalize, false);
    },
    identifier$1$unit: function(unit) {
      return this.identifier$2$normalize$unit(false, unit);
    },
    _identifierBody$3$normalize$unit: function(text, normalize, unit) {
      var t1, next, second, t2;
      for (t1 = this.scanner; true;) {
        next = t1.peekChar$0();
        if (next == null)
          break;
        else if (unit && next === 45) {
          second = t1.peekChar$1(1);
          if (second != null)
            if (second !== 46)
              t2 = second >= 48 && second <= 57;
            else
              t2 = true;
          else
            t2 = false;
          if (t2)
            break;
          text._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
        } else if (normalize && next === 95) {
          t1.readChar$0();
          text._contents += H.Primitives_stringFromCharCode(45);
        } else {
          if (next !== 95) {
            if (!(next >= 97 && next <= 122))
              t2 = next >= 65 && next <= 90;
            else
              t2 = true;
            t2 = t2 || next >= 128;
          } else
            t2 = true;
          if (!t2) {
            t2 = next >= 48 && next <= 57;
            t2 = t2 || next === 45;
          } else
            t2 = true;
          if (t2)
            text._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
          else if (next === 92)
            text._contents += H.S(this.escape$0());
          else
            break;
        }
      }
    },
    _identifierBody$1: function(text) {
      return this._identifierBody$3$normalize$unit(text, false, false);
    },
    string$0: function() {
      var t2, buffer, next,
        t1 = this.scanner,
        quote = t1.readChar$0();
      if (quote !== 39 && quote !== 34) {
        t2 = t1._string_scanner$_position;
        t1.error$2$position("Expected string.", t2 - 1);
      }
      buffer = new P.StringBuffer("");
      for (; true;) {
        next = t1.peekChar$0();
        if (next === quote) {
          t1.readChar$0();
          break;
        } else if (next == null || next === 10 || next === 13 || next === 12)
          t1.error$1("Expected " + H.Primitives_stringFromCharCode(quote) + ".");
        else if (next === 92) {
          t2 = t1.peekChar$1(1);
          if (t2 === 10 || t2 === 13 || t2 === 12) {
            t1.readChar$0();
            t1.readChar$0();
          } else
            buffer._contents += H.Primitives_stringFromCharCode(this.escapeCharacter$0());
        } else
          buffer._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
      }
      t1 = buffer._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    naturalNumber$0: function() {
      var number, t2,
        t1 = this.scanner,
        first = t1.readChar$0();
      if (!T.isDigit(first))
        t1.error$2$position("Expected digit.", t1._string_scanner$_position - 1);
      number = first - 48;
      while (true) {
        t2 = t1.peekChar$0();
        if (!(t2 != null && t2 >= 48 && t2 <= 57))
          break;
        number = number * 10 + (t1.readChar$0() - 48);
      }
      return number;
    },
    declarationValue$1$allowEmpty: function(allowEmpty) {
      var t1, t2, t3, wroteNewline, next, start, end, t4, url, _this = this,
        buffer = new P.StringBuffer(""),
        brackets = H.setRuntimeTypeInfo([], [P.int]);
      $label0$1:
        for (t1 = _this.scanner, t2 = _this.get$loudComment(), t3 = _this.get$string(), wroteNewline = false; true;) {
          next = t1.peekChar$0();
          switch (next) {
            case 92:
              buffer._contents += H.S(_this.escape$1$identifierStart(true));
              wroteNewline = false;
              break;
            case 34:
            case 39:
              start = t1._string_scanner$_position;
              t3.call$0();
              end = t1._string_scanner$_position;
              buffer._contents += J.substring$2$s(t1.string, start, end);
              wroteNewline = false;
              break;
            case 47:
              if (t1.peekChar$1(1) === 42) {
                start = t1._string_scanner$_position;
                t2.call$0();
                end = t1._string_scanner$_position;
                buffer._contents += J.substring$2$s(t1.string, start, end);
              } else
                buffer._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
              wroteNewline = false;
              break;
            case 32:
            case 9:
              if (!wroteNewline) {
                t4 = t1.peekChar$1(1);
                t4 = !(t4 === 32 || t4 === 9 || t4 === 10 || t4 === 13 || t4 === 12);
              } else
                t4 = true;
              if (t4)
                buffer._contents += H.Primitives_stringFromCharCode(32);
              t1.readChar$0();
              break;
            case 10:
            case 13:
            case 12:
              t4 = t1.peekChar$1(-1);
              if (!(t4 === 10 || t4 === 13 || t4 === 12))
                buffer._contents += "\n";
              t1.readChar$0();
              wroteNewline = true;
              break;
            case 40:
            case 123:
            case 91:
              buffer._contents += H.Primitives_stringFromCharCode(next);
              brackets.push(T.opposite(t1.readChar$0()));
              wroteNewline = false;
              break;
            case 41:
            case 125:
            case 93:
              if (brackets.length === 0)
                break $label0$1;
              buffer._contents += H.Primitives_stringFromCharCode(next);
              t1.expectChar$1(brackets.pop());
              wroteNewline = false;
              break;
            case 59:
              if (brackets.length === 0)
                break $label0$1;
              buffer._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
              break;
            case 117:
            case 85:
              url = _this.tryUrl$0();
              if (url != null)
                buffer._contents += url;
              else
                buffer._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
              wroteNewline = false;
              break;
            default:
              if (next == null)
                break $label0$1;
              if (_this.lookingAtIdentifier$0())
                buffer._contents += _this.identifier$0();
              else
                buffer._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
              wroteNewline = false;
              break;
          }
        }
      if (brackets.length !== 0)
        t1.expectChar$1(C.JSArray_methods.get$last(brackets));
      if (!allowEmpty && buffer._contents.length === 0)
        t1.error$1("Expected token.");
      t1 = buffer._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    declarationValue$0: function() {
      return this.declarationValue$1$allowEmpty(false);
    },
    tryUrl$0: function() {
      var buffer, next, t2, _this = this,
        t1 = _this.scanner,
        start = new S._SpanScannerState(t1, t1._string_scanner$_position);
      if (!_this.scanIdentifier$1("url"))
        return;
      if (!t1.scanChar$1(40)) {
        t1.set$state(start);
        return;
      }
      _this.whitespace$0();
      buffer = new P.StringBuffer("");
      buffer._contents = "url(";
      for (; true;) {
        next = t1.peekChar$0();
        if (next == null)
          break;
        else {
          if (next !== 37)
            if (next !== 38)
              if (next !== 35)
                t2 = next >= 42 && next <= 126 || next >= 128;
              else
                t2 = true;
            else
              t2 = true;
          else
            t2 = true;
          if (t2)
            buffer._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
          else if (next === 92)
            buffer._contents += H.S(_this.escape$0());
          else if (next === 32 || next === 9 || next === 10 || next === 13 || next === 12) {
            _this.whitespace$0();
            if (t1.peekChar$0() !== 41)
              break;
          } else if (next === 41) {
            t2 = buffer._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
            return t2.charCodeAt(0) == 0 ? t2 : t2;
          } else
            break;
        }
      }
      t1.set$state(start);
      return;
    },
    variableName$0: function() {
      this.scanner.expectChar$1(36);
      return this.identifier$1$normalize(true);
    },
    escape$1$identifierStart: function(identifierStart) {
      var first, value, i, next,
        t1 = this.scanner;
      t1.expectChar$1(92);
      first = t1.peekChar$0();
      if (first == null)
        return "";
      else if (T.isNewline(first)) {
        t1.error$1("Expected escape sequence.");
        value = 0;
      } else if (T.isHex(first)) {
        for (value = 0, i = 0; i < 6; ++i) {
          next = t1.peekChar$0();
          if (next == null || !T.isHex(next))
            break;
          value = value * 16 + T.asHex(t1.readChar$0());
        }
        this.scanCharIf$1(T.character__isWhitespace$closure());
      } else
        value = t1.readChar$0();
      if (identifierStart)
        t1 = value === 95 || T.isAlphabetic0(value) || value >= 128;
      else
        t1 = value === 95 || T.isAlphabetic0(value) || value >= 128 || T.isDigit(value) || value === 45;
      if (t1)
        return H.Primitives_stringFromCharCode(value);
      else {
        if (value > 31)
          if (value !== 127)
            t1 = identifierStart && T.isDigit(value);
          else
            t1 = true;
        else
          t1 = true;
        if (t1) {
          t1 = H.Primitives_stringFromCharCode(92);
          if (value > 15)
            t1 += H.Primitives_stringFromCharCode(T.hexCharFor(C.JSInt_methods._shrOtherPositive$1(value, 4)));
          t1 = t1 + H.Primitives_stringFromCharCode(T.hexCharFor(value & 15)) + H.Primitives_stringFromCharCode(32);
          return t1.charCodeAt(0) == 0 ? t1 : t1;
        } else
          return P.String_String$fromCharCodes(H.setRuntimeTypeInfo([92, value], [P.int]), 0, null);
      }
    },
    escape$0: function() {
      return this.escape$1$identifierStart(false);
    },
    escapeCharacter$0: function() {
      var first, value, i, next, t2,
        t1 = this.scanner;
      t1.expectChar$1(92);
      first = t1.peekChar$0();
      if (first == null)
        return 65533;
      else if (T.isNewline(first))
        t1.error$1("Expected escape sequence.");
      else if (T.isHex(first)) {
        for (value = 0, i = 0; i < 6; ++i) {
          next = t1.peekChar$0();
          if (next == null || !T.isHex(next))
            break;
          value = (value << 4 >>> 0) + T.asHex(t1.readChar$0());
        }
        t2 = t1.peekChar$0();
        if (t2 === 32 || t2 === 9 || T.isNewline(t2))
          t1.readChar$0();
        if (value !== 0)
          t1 = value >= 55296 && value <= 57343 || value >= 1114111;
        else
          t1 = true;
        if (t1)
          return 65533;
        else
          return value;
      } else
        return t1.readChar$0();
    },
    scanCharIf$1: function(condition) {
      var t1 = this.scanner;
      if (!condition.call$1(t1.peekChar$0()))
        return false;
      t1.readChar$0();
      return true;
    },
    scanCharIgnoreCase$1: function(letter) {
      var t1 = this.scanner;
      if ((t1.peekChar$0() | 32) !== letter)
        return false;
      t1.readChar$0();
      return true;
    },
    expectCharIgnoreCase$1: function(letter) {
      var t2, t3,
        t1 = this.scanner;
      if ((t1.readChar$0() | 32) === letter)
        return;
      t2 = 'Expected "' + H.Primitives_stringFromCharCode(letter) + '".';
      t3 = t1._string_scanner$_position;
      t1.error$2$position(t2, t3 - 1);
    },
    lookingAtNumber$0: function() {
      var second, third,
        t1 = this.scanner,
        first = t1.peekChar$0();
      if (first == null)
        return false;
      if (T.isDigit(first))
        return true;
      if (first === 46) {
        second = t1.peekChar$1(1);
        return second != null && T.isDigit(second);
      } else if (first === 43 || first === 45) {
        second = t1.peekChar$1(1);
        if (second == null)
          return false;
        if (T.isDigit(second))
          return true;
        if (second !== 46)
          return false;
        third = t1.peekChar$1(2);
        return third != null && T.isDigit(third);
      } else
        return false;
    },
    lookingAtIdentifier$1: function($forward) {
      var t1, first, second, third;
      if ($forward == null)
        $forward = 0;
      t1 = this.scanner;
      first = t1.peekChar$1($forward);
      if (first == null)
        return false;
      if (first === 95 || T.isAlphabetic0(first) || first >= 128 || first === 92)
        return true;
      if (first !== 45)
        return false;
      second = t1.peekChar$1($forward + 1);
      if (second == null)
        return false;
      if (second === 95 || T.isAlphabetic0(second) || second >= 128 || second === 92)
        return true;
      if (second !== 45)
        return false;
      third = t1.peekChar$1($forward + 2);
      if (third != null)
        t1 = third === 95 || T.isAlphabetic0(third) || third >= 128;
      else
        t1 = false;
      return t1;
    },
    lookingAtIdentifier$0: function() {
      return this.lookingAtIdentifier$1(null);
    },
    lookingAtIdentifierBody$0: function() {
      var t1,
        next = this.scanner.peekChar$0();
      if (next != null)
        t1 = next === 95 || T.isAlphabetic0(next) || next >= 128 || T.isDigit(next) || next === 45 || next === 92;
      else
        t1 = false;
      return t1;
    },
    scanIdentifier$1: function(text) {
      var t1, start, t2, i, _this = this;
      if (!_this.lookingAtIdentifier$0())
        return false;
      t1 = _this.scanner;
      start = new S._SpanScannerState(t1, t1._string_scanner$_position);
      for (t2 = text.length, i = 0; i < t2; ++i) {
        if (_this.scanCharIgnoreCase$1(C.JSString_methods._codeUnitAt$1(text, i)))
          continue;
        if (start._scanner !== t1)
          H.throwExpression(P.ArgumentError$("The given LineScannerState was not returned by this LineScanner."));
        t2 = start.position;
        if (t2 < 0 || t2 > t1.string.length)
          H.throwExpression(P.ArgumentError$("Invalid position " + t2));
        t1._string_scanner$_position = t2;
        t1._lastMatch = null;
        return false;
      }
      if (!_this.lookingAtIdentifierBody$0())
        return true;
      t1.set$state(start);
      return false;
    },
    expectIdentifier$2$name: function(text, $name) {
      var t1, start, t2, i;
      if ($name == null)
        $name = '"' + text + '"';
      t1 = this.scanner;
      start = t1._string_scanner$_position;
      for (t2 = text.length, i = 0; i < t2; ++i) {
        if (this.scanCharIgnoreCase$1(C.JSString_methods._codeUnitAt$1(text, i)))
          continue;
        t1.error$2$position("Expected " + $name + ".", start);
      }
      if (!this.lookingAtIdentifierBody$0())
        return;
      t1.error$2$position("Expected " + $name, start);
    },
    expectIdentifier$1: function(text) {
      return this.expectIdentifier$2$name(text, null);
    },
    rawText$1: function(consumer) {
      var t1 = this.scanner,
        start = t1._string_scanner$_position;
      consumer.call$0();
      return t1.substring$1(0, start);
    },
    error$2: function(message, span) {
      return H.throwExpression(E.StringScannerException$(message, span, this.scanner.string));
    },
    withErrorMessage$1$2: function(message, callback) {
      var error, t1, exception;
      try {
        t1 = callback.call$0();
        return t1;
      } catch (exception) {
        t1 = H.unwrapException(exception);
        if (t1 instanceof G.SourceSpanFormatException) {
          error = t1;
          throw H.wrapException(G.SourceSpanFormatException$(message, error._span, error.get$source()));
        } else
          throw exception;
      }
    },
    withErrorMessage$2: function(message, callback) {
      return this.withErrorMessage$1$2(message, callback, null);
    },
    wrapSpanFormatException$1$1: function(callback) {
      var error, span, startPosition, t1, exception;
      try {
        t1 = callback.call$0();
        return t1;
      } catch (exception) {
        t1 = H.unwrapException(exception);
        if (t1 instanceof G.SourceSpanFormatException) {
          error = t1;
          span = error._span;
          if (B.startsWithIgnoreCase(error._span_exception$_message, "expected")) {
            t1 = span;
            t1 = t1._end - t1._start === 0;
          } else
            t1 = false;
          if (t1) {
            t1 = span;
            startPosition = this._firstNewlineBefore$1(Y.FileLocation$_(t1.file, t1._start).offset);
            t1 = span;
            if (!J.$eq$(startPosition, Y.FileLocation$_(t1.file, t1._start).offset))
              span = span.file.span$2(startPosition, startPosition);
          }
          throw H.wrapException(E.SassFormatException$(error._span_exception$_message, span));
        } else
          throw exception;
      }
    },
    wrapSpanFormatException$1: function(callback) {
      return this.wrapSpanFormatException$1$1(callback, null);
    },
    _firstNewlineBefore$1: function(position) {
      var t1, t2, lastNewline, codeUnit,
        index = position - 1;
      for (t1 = this.scanner.string, t2 = J.getInterceptor$s(t1), lastNewline = null; index >= 0;) {
        codeUnit = t2.codeUnitAt$1(t1, index);
        if (!(codeUnit === 32 || codeUnit === 9 || codeUnit === 10 || codeUnit === 13 || codeUnit === 12))
          return lastNewline == null ? position : lastNewline;
        if (codeUnit === 10 || codeUnit === 13 || codeUnit === 12)
          lastNewline = index;
        --index;
      }
      return position;
    }
  };
  G.Parser__parseIdentifier_closure.prototype = {
    call$0: function() {
      var t1 = this.$this,
        result = t1.identifier$0();
      t1.scanner.expectDone$0();
      return result;
    }
  };
  U.SassParser.prototype = {
    get$currentIndentation: function() {
      return this._currentIndentation;
    },
    get$indented: function() {
      return true;
    },
    styleRuleSelector$0: function() {
      var t4,
        t1 = this.scanner,
        t2 = t1._string_scanner$_position,
        t3 = new P.StringBuffer(""),
        buffer = new Z.InterpolationBuffer(t3, []);
      do {
        buffer.addInterpolation$1(this.almostAnyValue$0());
        t4 = t3._contents += H.Primitives_stringFromCharCode(10);
      } while (C.JSString_methods.endsWith$1(C.JSString_methods.trimRight$0(t4.charCodeAt(0) == 0 ? t4 : t4), ",") && this.scanCharIf$1(T.character__isNewline$closure()));
      return buffer.interpolation$1(t1.spanFrom$1(new S._SpanScannerState(t1, t2)));
    },
    expectStatementSeparator$1: function($name) {
      var _this = this;
      if (!_this.atEndOfStatement$0())
        _this._expectNewline$0();
      if (_this._peekIndentation$0() <= _this._currentIndentation)
        return;
      _this.scanner.error$2$position("Nothing may be indented " + ($name == null ? "here" : "beneath a " + $name) + ".", _this._nextIndentationEnd.position);
    },
    expectStatementSeparator$0: function() {
      return this.expectStatementSeparator$1(null);
    },
    atEndOfStatement$0: function() {
      var next = this.scanner.peekChar$0();
      return next == null || T.isNewline(next);
    },
    lookingAtChildren$0: function() {
      return this.atEndOfStatement$0() && this._peekIndentation$0() > this._currentIndentation;
    },
    importArgument$0: function() {
      var start, next, t2, _this = this,
        t1 = _this.scanner;
      switch (t1.peekChar$0()) {
        case 117:
        case 85:
          start = new S._SpanScannerState(t1, t1._string_scanner$_position);
          if (_this.scanIdentifier$1("url"))
            if (t1.scanChar$1(40)) {
              t1.set$state(start);
              return _this.super$StylesheetParser$importArgument();
            } else
              t1.set$state(start);
          break;
        case 39:
        case 34:
          return _this.super$StylesheetParser$importArgument();
      }
      start = new S._SpanScannerState(t1, t1._string_scanner$_position);
      next = t1.peekChar$0();
      while (true) {
        if (next != null)
          if (next !== 44)
            if (next !== 59)
              t2 = !(next === 10 || next === 13 || next === 12);
            else
              t2 = false;
          else
            t2 = false;
        else
          t2 = false;
        if (!t2)
          break;
        t1.readChar$0();
        next = t1.peekChar$0();
      }
      return new B.DynamicImport(_this.parseImportUrl$1(t1.substring$1(0, start.position)), t1.spanFrom$1(start));
    },
    scanElse$1: function(ifIndentation) {
      var t1, t2, startIndentation, startNextIndentation, startNextIndentationEnd, _this = this;
      if (_this._peekIndentation$0() != ifIndentation)
        return false;
      t1 = _this.scanner;
      t2 = t1._string_scanner$_position;
      startIndentation = _this._currentIndentation;
      startNextIndentation = _this._nextIndentation;
      startNextIndentationEnd = _this._nextIndentationEnd;
      _this._readIndentation$0();
      if (t1.scanChar$1(64) && _this.scanIdentifier$1("else"))
        return true;
      t1.set$state(new S._SpanScannerState(t1, t2));
      _this._currentIndentation = startIndentation;
      _this._nextIndentation = startNextIndentation;
      _this._nextIndentationEnd = startNextIndentationEnd;
      return false;
    },
    children$1: function(child) {
      var children = H.setRuntimeTypeInfo([], [O.Statement]);
      this._whileIndentedLower$1(new U.SassParser_children_closure(this, children, child));
      return children;
    },
    statements$1: function(statement) {
      var statements, t2, child,
        t1 = this.scanner,
        first = t1.peekChar$0();
      if (first === 9 || first === 32)
        t1.error$3$length$position("Indenting at the beginning of the document is illegal.", t1._string_scanner$_position, 0);
      statements = H.setRuntimeTypeInfo([], [O.Statement]);
      for (t2 = t1.string.length; t1._string_scanner$_position !== t2;) {
        child = this._child$1(statement);
        if (child != null)
          statements.push(child);
        this._readIndentation$0();
      }
      return statements;
    },
    _child$1: function(child) {
      var _this = this,
        t1 = _this.scanner;
      switch (t1.peekChar$0()) {
        case 13:
        case 10:
        case 12:
          return;
        case 36:
          return _this.variableDeclaration$0();
        case 47:
          switch (t1.peekChar$1(1)) {
            case 47:
              return _this._silentComment$0();
            case 42:
              return _this._loudComment$0();
            default:
              return child.call$0();
          }
        default:
          return child.call$0();
      }
    },
    _silentComment$0: function() {
      var buffer, parentIndentation, t3, commentPrefix, i, t4, i0, t5, t6, _this = this,
        t1 = _this.scanner,
        t2 = t1._string_scanner$_position;
      t1.expect$1("//");
      buffer = new P.StringBuffer("");
      parentIndentation = _this._currentIndentation;
      t3 = t1.string;
      $label0$0:
        do {
          commentPrefix = t1.scanChar$1(47) ? "///" : "//";
          for (i = commentPrefix.length; true;) {
            t4 = buffer._contents += commentPrefix;
            for (i0 = i; i0 < _this._currentIndentation - parentIndentation; ++i0) {
              t4 += H.Primitives_stringFromCharCode(32);
              buffer._contents = t4;
            }
            t5 = t3.length;
            while (true) {
              if (t1._string_scanner$_position !== t5) {
                t6 = t1.peekChar$0();
                t6 = !(t6 === 10 || t6 === 13 || t6 === 12);
              } else
                t6 = false;
              if (!t6)
                break;
              t4 += H.Primitives_stringFromCharCode(t1.readChar$0());
              buffer._contents = t4;
            }
            buffer._contents = t4 + "\n";
            if (_this._peekIndentation$0() < parentIndentation)
              break $label0$0;
            if (_this._peekIndentation$0() === parentIndentation) {
              if (t1.peekChar$1(1 + parentIndentation) === 47 && t1.peekChar$1(2 + parentIndentation) === 47)
                _this._readIndentation$0();
              break;
            }
            _this._readIndentation$0();
          }
        } while (t1.scan$1("//"));
      t3 = buffer._contents;
      return _this.lastSilentComment = new B.SilentComment(t3.charCodeAt(0) == 0 ? t3 : t3, t1.spanFrom$1(new S._SpanScannerState(t1, t2)));
    },
    _loudComment$0: function() {
      var t3, t4, buffer, parentIndentation, t5, first, beginningOfComment, t6, end, i, t7, _this = this,
        t1 = _this.scanner,
        t2 = t1._string_scanner$_position;
      t1.expect$1("/*");
      t3 = new P.StringBuffer("");
      t4 = [];
      buffer = new Z.InterpolationBuffer(t3, t4);
      t3._contents = "/*";
      parentIndentation = _this._currentIndentation;
      for (t5 = t1.string, first = true; true; first = false) {
        if (first) {
          beginningOfComment = t1._string_scanner$_position;
          _this.spaces$0();
          t6 = t1.peekChar$0();
          if (t6 === 10 || t6 === 13 || t6 === 12) {
            _this._readIndentation$0();
            t3._contents += H.Primitives_stringFromCharCode(32);
          } else {
            end = t1._string_scanner$_position;
            t3._contents += J.substring$2$s(t5, beginningOfComment, end);
          }
        } else {
          t6 = t3._contents += "\n";
          t3._contents = t6 + " * ";
        }
        for (i = 3; i < _this._currentIndentation - parentIndentation; ++i)
          t3._contents += H.Primitives_stringFromCharCode(32);
        $label0$1:
          for (t6 = t5.length; t1._string_scanner$_position !== t6;)
            switch (t1.peekChar$0()) {
              case 10:
              case 13:
              case 12:
                break $label0$1;
              case 35:
                if (t1.peekChar$1(1) === 123) {
                  t7 = _this.singleInterpolation$0();
                  buffer._flushText$0();
                  t4.push(t7);
                } else
                  t3._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
                break;
              default:
                t3._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
                break;
            }
        if (_this._peekIndentation$0() <= parentIndentation)
          break;
        for (; _this._lookingAtDoubleNewline$0();) {
          _this._expectNewline$0();
          t6 = t3._contents += "\n";
          t3._contents = t6 + " *";
        }
        _this._readIndentation$0();
      }
      t4 = t3._contents;
      if (!C.JSString_methods.endsWith$1(C.JSString_methods.trimRight$0(t4.charCodeAt(0) == 0 ? t4 : t4), "*/"))
        t3._contents += " */";
      return new L.LoudComment(buffer.interpolation$1(t1.spanFrom$1(new S._SpanScannerState(t1, t2))));
    },
    whitespace$0: function() {
      var t1, t2, next;
      for (t1 = this.scanner, t2 = t1.string.length; t1._string_scanner$_position !== t2;) {
        next = t1.peekChar$0();
        if (next !== 9 && next !== 32)
          break;
        t1.readChar$0();
      }
      if (t1.peekChar$0() === 47 && t1.peekChar$1(1) === 47)
        this.silentComment$0();
    },
    _expectNewline$0: function() {
      var t1 = this.scanner;
      switch (t1.peekChar$0()) {
        case 59:
          t1.error$1("semicolons aren't allowed in the indented syntax.");
          break;
        case 13:
          t1.readChar$0();
          if (t1.peekChar$0() === 10)
            t1.readChar$0();
          return;
        case 10:
        case 12:
          t1.readChar$0();
          return;
        default:
          t1.error$1("expected newline.");
      }
    },
    _lookingAtDoubleNewline$0: function() {
      var nextChar,
        t1 = this.scanner;
      switch (t1.peekChar$0()) {
        case 13:
          nextChar = t1.peekChar$1(1);
          if (nextChar === 10)
            return T.isNewline(t1.peekChar$1(2));
          return nextChar === 13 || nextChar === 12;
        case 10:
        case 12:
          return T.isNewline(t1.peekChar$1(1));
        default:
          return false;
      }
    },
    _whileIndentedLower$1: function(body) {
      var t1, t2, childIndentation, indentation, t3, t4, t5, _this = this,
        parentIndentation = _this._currentIndentation;
      for (t1 = _this.scanner, t2 = t1._sourceFile, childIndentation = null; _this._peekIndentation$0() > parentIndentation;) {
        indentation = _this._readIndentation$0();
        if (childIndentation == null)
          childIndentation = indentation;
        if (childIndentation != indentation) {
          t3 = "Inconsistent indentation, expected " + H.S(childIndentation) + " spaces.";
          t4 = t1._string_scanner$_position;
          t5 = t2.getColumn$1(t4);
          t1.error$3$length$position(t3, t2.getColumn$1(t1._string_scanner$_position), t4 - t5);
        }
        body.call$0();
      }
    },
    _readIndentation$0: function() {
      var _this = this;
      if (_this._nextIndentation == null)
        _this._peekIndentation$0();
      _this._currentIndentation = _this._nextIndentation;
      _this.scanner.set$state(_this._nextIndentationEnd);
      _this._nextIndentationEnd = _this._nextIndentation = null;
      return _this._currentIndentation;
    },
    _peekIndentation$0: function() {
      var t2, t3, start, containsTab, containsSpace, next, t4, _this = this,
        t1 = _this._nextIndentation;
      if (t1 != null)
        return t1;
      t1 = _this.scanner;
      t2 = t1._string_scanner$_position;
      t3 = t1.string.length;
      if (t2 === t3) {
        _this._nextIndentation = 0;
        _this._nextIndentationEnd = new S._SpanScannerState(t1, t2);
        return 0;
      }
      start = new S._SpanScannerState(t1, t2);
      if (!_this.scanCharIf$1(T.character__isNewline$closure()))
        t1.error$2$position("Expected newline.", t1._string_scanner$_position);
      do {
        _this._nextIndentation = 0;
        for (containsTab = false, containsSpace = false; true;) {
          next = t1.peekChar$0();
          if (next === 32)
            containsSpace = true;
          else {
            if (next !== 9)
              break;
            containsTab = true;
          }
          _this._nextIndentation = _this._nextIndentation + 1;
          t1.readChar$0();
        }
        t2 = t1._string_scanner$_position;
        if (t2 === t3) {
          _this._nextIndentation = 0;
          _this._nextIndentationEnd = new S._SpanScannerState(t1, t2);
          t1.set$state(start);
          return 0;
        }
      } while (_this.scanCharIf$1(T.character__isNewline$closure()));
      if (containsTab) {
        if (containsSpace) {
          t2 = t1._string_scanner$_position;
          t3 = t1._sourceFile;
          t4 = t3.getColumn$1(t2);
          t1.error$3$length$position("Tabs and spaces may not be mixed.", t3.getColumn$1(t1._string_scanner$_position), t2 - t4);
        } else if (_this._spaces === true) {
          t2 = t1._string_scanner$_position;
          t3 = t1._sourceFile;
          t4 = t3.getColumn$1(t2);
          t1.error$3$length$position("Expected spaces, was tabs.", t3.getColumn$1(t1._string_scanner$_position), t2 - t4);
        }
      } else if (containsSpace && _this._spaces === false) {
        t2 = t1._string_scanner$_position;
        t3 = t1._sourceFile;
        t4 = t3.getColumn$1(t2);
        t1.error$3$length$position("Expected tabs, was spaces.", t3.getColumn$1(t1._string_scanner$_position), t2 - t4);
      }
      if (_this._nextIndentation > 0)
        if (_this._spaces == null)
          _this._spaces = containsSpace;
      _this._nextIndentationEnd = new S._SpanScannerState(t1, t1._string_scanner$_position);
      t1.set$state(start);
      return _this._nextIndentation;
    }
  };
  U.SassParser_children_closure.prototype = {
    call$0: function() {
      this.children.push(this.$this._child$1(this.child));
    }
  };
  L.ScssParser.prototype = {
    get$indented: function() {
      return false;
    },
    get$currentIndentation: function() {
      return;
    },
    styleRuleSelector$0: function() {
      return this.almostAnyValue$0();
    },
    expectStatementSeparator$1: function($name) {
      var t1, next;
      this.whitespaceWithoutComments$0();
      t1 = this.scanner;
      if (t1._string_scanner$_position === t1.string.length)
        return;
      next = t1.peekChar$0();
      if (next === 59 || next === 125)
        return;
      t1.expectChar$1(59);
    },
    expectStatementSeparator$0: function() {
      return this.expectStatementSeparator$1(null);
    },
    atEndOfStatement$0: function() {
      var next = this.scanner.peekChar$0();
      return next == null || next === 59 || next === 125 || next === 123;
    },
    lookingAtChildren$0: function() {
      return this.scanner.peekChar$0() === 123;
    },
    scanElse$1: function(_) {
      var t3, _this = this,
        t1 = _this.scanner,
        t2 = t1._string_scanner$_position;
      _this.whitespace$0();
      t3 = t1._string_scanner$_position;
      if (t1.scanChar$1(64)) {
        if (_this.scanIdentifier$1("else"))
          return true;
        if (_this.scanIdentifier$1("elseif")) {
          _this.logger.warn$3$deprecation$span('@elseif is deprecated and will not be supported in future Sass versions.\nUse "@else if" instead.', true, t1.spanFrom$1(new S._SpanScannerState(t1, t3)));
          t1.set$position(t1._string_scanner$_position - 2);
          return true;
        }
      }
      t1.set$state(new S._SpanScannerState(t1, t2));
      return false;
    },
    children$1: function(child) {
      var children, _this = this,
        t1 = _this.scanner;
      t1.expectChar$1(123);
      _this.whitespaceWithoutComments$0();
      children = H.setRuntimeTypeInfo([], [O.Statement]);
      for (; true;)
        switch (t1.peekChar$0()) {
          case 36:
            children.push(_this.variableDeclaration$0());
            break;
          case 47:
            switch (t1.peekChar$1(1)) {
              case 47:
                children.push(_this._scss$_silentComment$0());
                _this.whitespaceWithoutComments$0();
                break;
              case 42:
                children.push(_this._scss$_loudComment$0());
                _this.whitespaceWithoutComments$0();
                break;
              default:
                children.push(child.call$0());
                break;
            }
            break;
          case 59:
            t1.readChar$0();
            _this.whitespaceWithoutComments$0();
            break;
          case 125:
            t1.expectChar$1(125);
            return children;
          default:
            children.push(child.call$0());
            break;
        }
    },
    statements$1: function(statement) {
      var t1, t2, child, _this = this,
        statements = H.setRuntimeTypeInfo([], [O.Statement]);
      _this.whitespaceWithoutComments$0();
      for (t1 = _this.scanner, t2 = t1.string.length; t1._string_scanner$_position !== t2;)
        switch (t1.peekChar$0()) {
          case 36:
            statements.push(_this.variableDeclaration$0());
            break;
          case 47:
            switch (t1.peekChar$1(1)) {
              case 47:
                statements.push(_this._scss$_silentComment$0());
                _this.whitespaceWithoutComments$0();
                break;
              case 42:
                statements.push(_this._scss$_loudComment$0());
                _this.whitespaceWithoutComments$0();
                break;
              default:
                child = statement.call$0();
                if (child != null)
                  statements.push(child);
                break;
            }
            break;
          case 59:
            t1.readChar$0();
            _this.whitespaceWithoutComments$0();
            break;
          default:
            child = statement.call$0();
            if (child != null)
              statements.push(child);
            break;
        }
      return statements;
    },
    _scss$_silentComment$0: function() {
      var t2, t3, _this = this,
        t1 = _this.scanner,
        start = new S._SpanScannerState(t1, t1._string_scanner$_position);
      t1.expect$1("//");
      t2 = t1.string.length;
      do {
        while (true) {
          if (t1._string_scanner$_position !== t2) {
            t3 = t1.readChar$0();
            t3 = !(t3 === 10 || t3 === 13 || t3 === 12);
          } else
            t3 = false;
          if (!t3)
            break;
        }
        if (t1._string_scanner$_position === t2)
          break;
        _this.whitespaceWithoutComments$0();
      } while (t1.scan$1("//"));
      if (_this.get$plainCss())
        _this.error$2("Silent comments aren't allowed in plain CSS.", t1.spanFrom$1(start));
      return _this.lastSilentComment = new B.SilentComment(t1.substring$1(0, start.position), t1.spanFrom$1(start));
    },
    _scss$_loudComment$0: function() {
      var t3, t4, buffer, t5, endPosition,
        t1 = this.scanner,
        t2 = t1._string_scanner$_position;
      t1.expect$1("/*");
      t3 = new P.StringBuffer("");
      t4 = [];
      buffer = new Z.InterpolationBuffer(t3, t4);
      t3._contents = "/*";
      for (; true;)
        switch (t1.peekChar$0()) {
          case 35:
            if (t1.peekChar$1(1) === 123) {
              t5 = this.singleInterpolation$0();
              buffer._flushText$0();
              t4.push(t5);
            } else
              t3._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
            break;
          case 42:
            t3._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
            if (t1.peekChar$0() !== 47)
              break;
            t3._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
            endPosition = t1._string_scanner$_position;
            return new L.LoudComment(buffer.interpolation$1(Y._FileSpan$(t1._sourceFile, new S._SpanScannerState(t1, t2).position, endPosition)));
          case 13:
            t1.readChar$0();
            if (t1.peekChar$0() !== 10)
              t3._contents += H.Primitives_stringFromCharCode(10);
            break;
          case 12:
            t1.readChar$0();
            t3._contents += H.Primitives_stringFromCharCode(10);
            break;
          default:
            t3._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
            break;
        }
    }
  };
  T.SelectorParser.prototype = {
    parse$0: function() {
      return this.wrapSpanFormatException$1(new T.SelectorParser_parse_closure(this));
    },
    parseCompoundSelector$0: function() {
      return this.wrapSpanFormatException$1(new T.SelectorParser_parseCompoundSelector_closure(this));
    },
    _selectorList$0: function() {
      var t3, t4, lineBreak, _this = this,
        t1 = _this.scanner,
        t2 = t1._sourceFile,
        previousLine = t2.getLine$1(t1._string_scanner$_position),
        components = H.setRuntimeTypeInfo([_this._complexSelector$0()], [S.ComplexSelector]);
      _this.whitespace$0();
      for (t3 = t1.string; t1.scanChar$1(44);) {
        _this.whitespace$0();
        if (t1.peekChar$0() === 44)
          continue;
        t4 = t1._string_scanner$_position;
        if (t4 === t3.length)
          break;
        lineBreak = t2.getLine$1(t4) != previousLine;
        if (lineBreak)
          previousLine = t2.getLine$1(t1._string_scanner$_position);
        components.push(_this._complexSelector$1$lineBreak(lineBreak));
      }
      return D.SelectorList$(components);
    },
    _complexSelector$1$lineBreak: function(lineBreak) {
      var t1, next, _this = this,
        _s58_ = '"&" may only used at the beginning of a compound selector.',
        components = H.setRuntimeTypeInfo([], [S.ComplexSelectorComponent]);
      $label0$1:
        for (t1 = _this.scanner; true;) {
          _this.whitespace$0();
          next = t1.peekChar$0();
          switch (next) {
            case 43:
              t1.readChar$0();
              components.push(C.Combinator_uzg);
              break;
            case 62:
              t1.readChar$0();
              components.push(C.Combinator_sgq);
              break;
            case 126:
              t1.readChar$0();
              components.push(C.Combinator_CzM);
              break;
            case 91:
            case 46:
            case 35:
            case 37:
            case 58:
            case 38:
            case 42:
            case 124:
              components.push(_this._compoundSelector$0());
              if (t1.peekChar$0() === 38)
                t1.error$1(_s58_);
              break;
            default:
              if (next == null || !_this.lookingAtIdentifier$0())
                break $label0$1;
              components.push(_this._compoundSelector$0());
              if (t1.peekChar$0() === 38)
                t1.error$1(_s58_);
              break;
          }
        }
      if (components.length === 0)
        t1.error$1("expected selector.");
      return S.ComplexSelector$(components, lineBreak);
    },
    _complexSelector$0: function() {
      return this._complexSelector$1$lineBreak(false);
    },
    _compoundSelector$0: function() {
      var t2,
        components = H.setRuntimeTypeInfo([this._simpleSelector$0()], [M.SimpleSelector]),
        t1 = this.scanner;
      while (true) {
        t2 = t1.peekChar$0();
        if (!(t2 === 42 || t2 === 91 || t2 === 46 || t2 === 35 || t2 === 37 || t2 === 58))
          break;
        components.push(this._simpleSelector$1$allowParent(false));
      }
      return X.CompoundSelector$(components);
    },
    _simpleSelector$1$allowParent: function(allowParent) {
      var $name, text, t2, suffix, _this = this,
        t1 = _this.scanner,
        start = new S._SpanScannerState(t1, t1._string_scanner$_position);
      if (allowParent == null)
        allowParent = _this._allowParent;
      switch (t1.peekChar$0()) {
        case 91:
          return _this._attributeSelector$0();
        case 46:
          t1.expectChar$1(46);
          return new X.ClassSelector(_this.identifier$0());
        case 35:
          t1.expectChar$1(35);
          return new N.IDSelector(_this.identifier$0());
        case 37:
          t1.expectChar$1(37);
          $name = _this.identifier$0();
          if (!_this._allowPlaceholder)
            _this.error$2("Placeholder selectors aren't allowed here.", t1.spanFrom$1(start));
          return new N.PlaceholderSelector($name);
        case 58:
          return _this._pseudoSelector$0();
        case 38:
          t1.expectChar$1(38);
          if (_this.lookingAtIdentifierBody$0()) {
            text = new P.StringBuffer("");
            _this._identifierBody$1(text);
            if (text._contents.length === 0)
              t1.error$1("Expected identifier body.");
            t2 = text._contents;
            suffix = t2.charCodeAt(0) == 0 ? t2 : t2;
          } else
            suffix = null;
          if (!allowParent)
            _this.error$2("Parent selectors aren't allowed here.", t1.spanFrom$1(start));
          return new M.ParentSelector(suffix);
        default:
          return _this._typeOrUniversalSelector$0();
      }
    },
    _simpleSelector$0: function() {
      return this._simpleSelector$1$allowParent(null);
    },
    _attributeSelector$0: function() {
      var $name, operator, next, value, modifier, _this = this, _null = null,
        t1 = _this.scanner;
      t1.expectChar$1(91);
      _this.whitespace$0();
      $name = _this._attributeName$0();
      _this.whitespace$0();
      if (t1.scanChar$1(93))
        return new N.AttributeSelector($name, _null, _null, _null);
      operator = _this._attributeOperator$0();
      _this.whitespace$0();
      next = t1.peekChar$0();
      value = next === 39 || next === 34 ? _this.string$0() : _this.identifier$0();
      _this.whitespace$0();
      modifier = T.isAlphabetic0(t1.peekChar$0()) ? H.Primitives_stringFromCharCode(t1.readChar$0()) : _null;
      t1.expectChar$1(93);
      return new N.AttributeSelector($name, operator, value, modifier);
    },
    _attributeName$0: function() {
      var nameOrNamespace, _this = this,
        t1 = _this.scanner;
      if (t1.scanChar$1(42)) {
        t1.expectChar$1(124);
        return new D.QualifiedName(_this.identifier$0(), "*");
      }
      nameOrNamespace = _this.identifier$0();
      if (t1.peekChar$0() !== 124 || t1.peekChar$1(1) === 61)
        return new D.QualifiedName(nameOrNamespace, null);
      t1.readChar$0();
      return new D.QualifiedName(_this.identifier$0(), nameOrNamespace);
    },
    _attributeOperator$0: function() {
      var t1 = this.scanner,
        t2 = t1._string_scanner$_position;
      switch (t1.readChar$0()) {
        case 61:
          return C.AttributeOperator_sEs;
        case 126:
          t1.expectChar$1(61);
          return C.AttributeOperator_fz1;
        case 124:
          t1.expectChar$1(61);
          return C.AttributeOperator_AuK;
        case 94:
          t1.expectChar$1(61);
          return C.AttributeOperator_4L5;
        case 36:
          t1.expectChar$1(61);
          return C.AttributeOperator_mOX;
        case 42:
          t1.expectChar$1(61);
          return C.AttributeOperator_gqZ;
        default:
          t1.error$2$position('Expected "]".', t2);
      }
    },
    _pseudoSelector$0: function() {
      var element, $name, unvendored, selector, argument, t2, _this = this, _null = null,
        t1 = _this.scanner;
      t1.expectChar$1(58);
      element = t1.scanChar$1(58);
      $name = _this.identifier$0();
      if (!t1.scanChar$1(40))
        return D.PseudoSelector$($name, _null, element, _null);
      _this.whitespace$0();
      unvendored = B.unvendor($name);
      if (element)
        if ($._selectorPseudoElements.contains$1(0, unvendored)) {
          selector = _this._selectorList$0();
          argument = _null;
        } else {
          argument = _this.declarationValue$1$allowEmpty(true);
          selector = _null;
        }
      else if ($._selectorPseudoClasses.contains$1(0, unvendored)) {
        selector = _this._selectorList$0();
        argument = _null;
      } else if (unvendored === "nth-child" || unvendored === "nth-last-child") {
        argument = _this._aNPlusB$0();
        _this.whitespace$0();
        t2 = t1.peekChar$1(-1);
        if ((t2 === 32 || t2 === 9 || T.isNewline(t2)) && t1.peekChar$0() !== 41) {
          _this.expectIdentifier$1("of");
          argument += " of";
          _this.whitespace$0();
          selector = _this._selectorList$0();
        } else
          selector = _null;
      } else {
        argument = C.JSString_methods.trimRight$0(_this.declarationValue$1$allowEmpty(true));
        selector = _null;
      }
      t1.expectChar$1(41);
      return D.PseudoSelector$($name, argument, element, selector);
    },
    _aNPlusB$0: function() {
      var t2, first, t3, next, last, _this = this,
        t1 = _this.scanner;
      switch (t1.peekChar$0()) {
        case 101:
        case 69:
          _this.expectIdentifier$1("even");
          return "even";
        case 111:
        case 79:
          _this.expectIdentifier$1("odd");
          return "odd";
        case 43:
        case 45:
          t2 = H.Primitives_stringFromCharCode(t1.readChar$0());
          break;
        default:
          t2 = "";
      }
      first = t1.peekChar$0();
      if (first != null && T.isDigit(first)) {
        while (true) {
          t3 = t1.peekChar$0();
          if (!(t3 != null && t3 >= 48 && t3 <= 57))
            break;
          t2 += H.Primitives_stringFromCharCode(t1.readChar$0());
        }
        _this.whitespace$0();
        if (!_this.scanCharIgnoreCase$1(110))
          return t2.charCodeAt(0) == 0 ? t2 : t2;
      } else
        _this.expectCharIgnoreCase$1(110);
      t2 += H.Primitives_stringFromCharCode(110);
      _this.whitespace$0();
      next = t1.peekChar$0();
      if (next !== 43 && next !== 45)
        return t2.charCodeAt(0) == 0 ? t2 : t2;
      t2 += H.Primitives_stringFromCharCode(t1.readChar$0());
      _this.whitespace$0();
      last = t1.peekChar$0();
      if (last == null || !T.isDigit(last))
        t1.error$1("Expected a number.");
      while (true) {
        t3 = t1.peekChar$0();
        if (!(t3 != null && t3 >= 48 && t3 <= 57))
          break;
        t2 += H.Primitives_stringFromCharCode(t1.readChar$0());
      }
      return t2.charCodeAt(0) == 0 ? t2 : t2;
    },
    _typeOrUniversalSelector$0: function() {
      var nameOrNamespace, _this = this,
        t1 = _this.scanner,
        first = t1.peekChar$0();
      if (first === 42) {
        t1.readChar$0();
        if (!t1.scanChar$1(124))
          return new N.UniversalSelector(null);
        if (t1.scanChar$1(42))
          return new N.UniversalSelector("*");
        else
          return new F.TypeSelector(new D.QualifiedName(_this.identifier$0(), "*"));
      } else if (first === 124) {
        t1.readChar$0();
        if (t1.scanChar$1(42))
          return new N.UniversalSelector("");
        else
          return new F.TypeSelector(new D.QualifiedName(_this.identifier$0(), ""));
      }
      nameOrNamespace = _this.identifier$0();
      if (!t1.scanChar$1(124))
        return new F.TypeSelector(new D.QualifiedName(nameOrNamespace, null));
      else if (t1.scanChar$1(42))
        return new N.UniversalSelector(nameOrNamespace);
      else
        return new F.TypeSelector(new D.QualifiedName(_this.identifier$0(), nameOrNamespace));
    }
  };
  T.SelectorParser_parse_closure.prototype = {
    call$0: function() {
      var t1 = this.$this,
        selector = t1._selectorList$0();
      t1 = t1.scanner;
      if (t1._string_scanner$_position !== t1.string.length)
        t1.error$1("expected selector.");
      return selector;
    }
  };
  T.SelectorParser_parseCompoundSelector_closure.prototype = {
    call$0: function() {
      var t1 = this.$this,
        compound = t1._compoundSelector$0();
      t1 = t1.scanner;
      if (t1._string_scanner$_position !== t1.string.length)
        t1.error$1("expected selector.");
      return compound;
    }
  };
  V.StylesheetParser.prototype = {
    parse$0: function() {
      return this.wrapSpanFormatException$1(new V.StylesheetParser_parse_closure(this));
    },
    parseArgumentDeclaration$0: function() {
      return this.wrapSpanFormatException$1(new V.StylesheetParser_parseArgumentDeclaration_closure(this));
    },
    parseExpression$0: function() {
      return this.wrapSpanFormatException$1(new V.StylesheetParser_parseExpression_closure(this));
    },
    parseVariableDeclaration$0: function() {
      return this.wrapSpanFormatException$1(new V.StylesheetParser_parseVariableDeclaration_closure(this));
    },
    parseSignature$0: function() {
      return this.wrapSpanFormatException$1(new V.StylesheetParser_parseSignature_closure(this));
    },
    _statement$1$root: function(root) {
      var t2, _this = this,
        t1 = _this.scanner;
      switch (t1.peekChar$0()) {
        case 64:
          return _this.atRule$2$root(new V.StylesheetParser__statement_closure(_this), root);
        case 43:
          if (!_this.get$indented() || !_this.lookingAtIdentifier$1(1))
            return _this._stylesheet$_styleRule$0();
          _this._isUseAllowed = false;
          t2 = t1._string_scanner$_position;
          t1.readChar$0();
          return _this._includeRule$1(new S._SpanScannerState(t1, t2));
        case 61:
          if (!_this.get$indented())
            return _this._stylesheet$_styleRule$0();
          _this._isUseAllowed = false;
          t2 = t1._string_scanner$_position;
          t1.readChar$0();
          _this.whitespace$0();
          return _this._mixinRule$1(new S._SpanScannerState(t1, t2));
        default:
          _this._isUseAllowed = false;
          return _this._inStyleRule || _this._stylesheet$_inUnknownAtRule || _this._stylesheet$_inMixin || _this._inContentBlock ? _this._declarationOrStyleRule$0() : _this._stylesheet$_styleRule$0();
      }
    },
    _statement$0: function() {
      return this._statement$1$root(false);
    },
    variableDeclaration$0: function() {
      var t1, start, $name, name0, namespace, value, flagStart, t2, guarded, global, flag, endPosition, declaration, _this = this,
        precedingComment = _this.lastSilentComment;
      _this.lastSilentComment = null;
      t1 = _this.scanner;
      start = new S._SpanScannerState(t1, t1._string_scanner$_position);
      $name = _this.variableName$0();
      if (t1.scanChar$1(46)) {
        name0 = _this._publicIdentifier$0();
        namespace = $name;
        $name = name0;
      } else
        namespace = null;
      if (_this.get$plainCss())
        _this.error$2("Sass variables aren't allowed in plain CSS.", t1.spanFrom$1(start));
      _this.whitespace$0();
      t1.expectChar$1(58);
      _this.whitespace$0();
      value = _this.expression$0();
      flagStart = new S._SpanScannerState(t1, t1._string_scanner$_position);
      for (t2 = namespace != null, guarded = false, global = false; t1.scanChar$1(33);) {
        flag = _this.identifier$0();
        if (flag === "default")
          guarded = true;
        else if (flag === "global") {
          if (t2) {
            endPosition = t1._string_scanner$_position;
            _this.error$2("!global isn't allowed for variables in other modules.", Y._FileSpan$(t1._sourceFile, flagStart.position, endPosition));
          }
          global = true;
        } else {
          endPosition = t1._string_scanner$_position;
          _this.error$2("Invalid flag name.", Y._FileSpan$(t1._sourceFile, flagStart.position, endPosition));
        }
        _this.whitespace$0();
        flagStart = new S._SpanScannerState(t1, t1._string_scanner$_position);
      }
      _this.expectStatementSeparator$1("variable declaration");
      declaration = Z.VariableDeclaration$($name, value, t1.spanFrom$1(start), precedingComment, global, guarded, namespace);
      if (global)
        _this._globalVariables.putIfAbsent$2($name, new V.StylesheetParser_variableDeclaration_closure(declaration));
      return declaration;
    },
    _stylesheet$_styleRule$0: function() {
      var t1, rule, _this = this,
        wasInStyleRule = _this._inStyleRule;
      _this._inStyleRule = true;
      if (_this.get$indented())
        _this.scanner.scanChar$1(92);
      t1 = _this.scanner;
      rule = _this._withChildren$3(_this.get$_statement(), new S._SpanScannerState(t1, t1._string_scanner$_position), new V.StylesheetParser__styleRule_closure(_this.styleRuleSelector$0()));
      _this._inStyleRule = wasInStyleRule;
      return rule;
    },
    _declarationOrStyleRule$0: function() {
      var t1, start, declarationOrBuffer, selectorSpan, wasInStyleRule, _this = this;
      if (_this.get$plainCss() && _this._inStyleRule && !_this._stylesheet$_inUnknownAtRule)
        return _this._declaration$0();
      if (_this.get$indented() && _this.scanner.scanChar$1(92))
        return _this._stylesheet$_styleRule$0();
      t1 = _this.scanner;
      start = new S._SpanScannerState(t1, t1._string_scanner$_position);
      declarationOrBuffer = _this._declarationOrBuffer$0();
      if (declarationOrBuffer instanceof L.Declaration)
        return declarationOrBuffer;
      H.interceptedTypeCast(declarationOrBuffer, "$isInterpolationBuffer");
      declarationOrBuffer.addInterpolation$1(_this.styleRuleSelector$0());
      selectorSpan = t1.spanFrom$1(start);
      wasInStyleRule = _this._inStyleRule;
      _this._inStyleRule = true;
      if (declarationOrBuffer._interpolation_buffer$_contents.length === 0 && declarationOrBuffer._interpolation_buffer$_text._contents.length === 0)
        t1.error$1('expected "}".');
      return _this._withChildren$3(_this.get$_statement(), start, new V.StylesheetParser__declarationOrStyleRule_closure(_this, selectorSpan, wasInStyleRule, declarationOrBuffer, start));
    },
    _declarationOrBuffer$0: function() {
      var midBuffer, couldBeSelector, beforeDeclaration, additional, t3, $name, value, postColonWhitespace, t4, t5, exception, _this = this, t1 = {},
        t2 = _this.scanner,
        start = new S._SpanScannerState(t2, t2._string_scanner$_position),
        nameBuffer = new Z.InterpolationBuffer(new P.StringBuffer(""), []),
        first = t2.peekChar$0();
      if (first !== 58)
        if (first !== 42)
          if (first !== 46)
            t3 = first === 35 && t2.peekChar$1(1) !== 123;
          else
            t3 = true;
        else
          t3 = true;
      else
        t3 = true;
      if (t3) {
        t3 = t2.readChar$0();
        nameBuffer._interpolation_buffer$_text._contents += H.Primitives_stringFromCharCode(t3);
        t3 = _this.rawText$1(_this.get$whitespace());
        nameBuffer._interpolation_buffer$_text._contents += t3;
      }
      if (!_this._lookingAtInterpolatedIdentifier$0())
        return nameBuffer;
      nameBuffer.addInterpolation$1(_this.interpolatedIdentifier$0());
      if (t2.matches$1("/*")) {
        t3 = _this.rawText$1(_this.get$loudComment());
        nameBuffer._interpolation_buffer$_text._contents += t3;
      }
      midBuffer = new P.StringBuffer("");
      midBuffer._contents += _this.rawText$1(_this.get$whitespace());
      t3 = t2._string_scanner$_position;
      if (!t2.scanChar$1(58)) {
        if (midBuffer._contents.length !== 0)
          nameBuffer._interpolation_buffer$_text._contents += H.Primitives_stringFromCharCode(32);
        return nameBuffer;
      }
      midBuffer._contents += H.Primitives_stringFromCharCode(58);
      $name = nameBuffer.interpolation$1(t2.spanFrom$2(start, new S._SpanScannerState(t2, t3)));
      first = C.JSArray_methods.get$first($name.contents);
      if (C.JSString_methods.startsWith$1(typeof first === "string" ? first : "", "--")) {
        value = _this._interpolatedDeclarationValue$0();
        _this.expectStatementSeparator$1("custom property");
        return L.Declaration$($name, t2.spanFrom$1(start), null, value);
      }
      if (t2.scanChar$1(58)) {
        t1 = nameBuffer;
        t2 = t1._interpolation_buffer$_text;
        t2._contents += H.S(midBuffer);
        t2._contents += H.Primitives_stringFromCharCode(58);
        return t1;
      } else if (_this.get$indented() && _this._lookingAtInterpolatedIdentifier$0()) {
        t1 = nameBuffer;
        t1._interpolation_buffer$_text._contents += H.S(midBuffer);
        return t1;
      }
      postColonWhitespace = _this.rawText$1(_this.get$whitespace());
      if (_this.lookingAtChildren$0())
        return _this._withChildren$3(_this.get$_declarationChild(), start, new V.StylesheetParser__declarationOrBuffer_closure($name));
      midBuffer._contents += postColonWhitespace;
      couldBeSelector = postColonWhitespace.length === 0 && _this._lookingAtInterpolatedIdentifier$0();
      beforeDeclaration = new S._SpanScannerState(t2, t2._string_scanner$_position);
      t1.value = null;
      try {
        if (_this.lookingAtChildren$0()) {
          t3 = H.setRuntimeTypeInfo([], [P.Object]);
          t4 = Y.FileLocation$_(t2._sourceFile, t2._string_scanner$_position);
          t5 = t4.offset;
          value = new D.StringExpression(X.Interpolation$(t3, Y._FileSpan$(t4.file, t5, t5)), true);
        } else
          value = _this.expression$0();
        t3 = t1.value = value;
        if (_this.lookingAtChildren$0()) {
          if (couldBeSelector)
            _this.expectStatementSeparator$0();
        } else if (!_this.atEndOfStatement$0())
          _this.expectStatementSeparator$0();
      } catch (exception) {
        if (!!J.getInterceptor$(H.unwrapException(exception)).$isFormatException) {
          if (!couldBeSelector)
            throw exception;
          t2.set$state(beforeDeclaration);
          additional = _this.almostAnyValue$0();
          if (!_this.get$indented() && t2.peekChar$0() === 59)
            throw exception;
          nameBuffer._interpolation_buffer$_text._contents += H.S(midBuffer);
          nameBuffer.addInterpolation$1(additional);
          return nameBuffer;
        } else
          throw exception;
      }
      if (_this.lookingAtChildren$0())
        return _this._withChildren$3(_this.get$_declarationChild(), start, new V.StylesheetParser__declarationOrBuffer_closure0(t1, $name));
      else {
        _this.expectStatementSeparator$0();
        return L.Declaration$($name, t2.spanFrom$1(start), null, t3);
      }
    },
    _declaration$0: function() {
      var first, t3, nameBuffer, value, _this = this,
        _s48_ = "Nested declarations aren't allowed in plain CSS.",
        t1 = {},
        t2 = _this.scanner,
        start = new S._SpanScannerState(t2, t2._string_scanner$_position);
      t1.name = null;
      first = t2.peekChar$0();
      if (first !== 58)
        if (first !== 42)
          if (first !== 46)
            t3 = first === 35 && t2.peekChar$1(1) !== 123;
          else
            t3 = true;
        else
          t3 = true;
      else
        t3 = true;
      if (t3) {
        t3 = new P.StringBuffer("");
        nameBuffer = new Z.InterpolationBuffer(t3, []);
        t3._contents += H.Primitives_stringFromCharCode(t2.readChar$0());
        t3._contents += _this.rawText$1(_this.get$whitespace());
        nameBuffer.addInterpolation$1(_this.interpolatedIdentifier$0());
        t3 = t1.name = nameBuffer.interpolation$1(t2.spanFrom$1(start));
      } else
        t3 = t1.name = _this.interpolatedIdentifier$0();
      _this.whitespace$0();
      t2.expectChar$1(58);
      _this.whitespace$0();
      if (_this.lookingAtChildren$0()) {
        if (_this.get$plainCss())
          t2.error$1(_s48_);
        return _this._withChildren$3(_this.get$_declarationChild(), start, new V.StylesheetParser__declaration_closure(t1));
      }
      value = _this.expression$0();
      if (_this.lookingAtChildren$0()) {
        if (_this.get$plainCss())
          t2.error$1(_s48_);
        return _this._withChildren$3(_this.get$_declarationChild(), start, new V.StylesheetParser__declaration_closure0(t1, value));
      } else {
        _this.expectStatementSeparator$0();
        return L.Declaration$(t3, t2.spanFrom$1(start), null, value);
      }
    },
    _declarationChild$0: function() {
      if (this.scanner.peekChar$0() === 64)
        return this._declarationAtRule$0();
      return this._declaration$0();
    },
    atRule$2$root: function(child, root) {
      var $name, wasUseAllowed, value, optional, _this = this,
        t1 = _this.scanner,
        start = new S._SpanScannerState(t1, t1._string_scanner$_position);
      t1.expectChar$2$name(64, "@-rule");
      $name = _this.interpolatedIdentifier$0();
      _this.whitespace$0();
      wasUseAllowed = _this._isUseAllowed;
      _this._isUseAllowed = false;
      switch ($name.get$asPlain()) {
        case "at-root":
          return _this._atRootRule$1(start);
        case "charset":
          _this._isUseAllowed = wasUseAllowed;
          if (!root)
            _this._disallowedAtRule$1(start);
          _this.string$0();
          return;
        case "content":
          return _this._contentRule$1(start);
        case "debug":
          return _this._debugRule$1(start);
        case "each":
          return _this._eachRule$2(start, child);
        case "else":
          return _this._disallowedAtRule$1(start);
        case "error":
          return _this._errorRule$1(start);
        case "extend":
          if (!_this._inStyleRule && !_this._stylesheet$_inMixin && !_this._inContentBlock)
            _this.error$2("@extend may only be used within style rules.", t1.spanFrom$1(start));
          value = _this.almostAnyValue$0();
          optional = t1.scanChar$1(33);
          if (optional)
            _this.expectIdentifier$1("optional");
          _this.expectStatementSeparator$1("@extend rule");
          return new X.ExtendRule(value, optional, t1.spanFrom$1(start));
        case "for":
          return _this._forRule$2(start, child);
        case "forward":
          _this._isUseAllowed = wasUseAllowed;
          if (!root)
            _this._disallowedAtRule$1(start);
          return _this._forwardRule$1(start);
        case "function":
          return _this._functionRule$1(start);
        case "if":
          return _this._ifRule$2(start, child);
        case "import":
          return _this._importRule$1(start);
        case "include":
          return _this._includeRule$1(start);
        case "media":
          return _this.mediaRule$1(start);
        case "mixin":
          return _this._mixinRule$1(start);
        case "-moz-document":
          return _this.mozDocumentRule$2(start, $name);
        case "return":
          return _this._disallowedAtRule$1(start);
        case "supports":
          return _this.supportsRule$1(start);
        case "use":
          _this._isUseAllowed = wasUseAllowed;
          if (!root)
            _this._disallowedAtRule$1(start);
          return _this._useRule$1(start);
        case "warn":
          return _this._warnRule$1(start);
        case "while":
          return _this._whileRule$2(start, child);
        default:
          return _this.unknownAtRule$2(start, $name);
      }
    },
    _declarationAtRule$0: function() {
      var _this = this,
        t1 = _this.scanner,
        start = new S._SpanScannerState(t1, t1._string_scanner$_position);
      switch (_this._plainAtRuleName$0()) {
        case "content":
          return _this._contentRule$1(start);
        case "debug":
          return _this._debugRule$1(start);
        case "each":
          return _this._eachRule$2(start, _this.get$_declarationChild());
        case "else":
          return _this._disallowedAtRule$1(start);
        case "error":
          return _this._errorRule$1(start);
        case "for":
          return _this._forRule$2(start, _this.get$_declarationAtRule());
        case "if":
          return _this._ifRule$2(start, _this.get$_declarationChild());
        case "include":
          return _this._includeRule$1(start);
        case "warn":
          return _this._warnRule$1(start);
        case "while":
          return _this._whileRule$2(start, _this.get$_declarationChild());
        default:
          return _this._disallowedAtRule$1(start);
      }
    },
    _functionAtRule$0: function() {
      var position, statement, exception, start, value, _this = this,
        t1 = _this.scanner;
      if (t1.peekChar$0() !== 64) {
        position = t1._string_scanner$_position;
        statement = null;
        try {
          statement = _this._declarationOrStyleRule$0();
        } catch (exception) {
          if (H.unwrapException(exception) instanceof G.SourceSpanFormatException)
            t1.error$2$position("expected @-rule", position);
          else
            throw exception;
        }
        _this.error$2("@function rules may not contain " + (statement instanceof X.StyleRule ? "style rules" : "declarations") + ".", statement.get$span());
      }
      start = new S._SpanScannerState(t1, t1._string_scanner$_position);
      switch (_this._plainAtRuleName$0()) {
        case "debug":
          return _this._debugRule$1(start);
        case "each":
          return _this._eachRule$2(start, _this.get$_functionAtRule());
        case "else":
          return _this._disallowedAtRule$1(start);
        case "error":
          return _this._errorRule$1(start);
        case "for":
          return _this._forRule$2(start, _this.get$_functionAtRule());
        case "if":
          return _this._ifRule$2(start, _this.get$_functionAtRule());
        case "return":
          value = _this.expression$0();
          _this.expectStatementSeparator$1("@return rule");
          return new B.ReturnRule(value, t1.spanFrom$1(start));
        case "warn":
          return _this._warnRule$1(start);
        case "while":
          return _this._whileRule$2(start, _this.get$_functionAtRule());
        default:
          return _this._disallowedAtRule$1(start);
      }
    },
    _plainAtRuleName$0: function() {
      this.scanner.expectChar$2$name(64, "@-rule");
      var $name = this.identifier$0();
      this.whitespace$0();
      return $name;
    },
    _atRootRule$1: function(start) {
      var query, t2, t3, _this = this,
        t1 = _this.scanner;
      if (t1.peekChar$0() === 40) {
        query = _this._atRootQuery$0();
        _this.whitespace$0();
        return _this._withChildren$3(_this.get$_statement(), start, new V.StylesheetParser__atRootRule_closure(query));
      } else if (_this.lookingAtChildren$0())
        return _this._withChildren$3(_this.get$_statement(), start, new V.StylesheetParser__atRootRule_closure0());
      else {
        t2 = O.Statement;
        t3 = H.setRuntimeTypeInfo([_this._stylesheet$_styleRule$0()], [t2]);
        t1 = t1.spanFrom$1(start);
        t2 = P.List_List$unmodifiable(t3, t2);
        t3 = C.JSArray_methods.any$1(t2, new M.ParentStatement_closure());
        return new V.AtRootRule(null, t1, t2, t3);
      }
    },
    _atRootQuery$0: function() {
      var interpolation, t2, t3, t4, buffer, t5, _this = this,
        t1 = _this.scanner;
      if (t1.peekChar$0() === 35) {
        interpolation = _this.singleInterpolation$0();
        return X.Interpolation$(H.setRuntimeTypeInfo([interpolation], [P.Object]), interpolation.get$span());
      }
      t2 = t1._string_scanner$_position;
      t3 = new P.StringBuffer("");
      t4 = [];
      buffer = new Z.InterpolationBuffer(t3, t4);
      t1.expectChar$1(40);
      t3._contents += H.Primitives_stringFromCharCode(40);
      _this.whitespace$0();
      t5 = _this.expression$0();
      buffer._flushText$0();
      t4.push(t5);
      if (t1.scanChar$1(58)) {
        _this.whitespace$0();
        t3._contents += H.Primitives_stringFromCharCode(58);
        t3._contents += H.Primitives_stringFromCharCode(32);
        t5 = _this.expression$0();
        buffer._flushText$0();
        t4.push(t5);
      }
      t1.expectChar$1(41);
      _this.whitespace$0();
      t3._contents += H.Primitives_stringFromCharCode(41);
      return buffer.interpolation$1(t1.spanFrom$1(new S._SpanScannerState(t1, t2)));
    },
    _contentRule$1: function(start) {
      var t1, $arguments, t2, t3, _this = this;
      if (!_this._stylesheet$_inMixin)
        _this.error$2("@content is only allowed within mixin declarations.", _this.scanner.spanFrom$1(start));
      _this.whitespace$0();
      t1 = _this.scanner;
      if (t1.peekChar$0() === 40)
        $arguments = _this._argumentInvocation$1$mixin(true);
      else {
        t2 = Y.FileLocation$_(t1._sourceFile, t1._string_scanner$_position);
        t3 = t2.offset;
        $arguments = new X.ArgumentInvocation(C.List_empty8, C.Map_empty5, null, null, Y._FileSpan$(t2.file, t3, t3));
      }
      _this._mixinHasContent = true;
      _this.expectStatementSeparator$1("@content rule");
      return new Q.ContentRule(t1.spanFrom$1(start), $arguments);
    },
    _debugRule$1: function(start) {
      var value = this.expression$0();
      this.expectStatementSeparator$1("@debug rule");
      return new Q.DebugRule(value, this.scanner.spanFrom$1(start));
    },
    _eachRule$2: function(start, child) {
      var variables, t1, _this = this,
        wasInControlDirective = _this._inControlDirective;
      _this._inControlDirective = true;
      variables = H.setRuntimeTypeInfo([_this.variableName$0()], [P.String]);
      _this.whitespace$0();
      for (t1 = _this.scanner; t1.scanChar$1(44);) {
        _this.whitespace$0();
        t1.expectChar$1(36);
        variables.push(_this.identifier$1$normalize(true));
        _this.whitespace$0();
      }
      _this.expectIdentifier$1("in");
      _this.whitespace$0();
      return _this._withChildren$3(child, start, new V.StylesheetParser__eachRule_closure(_this, wasInControlDirective, variables, _this.expression$0()));
    },
    _errorRule$1: function(start) {
      var value = this.expression$0();
      this.expectStatementSeparator$1("@error rule");
      return new D.ErrorRule(value, this.scanner.spanFrom$1(start));
    },
    _functionRule$1: function(start) {
      var $name, $arguments, _this = this,
        precedingComment = _this.lastSilentComment;
      _this.lastSilentComment = null;
      $name = _this.identifier$1$normalize(true);
      _this.whitespace$0();
      $arguments = _this._argumentDeclaration$0();
      if (_this._stylesheet$_inMixin || _this._inContentBlock)
        _this.error$2("Mixins may not contain function declarations.", _this.scanner.spanFrom$1(start));
      else if (_this._inControlDirective)
        _this.error$2("Functions may not be declared in control directives.", _this.scanner.spanFrom$1(start));
      switch (B.unvendor($name)) {
        case "calc":
        case "element":
        case "expression":
        case "url":
        case "and":
        case "or":
        case "not":
          _this.error$2("Invalid function name.", _this.scanner.spanFrom$1(start));
          break;
      }
      _this.whitespace$0();
      return _this._withChildren$3(_this.get$_functionAtRule(), start, new V.StylesheetParser__functionRule_closure($name, $arguments, precedingComment));
    },
    _forRule$2: function(start, child) {
      var variable, from, _this = this, t1 = {},
        wasInControlDirective = _this._inControlDirective;
      _this._inControlDirective = true;
      variable = _this.variableName$0();
      _this.whitespace$0();
      _this.expectIdentifier$1("from");
      _this.whitespace$0();
      t1.exclusive = null;
      from = _this.expression$1$until(new V.StylesheetParser__forRule_closure(t1, _this));
      if (t1.exclusive == null)
        _this.scanner.error$1('Expected "to" or "through".');
      _this.whitespace$0();
      return _this._withChildren$3(child, start, new V.StylesheetParser__forRule_closure0(t1, _this, wasInControlDirective, variable, from, _this.expression$0()));
    },
    _forwardRule$1: function(start) {
      var prefix, members, shownMixinsAndFunctions, shownVariables, hiddenVariables, hiddenMixinsAndFunctions, span, t1, t2, _this = this, _null = null,
        url = _this._urlString$0();
      _this.whitespace$0();
      if (_this.scanIdentifier$1("as")) {
        _this.whitespace$0();
        prefix = _this.identifier$0();
        _this.scanner.expectChar$1(42);
        _this.whitespace$0();
      } else
        prefix = _null;
      if (_this.scanIdentifier$1("show")) {
        members = _this._memberList$0();
        shownMixinsAndFunctions = members.item1;
        shownVariables = members.item2;
        hiddenVariables = _null;
        hiddenMixinsAndFunctions = hiddenVariables;
      } else {
        if (_this.scanIdentifier$1("hide")) {
          members = _this._memberList$0();
          hiddenMixinsAndFunctions = members.item1;
          hiddenVariables = members.item2;
        } else {
          hiddenVariables = _null;
          hiddenMixinsAndFunctions = hiddenVariables;
        }
        shownVariables = _null;
        shownMixinsAndFunctions = shownVariables;
      }
      _this.expectStatementSeparator$1("@forward rule");
      span = _this.scanner.spanFrom$1(start);
      _this.error$2("@forward is coming soon, but it's not supported in this version of Dart Sass.", span);
      if (shownMixinsAndFunctions != null) {
        t1 = P.String;
        t2 = [t1];
        return new L.ForwardRule(url, new L.UnmodifiableSetView(P.LinkedHashSet_LinkedHashSet$of(shownMixinsAndFunctions, t1), t2), new L.UnmodifiableSetView(P.LinkedHashSet_LinkedHashSet$of(shownVariables, t1), t2), _null, _null, prefix, span);
      } else if (hiddenMixinsAndFunctions != null) {
        t1 = P.String;
        t2 = [t1];
        return new L.ForwardRule(url, _null, _null, new L.UnmodifiableSetView(P.LinkedHashSet_LinkedHashSet$of(hiddenMixinsAndFunctions, t1), t2), new L.UnmodifiableSetView(P.LinkedHashSet_LinkedHashSet$of(hiddenVariables, t1), t2), prefix, span);
      } else
        return new L.ForwardRule(url, _null, _null, _null, _null, prefix, span);
    },
    _memberList$0: function() {
      var _this = this,
        t1 = P.String,
        identifiers = P.LinkedHashSet_LinkedHashSet(t1),
        variables = P.LinkedHashSet_LinkedHashSet(t1);
      t1 = _this.scanner;
      do {
        _this.whitespace$0();
        _this.withErrorMessage$2("Expected variable, mixin, or function name", new V.StylesheetParser__memberList_closure(_this, variables, identifiers));
        _this.whitespace$0();
      } while (t1.scanChar$1(44));
      t1 = [P.Set, P.String];
      return new S.Tuple2(identifiers, variables, [t1, t1]);
    },
    _ifRule$2: function(start, child) {
      var condition, children, t1, t2, t3, clauses, lastClause, result, t4, span, _this = this,
        ifIndentation = _this.get$currentIndentation(),
        wasInControlDirective = _this._inControlDirective;
      _this._inControlDirective = true;
      condition = _this.expression$0();
      children = _this.children$1(child);
      _this.whitespaceWithoutComments$0();
      t1 = O.Statement;
      t2 = P.List_List$unmodifiable(children, t1);
      t3 = V.IfClause;
      clauses = H.setRuntimeTypeInfo([new V.IfClause(condition, t2, C.JSArray_methods.any$1(t2, new V.IfClause$__closure()))], [t3]);
      while (true) {
        if (!_this.scanElse$1(ifIndentation)) {
          lastClause = null;
          break;
        }
        _this.whitespace$0();
        if (_this.scanIdentifier$1("if")) {
          _this.whitespace$0();
          t2 = _this.expression$0();
          result = P.List_List$from(_this.children$1(child), false, t1);
          result.fixed$length = Array;
          result.immutable$list = Array;
          t4 = result;
          clauses.push(new V.IfClause(t2, t4, C.JSArray_methods.any$1(t4, new V.IfClause$__closure())));
        } else {
          result = P.List_List$from(_this.children$1(child), false, t1);
          result.fixed$length = Array;
          result.immutable$list = Array;
          t1 = result;
          lastClause = new V.IfClause(null, t1, C.JSArray_methods.any$1(t1, new V.IfClause$__closure()));
          break;
        }
      }
      _this._inControlDirective = wasInControlDirective;
      span = _this.scanner.spanFrom$1(start);
      _this.whitespaceWithoutComments$0();
      return new V.IfRule(P.List_List$unmodifiable(clauses, t3), lastClause, span);
    },
    _importRule$1: function(start) {
      var argument, _this = this,
        t1 = F.Import,
        imports = H.setRuntimeTypeInfo([], [t1]),
        t2 = _this.scanner;
      do {
        _this.whitespace$0();
        argument = _this.importArgument$0();
        if ((_this._inControlDirective || _this._stylesheet$_inMixin) && argument instanceof B.DynamicImport)
          _this._disallowedAtRule$1(start);
        imports.push(argument);
        _this.whitespace$0();
      } while (t2.scanChar$1(44));
      _this.expectStatementSeparator$1("@import rule");
      t2 = t2.spanFrom$1(start);
      return new B.ImportRule(P.List_List$unmodifiable(imports, t1), t2);
    },
    importArgument$0: function() {
      var url, urlSpan, innerError, queries, t2, t3, t4, exception, _this = this, _null = null,
        t1 = _this.scanner,
        start = new S._SpanScannerState(t1, t1._string_scanner$_position),
        next = t1.peekChar$0();
      if (next === 117 || next === 85) {
        url = _this.dynamicUrl$0();
        _this.whitespace$0();
        queries = _this.tryImportQueries$0();
        t2 = X.Interpolation$(H.setRuntimeTypeInfo([url], [P.Object]), t1.spanFrom$1(start));
        t1 = t1.spanFrom$1(start);
        t3 = queries == null;
        t4 = t3 ? _null : queries.item1;
        return new Q.StaticImport(t2, t4, t3 ? _null : queries.item2, t1);
      }
      url = _this.string$0();
      urlSpan = t1.spanFrom$1(start);
      _this.whitespace$0();
      queries = _this.tryImportQueries$0();
      if (_this._isPlainImportUrl$1(url) || queries != null) {
        t2 = urlSpan;
        t2 = X.Interpolation$(H.setRuntimeTypeInfo([P.String_String$fromCharCodes(C.NativeUint32List_methods.sublist$2(t2.file._decodedChars, t2._start, t2._end), 0, _null)], [P.Object]), urlSpan);
        t1 = t1.spanFrom$1(start);
        t3 = queries == null;
        t4 = t3 ? _null : queries.item1;
        return new Q.StaticImport(t2, t4, t3 ? _null : queries.item2, t1);
      } else
        try {
          t1 = _this.parseImportUrl$1(url);
          return new B.DynamicImport(t1, urlSpan);
        } catch (exception) {
          t1 = H.unwrapException(exception);
          if (!!J.getInterceptor$(t1).$isFormatException) {
            innerError = t1;
            _this.error$2("Invalid URL: " + H.S(J.get$message$x(innerError)), urlSpan);
          } else
            throw exception;
        }
    },
    parseImportUrl$1: function(url) {
      var t1 = $.$get$windows();
      if (t1.style.rootLength$1(url) > 0)
        return J.toString$0$(t1.toUri$1(url));
      P.Uri_parse(url);
      return url;
    },
    _isPlainImportUrl$1: function(url) {
      var first;
      if (url.length < 5)
        return false;
      if (C.JSString_methods.endsWith$1(url, ".css"))
        return true;
      first = C.JSString_methods._codeUnitAt$1(url, 0);
      if (first === 47)
        return C.JSString_methods._codeUnitAt$1(url, 1) === 47;
      if (first !== 104)
        return false;
      return C.JSString_methods.startsWith$1(url, "http://") || C.JSString_methods.startsWith$1(url, "https://");
    },
    tryImportQueries$0: function() {
      var t1, start, supports, $name, media, _this = this;
      if (_this.scanIdentifier$1("supports")) {
        t1 = _this.scanner;
        t1.expectChar$1(40);
        start = new S._SpanScannerState(t1, t1._string_scanner$_position);
        if (_this.scanIdentifier$1("not")) {
          _this.whitespace$0();
          supports = new M.SupportsNegation(_this._supportsConditionInParens$0(), t1.spanFrom$1(start));
        } else if (t1.peekChar$0() === 40)
          supports = _this._supportsCondition$0();
        else {
          $name = _this.expression$0();
          t1.expectChar$1(58);
          _this.whitespace$0();
          supports = new L.SupportsDeclaration($name, _this.expression$0(), t1.spanFrom$1(start));
        }
        t1.expectChar$1(41);
        _this.whitespace$0();
      } else
        supports = null;
      media = _this._lookingAtInterpolatedIdentifier$0() || _this.scanner.peekChar$0() === 40 ? _this._mediaQueryList$0() : null;
      if (supports == null && media == null)
        return;
      return new S.Tuple2(supports, media, [N.SupportsCondition, X.Interpolation]);
    },
    _includeRule$1: function(start) {
      var name0, namespace, $arguments, t3, t4, wasInContentBlock, $content, _this = this, _null = null, t1 = {},
        $name = _this.identifier$0(),
        t2 = _this.scanner;
      if (t2.scanChar$1(46)) {
        name0 = _this._publicIdentifier$0();
        namespace = $name;
        $name = name0;
      } else {
        $name = H.stringReplaceAllUnchecked($name, "_", "-");
        namespace = _null;
      }
      _this.whitespace$0();
      if (t2.peekChar$0() === 40)
        $arguments = _this._argumentInvocation$1$mixin(true);
      else {
        t3 = Y.FileLocation$_(t2._sourceFile, t2._string_scanner$_position);
        t4 = t3.offset;
        $arguments = new X.ArgumentInvocation(C.List_empty8, C.Map_empty5, _null, _null, Y._FileSpan$(t3.file, t4, t4));
      }
      _this.whitespace$0();
      t1.contentArguments = null;
      if (_this.scanIdentifier$1("using")) {
        _this.whitespace$0();
        t3 = t1.contentArguments = _this._argumentDeclaration$0();
        _this.whitespace$0();
      } else
        t3 = _null;
      if (t3 != null || _this.lookingAtChildren$0()) {
        wasInContentBlock = _this._inContentBlock;
        _this._inContentBlock = true;
        $content = _this._withChildren$3(_this.get$_statement(), start, new V.StylesheetParser__includeRule_closure(t1, _this));
        _this._inContentBlock = wasInContentBlock;
      } else {
        _this.expectStatementSeparator$0();
        $content = _null;
      }
      t1 = t2.spanFrom$2(start, start);
      return new A.IncludeRule(namespace, $name, $arguments, $content, t1.expand$1(0, ($content == null ? $arguments : $content).get$span()));
    },
    mediaRule$1: function(start) {
      return this._withChildren$3(this.get$_statement(), start, new V.StylesheetParser_mediaRule_closure(this._mediaQueryList$0()));
    },
    _mixinRule$1: function(start) {
      var $name, t1, $arguments, t2, t3, _this = this,
        precedingComment = _this.lastSilentComment;
      _this.lastSilentComment = null;
      $name = _this.identifier$1$normalize(true);
      _this.whitespace$0();
      t1 = _this.scanner;
      if (t1.peekChar$0() === 40)
        $arguments = _this._argumentDeclaration$0();
      else {
        t2 = Y.FileLocation$_(t1._sourceFile, t1._string_scanner$_position);
        t3 = t2.offset;
        $arguments = new B.ArgumentDeclaration(C.List_empty9, null, Y._FileSpan$(t2.file, t3, t3));
      }
      if (_this._stylesheet$_inMixin || _this._inContentBlock)
        _this.error$2("Mixins may not contain mixin declarations.", t1.spanFrom$1(start));
      else if (_this._inControlDirective)
        _this.error$2("Mixins may not be declared in control directives.", t1.spanFrom$1(start));
      _this.whitespace$0();
      _this._stylesheet$_inMixin = true;
      _this._mixinHasContent = false;
      return _this._withChildren$3(_this.get$_statement(), start, new V.StylesheetParser__mixinRule_closure(_this, $name, $arguments, precedingComment));
    },
    mozDocumentRule$2: function(start, $name) {
      var t5, identifier, contents, argument, trailing, endPosition, start0, end, _this = this, _box_0 = {},
        t1 = _this.scanner,
        t2 = t1._string_scanner$_position,
        t3 = new P.StringBuffer(""),
        t4 = [],
        buffer = new Z.InterpolationBuffer(t3, t4);
      _box_0.needsDeprecationWarning = false;
      for (; true;) {
        if (t1.peekChar$0() === 35) {
          t5 = _this.singleInterpolation$0();
          buffer._flushText$0();
          t4.push(t5);
          _box_0.needsDeprecationWarning = true;
        } else {
          t5 = t1._string_scanner$_position;
          identifier = _this.identifier$0();
          switch (identifier) {
            case "url":
            case "url-prefix":
            case "domain":
              contents = _this._tryUrlContents$2$name(new S._SpanScannerState(t1, t5), identifier);
              if (contents != null)
                buffer.addInterpolation$1(contents);
              else {
                t1.expectChar$1(40);
                _this.whitespace$0();
                argument = _this.interpolatedString$0();
                t1.expectChar$1(41);
                t3._contents += identifier;
                t3._contents += H.Primitives_stringFromCharCode(40);
                buffer.addInterpolation$1(argument.asInterpolation$0());
                t3._contents += H.Primitives_stringFromCharCode(41);
              }
              t5 = t3._contents;
              trailing = t5.charCodeAt(0) == 0 ? t5 : t5;
              if (!C.JSString_methods.endsWith$1(trailing, "url-prefix()") && !C.JSString_methods.endsWith$1(trailing, "url-prefix('')") && !C.JSString_methods.endsWith$1(trailing, 'url-prefix("")'))
                _box_0.needsDeprecationWarning = true;
              break;
            case "regexp":
              t3._contents += "regexp(";
              t1.expectChar$1(40);
              buffer.addInterpolation$1(_this.interpolatedString$0().asInterpolation$0());
              t1.expectChar$1(41);
              t3._contents += H.Primitives_stringFromCharCode(41);
              _box_0.needsDeprecationWarning = true;
              break;
            default:
              endPosition = t1._string_scanner$_position;
              _this.error$2("Invalid function name.", Y._FileSpan$(t1._sourceFile, t5, endPosition));
          }
        }
        _this.whitespace$0();
        if (!t1.scanChar$1(44))
          break;
        t3._contents += H.Primitives_stringFromCharCode(44);
        t5 = _this.get$whitespace();
        start0 = t1._string_scanner$_position;
        t5.call$0();
        end = t1._string_scanner$_position;
        t3._contents += J.substring$2$s(t1.string, start0, end);
      }
      return _this._withChildren$3(_this.get$_statement(), start, new V.StylesheetParser_mozDocumentRule_closure(_box_0, _this, $name, buffer.interpolation$1(t1.spanFrom$1(new S._SpanScannerState(t1, t2)))));
    },
    supportsRule$1: function(start) {
      var _this = this,
        condition = _this._supportsCondition$0();
      _this.whitespace$0();
      return _this._withChildren$3(_this.get$_statement(), start, new V.StylesheetParser_supportsRule_closure(condition));
    },
    _useRule$1: function(start) {
      var namespace, basename, dot, exception, span, _this = this,
        _s9_ = "@use rule",
        url = _this._urlString$0();
      _this.whitespace$0();
      namespace = null;
      if (_this.scanIdentifier$1("as")) {
        _this.whitespace$0();
        namespace = _this.scanner.scanChar$1(42) ? null : _this.identifier$0();
      } else {
        basename = url.get$pathSegments().length === 0 ? "" : C.JSArray_methods.get$last(url.get$pathSegments());
        dot = J.getInterceptor$asx(basename).indexOf$1(basename, ".");
        namespace = C.JSString_methods.substring$2(basename, 0, dot === -1 ? basename.length : dot);
        try {
          namespace = G.Parser$(namespace, _this.logger, null)._parseIdentifier$0();
        } catch (exception) {
          if (H.unwrapException(exception) instanceof E.SassFormatException)
            _this.error$2('Invalid Sass identifier "' + H.S(namespace) + '"', _this.scanner.spanFrom$1(start));
          else
            throw exception;
        }
      }
      _this.expectStatementSeparator$1(_s9_);
      span = _this.scanner.spanFrom$1(start);
      _this.error$2("@use is coming soon, but it's not supported in this version of Dart Sass.", span);
      _this.expectStatementSeparator$1(_s9_);
      return new T.UseRule(url, namespace, span);
    },
    _warnRule$1: function(start) {
      var value = this.expression$0();
      this.expectStatementSeparator$1("@warn rule");
      return new Y.WarnRule(value, this.scanner.spanFrom$1(start));
    },
    _whileRule$2: function(start, child) {
      var _this = this,
        wasInControlDirective = _this._inControlDirective;
      _this._inControlDirective = true;
      return _this._withChildren$3(child, start, new V.StylesheetParser__whileRule_closure(_this, wasInControlDirective, _this.expression$0()));
    },
    unknownAtRule$2: function(start, $name) {
      var t2, t3, rule, _this = this, t1 = {},
        wasInUnknownAtRule = _this._stylesheet$_inUnknownAtRule;
      _this._stylesheet$_inUnknownAtRule = true;
      t1.value = null;
      t2 = _this.scanner;
      t3 = t2.peekChar$0() !== 33 && !_this.atEndOfStatement$0() ? t1.value = _this.almostAnyValue$0() : null;
      if (_this.lookingAtChildren$0())
        rule = _this._withChildren$3(_this.get$_statement(), start, new V.StylesheetParser_unknownAtRule_closure(t1, $name));
      else {
        _this.expectStatementSeparator$0();
        rule = U.AtRule$($name, t2.spanFrom$1(start), null, t3);
      }
      _this._stylesheet$_inUnknownAtRule = wasInUnknownAtRule;
      return rule;
    },
    _disallowedAtRule$1: function(start) {
      this.almostAnyValue$0();
      this.error$2("This at-rule is not allowed here.", this.scanner.spanFrom$1(start));
    },
    _argumentDeclaration$0: function() {
      var t3, $arguments, named, restArgument, t4, $name, defaultValue, endPosition, _this = this,
        t1 = _this.scanner,
        t2 = t1._string_scanner$_position;
      t1.expectChar$1(40);
      _this.whitespace$0();
      t3 = Z.Argument;
      $arguments = H.setRuntimeTypeInfo([], [t3]);
      named = P.LinkedHashSet_LinkedHashSet$_empty(P.String);
      while (true) {
        if (!(t1.peekChar$0() === 36)) {
          restArgument = null;
          break;
        }
        t4 = t1._string_scanner$_position;
        t1.expectChar$1(36);
        $name = _this.identifier$1$normalize(true);
        _this.whitespace$0();
        if (t1.scanChar$1(58)) {
          _this.whitespace$0();
          defaultValue = _this._expressionUntilComma$0();
        } else {
          if (t1.scanChar$1(46)) {
            t1.expectChar$1(46);
            t1.expectChar$1(46);
            _this.whitespace$0();
            restArgument = $name;
            break;
          }
          defaultValue = null;
        }
        endPosition = t1._string_scanner$_position;
        $arguments.push(new Z.Argument($name, defaultValue, Y._FileSpan$(t1._sourceFile, t4, endPosition)));
        if (!named.add$1(0, $name))
          _this.error$2("Duplicate argument.", C.JSArray_methods.get$last($arguments).span);
        if (!t1.scanChar$1(44)) {
          restArgument = null;
          break;
        }
        _this.whitespace$0();
      }
      t1.expectChar$1(41);
      t1 = t1.spanFrom$1(new S._SpanScannerState(t1, t2));
      return new B.ArgumentDeclaration(P.List_List$unmodifiable($arguments, t3), restArgument, t1);
    },
    _argumentInvocation$1$mixin: function(mixin) {
      var t3, positional, named, keywordRest, rest, expression, t4, _this = this,
        t1 = _this.scanner,
        t2 = t1._string_scanner$_position;
      t1.expectChar$1(40);
      _this.whitespace$0();
      t3 = T.Expression;
      positional = H.setRuntimeTypeInfo([], [t3]);
      named = P.LinkedHashMap_LinkedHashMap$_empty(P.String, t3);
      t3 = !mixin;
      rest = null;
      while (true) {
        if (!_this._lookingAtExpression$0()) {
          keywordRest = null;
          break;
        }
        expression = _this._expressionUntilComma$1$singleEquals(t3);
        _this.whitespace$0();
        if (expression instanceof S.VariableExpression && t1.scanChar$1(58)) {
          _this.whitespace$0();
          t4 = expression.name;
          if (named.containsKey$1(t4))
            _this.error$2("Duplicate argument.", expression.span);
          named.$indexSet(0, t4, _this._expressionUntilComma$1$singleEquals(t3));
        } else if (t1.scanChar$1(46)) {
          t1.expectChar$1(46);
          t1.expectChar$1(46);
          if (rest != null) {
            _this.whitespace$0();
            keywordRest = expression;
            break;
          }
          rest = expression;
        } else if (named.get$isNotEmpty(named))
          t1.expect$1("...");
        else
          positional.push(expression);
        _this.whitespace$0();
        if (!t1.scanChar$1(44)) {
          keywordRest = null;
          break;
        }
        _this.whitespace$0();
      }
      t1.expectChar$1(41);
      return X.ArgumentInvocation$(positional, named, t1.spanFrom$1(new S._SpanScannerState(t1, t2)), keywordRest, rest);
    },
    _argumentInvocation$0: function() {
      return this._argumentInvocation$1$mixin(false);
    },
    expression$3$bracketList$singleEquals$until: function(bracketList, singleEquals, until) {
      var t2, beforeBracket, t3, wasInParentheses, resetState, resolveOneOperation, resolveOperations, addSingleExpression, addOperator, resolveSpaceExpressions, t4, first, next, t5, _this = this,
        _s20_ = "Expected expression.",
        _box_0 = {},
        t1 = until != null;
      if (t1 && until.call$0())
        _this.scanner.error$1(_s20_);
      if (bracketList) {
        t2 = _this.scanner;
        beforeBracket = new S._SpanScannerState(t2, t2._string_scanner$_position);
        t2.expectChar$1(91);
        _this.whitespace$0();
        if (t2.scanChar$1(93)) {
          t1 = T.Expression;
          t3 = H.setRuntimeTypeInfo([], [t1]);
          t2 = t2.spanFrom$1(beforeBracket);
          t1 = P.List_List$unmodifiable(t3, t1);
          return new D.ListExpression(t1, C.ListSeparator_undecided, true, t2);
        }
      } else
        beforeBracket = null;
      t2 = _this.scanner;
      t3 = t2._string_scanner$_position;
      wasInParentheses = _this._inParentheses;
      _box_0.operands = _box_0.operators = _box_0.spaceExpressions = _box_0.singleEqualsOperand = _box_0.commaExpressions = null;
      _box_0.allowSlash = _this.lookingAtNumber$0();
      _box_0.singleExpression = _this._singleExpression$0();
      resetState = new V.StylesheetParser_expression_resetState(_box_0, _this, new S._SpanScannerState(t2, t3));
      resolveOneOperation = new V.StylesheetParser_expression_resolveOneOperation(_box_0, _this);
      resolveOperations = new V.StylesheetParser_expression_resolveOperations(_box_0, resolveOneOperation);
      addSingleExpression = new V.StylesheetParser_expression_addSingleExpression(_box_0, _this, resetState, resolveOperations);
      addOperator = new V.StylesheetParser_expression_addOperator(_box_0, _this, resolveOneOperation);
      resolveSpaceExpressions = new V.StylesheetParser_expression_resolveSpaceExpressions(_box_0, resolveOperations);
      $label0$0:
        for (t3 = T.Expression, t4 = [t3]; true;) {
          _this.whitespace$0();
          if (t1 && until.call$0())
            break $label0$0;
          first = t2.peekChar$0();
          switch (first) {
            case 40:
              addSingleExpression.call$1(_this._parentheses$0());
              break;
            case 91:
              addSingleExpression.call$1(_this.expression$1$bracketList(true));
              break;
            case 36:
              addSingleExpression.call$1(_this._variable$0());
              break;
            case 38:
              addSingleExpression.call$1(_this._selector$0());
              break;
            case 39:
            case 34:
              addSingleExpression.call$1(_this.interpolatedString$0());
              break;
            case 35:
              addSingleExpression.call$1(_this._hashExpression$0());
              break;
            case 61:
              t2.readChar$0();
              if (singleEquals && t2.peekChar$0() !== 61) {
                resolveSpaceExpressions.call$0();
                _box_0.singleEqualsOperand = _box_0.singleExpression;
                _box_0.singleExpression = null;
              } else {
                t2.expectChar$1(61);
                addOperator.call$1(C.BinaryOperator_YlX);
              }
              break;
            case 33:
              next = t2.peekChar$1(1);
              if (next === 61) {
                t2.readChar$0();
                t2.readChar$0();
                addOperator.call$1(C.BinaryOperator_i5H);
              } else {
                if (next != null)
                  if ((next | 32) !== 105)
                    t5 = next === 32 || next === 9 || next === 10 || next === 13 || next === 12;
                  else
                    t5 = true;
                else
                  t5 = true;
                if (t5)
                  addSingleExpression.call$1(_this._importantExpression$0());
                else
                  break $label0$0;
              }
              break;
            case 60:
              t2.readChar$0();
              addOperator.call$1(t2.scanChar$1(61) ? C.BinaryOperator_33h : C.BinaryOperator_8qt);
              break;
            case 62:
              t2.readChar$0();
              addOperator.call$1(t2.scanChar$1(61) ? C.BinaryOperator_1da : C.BinaryOperator_AcR);
              break;
            case 42:
              t2.readChar$0();
              addOperator.call$1(C.BinaryOperator_O1M);
              break;
            case 43:
              if (_box_0.singleExpression == null)
                addSingleExpression.call$1(_this._unaryOperation$0());
              else {
                t2.readChar$0();
                addOperator.call$1(C.BinaryOperator_AcR0);
              }
              break;
            case 45:
              next = t2.peekChar$1(1);
              if (next != null && next >= 48 && next <= 57 || next === 46)
                if (_box_0.singleExpression != null) {
                  t5 = t2.peekChar$1(-1);
                  t5 = t5 === 32 || t5 === 9 || t5 === 10 || t5 === 13 || t5 === 12;
                } else
                  t5 = true;
              else
                t5 = false;
              if (t5)
                addSingleExpression.call$2$number(_this._number$0(), true);
              else if (_this._lookingAtInterpolatedIdentifier$0())
                addSingleExpression.call$1(_this.identifierLike$0());
              else if (_box_0.singleExpression == null)
                addSingleExpression.call$1(_this._unaryOperation$0());
              else {
                t2.readChar$0();
                addOperator.call$1(C.BinaryOperator_iyO);
              }
              break;
            case 47:
              if (_box_0.singleExpression == null)
                addSingleExpression.call$1(_this._unaryOperation$0());
              else {
                t2.readChar$0();
                addOperator.call$1(C.BinaryOperator_RTB);
              }
              break;
            case 37:
              t2.readChar$0();
              addOperator.call$1(C.BinaryOperator_2ad);
              break;
            case 48:
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
            case 56:
            case 57:
              addSingleExpression.call$2$number(_this._number$0(), true);
              break;
            case 46:
              if (t2.peekChar$1(1) === 46)
                break $label0$0;
              addSingleExpression.call$2$number(_this._number$0(), true);
              break;
            case 97:
              if (!_this.get$plainCss() && _this.scanIdentifier$1("and"))
                addOperator.call$1(C.BinaryOperator_and_and_2);
              else
                addSingleExpression.call$1(_this.identifierLike$0());
              break;
            case 111:
              if (!_this.get$plainCss() && _this.scanIdentifier$1("or"))
                addOperator.call$1(C.BinaryOperator_or_or_1);
              else
                addSingleExpression.call$1(_this.identifierLike$0());
              break;
            case 117:
            case 85:
              if (t2.peekChar$1(1) === 43)
                addSingleExpression.call$1(_this._unicodeRange$0());
              else
                addSingleExpression.call$1(_this.identifierLike$0());
              break;
            case 98:
            case 99:
            case 100:
            case 101:
            case 102:
            case 103:
            case 104:
            case 105:
            case 106:
            case 107:
            case 108:
            case 109:
            case 110:
            case 112:
            case 113:
            case 114:
            case 115:
            case 116:
            case 118:
            case 119:
            case 120:
            case 121:
            case 122:
            case 65:
            case 66:
            case 67:
            case 68:
            case 69:
            case 70:
            case 71:
            case 72:
            case 73:
            case 74:
            case 75:
            case 76:
            case 77:
            case 78:
            case 79:
            case 80:
            case 81:
            case 82:
            case 83:
            case 84:
            case 86:
            case 87:
            case 88:
            case 89:
            case 90:
            case 95:
            case 92:
              addSingleExpression.call$1(_this.identifierLike$0());
              break;
            case 44:
              if (_this._inParentheses) {
                _this._inParentheses = false;
                if (_box_0.allowSlash) {
                  resetState.call$0();
                  break;
                }
              }
              if (_box_0.commaExpressions == null)
                _box_0.commaExpressions = H.setRuntimeTypeInfo([], t4);
              if (_box_0.singleExpression == null)
                t2.error$1(_s20_);
              resolveSpaceExpressions.call$0();
              _box_0.commaExpressions.push(_box_0.singleExpression);
              t2.readChar$0();
              _box_0.allowSlash = true;
              _box_0.singleExpression = null;
              break;
            default:
              if (first != null && first >= 128) {
                addSingleExpression.call$1(_this.identifierLike$0());
                break;
              } else
                break $label0$0;
          }
        }
      if (bracketList)
        t2.expectChar$1(93);
      if (_box_0.commaExpressions != null) {
        resolveSpaceExpressions.call$0();
        _this._inParentheses = wasInParentheses;
        t1 = _box_0.singleExpression;
        if (t1 != null)
          _box_0.commaExpressions.push(t1);
        t1 = _box_0.commaExpressions;
        t2 = bracketList ? t2.spanFrom$1(beforeBracket) : null;
        t3 = P.List_List$unmodifiable(t1, t3);
        return new D.ListExpression(t3, C.ListSeparator_comma, bracketList, t2 == null ? B.spanForList(t3) : t2);
      } else if (bracketList && _box_0.spaceExpressions != null && _box_0.singleEqualsOperand == null) {
        resolveOperations.call$0();
        t1 = _box_0.spaceExpressions;
        t1.push(_box_0.singleExpression);
        t2 = t2.spanFrom$1(beforeBracket);
        t3 = P.List_List$unmodifiable(t1, t3);
        return new D.ListExpression(t3, C.ListSeparator_space, true, t2);
      } else {
        resolveSpaceExpressions.call$0();
        if (bracketList) {
          t1 = H.setRuntimeTypeInfo([_box_0.singleExpression], t4);
          t2 = t2.spanFrom$1(beforeBracket);
          t3 = P.List_List$unmodifiable(t1, t3);
          _box_0.singleExpression = new D.ListExpression(t3, C.ListSeparator_undecided, true, t2);
        }
        return _box_0.singleExpression;
      }
    },
    expression$2$singleEquals$until: function(singleEquals, until) {
      return this.expression$3$bracketList$singleEquals$until(false, singleEquals, until);
    },
    expression$1$bracketList: function(bracketList) {
      return this.expression$3$bracketList$singleEquals$until(bracketList, false, null);
    },
    expression$0: function() {
      return this.expression$3$bracketList$singleEquals$until(false, false, null);
    },
    expression$1$singleEquals: function(singleEquals) {
      return this.expression$3$bracketList$singleEquals$until(false, singleEquals, null);
    },
    expression$1$until: function(until) {
      return this.expression$3$bracketList$singleEquals$until(false, false, until);
    },
    _expressionUntilComma$1$singleEquals: function(singleEquals) {
      return this.expression$2$singleEquals$until(singleEquals, new V.StylesheetParser__expressionUntilComma_closure(this));
    },
    _expressionUntilComma$0: function() {
      return this._expressionUntilComma$1$singleEquals(false);
    },
    _singleExpression$0: function() {
      var next, _this = this,
        t1 = _this.scanner,
        first = t1.peekChar$0();
      switch (first) {
        case 40:
          return _this._parentheses$0();
        case 47:
          return _this._unaryOperation$0();
        case 46:
          return _this._number$0();
        case 91:
          return _this.expression$1$bracketList(true);
        case 36:
          return _this._variable$0();
        case 38:
          return _this._selector$0();
        case 39:
        case 34:
          return _this.interpolatedString$0();
        case 35:
          return _this._hashExpression$0();
        case 43:
          next = t1.peekChar$1(1);
          return T.isDigit(next) || next === 46 ? _this._number$0() : _this._unaryOperation$0();
        case 45:
          return _this._minusExpression$0();
        case 33:
          return _this._importantExpression$0();
        case 117:
        case 85:
          if (t1.peekChar$1(1) === 43)
            return _this._unicodeRange$0();
          else
            return _this.identifierLike$0();
        case 48:
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          return _this._number$0();
        case 97:
        case 98:
        case 99:
        case 100:
        case 101:
        case 102:
        case 103:
        case 104:
        case 105:
        case 106:
        case 107:
        case 108:
        case 109:
        case 110:
        case 111:
        case 112:
        case 113:
        case 114:
        case 115:
        case 116:
        case 118:
        case 119:
        case 120:
        case 121:
        case 122:
        case 65:
        case 66:
        case 67:
        case 68:
        case 69:
        case 70:
        case 71:
        case 72:
        case 73:
        case 74:
        case 75:
        case 76:
        case 77:
        case 78:
        case 79:
        case 80:
        case 81:
        case 82:
        case 83:
        case 84:
        case 86:
        case 87:
        case 88:
        case 89:
        case 90:
        case 95:
        case 92:
          return _this.identifierLike$0();
        default:
          if (first != null && first >= 128)
            return _this.identifierLike$0();
          t1.error$1("Expected expression.");
      }
    },
    _parentheses$0: function() {
      var wasInParentheses, start, first, expressions, t1, t2, t3, _this = this;
      if (_this.get$plainCss())
        _this.scanner.error$2$length("Parentheses aren't allowed in plain CSS.", 1);
      wasInParentheses = _this._inParentheses;
      _this._inParentheses = true;
      try {
        t1 = _this.scanner;
        start = new S._SpanScannerState(t1, t1._string_scanner$_position);
        t1.expectChar$1(40);
        _this.whitespace$0();
        if (!_this._lookingAtExpression$0()) {
          t1.expectChar$1(41);
          t2 = T.Expression;
          t3 = H.setRuntimeTypeInfo([], [t2]);
          t1 = t1.spanFrom$1(start);
          t2 = P.List_List$unmodifiable(t3, t2);
          return new D.ListExpression(t2, C.ListSeparator_undecided, false, t1);
        }
        first = _this._expressionUntilComma$0();
        if (t1.scanChar$1(58)) {
          _this.whitespace$0();
          t1 = _this._stylesheet$_map$2(first, start);
          return t1;
        }
        if (!t1.scanChar$1(44)) {
          t1.expectChar$1(41);
          t1 = t1.spanFrom$1(start);
          return new T.ParenthesizedExpression(first, t1);
        }
        _this.whitespace$0();
        t2 = T.Expression;
        expressions = H.setRuntimeTypeInfo([first], [t2]);
        for (; true;) {
          if (!_this._lookingAtExpression$0())
            break;
          J.add$1$ax(expressions, _this._expressionUntilComma$0());
          if (!t1.scanChar$1(44))
            break;
          _this.whitespace$0();
        }
        t1.expectChar$1(41);
        t1 = t1.spanFrom$1(start);
        t2 = P.List_List$unmodifiable(expressions, t2);
        return new D.ListExpression(t2, C.ListSeparator_comma, false, t1);
      } finally {
        _this._inParentheses = wasInParentheses;
      }
    },
    _stylesheet$_map$2: function(first, start) {
      var t2, pairs, t3, key, _this = this,
        t1 = T.Expression;
      t1 = [t1, t1];
      t2 = [S.Tuple2, T.Expression, T.Expression];
      pairs = H.setRuntimeTypeInfo([new S.Tuple2(first, _this._expressionUntilComma$0(), t1)], [t2]);
      for (t3 = _this.scanner; t3.scanChar$1(44);) {
        _this.whitespace$0();
        if (!_this._lookingAtExpression$0())
          break;
        key = _this._expressionUntilComma$0();
        t3.expectChar$1(58);
        _this.whitespace$0();
        pairs.push(new S.Tuple2(key, _this._expressionUntilComma$0(), t1));
      }
      t3.expectChar$1(41);
      t1 = t3.spanFrom$1(start);
      return new A.MapExpression(P.List_List$unmodifiable(pairs, t2), t1);
    },
    _hashExpression$0: function() {
      var start, first, t2, identifier, buffer, _this = this,
        t1 = _this.scanner;
      if (t1.peekChar$1(1) === 123)
        return _this.identifierLike$0();
      start = new S._SpanScannerState(t1, t1._string_scanner$_position);
      t1.expectChar$1(35);
      first = t1.peekChar$0();
      if (first != null && T.isDigit(first))
        return new K.ColorExpression(_this._hexColorContents$1(start));
      t2 = t1._string_scanner$_position;
      identifier = _this.interpolatedIdentifier$0();
      if (_this._isHexColor$1(identifier)) {
        t1.set$state(new S._SpanScannerState(t1, t2));
        return new K.ColorExpression(_this._hexColorContents$1(start));
      }
      t2 = new P.StringBuffer("");
      buffer = new Z.InterpolationBuffer(t2, []);
      t2._contents += H.Primitives_stringFromCharCode(35);
      buffer.addInterpolation$1(identifier);
      return new D.StringExpression(buffer.interpolation$1(t1.spanFrom$1(start)), false);
    },
    _hexColorContents$1: function(start) {
      var red, green, blue, alpha, digit4, t2, t3, _this = this,
        digit1 = _this._hexDigit$0(),
        digit2 = _this._hexDigit$0(),
        digit3 = _this._hexDigit$0(),
        t1 = _this.scanner;
      if (!T.isHex(t1.peekChar$0())) {
        red = (digit1 << 4 >>> 0) + digit1;
        green = (digit2 << 4 >>> 0) + digit2;
        blue = (digit3 << 4 >>> 0) + digit3;
        alpha = 1;
      } else {
        digit4 = _this._hexDigit$0();
        t2 = digit1 << 4 >>> 0;
        t3 = digit3 << 4 >>> 0;
        if (!T.isHex(t1.peekChar$0())) {
          red = t2 + digit1;
          green = (digit2 << 4 >>> 0) + digit2;
          blue = t3 + digit3;
          alpha = ((digit4 << 4 >>> 0) + digit4) / 255;
        } else {
          red = t2 + digit2;
          green = t3 + digit4;
          blue = (_this._hexDigit$0() << 4 >>> 0) + _this._hexDigit$0();
          alpha = T.isHex(t1.peekChar$0()) ? ((_this._hexDigit$0() << 4 >>> 0) + _this._hexDigit$0()) / 255 : 1;
        }
      }
      return K.SassColor$rgb(red, green, blue, alpha, t1.spanFrom$1(start));
    },
    _isHexColor$1: function(interpolation) {
      var t1,
        plain = interpolation.get$asPlain();
      if (plain == null)
        return false;
      t1 = plain.length;
      if (t1 !== 3 && t1 !== 4 && t1 !== 6 && t1 !== 8)
        return false;
      t1 = new H.CodeUnits(plain);
      return t1.every$1(t1, T.character__isHex$closure());
    },
    _hexDigit$0: function() {
      var t1 = this.scanner,
        char = t1.peekChar$0();
      if (char == null || !T.isHex(char))
        t1.error$1("Expected hex digit.");
      return T.asHex(t1.readChar$0());
    },
    _minusExpression$0: function() {
      var _this = this,
        next = _this.scanner.peekChar$1(1);
      if (T.isDigit(next) || next === 46)
        return _this._number$0();
      if (_this._lookingAtInterpolatedIdentifier$0())
        return _this.identifierLike$0();
      return _this._unaryOperation$0();
    },
    _importantExpression$0: function() {
      var t1 = this.scanner,
        t2 = t1._string_scanner$_position;
      t1.readChar$0();
      this.whitespace$0();
      this.expectIdentifier$1("important");
      t2 = t1.spanFrom$1(new S._SpanScannerState(t1, t2));
      return new D.StringExpression(X.Interpolation$(H.setRuntimeTypeInfo(["!important"], [P.Object]), t2), false);
    },
    _unaryOperation$0: function() {
      var _this = this,
        t1 = _this.scanner,
        t2 = t1._string_scanner$_position,
        operator = _this._unaryOperatorFor$1(t1.readChar$0());
      if (operator == null)
        t1.error$2$position("Expected unary operator.", t1._string_scanner$_position - 1);
      else if (_this.get$plainCss() && operator !== C.UnaryOperator_zDx)
        t1.error$3$length$position("Operators aren't allowed in plain CSS.", 1, t1._string_scanner$_position - 1);
      _this.whitespace$0();
      return new X.UnaryOperationExpression(operator, _this._singleExpression$0(), t1.spanFrom$1(new S._SpanScannerState(t1, t2)));
    },
    _unaryOperatorFor$1: function(character) {
      switch (character) {
        case 43:
          return C.UnaryOperator_j2w;
        case 45:
          return C.UnaryOperator_U4G;
        case 47:
          return C.UnaryOperator_zDx;
        default:
          return;
      }
    },
    _number$0: function() {
      var number, t4, unit, t5, _this = this,
        t1 = _this.scanner,
        t2 = t1._string_scanner$_position,
        first = t1.peekChar$0(),
        t3 = first === 45,
        sign = t3 ? -1 : 1;
      if (first === 43 || t3)
        t1.readChar$0();
      number = t1.peekChar$0() === 46 ? 0 : _this.naturalNumber$0();
      t3 = _this._tryDecimal$1$allowTrailingDot(t1._string_scanner$_position !== t2);
      t4 = _this._tryExponent$0();
      if (t1.scanChar$1(37))
        unit = "%";
      else {
        if (_this.lookingAtIdentifier$0())
          t5 = t1.peekChar$0() !== 45 || t1.peekChar$1(1) !== 45;
        else
          t5 = false;
        unit = t5 ? _this.identifier$1$unit(true) : null;
      }
      return new T.NumberExpression(sign * ((number + t3) * t4), unit, t1.spanFrom$1(new S._SpanScannerState(t1, t2)));
    },
    _tryDecimal$1$allowTrailingDot: function(allowTrailingDot) {
      var t2,
        t1 = this.scanner,
        start = t1._string_scanner$_position;
      if (t1.peekChar$0() !== 46)
        return 0;
      if (!T.isDigit(t1.peekChar$1(1))) {
        if (allowTrailingDot)
          return 0;
        t1.error$2$position("Expected digit.", t1._string_scanner$_position + 1);
      }
      t1.readChar$0();
      while (true) {
        t2 = t1.peekChar$0();
        if (!(t2 != null && t2 >= 48 && t2 <= 57))
          break;
        t1.readChar$0();
      }
      return P.double_parse(t1.substring$1(0, start));
    },
    _tryExponent$0: function() {
      var next, t2, exponentSign, exponent,
        t1 = this.scanner,
        first = t1.peekChar$0();
      if (first !== 101 && first !== 69)
        return 1;
      next = t1.peekChar$1(1);
      if (!T.isDigit(next) && next !== 45 && next !== 43)
        return 1;
      t1.readChar$0();
      t2 = next === 45;
      exponentSign = t2 ? -1 : 1;
      if (next === 43 || t2)
        t1.readChar$0();
      if (!T.isDigit(t1.peekChar$0()))
        t1.error$1("Expected digit.");
      exponent = 0;
      while (true) {
        t2 = t1.peekChar$0();
        if (!(t2 != null && t2 >= 48 && t2 <= 57))
          break;
        exponent = exponent * 10 + (t1.readChar$0() - 48);
      }
      return Math.pow(10, exponentSign * exponent);
    },
    _unicodeRange$0: function() {
      var i, t2, j, _this = this,
        t1 = _this.scanner,
        start = new S._SpanScannerState(t1, t1._string_scanner$_position);
      _this.expectCharIgnoreCase$1(117);
      t1.expectChar$1(43);
      for (i = 0; i < 6; ++i)
        if (!_this.scanCharIf$1(new V.StylesheetParser__unicodeRange_closure()))
          break;
      if (t1.scanChar$1(63)) {
        ++i;
        for (; i < 6; ++i)
          if (!t1.scanChar$1(63))
            break;
        t2 = t1.substring$1(0, start.position);
        t1 = t1.spanFrom$1(start);
        return new D.StringExpression(X.Interpolation$(H.setRuntimeTypeInfo([t2], [P.Object]), t1), false);
      }
      if (i === 0)
        t1.error$1('Expected hex digit or "?".');
      if (t1.scanChar$1(45)) {
        for (j = 0; j < 6; ++j)
          if (!_this.scanCharIf$1(new V.StylesheetParser__unicodeRange_closure0()))
            break;
        if (j === 0)
          t1.error$1("Expected hex digit.");
      }
      if (_this._lookingAtInterpolatedIdentifierBody$0())
        t1.error$1("Expected end of identifier.");
      t2 = t1.substring$1(0, start.position);
      t1 = t1.spanFrom$1(start);
      return new D.StringExpression(X.Interpolation$(H.setRuntimeTypeInfo([t2], [P.Object]), t1), false);
    },
    _variable$0: function() {
      var $name, name0, namespace, _this = this,
        t1 = _this.scanner,
        start = new S._SpanScannerState(t1, t1._string_scanner$_position);
      t1.expectChar$1(36);
      $name = _this.identifier$0();
      if (t1.peekChar$0() === 46 && t1.peekChar$1(1) !== 46) {
        t1.readChar$0();
        name0 = _this._publicIdentifier$0();
        namespace = $name;
        $name = name0;
      } else {
        $name = H.stringReplaceAllUnchecked($name, "_", "-");
        namespace = null;
      }
      if (_this.get$plainCss())
        _this.error$2("Sass variables aren't allowed in plain CSS.", t1.spanFrom$1(start));
      return new S.VariableExpression(namespace, $name, t1.spanFrom$1(start));
    },
    _selector$0: function() {
      var t1, start, _this = this;
      if (_this.get$plainCss())
        _this.scanner.error$2$length("The parent selector isn't allowed in plain CSS.", 1);
      t1 = _this.scanner;
      start = new S._SpanScannerState(t1, t1._string_scanner$_position);
      t1.expectChar$1(38);
      if (t1.scanChar$1(38)) {
        _this.logger.warn$2$span('In Sass, "&&" means two copies of the parent selector. You probably want to use "and" instead.', t1.spanFrom$1(start));
        t1.set$position(t1._string_scanner$_position - 1);
      }
      return new T.SelectorExpression(t1.spanFrom$1(start));
    },
    interpolatedString$0: function() {
      var t3, t4, buffer, next, second, t5,
        t1 = this.scanner,
        t2 = t1._string_scanner$_position,
        quote = t1.readChar$0();
      if (quote !== 39 && quote !== 34)
        t1.error$2$position("Expected string.", t2);
      t3 = new P.StringBuffer("");
      t4 = [];
      buffer = new Z.InterpolationBuffer(t3, t4);
      for (; true;) {
        next = t1.peekChar$0();
        if (next === quote) {
          t1.readChar$0();
          break;
        } else if (next == null || next === 10 || next === 13 || next === 12)
          t1.error$1("Expected " + H.Primitives_stringFromCharCode(quote) + ".");
        else if (next === 92) {
          second = t1.peekChar$1(1);
          if (second === 10 || second === 13 || second === 12) {
            t1.readChar$0();
            t1.readChar$0();
            if (second === 13)
              t1.scanChar$1(10);
          } else
            t3._contents += H.Primitives_stringFromCharCode(this.escapeCharacter$0());
        } else if (next === 35)
          if (t1.peekChar$1(1) === 123) {
            t5 = this.singleInterpolation$0();
            buffer._flushText$0();
            t4.push(t5);
          } else
            t3._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
        else
          t3._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
      }
      return new D.StringExpression(buffer.interpolation$1(t1.spanFrom$1(new S._SpanScannerState(t1, t2))), true);
    },
    identifierLike$0: function() {
      var invocation, lower, color, specialFunction, namespace, t2, $name, _this = this,
        t1 = _this.scanner,
        start = new S._SpanScannerState(t1, t1._string_scanner$_position),
        identifier = _this.interpolatedIdentifier$0(),
        plain = identifier.get$asPlain();
      if (plain != null) {
        if (plain === "if") {
          invocation = _this._argumentInvocation$0();
          return new L.IfExpression(invocation, B.spanForList(H.setRuntimeTypeInfo([identifier, invocation], [B.AstNode])));
        } else if (plain === "not") {
          _this.whitespace$0();
          return new X.UnaryOperationExpression(C.UnaryOperator_not_not, _this._singleExpression$0(), identifier.span);
        }
        lower = plain.toLowerCase();
        if (t1.peekChar$0() !== 40) {
          switch (plain) {
            case "false":
              return new Z.BooleanExpression(false, identifier.span);
            case "null":
              return new O.NullExpression(identifier.span);
            case "true":
              return new Z.BooleanExpression(true, identifier.span);
          }
          color = $.$get$colorsByName().$index(0, lower);
          if (color != null)
            return new K.ColorExpression(K.SassColor$rgb(color.get$red(), color.get$green(), color.get$blue(), color.alpha, identifier.span));
        }
        specialFunction = _this.trySpecialFunction$2(lower, start);
        if (specialFunction != null)
          return specialFunction;
      }
      switch (t1.peekChar$0()) {
        case 46:
          if (t1.peekChar$1(1) === 46)
            return new D.StringExpression(identifier, false);
          namespace = identifier.get$asPlain();
          t1.readChar$0();
          t2 = t1._string_scanner$_position;
          $name = X.Interpolation$(H.setRuntimeTypeInfo([_this._publicIdentifier$0()], [P.Object]), t1.spanFrom$1(new S._SpanScannerState(t1, t2)));
          if (namespace == null)
            _this.error$2("Interpolation isn't allowed in namespaces.", identifier.span);
          return new F.FunctionExpression(namespace, $name, _this._argumentInvocation$0(), t1.spanFrom$1(start));
        case 40:
          return new F.FunctionExpression(null, identifier, _this._argumentInvocation$0(), t1.spanFrom$1(start));
        default:
          return new D.StringExpression(identifier, false);
      }
    },
    trySpecialFunction$2: function($name, start) {
      var t1, buffer, t2, t3, next, contents, _this = this;
      switch (B.unvendor($name)) {
        case "calc":
        case "element":
        case "expression":
          if (!_this.scanner.scanChar$1(40))
            return;
          t1 = new P.StringBuffer("");
          buffer = new Z.InterpolationBuffer(t1, []);
          t1._contents = $name;
          t1._contents += H.Primitives_stringFromCharCode(40);
          break;
        case "min":
        case "max":
          t1 = _this.scanner;
          t2 = t1._string_scanner$_position;
          if (!t1.scanChar$1(40))
            return;
          _this.whitespace$0();
          t3 = new P.StringBuffer("");
          buffer = new Z.InterpolationBuffer(t3, []);
          t3._contents = $name;
          t3._contents += H.Primitives_stringFromCharCode(40);
          if (!_this._tryMinMaxContents$1(buffer)) {
            t1.set$state(new S._SpanScannerState(t1, t2));
            return;
          }
          return new D.StringExpression(buffer.interpolation$1(t1.spanFrom$1(start)), false);
        case "progid":
          t1 = _this.scanner;
          if (!t1.scanChar$1(58))
            return;
          t2 = new P.StringBuffer("");
          buffer = new Z.InterpolationBuffer(t2, []);
          t2._contents = $name;
          t2._contents += H.Primitives_stringFromCharCode(58);
          next = t1.peekChar$0();
          while (true) {
            if (next != null) {
              if (!(next >= 97 && next <= 122))
                t3 = next >= 65 && next <= 90;
              else
                t3 = true;
              t3 = t3 || next === 46;
            } else
              t3 = false;
            if (!t3)
              break;
            t2._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
            next = t1.peekChar$0();
          }
          t1.expectChar$1(40);
          t2._contents += H.Primitives_stringFromCharCode(40);
          break;
        case "url":
          contents = _this._tryUrlContents$1(start);
          return contents == null ? null : new D.StringExpression(contents, false);
        default:
          return;
      }
      buffer.addInterpolation$1(_this._interpolatedDeclarationValue$1$allowEmpty(true).text);
      t1 = _this.scanner;
      t1.expectChar$1(41);
      buffer._interpolation_buffer$_text._contents += H.Primitives_stringFromCharCode(41);
      return new D.StringExpression(buffer.interpolation$1(t1.spanFrom$1(start)), false);
    },
    _tryMinMaxContents$2$allowComma: function(buffer, allowComma) {
      var t1, t2, t3, t4, start, end, exception, t5, _this = this;
      for (t1 = _this.scanner, t2 = buffer._interpolation_buffer$_text, t3 = !allowComma, t4 = _this.get$_number(); true;) {
        switch (t1.peekChar$0()) {
          case 45:
          case 43:
          case 48:
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
            try {
              start = t1._string_scanner$_position;
              t4.call$0();
              end = t1._string_scanner$_position;
              t2._contents += J.substring$2$s(t1.string, start, end);
            } catch (exception) {
              if (!!J.getInterceptor$(H.unwrapException(exception)).$isFormatException)
                return false;
              else
                throw exception;
            }
            break;
          case 35:
            if (t1.peekChar$1(1) !== 123)
              return false;
            t5 = _this.singleInterpolation$0();
            buffer._flushText$0();
            buffer._interpolation_buffer$_contents.push(t5);
            break;
          case 99:
          case 67:
            if (!_this._tryMinMaxFunction$2(buffer, "calc"))
              return false;
            break;
          case 101:
          case 69:
            if (!_this._tryMinMaxFunction$2(buffer, "env"))
              return false;
            break;
          case 118:
          case 86:
            if (!_this._tryMinMaxFunction$2(buffer, "var"))
              return false;
            break;
          case 40:
            t2._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
            if (!_this._tryMinMaxContents$2$allowComma(buffer, false))
              return false;
            break;
          case 109:
          case 77:
            t1.readChar$0();
            if (_this.scanCharIgnoreCase$1(105)) {
              if (!_this.scanCharIgnoreCase$1(110))
                return false;
              t2._contents += "min(";
            } else if (_this.scanCharIgnoreCase$1(97)) {
              if (!_this.scanCharIgnoreCase$1(120))
                return false;
              t2._contents += "max(";
            } else
              return false;
            if (!t1.scanChar$1(40))
              return false;
            if (!_this._tryMinMaxContents$1(buffer))
              return false;
            break;
          default:
            return false;
        }
        _this.whitespace$0();
        switch (t1.peekChar$0()) {
          case 41:
            t2._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
            return true;
          case 43:
          case 45:
          case 42:
          case 47:
            t2._contents += H.Primitives_stringFromCharCode(32);
            t2._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
            t2._contents += H.Primitives_stringFromCharCode(32);
            break;
          case 44:
            if (t3)
              return false;
            t2._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
            t2._contents += H.Primitives_stringFromCharCode(32);
            break;
          default:
            return false;
        }
        _this.whitespace$0();
      }
    },
    _tryMinMaxContents$1: function(buffer) {
      return this._tryMinMaxContents$2$allowComma(buffer, true);
    },
    _tryMinMaxFunction$2: function(buffer, $name) {
      var t1, t2;
      if (!this.scanIdentifier$1($name))
        return false;
      t1 = this.scanner;
      if (!t1.scanChar$1(40))
        return false;
      t2 = buffer._interpolation_buffer$_text;
      t2._contents += $name;
      t2._contents += H.Primitives_stringFromCharCode(40);
      buffer.addInterpolation$1(this._interpolatedDeclarationValue$1$allowEmpty(true).asInterpolation$0());
      t2._contents += H.Primitives_stringFromCharCode(41);
      if (!t1.scanChar$1(41))
        return false;
      return true;
    },
    _tryUrlContents$2$name: function(start, $name) {
      var t3, t4, buffer, next, t5, endPosition, _this = this,
        t1 = _this.scanner,
        t2 = t1._string_scanner$_position;
      if (!t1.scanChar$1(40))
        return;
      _this.whitespaceWithoutComments$0();
      t3 = new P.StringBuffer("");
      t4 = [];
      buffer = new Z.InterpolationBuffer(t3, t4);
      t3._contents = $name == null ? "url" : $name;
      t3._contents += H.Primitives_stringFromCharCode(40);
      for (; true;) {
        next = t1.peekChar$0();
        if (next == null)
          break;
        else {
          if (next !== 33)
            if (next !== 37)
              if (next !== 38)
                t5 = next >= 42 && next <= 126 || next >= 128;
              else
                t5 = true;
            else
              t5 = true;
          else
            t5 = true;
          if (t5)
            t3._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
          else if (next === 92)
            t3._contents += H.S(_this.escape$0());
          else if (next === 35)
            if (t1.peekChar$1(1) === 123) {
              t5 = _this.singleInterpolation$0();
              buffer._flushText$0();
              t4.push(t5);
            } else
              t3._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
          else if (next === 32 || next === 9 || next === 10 || next === 13 || next === 12) {
            _this.whitespaceWithoutComments$0();
            if (t1.peekChar$0() !== 41)
              break;
          } else if (next === 41) {
            t3._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
            endPosition = t1._string_scanner$_position;
            return buffer.interpolation$1(Y._FileSpan$(t1._sourceFile, start.position, endPosition));
          } else
            break;
        }
      }
      t1.set$state(new S._SpanScannerState(t1, t2));
      return;
    },
    _tryUrlContents$1: function(start) {
      return this._tryUrlContents$2$name(start, null);
    },
    dynamicUrl$0: function() {
      var contents, _this = this,
        t1 = _this.scanner,
        start = new S._SpanScannerState(t1, t1._string_scanner$_position);
      _this.expectIdentifier$1("url");
      contents = _this._tryUrlContents$1(start);
      if (contents != null)
        return new D.StringExpression(contents, false);
      return new F.FunctionExpression(null, X.Interpolation$(H.setRuntimeTypeInfo(["url"], [P.Object]), t1.spanFrom$1(start)), _this._argumentInvocation$0(), t1.spanFrom$1(start));
    },
    almostAnyValue$0: function() {
      var t4, next, commentStart, end, t5, contents, _this = this,
        t1 = _this.scanner,
        t2 = t1._string_scanner$_position,
        t3 = new P.StringBuffer(""),
        buffer = new Z.InterpolationBuffer(t3, []);
      $label0$1:
        for (t4 = t1.string; true;) {
          next = t1.peekChar$0();
          switch (next) {
            case 92:
              t3._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
              t3._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
              break;
            case 34:
            case 39:
              buffer.addInterpolation$1(_this.interpolatedString$0().asInterpolation$0());
              break;
            case 47:
              commentStart = t1._string_scanner$_position;
              if (_this.scanComment$0()) {
                end = t1._string_scanner$_position;
                t3._contents += J.substring$2$s(t4, commentStart, end);
              } else
                t3._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
              break;
            case 35:
              if (t1.peekChar$1(1) === 123)
                buffer.addInterpolation$1(_this.interpolatedIdentifier$0());
              else
                t3._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
              break;
            case 13:
            case 10:
            case 12:
              if (_this.get$indented())
                break $label0$1;
              t3._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
              break;
            case 33:
            case 59:
            case 123:
            case 125:
              break $label0$1;
            case 117:
            case 85:
              t5 = t1._string_scanner$_position;
              if (!_this.scanIdentifier$1("url")) {
                t3._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
                break;
              }
              contents = _this._tryUrlContents$1(new S._SpanScannerState(t1, t5));
              if (contents == null) {
                if (t5 < 0 || t5 > t4.length)
                  H.throwExpression(P.ArgumentError$("Invalid position " + t5));
                t1._string_scanner$_position = t5;
                t1._lastMatch = null;
                t3._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
              } else
                buffer.addInterpolation$1(contents);
              break;
            default:
              if (next == null)
                break $label0$1;
              if (_this.lookingAtIdentifier$0())
                t3._contents += _this.identifier$0();
              else
                t3._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
              break;
          }
        }
      return buffer.interpolation$1(t1.spanFrom$1(new S._SpanScannerState(t1, t2)));
    },
    _interpolatedDeclarationValue$1$allowEmpty: function(allowEmpty) {
      var t4, t5, wroteNewline, next, start, end, t6, contents, _this = this,
        t1 = _this.scanner,
        t2 = t1._string_scanner$_position,
        t3 = new P.StringBuffer(""),
        buffer = new Z.InterpolationBuffer(t3, []),
        brackets = H.setRuntimeTypeInfo([], [P.int]);
      $label0$1:
        for (t4 = t1.string, t5 = _this.get$loudComment(), wroteNewline = false; true;) {
          next = t1.peekChar$0();
          switch (next) {
            case 92:
              t3._contents += H.S(_this.escape$1$identifierStart(true));
              wroteNewline = false;
              break;
            case 34:
            case 39:
              buffer.addInterpolation$1(_this.interpolatedString$0().asInterpolation$0());
              wroteNewline = false;
              break;
            case 47:
              if (t1.peekChar$1(1) === 42) {
                start = t1._string_scanner$_position;
                t5.call$0();
                end = t1._string_scanner$_position;
                t3._contents += J.substring$2$s(t4, start, end);
              } else
                t3._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
              wroteNewline = false;
              break;
            case 35:
              if (t1.peekChar$1(1) === 123)
                buffer.addInterpolation$1(_this.interpolatedIdentifier$0());
              else
                t3._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
              wroteNewline = false;
              break;
            case 32:
            case 9:
              if (!wroteNewline) {
                t6 = t1.peekChar$1(1);
                t6 = !(t6 === 32 || t6 === 9 || t6 === 10 || t6 === 13 || t6 === 12);
              } else
                t6 = true;
              if (t6)
                t3._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
              else
                t1.readChar$0();
              break;
            case 10:
            case 13:
            case 12:
              if (_this.get$indented())
                break $label0$1;
              t6 = t1.peekChar$1(-1);
              if (!(t6 === 10 || t6 === 13 || t6 === 12))
                t3._contents += "\n";
              t1.readChar$0();
              wroteNewline = true;
              break;
            case 40:
            case 123:
            case 91:
              t3._contents += H.Primitives_stringFromCharCode(next);
              brackets.push(T.opposite(t1.readChar$0()));
              wroteNewline = false;
              break;
            case 41:
            case 125:
            case 93:
              if (brackets.length === 0)
                break $label0$1;
              t3._contents += H.Primitives_stringFromCharCode(next);
              t1.expectChar$1(brackets.pop());
              wroteNewline = false;
              break;
            case 59:
              if (brackets.length === 0)
                break $label0$1;
              t3._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
              break;
            case 117:
            case 85:
              t6 = t1._string_scanner$_position;
              if (!_this.scanIdentifier$1("url")) {
                t3._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
                wroteNewline = false;
                break;
              }
              contents = _this._tryUrlContents$1(new S._SpanScannerState(t1, t6));
              if (contents == null) {
                if (t6 < 0 || t6 > t4.length)
                  H.throwExpression(P.ArgumentError$("Invalid position " + t6));
                t1._string_scanner$_position = t6;
                t1._lastMatch = null;
                t3._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
              } else
                buffer.addInterpolation$1(contents);
              wroteNewline = false;
              break;
            default:
              if (next == null)
                break $label0$1;
              if (_this.lookingAtIdentifier$0())
                t3._contents += _this.identifier$0();
              else
                t3._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
              wroteNewline = false;
              break;
          }
        }
      if (brackets.length !== 0)
        t1.expectChar$1(C.JSArray_methods.get$last(brackets));
      if (!allowEmpty && buffer._interpolation_buffer$_contents.length === 0 && t3._contents.length === 0)
        t1.error$1("Expected token.");
      return new D.StringExpression(buffer.interpolation$1(t1.spanFrom$1(new S._SpanScannerState(t1, t2))), false);
    },
    _interpolatedDeclarationValue$0: function() {
      return this._interpolatedDeclarationValue$1$allowEmpty(false);
    },
    interpolatedIdentifier$0: function() {
      var first, t4, next, t5, _this = this,
        _s20_ = "Expected identifier.",
        t1 = _this.scanner,
        t2 = t1._string_scanner$_position,
        t3 = new P.StringBuffer(""),
        buffer = new Z.InterpolationBuffer(t3, []);
      for (; t1.scanChar$1(45);)
        t3._contents += H.Primitives_stringFromCharCode(45);
      first = t1.peekChar$0();
      if (first == null)
        t1.error$1(_s20_);
      else if (first === 95 || T.isAlphabetic0(first) || first >= 128)
        t3._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
      else if (first === 92)
        t3._contents += H.S(_this.escape$1$identifierStart(true));
      else if (first === 35 && t1.peekChar$1(1) === 123) {
        t4 = _this.singleInterpolation$0();
        buffer._flushText$0();
        buffer._interpolation_buffer$_contents.push(t4);
      } else
        t1.error$1(_s20_);
      for (t4 = buffer._interpolation_buffer$_contents; true;) {
        next = t1.peekChar$0();
        if (next == null)
          break;
        else {
          if (next !== 95)
            if (next !== 45) {
              if (!(next >= 97 && next <= 122))
                t5 = next >= 65 && next <= 90;
              else
                t5 = true;
              if (!t5)
                t5 = next >= 48 && next <= 57;
              else
                t5 = true;
              t5 = t5 || next >= 128;
            } else
              t5 = true;
          else
            t5 = true;
          if (t5)
            t3._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
          else if (next === 92)
            t3._contents += H.S(_this.escape$0());
          else if (next === 35 && t1.peekChar$1(1) === 123) {
            t5 = _this.singleInterpolation$0();
            buffer._flushText$0();
            t4.push(t5);
          } else
            break;
        }
      }
      return buffer.interpolation$1(t1.spanFrom$1(new S._SpanScannerState(t1, t2)));
    },
    singleInterpolation$0: function() {
      var contents, _this = this,
        t1 = _this.scanner,
        t2 = t1._string_scanner$_position;
      t1.expect$1("#{");
      _this.whitespace$0();
      contents = _this.expression$0();
      t1.expectChar$1(125);
      if (_this.get$plainCss())
        _this.error$2("Interpolation isn't allowed in plain CSS.", t1.spanFrom$1(new S._SpanScannerState(t1, t2)));
      return contents;
    },
    _mediaQueryList$0: function() {
      var t1 = this.scanner,
        t2 = t1._string_scanner$_position,
        t3 = new P.StringBuffer(""),
        buffer = new Z.InterpolationBuffer(t3, []);
      for (; true;) {
        this.whitespace$0();
        this._stylesheet$_mediaQuery$1(buffer);
        if (!t1.scanChar$1(44))
          break;
        t3._contents += H.Primitives_stringFromCharCode(44);
        t3._contents += H.Primitives_stringFromCharCode(32);
      }
      return buffer.interpolation$1(t1.spanFrom$1(new S._SpanScannerState(t1, t2)));
    },
    _stylesheet$_mediaQuery$1: function(buffer) {
      var t1, identifier, _this = this;
      if (_this.scanner.peekChar$0() !== 40) {
        buffer.addInterpolation$1(_this.interpolatedIdentifier$0());
        _this.whitespace$0();
        if (!_this._lookingAtInterpolatedIdentifier$0())
          return;
        t1 = buffer._interpolation_buffer$_text;
        t1._contents += H.Primitives_stringFromCharCode(32);
        identifier = _this.interpolatedIdentifier$0();
        _this.whitespace$0();
        if (B.equalsIgnoreCase(identifier.get$asPlain(), "and"))
          t1._contents += " and ";
        else {
          buffer.addInterpolation$1(identifier);
          if (_this.scanIdentifier$1("and")) {
            _this.whitespace$0();
            t1._contents += " and ";
          } else
            return;
        }
      }
      for (t1 = buffer._interpolation_buffer$_text; true;) {
        _this.whitespace$0();
        buffer.addInterpolation$1(_this._mediaFeature$0());
        _this.whitespace$0();
        if (!_this.scanIdentifier$1("and"))
          break;
        t1._contents += " and ";
      }
    },
    _mediaFeature$0: function() {
      var interpolation, t2, t3, t4, buffer, t5, next, isAngle, _this = this,
        t1 = _this.scanner;
      if (t1.peekChar$0() === 35) {
        interpolation = _this.singleInterpolation$0();
        return X.Interpolation$(H.setRuntimeTypeInfo([interpolation], [P.Object]), interpolation.get$span());
      }
      t2 = t1._string_scanner$_position;
      t3 = new P.StringBuffer("");
      t4 = [];
      buffer = new Z.InterpolationBuffer(t3, t4);
      t1.expectChar$1(40);
      t3._contents += H.Primitives_stringFromCharCode(40);
      _this.whitespace$0();
      t5 = _this._expressionUntilComparison$0();
      buffer._flushText$0();
      t4.push(t5);
      if (t1.scanChar$1(58)) {
        _this.whitespace$0();
        t3._contents += H.Primitives_stringFromCharCode(58);
        t3._contents += H.Primitives_stringFromCharCode(32);
        t5 = _this.expression$0();
        buffer._flushText$0();
        t4.push(t5);
      } else {
        next = t1.peekChar$0();
        isAngle = next === 60 || next === 62;
        if (isAngle || next === 61) {
          t3._contents += H.Primitives_stringFromCharCode(32);
          t3._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
          if (isAngle && t1.scanChar$1(61))
            t3._contents += H.Primitives_stringFromCharCode(61);
          t3._contents += H.Primitives_stringFromCharCode(32);
          _this.whitespace$0();
          t5 = _this._expressionUntilComparison$0();
          buffer._flushText$0();
          t4.push(t5);
          if (isAngle && t1.scanChar$1(next)) {
            t3._contents += H.Primitives_stringFromCharCode(32);
            t3._contents += H.Primitives_stringFromCharCode(next);
            if (t1.scanChar$1(61))
              t3._contents += H.Primitives_stringFromCharCode(61);
            t3._contents += H.Primitives_stringFromCharCode(32);
            _this.whitespace$0();
            t5 = _this._expressionUntilComparison$0();
            buffer._flushText$0();
            t4.push(t5);
          }
        }
      }
      t1.expectChar$1(41);
      _this.whitespace$0();
      t3._contents += H.Primitives_stringFromCharCode(41);
      return buffer.interpolation$1(t1.spanFrom$1(new S._SpanScannerState(t1, t2)));
    },
    _expressionUntilComparison$0: function() {
      return this.expression$1$until(new V.StylesheetParser__expressionUntilComparison_closure(this));
    },
    _supportsCondition$0: function() {
      var condition, operator, right, endPosition, lowerOperator, _this = this,
        t1 = _this.scanner,
        t2 = t1._string_scanner$_position,
        first = t1.peekChar$0();
      if (first !== 40 && first !== 35) {
        t2 = t1._string_scanner$_position;
        _this.expectIdentifier$1("not");
        _this.whitespace$0();
        return new M.SupportsNegation(_this._supportsConditionInParens$0(), t1.spanFrom$1(new S._SpanScannerState(t1, t2)));
      }
      condition = _this._supportsConditionInParens$0();
      _this.whitespace$0();
      for (; _this.lookingAtIdentifier$0();) {
        if (_this.scanIdentifier$1("or"))
          operator = "or";
        else {
          _this.expectIdentifier$1("and");
          operator = "and";
        }
        _this.whitespace$0();
        right = _this._supportsConditionInParens$0();
        endPosition = t1._string_scanner$_position;
        condition = new U.SupportsOperation(condition, right, operator, Y._FileSpan$(t1._sourceFile, t2, endPosition));
        lowerOperator = operator.toLowerCase();
        if (lowerOperator !== "and" && lowerOperator !== "or")
          H.throwExpression(P.ArgumentError$value(operator, "operator", 'may only be "and" or "or".'));
        _this.whitespace$0();
      }
      return condition;
    },
    _supportsConditionInParens$0: function() {
      var next, condition, negation, $name, value, _this = this,
        t1 = _this.scanner,
        start = new S._SpanScannerState(t1, t1._string_scanner$_position);
      if (t1.peekChar$0() === 35)
        return new X.SupportsInterpolation(_this.singleInterpolation$0(), t1.spanFrom$1(start));
      t1.expectChar$1(40);
      _this.whitespace$0();
      next = t1.peekChar$0();
      if (next === 40 || next === 35) {
        condition = _this._supportsCondition$0();
        _this.whitespace$0();
        t1.expectChar$1(41);
        return condition;
      }
      if (next === 110 || next === 78) {
        negation = _this._trySupportsNegation$0();
        if (negation != null) {
          t1.expectChar$1(41);
          return negation;
        }
      }
      $name = _this.expression$0();
      t1.expectChar$1(58);
      _this.whitespace$0();
      value = _this.expression$0();
      t1.expectChar$1(41);
      return new L.SupportsDeclaration($name, value, t1.spanFrom$1(start));
    },
    _trySupportsNegation$0: function() {
      var next, _this = this,
        t1 = _this.scanner,
        start = new S._SpanScannerState(t1, t1._string_scanner$_position);
      if (!_this.scanIdentifier$1("not") || t1._string_scanner$_position === t1.string.length) {
        t1.set$state(start);
        return;
      }
      next = t1.peekChar$0();
      if (!(next === 32 || next === 9 || T.isNewline(next)) && next !== 40) {
        t1.set$state(start);
        return;
      }
      _this.whitespace$0();
      return new M.SupportsNegation(_this._supportsConditionInParens$0(), t1.spanFrom$1(start));
    },
    _lookingAtInterpolatedIdentifier$0: function() {
      var second, third,
        t1 = this.scanner,
        first = t1.peekChar$0();
      if (first == null)
        return false;
      if (first === 95 || T.isAlphabetic0(first) || first >= 128 || first === 92)
        return true;
      if (first === 35)
        return t1.peekChar$1(1) === 123;
      if (first !== 45)
        return false;
      second = t1.peekChar$1(1);
      if (second == null)
        return false;
      if (second === 95 || T.isAlphabetic0(second) || second >= 128 || second === 92)
        return true;
      if (second === 35)
        return t1.peekChar$1(2) === 123;
      if (second !== 45)
        return false;
      third = t1.peekChar$1(2);
      if (third == null)
        return false;
      if (third === 35)
        return t1.peekChar$1(3) === 123;
      return third === 95 || T.isAlphabetic0(third) || third >= 128;
    },
    _lookingAtInterpolatedIdentifierBody$0: function() {
      var t1 = this.scanner,
        first = t1.peekChar$0();
      if (first == null)
        return false;
      if (first === 95 || T.isAlphabetic0(first) || first >= 128 || T.isDigit(first) || first === 45 || first === 92)
        return true;
      return first === 35 && t1.peekChar$1(1) === 123;
    },
    _lookingAtExpression$0: function() {
      var next,
        t1 = this.scanner,
        character = t1.peekChar$0();
      if (character == null)
        return false;
      if (character === 46)
        return t1.peekChar$1(1) !== 46;
      if (character === 33) {
        next = t1.peekChar$1(1);
        if (next != null)
          if ((next | 32) !== 105)
            t1 = next === 32 || next === 9 || T.isNewline(next);
          else
            t1 = true;
        else
          t1 = true;
        return t1;
      }
      if (character !== 40)
        if (character !== 47)
          if (character !== 91)
            if (character !== 39)
              if (character !== 34)
                if (character !== 35)
                  if (character !== 43)
                    if (character !== 45)
                      if (character !== 92)
                        if (character !== 36)
                          if (character !== 38)
                            t1 = character === 95 || T.isAlphabetic0(character) || character >= 128 || T.isDigit(character);
                          else
                            t1 = true;
                        else
                          t1 = true;
                      else
                        t1 = true;
                    else
                      t1 = true;
                  else
                    t1 = true;
                else
                  t1 = true;
              else
                t1 = true;
            else
              t1 = true;
          else
            t1 = true;
        else
          t1 = true;
      else
        t1 = true;
      return t1;
    },
    _withChildren$1$3: function(child, start, create) {
      var result = create.call$2(this.children$1(child), this.scanner.spanFrom$1(start));
      this.whitespaceWithoutComments$0();
      return result;
    },
    _withChildren$3: function(child, start, create) {
      return this._withChildren$1$3(child, start, create, null);
    },
    _urlString$0: function() {
      var innerError, t2, exception,
        t1 = this.scanner,
        start = new S._SpanScannerState(t1, t1._string_scanner$_position),
        url = this.string$0();
      try {
        t2 = P.Uri_parse(url);
        return t2;
      } catch (exception) {
        t2 = H.unwrapException(exception);
        if (!!J.getInterceptor$(t2).$isFormatException) {
          innerError = t2;
          this.error$2("Invalid URL: " + H.S(J.get$message$x(innerError)), t1.spanFrom$1(start));
        } else
          throw exception;
      }
    },
    _publicIdentifier$0: function() {
      var t1 = this.scanner,
        t2 = t1._string_scanner$_position,
        result = this.identifier$1$normalize(true),
        first = C.JSString_methods._codeUnitAt$1(result, 0);
      if (first === 45 || first === 95)
        this.error$2("Private members can't be accessed from outside their modules.", t1.spanFrom$1(new S._SpanScannerState(t1, t2)));
      return result;
    },
    get$plainCss: function() {
      return false;
    }
  };
  V.StylesheetParser_parse_closure.prototype = {
    call$0: function() {
      var statements, t4,
        t1 = this.$this,
        t2 = t1.scanner,
        t3 = t2._string_scanner$_position;
      t2.scanChar$1(65279);
      statements = t1.statements$1(new V.StylesheetParser_parse__closure(t1));
      t2.expectDone$0();
      t4 = t1._globalVariables.get$values();
      C.JSArray_methods.addAll$1(statements, H.MappedIterable_MappedIterable(t4, new V.StylesheetParser_parse__closure0(), H.getRuntimeTypeArgument(t4, "Iterable", 0), O.Statement));
      return V.Stylesheet$(statements, t2.spanFrom$1(new S._SpanScannerState(t2, t3)), t1.get$plainCss());
    }
  };
  V.StylesheetParser_parse__closure.prototype = {
    call$0: function() {
      return this.$this._statement$1$root(true);
    }
  };
  V.StylesheetParser_parse__closure0.prototype = {
    call$1: function(declaration) {
      return Z.VariableDeclaration$(declaration.name, new O.NullExpression(declaration.expression.get$span()), declaration.span, null, false, true, null);
    }
  };
  V.StylesheetParser_parseArgumentDeclaration_closure.prototype = {
    call$0: function() {
      var t1 = this.$this,
        declaration = t1._argumentDeclaration$0();
      t1.scanner.expectDone$0();
      return declaration;
    }
  };
  V.StylesheetParser_parseExpression_closure.prototype = {
    call$0: function() {
      var t1 = this.$this,
        result = t1.expression$0();
      t1.scanner.expectDone$0();
      return result;
    }
  };
  V.StylesheetParser_parseVariableDeclaration_closure.prototype = {
    call$0: function() {
      var t1 = this.$this,
        declaration = t1.variableDeclaration$0();
      t1.scanner.expectDone$0();
      return declaration;
    }
  };
  V.StylesheetParser_parseSignature_closure.prototype = {
    call$0: function() {
      var t2, $arguments, t3,
        t1 = this.$this,
        $name = t1.identifier$0();
      t1.whitespace$0();
      t2 = t1.scanner;
      if (t2.peekChar$0() === 40)
        $arguments = t1._argumentDeclaration$0();
      else {
        t1 = Y.FileLocation$_(t2._sourceFile, t2._string_scanner$_position);
        t3 = t1.offset;
        $arguments = new B.ArgumentDeclaration(C.List_empty9, null, Y._FileSpan$(t1.file, t3, t3));
      }
      t2.expectDone$0();
      return new S.Tuple2($name, $arguments, [P.String, B.ArgumentDeclaration]);
    }
  };
  V.StylesheetParser__statement_closure.prototype = {
    call$0: function() {
      return this.$this._statement$0();
    }
  };
  V.StylesheetParser_variableDeclaration_closure.prototype = {
    call$0: function() {
      return this.declaration;
    }
  };
  V.StylesheetParser__styleRule_closure.prototype = {
    call$2: function(children, span) {
      var t1 = P.List_List$unmodifiable(children, O.Statement),
        t2 = C.JSArray_methods.any$1(t1, new M.ParentStatement_closure());
      return new X.StyleRule(this.selector, span, t1, t2);
    }
  };
  V.StylesheetParser__declarationOrStyleRule_closure.prototype = {
    call$2: function(children, span) {
      var t2, t3, t4, _this = this,
        t1 = _this.$this;
      if (t1.get$indented() && children.length === 0)
        t1.logger.warn$2$span("This selector doesn't have any properties and won't be rendered.", _this.selectorSpan);
      t1._inStyleRule = _this.wasInStyleRule;
      t2 = _this.buffer.interpolation$1(_this.selectorSpan);
      t1 = t1.scanner.spanFrom$1(_this.start);
      t3 = P.List_List$unmodifiable(children, O.Statement);
      t4 = C.JSArray_methods.any$1(t3, new M.ParentStatement_closure());
      return new X.StyleRule(t2, t1, t3, t4);
    }
  };
  V.StylesheetParser__declarationOrBuffer_closure.prototype = {
    call$2: function(children, span) {
      return L.Declaration$(this.name, span, children, null);
    }
  };
  V.StylesheetParser__declarationOrBuffer_closure0.prototype = {
    call$2: function(children, span) {
      return L.Declaration$(this.name, span, children, this._box_0.value);
    }
  };
  V.StylesheetParser__declaration_closure.prototype = {
    call$2: function(children, span) {
      return L.Declaration$(this._box_0.name, span, children, null);
    }
  };
  V.StylesheetParser__declaration_closure0.prototype = {
    call$2: function(children, span) {
      return L.Declaration$(this._box_0.name, span, children, this.value);
    }
  };
  V.StylesheetParser__atRootRule_closure.prototype = {
    call$2: function(children, span) {
      var t1 = P.List_List$unmodifiable(children, O.Statement),
        t2 = C.JSArray_methods.any$1(t1, new M.ParentStatement_closure());
      return new V.AtRootRule(this.query, span, t1, t2);
    }
  };
  V.StylesheetParser__atRootRule_closure0.prototype = {
    call$2: function(children, span) {
      var t1 = P.List_List$unmodifiable(children, O.Statement),
        t2 = C.JSArray_methods.any$1(t1, new M.ParentStatement_closure());
      return new V.AtRootRule(null, span, t1, t2);
    }
  };
  V.StylesheetParser__eachRule_closure.prototype = {
    call$2: function(children, span) {
      var t1, t2, t3, _this = this;
      _this.$this._inControlDirective = _this.wasInControlDirective;
      t1 = P.List_List$unmodifiable(_this.variables, P.String);
      t2 = P.List_List$unmodifiable(children, O.Statement);
      t3 = C.JSArray_methods.any$1(t2, new M.ParentStatement_closure());
      return new V.EachRule(t1, _this.list, span, t2, t3);
    }
  };
  V.StylesheetParser__functionRule_closure.prototype = {
    call$2: function(children, span) {
      var t1 = P.List_List$unmodifiable(children, O.Statement),
        t2 = C.JSArray_methods.any$1(t1, new M.ParentStatement_closure());
      return new M.FunctionRule(this.name, this.$arguments, span, t1, t2);
    }
  };
  V.StylesheetParser__forRule_closure.prototype = {
    call$0: function() {
      var t1 = this.$this;
      if (!t1.lookingAtIdentifier$0())
        return false;
      if (t1.scanIdentifier$1("to"))
        return this._box_0.exclusive = true;
      else if (t1.scanIdentifier$1("through")) {
        this._box_0.exclusive = false;
        return true;
      } else
        return false;
    }
  };
  V.StylesheetParser__forRule_closure0.prototype = {
    call$2: function(children, span) {
      var t1, t2, t3, _this = this;
      _this.$this._inControlDirective = _this.wasInControlDirective;
      t1 = _this._box_0.exclusive;
      t2 = P.List_List$unmodifiable(children, O.Statement);
      t3 = C.JSArray_methods.any$1(t2, new M.ParentStatement_closure());
      return new B.ForRule(_this.variable, _this.from, _this.to, t1, span, t2, t3);
    }
  };
  V.StylesheetParser__memberList_closure.prototype = {
    call$0: function() {
      var t1 = this.$this;
      if (t1.scanner.peekChar$0() === 36)
        this.variables.add$1(0, t1.variableName$0());
      else
        this.identifiers.add$1(0, t1.identifier$0());
    }
  };
  V.StylesheetParser__includeRule_closure.prototype = {
    call$2: function(children, span) {
      var t2, t3,
        t1 = this._box_0.contentArguments;
      if (t1 == null) {
        t1 = this.$this.scanner;
        t1 = Y.FileLocation$_(t1._sourceFile, t1._string_scanner$_position);
        t2 = t1.offset;
        t2 = new B.ArgumentDeclaration(C.List_empty9, null, Y._FileSpan$(t1.file, t2, t2));
        t1 = t2;
      }
      t2 = P.List_List$unmodifiable(children, O.Statement);
      t3 = C.JSArray_methods.any$1(t2, new M.ParentStatement_closure());
      return new Y.ContentBlock(null, t1, span, t2, t3);
    }
  };
  V.StylesheetParser_mediaRule_closure.prototype = {
    call$2: function(children, span) {
      var t1 = P.List_List$unmodifiable(children, O.Statement),
        t2 = C.JSArray_methods.any$1(t1, new M.ParentStatement_closure());
      return new G.MediaRule(this.query, span, t1, t2);
    }
  };
  V.StylesheetParser__mixinRule_closure.prototype = {
    call$2: function(children, span) {
      var t2,
        t1 = this.$this,
        hadContent = t1._mixinHasContent;
      t1._stylesheet$_inMixin = false;
      t1._mixinHasContent = null;
      t1 = P.List_List$unmodifiable(children, O.Statement);
      t2 = C.JSArray_methods.any$1(t1, new M.ParentStatement_closure());
      return new T.MixinRule(hadContent, this.name, this.$arguments, span, t1, t2);
    }
  };
  V.StylesheetParser_mozDocumentRule_closure.prototype = {
    call$2: function(children, span) {
      var _this = this;
      if (_this._box_0.needsDeprecationWarning)
        _this.$this.logger.warn$3$deprecation$span("@-moz-document is deprecated and support will be removed from Sass in a future\nrelase. For details, see http://bit.ly/moz-document.\n", true, span);
      return U.AtRule$(_this.name, span, children, _this.value);
    }
  };
  V.StylesheetParser_supportsRule_closure.prototype = {
    call$2: function(children, span) {
      var t1 = P.List_List$unmodifiable(children, O.Statement),
        t2 = C.JSArray_methods.any$1(t1, new M.ParentStatement_closure());
      return new B.SupportsRule(this.condition, span, t1, t2);
    }
  };
  V.StylesheetParser__whileRule_closure.prototype = {
    call$2: function(children, span) {
      var t1, t2;
      this.$this._inControlDirective = this.wasInControlDirective;
      t1 = P.List_List$unmodifiable(children, O.Statement);
      t2 = C.JSArray_methods.any$1(t1, new M.ParentStatement_closure());
      return new G.WhileRule(this.condition, span, t1, t2);
    }
  };
  V.StylesheetParser_unknownAtRule_closure.prototype = {
    call$2: function(children, span) {
      return U.AtRule$(this.name, span, children, this._box_0.value);
    }
  };
  V.StylesheetParser_expression_resetState.prototype = {
    call$0: function() {
      var t2,
        t1 = this._box_0;
      t1.operands = t1.operators = t1.spaceExpressions = t1.commaExpressions = null;
      t2 = this.$this;
      t2.scanner.set$state(this.start);
      t1.allowSlash = t2.lookingAtNumber$0();
      t1.singleExpression = t2._singleExpression$0();
    }
  };
  V.StylesheetParser_expression_resolveOneOperation.prototype = {
    call$0: function() {
      var t2, t3,
        t1 = this._box_0,
        operator = t1.operators.pop();
      if (operator !== C.BinaryOperator_RTB)
        t1.allowSlash = false;
      t2 = t1.allowSlash && !this.$this._inParentheses;
      t3 = t1.operands;
      if (t2)
        t1.singleExpression = new V.BinaryOperationExpression(C.BinaryOperator_RTB, t3.pop(), t1.singleExpression, true);
      else
        t1.singleExpression = new V.BinaryOperationExpression(operator, t3.pop(), t1.singleExpression, false);
    }
  };
  V.StylesheetParser_expression_resolveOperations.prototype = {
    call$0: function() {
      var t2,
        t1 = this._box_0;
      if (t1.operators == null)
        return;
      for (t2 = this.resolveOneOperation; t1.operators.length !== 0;)
        t2.call$0();
    }
  };
  V.StylesheetParser_expression_addSingleExpression.prototype = {
    call$2$number: function(expression, number) {
      var t2, _this = this,
        t1 = _this._box_0;
      if (t1.singleExpression != null) {
        t2 = _this.$this;
        if (t2._inParentheses) {
          t2._inParentheses = false;
          if (t1.allowSlash) {
            _this.resetState.call$0();
            return;
          }
        }
        if (t1.spaceExpressions == null)
          t1.spaceExpressions = H.setRuntimeTypeInfo([], [T.Expression]);
        _this.resolveOperations.call$0();
        t1.spaceExpressions.push(t1.singleExpression);
        t1.allowSlash = number;
      } else if (!number)
        t1.allowSlash = false;
      t1.singleExpression = expression;
    },
    call$1: function(expression) {
      return this.call$2$number(expression, false);
    }
  };
  V.StylesheetParser_expression_addOperator.prototype = {
    call$1: function(operator) {
      var t2, t3, t4, t5, singleExpression,
        t1 = this.$this;
      if (t1.get$plainCss() && operator !== C.BinaryOperator_RTB) {
        t2 = t1.scanner;
        t3 = operator.operator.length;
        t2.error$3$length$position("Operators aren't allowed in plain CSS.", t3, t2._string_scanner$_position - t3);
      }
      t2 = this._box_0;
      t2.allowSlash = t2.allowSlash && operator === C.BinaryOperator_RTB;
      if (t2.operators == null)
        t2.operators = H.setRuntimeTypeInfo([], [V.BinaryOperator]);
      if (t2.operands == null)
        t2.operands = H.setRuntimeTypeInfo([], [T.Expression]);
      t3 = this.resolveOneOperation;
      t4 = operator.precedence;
      while (true) {
        t5 = t2.operators;
        if (!(t5.length !== 0 && (t5 && C.JSArray_methods).get$last(t5).precedence >= t4))
          break;
        t3.call$0();
      }
      t2.operators.push(operator);
      t2.operands.push(t2.singleExpression);
      t1.whitespace$0();
      t2.allowSlash = t2.allowSlash && t1.lookingAtNumber$0();
      singleExpression = t1._singleExpression$0();
      t2.singleExpression = singleExpression;
      t2.allowSlash = t2.allowSlash && singleExpression instanceof T.NumberExpression;
    }
  };
  V.StylesheetParser_expression_resolveSpaceExpressions.prototype = {
    call$0: function() {
      var t1, t2, t3;
      this.resolveOperations.call$0();
      t1 = this._box_0;
      t2 = t1.spaceExpressions;
      if (t2 != null) {
        t2.push(t1.singleExpression);
        t2 = P.List_List$unmodifiable(t1.spaceExpressions, T.Expression);
        t3 = B.spanForList(t2);
        t1.singleExpression = new D.ListExpression(t2, C.ListSeparator_space, false, t3);
        t1.spaceExpressions = null;
      }
      t2 = t1.singleEqualsOperand;
      if (t2 != null) {
        t1.singleExpression = new V.BinaryOperationExpression(C.BinaryOperator_kjl, t2, t1.singleExpression, false);
        t1.singleEqualsOperand = null;
      }
    }
  };
  V.StylesheetParser__expressionUntilComma_closure.prototype = {
    call$0: function() {
      return this.$this.scanner.peekChar$0() === 44;
    }
  };
  V.StylesheetParser__unicodeRange_closure.prototype = {
    call$1: function(char) {
      return char != null && T.isHex(char);
    },
    $signature: 13
  };
  V.StylesheetParser__unicodeRange_closure0.prototype = {
    call$1: function(char) {
      return char != null && T.isHex(char);
    },
    $signature: 13
  };
  V.StylesheetParser__expressionUntilComparison_closure.prototype = {
    call$0: function() {
      var t1 = this.$this.scanner,
        next = t1.peekChar$0();
      if (next === 61)
        return t1.peekChar$1(1) !== 61;
      return next === 60 || next === 62;
    }
  };
  M.StylesheetGraph.prototype = {
    modifiedSince$3: function(url, since, baseImporter) {
      var node = this._stylesheet_graph$_add$3(url, baseImporter, null);
      if (node == null)
        return true;
      return new M.StylesheetGraph_modifiedSince_transitiveModificationTime(this).call$1(node)._value > since._value;
    },
    _stylesheet_graph$_add$3: function(url, baseImporter, baseUrl) {
      var tuple = this._ignoreErrors$1(new M.StylesheetGraph__add_closure(this, url, baseImporter, baseUrl));
      if (tuple == null)
        return;
      return this.addCanonical$3(tuple.item1, tuple.item2, tuple.item3);
    },
    addCanonical$3: function(importer, canonicalUrl, originalUrl) {
      var _this = this,
        stylesheet = _this._ignoreErrors$1(new M.StylesheetGraph_addCanonical_closure(_this, importer, canonicalUrl, originalUrl));
      if (stylesheet == null)
        return;
      return _this._nodes.putIfAbsent$2(canonicalUrl, new M.StylesheetGraph_addCanonical_closure0(_this, stylesheet, importer, canonicalUrl));
    },
    _upstreamNodes$3: function(stylesheet, baseImporter, baseUrl) {
      var upstreamUrls, t3,
        t1 = P.Uri,
        active = P.LinkedHashSet_LinkedHashSet$_literal([baseUrl], t1),
        t2 = H.setRuntimeTypeInfo([], [B.DynamicImport]);
      new L._FindImportsVisitor(t2).visitChildren$1(stylesheet);
      upstreamUrls = new H.MappedListIterable(t2, new M.StylesheetGraph__upstreamNodes_closure(), [H.getTypeArgumentByIndex(t2, 0), t1]);
      t1 = P.LinkedHashMap_LinkedHashMap$_empty(t1, M.StylesheetNode);
      for (t2 = new H.ListIterator(upstreamUrls, upstreamUrls.get$length(upstreamUrls)); t2.moveNext$0();) {
        t3 = t2.__internal$_current;
        t1.$indexSet(0, t3, this._nodeFor$4(t3, baseImporter, baseUrl, active));
      }
      return t1;
    },
    reload$1: function(canonicalUrl) {
      var stylesheet, _this = this,
        node = _this._nodes.$index(0, canonicalUrl);
      if (node == null)
        throw H.wrapException(P.StateError$(H.S(canonicalUrl) + " is not in the dependency graph."));
      _this._transitiveModificationTimes.clear$0(0);
      _this.importCache.clearImport$1(canonicalUrl);
      stylesheet = _this._ignoreErrors$1(new M.StylesheetGraph_reload_closure(_this, node, canonicalUrl));
      if (stylesheet == null) {
        _this.remove$1(0, canonicalUrl);
        return;
      }
      node._replaceUpstream$1(_this._upstreamNodes$3(stylesheet, node.importer, canonicalUrl));
      return node;
    },
    remove$1: function(_, canonicalUrl) {
      var node = this._nodes.remove$1(0, canonicalUrl);
      if (node == null)
        throw H.wrapException(P.StateError$(H.S(canonicalUrl) + " is not in the dependency graph."));
      this._transitiveModificationTimes.clear$0(0);
      this.importCache.clearImport$1(canonicalUrl);
      node._stylesheet_graph$_remove$0();
    },
    _nodeFor$4: function(url, baseImporter, baseUrl, active) {
      var importer, canonicalUrl, resolvedUrl, t1, stylesheet, node, _this = this,
        tuple = _this._ignoreErrors$1(new M.StylesheetGraph__nodeFor_closure(_this, url, baseImporter, baseUrl));
      if (tuple == null)
        return;
      importer = tuple.item1;
      canonicalUrl = tuple.item2;
      resolvedUrl = tuple.item3;
      t1 = _this._nodes;
      if (t1.containsKey$1(canonicalUrl))
        return t1.$index(0, canonicalUrl);
      if (active.contains$1(0, canonicalUrl))
        return;
      stylesheet = _this._ignoreErrors$1(new M.StylesheetGraph__nodeFor_closure0(_this, importer, canonicalUrl, resolvedUrl));
      if (stylesheet == null)
        return;
      active.add$1(0, canonicalUrl);
      node = M.StylesheetNode$_(stylesheet, importer, canonicalUrl, _this._upstreamNodes$3(stylesheet, importer, canonicalUrl));
      active.remove$1(0, canonicalUrl);
      t1.$indexSet(0, canonicalUrl, node);
      return node;
    },
    _ignoreErrors$1$1: function(callback) {
      var t1, exception;
      try {
        t1 = callback.call$0();
        return t1;
      } catch (exception) {
        H.unwrapException(exception);
        return;
      }
    },
    _ignoreErrors$1: function(callback) {
      return this._ignoreErrors$1$1(callback, null);
    }
  };
  M.StylesheetGraph_modifiedSince_transitiveModificationTime.prototype = {
    call$1: function(node) {
      return this.$this._transitiveModificationTimes.putIfAbsent$2(node.canonicalUrl, new M.StylesheetGraph_modifiedSince_transitiveModificationTime_closure(node, this));
    }
  };
  M.StylesheetGraph_modifiedSince_transitiveModificationTime_closure.prototype = {
    call$0: function() {
      var t2, t3, upstreamTime,
        t1 = this.node,
        latest = t1.importer.modificationTime$1(t1.canonicalUrl);
      for (t1 = t1._upstream.get$values(), t1 = t1.get$iterator(t1), t2 = this.transitiveModificationTime; t1.moveNext$0();) {
        t3 = t1.get$current(t1);
        upstreamTime = t3 == null ? new P.DateTime(Date.now(), false) : t2.call$1(t3);
        if (upstreamTime._value > latest._value)
          latest = upstreamTime;
      }
      return latest;
    }
  };
  M.StylesheetGraph__add_closure.prototype = {
    call$0: function() {
      var _this = this;
      return _this.$this.importCache.canonicalize$3(_this.url, _this.baseImporter, _this.baseUrl);
    }
  };
  M.StylesheetGraph_addCanonical_closure.prototype = {
    call$0: function() {
      var _this = this;
      return _this.$this.importCache.importCanonical$3(_this.importer, _this.canonicalUrl, _this.originalUrl);
    }
  };
  M.StylesheetGraph_addCanonical_closure0.prototype = {
    call$0: function() {
      var _this = this,
        t1 = _this.stylesheet,
        t2 = _this.importer,
        t3 = _this.canonicalUrl;
      return M.StylesheetNode$_(t1, t2, t3, _this.$this._upstreamNodes$3(t1, t2, t3));
    }
  };
  M.StylesheetGraph__upstreamNodes_closure.prototype = {
    call$1: function($import) {
      return P.Uri_parse($import.url);
    }
  };
  M.StylesheetGraph_reload_closure.prototype = {
    call$0: function() {
      return this.$this.importCache.importCanonical$2(this.node.importer, this.canonicalUrl);
    }
  };
  M.StylesheetGraph__nodeFor_closure.prototype = {
    call$0: function() {
      var _this = this;
      return _this.$this.importCache.canonicalize$3(_this.url, _this.baseImporter, _this.baseUrl);
    }
  };
  M.StylesheetGraph__nodeFor_closure0.prototype = {
    call$0: function() {
      var _this = this;
      return _this.$this.importCache.importCanonical$3(_this.importer, _this.canonicalUrl, _this.resolvedUrl);
    }
  };
  M.StylesheetNode.prototype = {
    StylesheetNode$_$4: function(_stylesheet, importer, canonicalUrl, _upstream) {
      var t1, t2;
      for (t1 = this._upstream.get$values(), t1 = t1.get$iterator(t1); t1.moveNext$0();) {
        t2 = t1.get$current(t1);
        if (t2 != null)
          t2._downstream.add$1(0, this);
      }
    },
    _replaceUpstream$1: function(newUpstream) {
      var newUpstreamSet, _this = this,
        t1 = M.StylesheetNode,
        oldUpstream = P.LinkedHashSet_LinkedHashSet$of(_this._upstream.get$values(), t1);
      oldUpstream.remove$1(0, null);
      newUpstreamSet = P.LinkedHashSet_LinkedHashSet$of(newUpstream.get$values(), t1);
      newUpstreamSet.remove$1(0, null);
      for (t1 = oldUpstream.difference$1(newUpstreamSet), t1 = P._LinkedHashSetIterator$(t1, t1._collection$_modifications); t1.moveNext$0();)
        t1._collection$_current._downstream.remove$1(0, _this);
      for (t1 = newUpstreamSet.difference$1(oldUpstream), t1 = P._LinkedHashSetIterator$(t1, t1._collection$_modifications); t1.moveNext$0();)
        t1._collection$_current._downstream.add$1(0, _this);
      _this._upstream = newUpstream;
    },
    _stylesheet_graph$_remove$0: function() {
      var t1, t2, t3, t4, _i, url, _this = this;
      for (t1 = _this._upstream.get$values(), t1 = t1.get$iterator(t1); t1.moveNext$0();) {
        t2 = t1.get$current(t1);
        if (t2 == null)
          continue;
        t2._downstream.remove$1(0, _this);
      }
      for (t1 = _this._downstream, t1 = t1.get$iterator(t1); t1.moveNext$0();) {
        t2 = t1.get$current(t1);
        for (t3 = t2._upstream.get$keys(), t3 = P.List_List$from(t3, true, H.getRuntimeTypeArgument(t3, "Iterable", 0)), t4 = t3.length, _i = 0; _i < t3.length; t3.length === t4 || (0, H.throwConcurrentModificationError)(t3), ++_i) {
          url = t3[_i];
          if (J.$eq$(t2._upstream.$index(0, url), _this)) {
            t2._upstream.$indexSet(0, url, null);
            break;
          }
        }
      }
    }
  };
  M.Syntax.prototype = {
    toString$0: function(_) {
      return this._syntax$_name;
    }
  };
  G.FixedLengthListBuilder.prototype = {
    add$1: function(_, element) {
      var t1, _this = this;
      _this._checkUnbuilt$0();
      t1 = _this._fixed_length_list_builder$_index;
      _this._list[t1] = element;
      _this._fixed_length_list_builder$_index = t1 + 1;
    },
    addAll$1: function(_, elements) {
      var _this = this;
      _this._checkUnbuilt$0();
      C.JSArray_methods.setAll$2(_this._list, _this._fixed_length_list_builder$_index, elements);
      _this._fixed_length_list_builder$_index = _this._fixed_length_list_builder$_index + elements.length;
    },
    addRange$3: function(elements, start, end) {
      var $length, t1, _this = this;
      _this._checkUnbuilt$0();
      $length = (end == null ? J.get$length$asx(elements._collection$_source) : end) - start;
      t1 = _this._fixed_length_list_builder$_index;
      C.JSArray_methods.setRange$4(_this._list, t1, t1 + $length, elements, start);
      _this._fixed_length_list_builder$_index += $length;
    },
    addRange$2: function(elements, start) {
      return this.addRange$3(elements, start, null);
    },
    build$0: function() {
      this._checkUnbuilt$0();
      this._fixed_length_list_builder$_index = -1;
      return this._list;
    },
    _checkUnbuilt$0: function() {
      if (this._fixed_length_list_builder$_index === -1)
        throw H.wrapException(P.StateError$("build() has already been called."));
    }
  };
  K.LimitedMapView.prototype = {
    get$keys: function() {
      return this._limited_map_view$_keys;
    },
    get$length: function(_) {
      return this._limited_map_view$_keys._collection$_length;
    },
    get$isEmpty: function(_) {
      return this._limited_map_view$_keys._collection$_length === 0;
    },
    get$isNotEmpty: function(_) {
      return this._limited_map_view$_keys._collection$_length !== 0;
    },
    $index: function(_, key) {
      return this._limited_map_view$_keys.contains$1(0, key) ? this._limited_map_view$_map.$index(0, key) : null;
    },
    containsKey$1: function(key) {
      return this._limited_map_view$_keys.contains$1(0, key);
    }
  };
  Z.MergedMapView.prototype = {
    get$keys: function() {
      return this._mapsByKey.get$keys();
    },
    get$length: function(_) {
      var t1 = this._mapsByKey;
      return t1.get$length(t1);
    },
    get$isEmpty: function(_) {
      var t1 = this._mapsByKey;
      return t1.get$isEmpty(t1);
    },
    get$isNotEmpty: function(_) {
      var t1 = this._mapsByKey;
      return t1.get$isNotEmpty(t1);
    },
    MergedMapView$1: function(maps, $K, $V) {
      var t1, t2, t3, _i, map, t4, t5;
      for (t1 = maps.length, t2 = this._mapsByKey, t3 = [$K, $V], _i = 0; _i < maps.length; maps.length === t1 || (0, H.throwConcurrentModificationError)(maps), ++_i) {
        map = maps[_i];
        if (H.checkSubtype(map, "$isMergedMapView", t3, null))
          for (t4 = map._mapsByKey.get$values(), t4 = t4.get$iterator(t4); t4.moveNext$0();) {
            t5 = t4.get$current(t4);
            B.setAll(t2, t5.get$keys(), t5);
          }
        else
          B.setAll(t2, map.get$keys(), map);
      }
    },
    $index: function(_, key) {
      var child = this._mapsByKey.$index(0, key);
      return child == null ? null : child.$index(0, key);
    },
    $indexSet: function(_, key, value) {
      var child = this._mapsByKey.$index(0, key);
      if (child == null)
        throw H.wrapException(P.UnsupportedError$("New entries may not be added to MergedMapView."));
      child.$indexSet(0, key, value);
    },
    remove$1: function(_, key) {
      throw H.wrapException(P.UnsupportedError$("Entries may not be removed from MergedMapView."));
    },
    containsKey$1: function(key) {
      return this._mapsByKey.containsKey$1(key);
    }
  };
  U.MultiDirWatcher.prototype = {
    watch$1: function(_, directory) {
      var t1, t2, t3, t4, isParentOfExistingDir, _i, existingDir, t5, future, completer;
      for (t1 = this._watchers, t2 = t1.get$keys(), t2 = P.List_List$from(t2, true, H.getRuntimeTypeArgument(t2, "Iterable", 0)), t3 = t2.length, t4 = this._group, isParentOfExistingDir = false, _i = 0; _i < t2.length; t2.length === t3 || (0, H.throwConcurrentModificationError)(t2), ++_i) {
        existingDir = t2[_i];
        if (!isParentOfExistingDir) {
          t5 = $.$get$context();
          t5 = t5._isWithinOrEquals$2(existingDir, directory) === C._PathRelation_equal || t5._isWithinOrEquals$2(existingDir, directory) === C._PathRelation_within;
        } else
          t5 = false;
        if (t5) {
          t1 = new P._Future($.Zone__current, [-1]);
          t1._asyncComplete$1(null);
          return t1;
        }
        if ($.$get$context()._isWithinOrEquals$2(directory, existingDir) === C._PathRelation_within) {
          t4.remove$1(0, t1.remove$1(0, existingDir));
          isParentOfExistingDir = true;
        }
      }
      future = B.watchDir(directory, this._poll);
      t2 = E.WatchEvent;
      t3 = new Y._CompleterStream([t2]);
      completer = new Y.StreamCompleter(t3, [t2]);
      future.then$1$2$onError(completer.get$setSourceStream(), completer.get$setError(), -1);
      t1.$indexSet(0, directory, t3);
      t4.add$1(0, t3);
      return future;
    }
  };
  N.NoSourceMapBuffer.prototype = {
    get$length: function(_) {
      return this._no_source_map_buffer$_buffer._contents.length;
    },
    get$sourceFiles: function() {
      return C.Map_empty0;
    },
    forSpan$1$2: function(span, callback) {
      return callback.call$0();
    },
    forSpan$2: function(span, callback) {
      return this.forSpan$1$2(span, callback, null);
    },
    write$1: function(_, object) {
      this._no_source_map_buffer$_buffer._contents += H.S(object);
      return;
    },
    writeCharCode$1: function(charCode) {
      this._no_source_map_buffer$_buffer._contents += H.Primitives_stringFromCharCode(charCode);
      return;
    },
    toString$0: function(_) {
      var t1 = this._no_source_map_buffer$_buffer._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    buildSourceMap$1$prefix: function(prefix) {
      return H.throwExpression(P.UnsupportedError$("NoSourceMapBuffer.buildSourceMap() is not supported."));
    },
    $isStringBuffer: 1
  };
  F.PrefixedMapView.prototype = {
    get$keys: function() {
      return new F._PrefixedKeys(this);
    },
    get$length: function(_) {
      var t1 = this._prefixed_map_view$_map;
      return t1.get$length(t1);
    },
    get$isEmpty: function(_) {
      var t1 = this._prefixed_map_view$_map;
      return t1.get$isEmpty(t1);
    },
    get$isNotEmpty: function(_) {
      var t1 = this._prefixed_map_view$_map;
      return t1.get$isNotEmpty(t1);
    },
    $index: function(_, key) {
      var t1;
      if (typeof key === "string") {
        t1 = this._prefix;
        t1 = key.length >= t1.length && C.JSString_methods.startsWith$1(key, t1);
      } else
        t1 = false;
      return t1 ? this._prefixed_map_view$_map.$index(0, J.substring$1$s(key, this._prefix.length)) : null;
    },
    containsKey$1: function(key) {
      var t1;
      if (typeof key === "string") {
        t1 = this._prefix;
        t1 = key.length >= t1.length && C.JSString_methods.startsWith$1(key, t1);
      } else
        t1 = false;
      return t1 && this._prefixed_map_view$_map.containsKey$1(J.substring$1$s(key, this._prefix.length));
    },
    $asMapMixin: function($V) {
      return [P.String, $V];
    },
    $asMap: function($V) {
      return [P.String, $V];
    }
  };
  F._PrefixedKeys.prototype = {
    get$length: function(_) {
      var t1 = this._view._prefixed_map_view$_map;
      return t1.get$length(t1);
    },
    get$iterator: function(_) {
      var t1 = J.map$1$1$ax(this._view._prefixed_map_view$_map.get$keys(), new F._PrefixedKeys_iterator_closure(this), P.String);
      return t1.get$iterator(t1);
    },
    contains$1: function(_, key) {
      return this._view.containsKey$1(key);
    },
    $asIterable: function() {
      return [P.String];
    }
  };
  F._PrefixedKeys_iterator_closure.prototype = {
    call$1: function(key) {
      return this.$this._view._prefix + H.S(key);
    }
  };
  U.PublicMemberMapView.prototype = {
    get$keys: function() {
      return J.where$1$ax(this._inner.get$keys(), B.utils__isPublic$closure());
    },
    containsKey$1: function(key) {
      return typeof key === "string" && B.isPublic(key) && this._inner.containsKey$1(key);
    },
    $index: function(_, key) {
      if (typeof key === "string" && B.isPublic(key))
        return this._inner.$index(0, key);
      return;
    },
    $asMapMixin: function($V) {
      return [P.String, $V];
    },
    $asMap: function($V) {
      return [P.String, $V];
    }
  };
  D.SourceMapBuffer.prototype = {
    get$sourceFiles: function() {
      var t1 = Y.SourceFile,
        t2 = P.String;
      return new P.UnmodifiableMapView(Y.mapMap(this._sourceFiles, new D.SourceMapBuffer_sourceFiles_closure(), null, P.Uri, t1, t2, t1), [t2, t1]);
    },
    get$_targetLocation: function() {
      var t1 = this._source_map_buffer$_buffer._contents,
        t2 = this._line;
      return V.SourceLocation$(t1.length, this._column, t2, null);
    },
    get$length: function(_) {
      return this._source_map_buffer$_buffer._contents.length;
    },
    forSpan$1$2: function(span, callback) {
      var t1, _this = this,
        wasInSpan = _this._inSpan;
      _this._inSpan = true;
      _this._addEntry$2(Y.FileLocation$_(span.file, span._start), _this.get$_targetLocation());
      try {
        t1 = callback.call$0();
        return t1;
      } finally {
        _this._inSpan = wasInSpan;
      }
    },
    forSpan$2: function(span, callback) {
      return this.forSpan$1$2(span, callback, null);
    },
    _addEntry$2: function(source, target) {
      var entry, t2,
        t1 = this._entries;
      if (t1.length !== 0) {
        entry = C.JSArray_methods.get$last(t1);
        t2 = entry.source;
        if (t2.file.getLine$1(t2.offset) == source.file.getLine$1(source.offset) && entry.target.line === target.line)
          return;
        if (entry.target.offset == target.offset)
          return;
      }
      this._sourceFiles.putIfAbsent$2(source.file.url, new D.SourceMapBuffer__addEntry_closure(source));
      t1.push(new L.Entry(source, target, null));
    },
    write$1: function(_, object) {
      var t1, i,
        string = J.toString$0$(object);
      this._source_map_buffer$_buffer._contents += H.S(string);
      for (t1 = string.length, i = 0; i < t1; ++i)
        if (C.JSString_methods._codeUnitAt$1(string, i) === 10)
          this._writeLine$0();
        else
          ++this._column;
    },
    writeCharCode$1: function(charCode) {
      this._source_map_buffer$_buffer._contents += H.Primitives_stringFromCharCode(charCode);
      if (charCode === 10)
        this._writeLine$0();
      else
        ++this._column;
    },
    _writeLine$0: function() {
      var _this = this,
        t1 = _this._entries;
      if (C.JSArray_methods.get$last(t1).target.line === _this._line && C.JSArray_methods.get$last(t1).target.column === _this._column)
        t1.pop();
      ++_this._line;
      _this._column = 0;
      if (_this._inSpan)
        t1.push(new L.Entry(C.JSArray_methods.get$last(t1).source, _this.get$_targetLocation(), null));
    },
    toString$0: function(_) {
      var t1 = this._source_map_buffer$_buffer._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    buildSourceMap$1$prefix: function(prefix) {
      var i, t2, prefixColumn, _box_0 = {},
        t1 = prefix.length;
      if (t1 === 0)
        return T.SingleMapping_SingleMapping$fromEntries(this._entries);
      _box_0.prefixColumn = _box_0.prefixLines = 0;
      for (i = 0, t2 = 0; i < t1; ++i)
        if (C.JSString_methods._codeUnitAt$1(prefix, i) === 10) {
          ++_box_0.prefixLines;
          _box_0.prefixColumn = 0;
          t2 = 0;
        } else {
          prefixColumn = t2 + 1;
          _box_0.prefixColumn = prefixColumn;
          t2 = prefixColumn;
        }
      t2 = this._entries;
      return T.SingleMapping_SingleMapping$fromEntries(new H.MappedListIterable(t2, new D.SourceMapBuffer_buildSourceMap_closure(_box_0, t1), [H.getTypeArgumentByIndex(t2, 0), L.Entry]));
    },
    $isStringBuffer: 1
  };
  D.SourceMapBuffer_sourceFiles_closure.prototype = {
    call$2: function(url, _) {
      return J.toString$0$(url);
    },
    $signature: 15
  };
  D.SourceMapBuffer__addEntry_closure.prototype = {
    call$0: function() {
      return this.source.file;
    }
  };
  D.SourceMapBuffer_buildSourceMap_closure.prototype = {
    call$1: function(entry) {
      var t1 = entry.source,
        t2 = entry.target,
        t3 = t2.line,
        t4 = this._box_0,
        t5 = t4.prefixLines;
      t4 = t3 === 0 ? t4.prefixColumn : 0;
      return new L.Entry(t1, V.SourceLocation$(t2.offset + this.prefixLength, t2.column + t4, t3 + t5, null), entry.identifierName);
    }
  };
  B.indent_closure.prototype = {
    call$1: function(line) {
      return C.JSString_methods.$add(C.JSString_methods.$mul(" ", this.indentation), line);
    }
  };
  B.flattenVertically_closure.prototype = {
    call$1: function(inner) {
      return Q.QueueList_QueueList$from(inner, this.T);
    }
  };
  B.flattenVertically_closure0.prototype = {
    call$1: function(queue) {
      this.result.push(queue.removeFirst$0());
      return queue.get$length(queue) === 0;
    }
  };
  B.longestCommonSubsequence_closure.prototype = {
    call$2: function(element1, element2) {
      return J.$eq$(element1, element2) ? element1 : null;
    },
    $signature: function() {
      var t1 = this.T;
      return {func: 1, ret: t1, args: [t1, t1]};
    }
  };
  B.longestCommonSubsequence_closure0.prototype = {
    call$1: function(_) {
      return P.List_List$filled(J.get$length$asx(this.list2) + 1, 0, P.int);
    },
    $signature: 49
  };
  B.longestCommonSubsequence_closure1.prototype = {
    call$1: function(_) {
      var t1 = new Array(J.get$length$asx(this.list2));
      t1.fixed$length = Array;
      return H.setRuntimeTypeInfo(t1, [this.T]);
    },
    $signature: function() {
      return {func: 1, ret: [P.List, this.T], args: [P.int]};
    }
  };
  B.longestCommonSubsequence_backtrack.prototype = {
    call$2: function(i, j) {
      var selection, t1, _this = this;
      if (i === -1 || j === -1)
        return H.setRuntimeTypeInfo([], [_this.T]);
      selection = J.$index$asx(_this.selections[i], j);
      if (selection != null) {
        t1 = _this.call$2(i - 1, j - 1);
        J.add$1$ax(t1, selection);
        return t1;
      }
      t1 = _this.lengths;
      return J.$index$asx(t1[i + 1], j) > J.$index$asx(t1[i], j + 1) ? _this.call$2(i, j - 1) : _this.call$2(i - 1, j);
    }
  };
  B.mapAddAll2_closure.prototype = {
    call$2: function(key, inner) {
      var t1 = this.destination;
      if (t1.containsKey$1(key))
        t1.$index(0, key).addAll$1(0, inner);
      else
        t1.$indexSet(0, key, inner);
    }
  };
  B.mapMapAsync_closure.prototype = {
    call$2: function(mapKey, _) {
      return this.$call$body$mapMapAsync_closure(mapKey, _, this.K2);
    },
    $call$body$mapMapAsync_closure: function(mapKey, _, $async$type) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter($async$type),
        $async$returnValue, $async$self = this;
      var $async$call$2 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$returnValue = H.subtypeOfRuntimeTypeCast(mapKey, $async$self.K2);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$2, $async$completer);
    },
    $signature: function() {
      return {func: 1, ret: [P.Future, this.K2], args: [this.K1, this.V1]};
    }
  };
  B.copyMapOfMap_closure.prototype = {
    call$2: function(_, innerMap) {
      return P.LinkedHashMap_LinkedHashMap$of(innerMap, this.K2, this.V);
    }
  };
  B.copyMapOfList_closure.prototype = {
    call$2: function(_, list) {
      return J.toList$0$ax(list);
    }
  };
  F.Value.prototype = {
    get$isTruthy: function() {
      return true;
    },
    get$separator: function() {
      return C.ListSeparator_undecided;
    },
    get$hasBrackets: function() {
      return false;
    },
    get$asList: function() {
      return H.setRuntimeTypeInfo([this], [F.Value]);
    },
    get$lengthAsList: function() {
      return 1;
    },
    get$isBlank: function() {
      return false;
    },
    get$isSpecialNumber: function() {
      return false;
    },
    get$isVar: function() {
      return false;
    },
    get$realNull: function() {
      return this;
    },
    sassIndexToListIndex$2: function(sassIndex, $name) {
      var _this = this,
        index = sassIndex.assertNumber$1($name).assertInt$1($name);
      if (index === 0)
        throw H.wrapException(_this._value$_exception$2("List index may not be 0.", $name));
      if (Math.abs(index) > _this.get$lengthAsList())
        throw H.wrapException(_this._value$_exception$2("Invalid index " + sassIndex.toString$0(0) + " for a list with " + _this.get$lengthAsList() + " elements.", $name));
      return index < 0 ? _this.get$lengthAsList() + index : index - 1;
    },
    assertColor$1: function($name) {
      return H.throwExpression(this._value$_exception$2(this.toString$0(0) + " is not a color.", $name));
    },
    assertFunction$1: function($name) {
      return H.throwExpression(this._value$_exception$2(this.toString$0(0) + " is not a function reference.", $name));
    },
    assertMap$1: function($name) {
      return H.throwExpression(this._value$_exception$2(this.toString$0(0) + " is not a map.", $name));
    },
    assertNumber$1: function($name) {
      return H.throwExpression(this._value$_exception$2(this.toString$0(0) + " is not a number.", $name));
    },
    assertNumber$0: function() {
      return this.assertNumber$1(null);
    },
    assertString$1: function($name) {
      return H.throwExpression(this._value$_exception$2(this.toString$0(0) + " is not a string.", $name));
    },
    assertSelector$2$allowParent$name: function(allowParent, $name) {
      var error, t1, exception,
        string = this._selectorString$1($name);
      try {
        t1 = D.SelectorList_SelectorList$parse(string, allowParent, true, null);
        return t1;
      } catch (exception) {
        t1 = H.unwrapException(exception);
        if (t1 instanceof E.SassFormatException) {
          error = t1;
          throw H.wrapException(this._value$_exception$2(C.JSString_methods.replaceFirst$2(J.toString$0$(error), "Error: ", ""), $name));
        } else
          throw exception;
      }
    },
    assertSelector$1$name: function($name) {
      return this.assertSelector$2$allowParent$name(false, $name);
    },
    assertSelector$0: function() {
      return this.assertSelector$2$allowParent$name(false, null);
    },
    assertSelector$1$allowParent: function(allowParent) {
      return this.assertSelector$2$allowParent$name(allowParent, null);
    },
    assertCompoundSelector$1$name: function($name) {
      var error, t1, exception,
        allowParent = false,
        string = this._selectorString$1($name);
      try {
        t1 = S.SpanScanner$(string, null);
        t1 = new T.SelectorParser(allowParent, true, t1, C.StderrLogger_false).parseCompoundSelector$0();
        return t1;
      } catch (exception) {
        t1 = H.unwrapException(exception);
        if (t1 instanceof E.SassFormatException) {
          error = t1;
          throw H.wrapException(this._value$_exception$2(C.JSString_methods.replaceFirst$2(J.toString$0$(error), "Error: ", ""), $name));
        } else
          throw exception;
      }
    },
    _selectorString$1: function($name) {
      var string = this._selectorStringOrNull$0();
      if (string != null)
        return string;
      throw H.wrapException(this._value$_exception$2(this.toString$0(0) + " is not a valid selector: it must be a string,\na list of strings, or a list of lists of strings.", $name));
    },
    _selectorString$0: function() {
      return this._selectorString$1(null);
    },
    _selectorStringOrNull$0: function() {
      var t1, t2, result, t3, _i, complex, t4, string, compound, _this = this;
      if (!!_this.$isSassString)
        return _this.text;
      if (!_this.$isSassList)
        return;
      t1 = _this._list$_contents;
      t2 = t1.length;
      if (t2 === 0)
        return;
      result = H.setRuntimeTypeInfo([], [P.String]);
      t3 = _this.separator === C.ListSeparator_comma;
      if (t3)
        for (_i = 0; _i < t2; ++_i) {
          complex = t1[_i];
          t4 = J.getInterceptor$(complex);
          if (!!t4.$isSassString)
            result.push(complex.text);
          else if (!!t4.$isSassList && complex.separator === C.ListSeparator_space) {
            string = complex._selectorString$0();
            result.push(string);
          } else
            return;
        }
      else
        for (_i = 0; _i < t2; ++_i) {
          compound = t1[_i];
          if (compound instanceof D.SassString)
            result.push(compound.text);
          else
            return;
        }
      return C.JSArray_methods.join$1(result, t3 ? ", " : " ");
    },
    changeListContents$2$separator: function(contents, separator) {
      var t1 = separator == null ? this.get$separator() : separator,
        t2 = this.get$hasBrackets();
      return D.SassList$(contents, t1, t2);
    },
    changeListContents$1: function(contents) {
      return this.changeListContents$2$separator(contents, null);
    },
    greaterThan$1: function(other) {
      return H.throwExpression(E.SassScriptException$('Undefined operation "' + this.toString$0(0) + " > " + H.S(other) + '".'));
    },
    greaterThanOrEquals$1: function(other) {
      return H.throwExpression(E.SassScriptException$('Undefined operation "' + this.toString$0(0) + " >= " + H.S(other) + '".'));
    },
    lessThan$1: function(other) {
      return H.throwExpression(E.SassScriptException$('Undefined operation "' + this.toString$0(0) + " < " + H.S(other) + '".'));
    },
    lessThanOrEquals$1: function(other) {
      return H.throwExpression(E.SassScriptException$('Undefined operation "' + this.toString$0(0) + " <= " + H.S(other) + '".'));
    },
    times$1: function(other) {
      return H.throwExpression(E.SassScriptException$('Undefined operation "' + this.toString$0(0) + " * " + H.S(other) + '".'));
    },
    modulo$1: function(other) {
      return H.throwExpression(E.SassScriptException$('Undefined operation "' + this.toString$0(0) + " % " + H.S(other) + '".'));
    },
    plus$1: function(other) {
      var t1;
      if (other instanceof D.SassString)
        return new D.SassString(C.JSString_methods.$add(N.serializeValue(this, false, true), other.text), other.hasQuotes);
      else {
        t1 = N.serializeValue(this, false, true);
        other.toString;
        return new D.SassString(t1 + N.serializeValue(other, false, true), false);
      }
    },
    minus$1: function(other) {
      var t1 = N.serializeValue(this, false, true) + "-";
      other.toString;
      return new D.SassString(t1 + N.serializeValue(other, false, true), false);
    },
    dividedBy$1: function(other) {
      var t1 = N.serializeValue(this, false, true) + "/";
      other.toString;
      return new D.SassString(t1 + N.serializeValue(other, false, true), false);
    },
    unaryPlus$0: function() {
      return new D.SassString("+" + N.serializeValue(this, false, true), false);
    },
    unaryMinus$0: function() {
      return new D.SassString("-" + N.serializeValue(this, false, true), false);
    },
    unaryNot$0: function() {
      return C.SassBoolean_false;
    },
    withoutSlash$0: function() {
      return this;
    },
    toString$0: function(_) {
      return N.serializeValue(this, true, true);
    },
    _value$_exception$2: function(message, $name) {
      return new E.SassScriptException($name == null ? message : "$" + $name + ": " + message);
    }
  };
  D.SassArgumentList.prototype = {};
  Z.SassBoolean.prototype = {
    get$isTruthy: function() {
      return this.value;
    },
    accept$1$1: function(visitor) {
      return visitor._buffer.write$1(0, String(this.value));
    },
    accept$1: function(visitor) {
      return this.accept$1$1(visitor, null);
    },
    unaryNot$0: function() {
      return this.value ? C.SassBoolean_false : C.SassBoolean_true;
    }
  };
  K.SassColor.prototype = {
    get$red: function() {
      if (this._red == null)
        this._hslToRgb$0();
      return this._red;
    },
    get$green: function() {
      if (this._green == null)
        this._hslToRgb$0();
      return this._green;
    },
    get$blue: function() {
      if (this._blue == null)
        this._hslToRgb$0();
      return this._blue;
    },
    get$hue: function() {
      if (this._hue == null)
        this._rgbToHsl$0();
      return this._hue;
    },
    get$saturation: function() {
      if (this._saturation == null)
        this._rgbToHsl$0();
      return this._saturation;
    },
    get$lightness: function() {
      if (this._lightness == null)
        this._rgbToHsl$0();
      return this._lightness;
    },
    get$original: function() {
      var t1 = this.originalSpan;
      return t1 == null ? null : P.String_String$fromCharCodes(C.NativeUint32List_methods.sublist$2(t1.file._decodedChars, t1._start, t1._end), 0, null);
    },
    accept$1$1: function(visitor) {
      return visitor.visitColor$1(this);
    },
    accept$1: function(visitor) {
      return this.accept$1$1(visitor, null);
    },
    assertColor$1: function($name) {
      return this;
    },
    changeRgb$4$alpha$blue$green$red: function(alpha, blue, green, red) {
      var _this = this,
        t1 = red == null ? _this.get$red() : red,
        t2 = green == null ? _this.get$green() : green,
        t3 = blue == null ? _this.get$blue() : blue;
      return K.SassColor$rgb(t1, t2, t3, alpha == null ? _this.alpha : alpha, null);
    },
    changeRgb$1$alpha: function(alpha) {
      return this.changeRgb$4$alpha$blue$green$red(alpha, null, null, null);
    },
    changeRgb$1$blue: function(blue) {
      return this.changeRgb$4$alpha$blue$green$red(null, blue, null, null);
    },
    changeRgb$1$green: function(green) {
      return this.changeRgb$4$alpha$blue$green$red(null, null, green, null);
    },
    changeRgb$1$red: function(red) {
      return this.changeRgb$4$alpha$blue$green$red(null, null, null, red);
    },
    changeRgb$3$blue$green$red: function(blue, green, red) {
      return this.changeRgb$4$alpha$blue$green$red(null, blue, green, red);
    },
    changeHsl$4$alpha$hue$lightness$saturation: function(alpha, hue, lightness, saturation) {
      var _this = this,
        t1 = hue == null ? _this.get$hue() : hue,
        t2 = saturation == null ? _this.get$saturation() : saturation,
        t3 = lightness == null ? _this.get$lightness() : lightness;
      return K.SassColor$hsl(t1, t2, t3, alpha == null ? _this.alpha : alpha);
    },
    changeHsl$3$alpha$lightness$saturation: function(alpha, lightness, saturation) {
      return this.changeHsl$4$alpha$hue$lightness$saturation(alpha, null, lightness, saturation);
    },
    changeHsl$1$saturation: function(saturation) {
      return this.changeHsl$4$alpha$hue$lightness$saturation(null, null, null, saturation);
    },
    changeHsl$1$lightness: function(lightness) {
      return this.changeHsl$4$alpha$hue$lightness$saturation(null, null, lightness, null);
    },
    changeHsl$1$hue: function(hue) {
      return this.changeHsl$4$alpha$hue$lightness$saturation(null, hue, null, null);
    },
    changeAlpha$1: function(alpha) {
      var _this = this;
      return new K.SassColor(_this._red, _this._green, _this._blue, _this._hue, _this._saturation, _this._lightness, T.fuzzyAssertRange(alpha, 0, 1, "alpha"), null);
    },
    plus$1: function(other) {
      var t1 = J.getInterceptor$(other);
      if (!t1.$isSassNumber && !t1.$isSassColor)
        return this.super$Value$plus(other);
      throw H.wrapException(E.SassScriptException$('Undefined operation "' + this.toString$0(0) + " + " + H.S(other) + '".'));
    },
    minus$1: function(other) {
      var t1 = J.getInterceptor$(other);
      if (!t1.$isSassNumber && !t1.$isSassColor)
        return this.super$Value$minus(other);
      throw H.wrapException(E.SassScriptException$('Undefined operation "' + this.toString$0(0) + " - " + H.S(other) + '".'));
    },
    dividedBy$1: function(other) {
      var t1 = J.getInterceptor$(other);
      if (!t1.$isSassNumber && !t1.$isSassColor)
        return this.super$Value$dividedBy(other);
      throw H.wrapException(E.SassScriptException$('Undefined operation "' + this.toString$0(0) + " / " + H.S(other) + '".'));
    },
    modulo$1: function(other) {
      return H.throwExpression(E.SassScriptException$('Undefined operation "' + this.toString$0(0) + " % " + H.S(other) + '".'));
    },
    $eq: function(_, other) {
      var _this = this;
      if (other == null)
        return false;
      return other instanceof K.SassColor && other.get$red() == _this.get$red() && other.get$green() == _this.get$green() && other.get$blue() == _this.get$blue() && other.alpha === _this.alpha;
    },
    get$hashCode: function(_) {
      var _this = this;
      return J.get$hashCode$(_this.get$red()) ^ J.get$hashCode$(_this.get$green()) ^ J.get$hashCode$(_this.get$blue()) ^ C.JSNumber_methods.get$hashCode(_this.alpha);
    },
    _rgbToHsl$0: function() {
      var t2, t3, _this = this,
        scaledRed = _this.get$red() / 255,
        scaledGreen = _this.get$green() / 255,
        scaledBlue = _this.get$blue() / 255,
        max = Math.max(Math.max(scaledRed, scaledGreen), scaledBlue),
        min = Math.min(Math.min(scaledRed, scaledGreen), scaledBlue),
        delta = max - min,
        t1 = max === min;
      if (t1)
        _this._hue = 0;
      else if (max === scaledRed)
        _this._hue = C.JSDouble_methods.$mod(60 * (scaledGreen - scaledBlue) / delta, 360);
      else if (max === scaledGreen)
        _this._hue = C.JSNumber_methods.$mod(120 + 60 * (scaledBlue - scaledRed) / delta, 360);
      else if (max === scaledBlue)
        _this._hue = C.JSNumber_methods.$mod(240 + 60 * (scaledRed - scaledGreen) / delta, 360);
      t2 = max + min;
      t3 = 50 * t2;
      _this._lightness = t3;
      if (t1)
        _this._saturation = 0;
      else {
        t1 = 100 * delta;
        if (t3 < 50)
          _this._saturation = t1 / t2;
        else
          _this._saturation = t1 / (2 - max - min);
      }
    },
    _hslToRgb$0: function() {
      var _this = this,
        scaledHue = _this.get$hue() / 360,
        scaledSaturation = _this.get$saturation() / 100,
        scaledLightness = _this.get$lightness() / 100,
        m2 = scaledLightness <= 0.5 ? scaledLightness * (scaledSaturation + 1) : scaledLightness + scaledSaturation - scaledLightness * scaledSaturation,
        m1 = scaledLightness * 2 - m2;
      _this._red = _this._hueToRgb$3(m1, m2, scaledHue + 0.3333333333333333);
      _this._green = _this._hueToRgb$3(m1, m2, scaledHue);
      _this._blue = _this._hueToRgb$3(m1, m2, scaledHue - 0.3333333333333333);
    },
    _hueToRgb$3: function(m1, m2, hue) {
      var result;
      if (hue < 0)
        ++hue;
      if (hue > 1)
        --hue;
      if (hue < 0.16666666666666666)
        result = m1 + (m2 - m1) * hue * 6;
      else if (hue < 0.5)
        result = m2;
      else
        result = hue < 0.6666666666666666 ? m1 + (m2 - m1) * (0.6666666666666666 - hue) * 6 : m1;
      return T.fuzzyRound(result * 255);
    }
  };
  F.SassFunction.prototype = {
    accept$1$1: function(visitor) {
      var t1;
      if (!visitor._inspect)
        H.throwExpression(E.SassScriptException$(this.toString$0(0) + " isn't a valid CSS value."));
      t1 = visitor._buffer;
      t1.write$1(0, "get-function(");
      visitor._visitQuotedString$1(this.callable.get$name());
      t1.writeCharCode$1(41);
      return;
    },
    accept$1: function(visitor) {
      return this.accept$1$1(visitor, null);
    },
    assertFunction$1: function($name) {
      return this;
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return other instanceof F.SassFunction && J.$eq$(this.callable, other.callable);
    },
    get$hashCode: function(_) {
      return J.get$hashCode$(this.callable);
    }
  };
  D.SassList.prototype = {
    get$isBlank: function() {
      return C.JSArray_methods.every$1(this._list$_contents, new D.SassList_isBlank_closure());
    },
    get$asList: function() {
      return this._list$_contents;
    },
    get$lengthAsList: function() {
      return this._list$_contents.length;
    },
    SassList$3$brackets: function(contents, separator, brackets) {
      if (this.separator === C.ListSeparator_undecided && this._list$_contents.length > 1)
        throw H.wrapException(P.ArgumentError$("A list with more than one element must have an explicit separator."));
    },
    accept$1$1: function(visitor) {
      return visitor.visitList$1(this);
    },
    accept$1: function(visitor) {
      return this.accept$1$1(visitor, null);
    },
    assertMap$1: function($name) {
      return this._list$_contents.length === 0 ? C.SassMap_Map_empty : this.super$Value$assertMap($name);
    },
    $eq: function(_, other) {
      var t1, _this = this;
      if (other == null)
        return false;
      t1 = J.getInterceptor$(other);
      if (!(!!t1.$isSassList && other.separator === _this.separator && other.hasBrackets === _this.hasBrackets && C.C_ListEquality.equals$2(other._list$_contents, _this._list$_contents)))
        t1 = _this._list$_contents.length === 0 && !!t1.$isSassMap && other.get$asList().length === 0;
      else
        t1 = true;
      return t1;
    },
    get$hashCode: function(_) {
      return C.C_ListEquality.hash$1(this._list$_contents);
    },
    get$separator: function() {
      return this.separator;
    },
    get$hasBrackets: function() {
      return this.hasBrackets;
    }
  };
  D.SassList_isBlank_closure.prototype = {
    call$1: function(element) {
      return element.get$isBlank();
    }
  };
  D.ListSeparator.prototype = {
    toString$0: function(_) {
      return this._list$_name;
    }
  };
  A.SassMap.prototype = {
    get$separator: function() {
      var t1 = this.contents;
      return t1.get$isEmpty(t1) ? C.ListSeparator_undecided : C.ListSeparator_comma;
    },
    get$asList: function() {
      var result = H.setRuntimeTypeInfo([], [F.Value]);
      this.contents.forEach$1(0, new A.SassMap_asList_closure(result));
      return result;
    },
    get$lengthAsList: function() {
      var t1 = this.contents;
      return t1.get$length(t1);
    },
    accept$1$1: function(visitor) {
      return visitor.visitMap$1(this);
    },
    accept$1: function(visitor) {
      return this.accept$1$1(visitor, null);
    },
    assertMap$1: function($name) {
      return this;
    },
    $eq: function(_, other) {
      var t1, t2;
      if (other == null)
        return false;
      t1 = J.getInterceptor$(other);
      if (!(!!t1.$isSassMap && C.C_MapEquality.equals$2(other.contents, this.contents))) {
        t2 = this.contents;
        t1 = t2.get$isEmpty(t2) && !!t1.$isSassList && other._list$_contents.length === 0;
      } else
        t1 = true;
      return t1;
    },
    get$hashCode: function(_) {
      var t1 = this.contents;
      return t1.get$isEmpty(t1) ? C.C_ListEquality.hash$1(C.List_empty1) : C.C_MapEquality.hash$1(t1);
    }
  };
  A.SassMap_asList_closure.prototype = {
    call$2: function(key, value) {
      this.result.push(D.SassList$(H.setRuntimeTypeInfo([key, value], [F.Value]), C.ListSeparator_space, false));
    }
  };
  O.SassNull.prototype = {
    get$isTruthy: function() {
      return false;
    },
    get$isBlank: function() {
      return true;
    },
    get$realNull: function() {
      return;
    },
    accept$1$1: function(visitor) {
      if (visitor._inspect)
        visitor._buffer.write$1(0, "null");
      return;
    },
    accept$1: function(visitor) {
      return this.accept$1$1(visitor, null);
    },
    unaryNot$0: function() {
      return C.SassBoolean_true;
    }
  };
  T.SassNumber.prototype = {
    get$unitString: function() {
      var _this = this,
        t1 = _this.numeratorUnits;
      return t1.length !== 0 || _this.denominatorUnits.length !== 0 ? _this._unitString$2(t1, _this.denominatorUnits) : "";
    },
    accept$1$1: function(visitor) {
      return visitor.visitNumber$1(this);
    },
    accept$1: function(visitor) {
      return this.accept$1$1(visitor, null);
    },
    withoutSlash$0: function() {
      var _this = this;
      if (_this.asSlash == null)
        return _this;
      return new T.SassNumber(_this.value, _this.numeratorUnits, _this.denominatorUnits, null);
    },
    withSlash$2: function(numerator, denominator) {
      var t1 = T.SassNumber;
      return new T.SassNumber(this.value, this.numeratorUnits, this.denominatorUnits, new S.Tuple2(numerator, denominator, [t1, t1]));
    },
    assertNumber$1: function($name) {
      return this;
    },
    assertNumber$0: function() {
      return this.assertNumber$1(null);
    },
    assertInt$1: function($name) {
      var t1 = this.value,
        integer = T.fuzzyIsInt(t1) ? J.round$0$n(t1) : null;
      if (integer != null)
        return integer;
      throw H.wrapException(this._number0$_exception$2(this.toString$0(0) + " is not an int.", $name));
    },
    assertInt$0: function() {
      return this.assertInt$1(null);
    },
    valueInRange$3: function(min, max, $name) {
      var _this = this,
        result = T.fuzzyCheckRange(_this.value, min, max);
      if (result != null)
        return result;
      throw H.wrapException(_this._number0$_exception$2("Expected " + _this.toString$0(0) + " to be within " + min + _this.get$unitString() + " and " + max + _this.get$unitString() + ".", $name));
    },
    hasUnit$1: function(unit) {
      var t1 = this.numeratorUnits;
      return t1.length === 1 && this.denominatorUnits.length === 0 && J.$eq$(C.JSArray_methods.get$first(t1), unit);
    },
    assertUnit$2: function(unit, $name) {
      if (this.hasUnit$1(unit))
        return;
      throw H.wrapException(this._number0$_exception$2("Expected " + this.toString$0(0) + ' to have unit "' + unit + '".', $name));
    },
    assertNoUnits$1: function($name) {
      var _this = this;
      if (!(_this.numeratorUnits.length !== 0 || _this.denominatorUnits.length !== 0))
        return;
      throw H.wrapException(_this._number0$_exception$2("Expected " + _this.toString$0(0) + " to have no units.", $name));
    },
    valueInUnits$2: function(newNumerators, newDenominators) {
      var t2, oldNumerators, _i, oldDenominators, t3, _this = this, _box_0 = {},
        t1 = newNumerators.length;
      if (!(t1 === 0 && newDenominators.length === 0)) {
        t2 = _this.numeratorUnits;
        if (!(t2.length === 0 && _this.denominatorUnits.length === 0))
          t2 = C.C_ListEquality.equals$2(t2, newNumerators) && C.C_ListEquality.equals$2(_this.denominatorUnits, newDenominators);
        else
          t2 = true;
      } else
        t2 = true;
      if (t2)
        return _this.value;
      _box_0.value = _this.value;
      t2 = _this.numeratorUnits;
      oldNumerators = H.setRuntimeTypeInfo(t2.slice(0), [H.getTypeArgumentByIndex(t2, 0)]);
      for (_i = 0; _i < t1; ++_i)
        B.removeFirstWhere(oldNumerators, new T.SassNumber_valueInUnits_closure(_box_0, _this, newNumerators[_i]), new T.SassNumber_valueInUnits_closure0(_this, newNumerators, newDenominators));
      t1 = _this.denominatorUnits;
      oldDenominators = H.setRuntimeTypeInfo(t1.slice(0), [H.getTypeArgumentByIndex(t1, 0)]);
      for (t3 = newDenominators.length, _i = 0; _i < t3; ++_i)
        B.removeFirstWhere(oldDenominators, new T.SassNumber_valueInUnits_closure1(_box_0, _this, newDenominators[_i]), new T.SassNumber_valueInUnits_closure2(_this, newNumerators, newDenominators));
      if (oldNumerators.length !== 0 || oldDenominators.length !== 0)
        throw H.wrapException(E.SassScriptException$("Incompatible units " + _this._unitString$2(t2, t1) + " and " + _this._unitString$2(newNumerators, newDenominators) + "."));
      return _box_0.value;
    },
    isComparableTo$1: function(other) {
      var t1, exception;
      if (this.numeratorUnits.length !== 0 || this.denominatorUnits.length !== 0)
        t1 = !(other.numeratorUnits.length !== 0 || other.denominatorUnits.length !== 0);
      else
        t1 = true;
      if (t1)
        return true;
      try {
        this.greaterThan$1(other);
        return true;
      } catch (exception) {
        if (H.unwrapException(exception) instanceof E.SassScriptException)
          return false;
        else
          throw exception;
      }
    },
    greaterThan$1: function(other) {
      if (other instanceof T.SassNumber)
        return this._coerceUnits$2(other, T.number__fuzzyGreaterThan$closure()) ? C.SassBoolean_true : C.SassBoolean_false;
      throw H.wrapException(E.SassScriptException$('Undefined operation "' + this.toString$0(0) + " > " + H.S(other) + '".'));
    },
    greaterThanOrEquals$1: function(other) {
      if (other instanceof T.SassNumber)
        return this._coerceUnits$2(other, T.number__fuzzyGreaterThanOrEquals$closure()) ? C.SassBoolean_true : C.SassBoolean_false;
      throw H.wrapException(E.SassScriptException$('Undefined operation "' + this.toString$0(0) + " >= " + H.S(other) + '".'));
    },
    lessThan$1: function(other) {
      if (other instanceof T.SassNumber)
        return this._coerceUnits$2(other, T.number__fuzzyLessThan$closure()) ? C.SassBoolean_true : C.SassBoolean_false;
      throw H.wrapException(E.SassScriptException$('Undefined operation "' + this.toString$0(0) + " < " + H.S(other) + '".'));
    },
    lessThanOrEquals$1: function(other) {
      if (other instanceof T.SassNumber)
        return this._coerceUnits$2(other, T.number__fuzzyLessThanOrEquals$closure()) ? C.SassBoolean_true : C.SassBoolean_false;
      throw H.wrapException(E.SassScriptException$('Undefined operation "' + this.toString$0(0) + " <= " + H.S(other) + '".'));
    },
    modulo$1: function(other) {
      if (other instanceof T.SassNumber)
        return this._coerceNumber$2(other, new T.SassNumber_modulo_closure());
      throw H.wrapException(E.SassScriptException$('Undefined operation "' + this.toString$0(0) + " % " + H.S(other) + '".'));
    },
    plus$1: function(other) {
      var t1 = J.getInterceptor$(other);
      if (!!t1.$isSassNumber)
        return this._coerceNumber$2(other, new T.SassNumber_plus_closure());
      if (!t1.$isSassColor)
        return this.super$Value$plus(other);
      throw H.wrapException(E.SassScriptException$('Undefined operation "' + this.toString$0(0) + " + " + other.toString$0(0) + '".'));
    },
    minus$1: function(other) {
      var t1 = J.getInterceptor$(other);
      if (!!t1.$isSassNumber)
        return this._coerceNumber$2(other, new T.SassNumber_minus_closure());
      if (!t1.$isSassColor)
        return this.super$Value$minus(other);
      throw H.wrapException(E.SassScriptException$('Undefined operation "' + this.toString$0(0) + " - " + other.toString$0(0) + '".'));
    },
    times$1: function(other) {
      var _this = this;
      if (other instanceof T.SassNumber)
        return _this._multiplyUnits$5(_this.value * other.value, _this.numeratorUnits, _this.denominatorUnits, other.numeratorUnits, other.denominatorUnits);
      throw H.wrapException(E.SassScriptException$('Undefined operation "' + _this.toString$0(0) + " * " + H.S(other) + '".'));
    },
    dividedBy$1: function(other) {
      var _this = this;
      if (other instanceof T.SassNumber)
        return _this._multiplyUnits$5(_this.value / other.value, _this.numeratorUnits, _this.denominatorUnits, other.denominatorUnits, other.numeratorUnits);
      return _this.super$Value$dividedBy(other);
    },
    unaryPlus$0: function() {
      return this;
    },
    unaryMinus$0: function() {
      return T.SassNumber$withUnits(-this.value, this.denominatorUnits, this.numeratorUnits);
    },
    _coerceNumber$2: function(other, operation) {
      var _this = this,
        result = _this._coerceUnits$2(other, operation),
        t1 = _this.numeratorUnits,
        t2 = t1.length === 0;
      t1 = !t2 || _this.denominatorUnits.length !== 0 ? t1 : other.numeratorUnits;
      return T.SassNumber$withUnits(result, !t2 || _this.denominatorUnits.length !== 0 ? _this.denominatorUnits : other.denominatorUnits, t1);
    },
    _coerceUnits$1$2: function(other, operation) {
      var num1, num2, _this = this,
        t1 = _this.numeratorUnits;
      if (t1.length !== 0 || _this.denominatorUnits.length !== 0) {
        num1 = _this.value;
        num2 = other.valueInUnits$2(t1, _this.denominatorUnits);
      } else {
        num1 = _this.valueInUnits$2(other.numeratorUnits, other.denominatorUnits);
        num2 = other.value;
      }
      return operation.call$2(num1, num2);
    },
    _coerceUnits$2: function(other, operation) {
      return this._coerceUnits$1$2(other, operation, null);
    },
    _multiplyUnits$5: function(value, numerators1, denominators1, numerators2, denominators2) {
      var t1, newNumerators, mutableDenominators2, _i, numerator, mutableDenominators1, _this = this, _box_0 = {};
      _box_0.value = value;
      t1 = numerators1.length;
      if (t1 === 0) {
        if (denominators2.length === 0 && !_this._areAnyConvertible$2(denominators1, numerators2))
          return T.SassNumber$withUnits(value, denominators1, numerators2);
        else if (denominators1.length === 0)
          return T.SassNumber$withUnits(value, denominators2, numerators2);
      } else if (numerators2.length === 0)
        if (denominators2.length === 0)
          return T.SassNumber$withUnits(value, denominators2, numerators1);
        else if (denominators1.length === 0 && !_this._areAnyConvertible$2(numerators1, denominators2))
          return T.SassNumber$withUnits(value, denominators2, numerators1);
      newNumerators = H.setRuntimeTypeInfo([], [P.String]);
      mutableDenominators2 = H.setRuntimeTypeInfo(denominators2.slice(0), [H.getTypeArgumentByIndex(denominators2, 0)]);
      for (_i = 0; _i < t1; ++_i) {
        numerator = numerators1[_i];
        B.removeFirstWhere(mutableDenominators2, new T.SassNumber__multiplyUnits_closure(_box_0, _this, numerator), new T.SassNumber__multiplyUnits_closure0(newNumerators, numerator));
      }
      mutableDenominators1 = H.setRuntimeTypeInfo(denominators1.slice(0), [H.getTypeArgumentByIndex(denominators1, 0)]);
      for (t1 = numerators2.length, _i = 0; _i < t1; ++_i) {
        numerator = numerators2[_i];
        B.removeFirstWhere(mutableDenominators1, new T.SassNumber__multiplyUnits_closure1(_box_0, _this, numerator), new T.SassNumber__multiplyUnits_closure2(newNumerators, numerator));
      }
      t1 = _box_0.value;
      C.JSArray_methods.addAll$1(mutableDenominators1, mutableDenominators2);
      return T.SassNumber$withUnits(t1, mutableDenominators1, newNumerators);
    },
    _areAnyConvertible$2: function(units1, units2) {
      return C.JSArray_methods.any$1(units1, new T.SassNumber__areAnyConvertible_closure(this, units2));
    },
    _conversionFactor$2: function(unit1, unit2) {
      var innerMap;
      if (unit1 == unit2)
        return 1;
      innerMap = $.$get$_conversions().$index(0, unit1);
      if (innerMap == null)
        return;
      return innerMap.$index(0, unit2);
    },
    _unitString$2: function(numerators, denominators) {
      var t1;
      if (numerators.length === 0) {
        t1 = denominators.length;
        if (t1 === 0)
          return "no units";
        if (t1 === 1)
          return J.$add$ansx(C.JSArray_methods.get$single(denominators), "^-1");
        return "(" + C.JSArray_methods.join$1(denominators, "*") + ")^-1";
      }
      if (denominators.length === 0)
        return C.JSArray_methods.join$1(numerators, "*");
      return C.JSArray_methods.join$1(numerators, "*") + "/" + C.JSArray_methods.join$1(denominators, "*");
    },
    $eq: function(_, other) {
      var t1, t2, t3, exception, _this = this;
      if (other == null)
        return false;
      if (other instanceof T.SassNumber) {
        t1 = _this.numeratorUnits.length === 0;
        t2 = !t1 || _this.denominatorUnits.length !== 0;
        t3 = other;
        if (t2 !== (t3.numeratorUnits.length !== 0 || t3.denominatorUnits.length !== 0))
          return false;
        if (!(!t1 || _this.denominatorUnits.length !== 0))
          return Math.abs(_this.value - other.value) < $.$get$epsilon();
        try {
          t1 = _this._coerceUnits$2(other, T.number__fuzzyEquals$closure());
          return t1;
        } catch (exception) {
          if (H.unwrapException(exception) instanceof E.SassScriptException)
            return false;
          else
            throw exception;
        }
      } else
        return false;
    },
    get$hashCode: function(_) {
      var _this = this;
      return C.JSInt_methods.get$hashCode(C.JSDouble_methods.round$0(_this.value * _this._canonicalMultiplier$1(_this.numeratorUnits) / _this._canonicalMultiplier$1(_this.denominatorUnits) * $.$get$_inverseEpsilon()));
    },
    _canonicalMultiplier$1: function(units) {
      return C.JSArray_methods.fold$2(units, 1, new T.SassNumber__canonicalMultiplier_closure());
    },
    _number0$_exception$2: function(message, $name) {
      return new E.SassScriptException($name == null ? message : "$" + $name + ": " + message);
    }
  };
  T.SassNumber_valueInUnits_closure.prototype = {
    call$1: function(oldNumerator) {
      var t1,
        factor = this.$this._conversionFactor$2(this.newNumerator, oldNumerator);
      if (factor == null)
        return false;
      t1 = this._box_0;
      t1.value = t1.value * factor;
      return true;
    }
  };
  T.SassNumber_valueInUnits_closure0.prototype = {
    call$0: function() {
      var t1 = this.$this;
      throw H.wrapException(E.SassScriptException$("Incompatible units " + t1._unitString$2(t1.numeratorUnits, t1.denominatorUnits) + " and " + t1._unitString$2(this.newNumerators, this.newDenominators) + "."));
    }
  };
  T.SassNumber_valueInUnits_closure1.prototype = {
    call$1: function(oldDenominator) {
      var t1,
        factor = this.$this._conversionFactor$2(this.newDenominator, oldDenominator);
      if (factor == null)
        return false;
      t1 = this._box_0;
      t1.value = t1.value / factor;
      return true;
    }
  };
  T.SassNumber_valueInUnits_closure2.prototype = {
    call$0: function() {
      var t1 = this.$this;
      throw H.wrapException(E.SassScriptException$("Incompatible units " + t1._unitString$2(t1.numeratorUnits, t1.denominatorUnits) + " and " + t1._unitString$2(this.newNumerators, this.newDenominators) + "."));
    }
  };
  T.SassNumber_modulo_closure.prototype = {
    call$2: function(num1, num2) {
      var t1;
      if (num2 > 0)
        return C.JSNumber_methods.$mod(num1, num2);
      if (num2 === 0)
        return 0 / 0;
      t1 = C.JSNumber_methods.$mod(num1, num2);
      return t1 === 0 ? 0 : t1 + num2;
    }
  };
  T.SassNumber_plus_closure.prototype = {
    call$2: function(num1, num2) {
      return num1 + num2;
    }
  };
  T.SassNumber_minus_closure.prototype = {
    call$2: function(num1, num2) {
      return num1 - num2;
    }
  };
  T.SassNumber__multiplyUnits_closure.prototype = {
    call$1: function(denominator) {
      var factor = this.$this._conversionFactor$2(this.numerator, denominator);
      if (factor == null)
        return false;
      this._box_0.value /= factor;
      return true;
    }
  };
  T.SassNumber__multiplyUnits_closure0.prototype = {
    call$0: function() {
      this.newNumerators.push(this.numerator);
      return;
    }
  };
  T.SassNumber__multiplyUnits_closure1.prototype = {
    call$1: function(denominator) {
      var factor = this.$this._conversionFactor$2(this.numerator, denominator);
      if (factor == null)
        return false;
      this._box_0.value /= factor;
      return true;
    }
  };
  T.SassNumber__multiplyUnits_closure2.prototype = {
    call$0: function() {
      this.newNumerators.push(this.numerator);
      return;
    }
  };
  T.SassNumber__areAnyConvertible_closure.prototype = {
    call$1: function(unit1) {
      var t1 = $.$get$_conversions();
      if (!t1.containsKey$1(unit1))
        return C.JSArray_methods.contains$1(this.units2, unit1);
      return C.JSArray_methods.any$1(this.units2, t1.$index(0, unit1).get$containsKey());
    }
  };
  T.SassNumber__canonicalMultiplier_closure.prototype = {
    call$2: function(multiplier, unit) {
      var t1,
        innerMap = $.$get$_conversions().$index(0, unit);
      if (innerMap == null)
        t1 = multiplier;
      else {
        t1 = innerMap.get$values();
        t1 = multiplier / t1.get$first(t1);
      }
      return t1;
    }
  };
  D.SassString.prototype = {
    get$sassLength: function() {
      var t1 = this._sassLength;
      if (t1 == null) {
        t1 = this.text;
        t1.toString;
        t1 = new P.Runes(t1);
        t1 = this._sassLength = t1.get$length(t1);
      }
      return t1;
    },
    get$isSpecialNumber: function() {
      var t1, t2;
      if (this.hasQuotes)
        return false;
      t1 = this.text;
      if (t1.length < 6)
        return false;
      t2 = J.getInterceptor$s(t1)._codeUnitAt$1(t1, 0) | 32;
      if (t2 === 99) {
        if ((C.JSString_methods._codeUnitAt$1(t1, 1) | 32) !== 97)
          return false;
        if ((C.JSString_methods._codeUnitAt$1(t1, 2) | 32) !== 108)
          return false;
        if ((C.JSString_methods._codeUnitAt$1(t1, 3) | 32) !== 99)
          return false;
        return C.JSString_methods._codeUnitAt$1(t1, 4) === 40;
      } else if (t2 === 118) {
        if ((C.JSString_methods._codeUnitAt$1(t1, 1) | 32) !== 97)
          return false;
        if ((C.JSString_methods._codeUnitAt$1(t1, 2) | 32) !== 114)
          return false;
        return C.JSString_methods._codeUnitAt$1(t1, 3) === 40;
      } else if (t2 === 101) {
        if ((C.JSString_methods._codeUnitAt$1(t1, 1) | 32) !== 110)
          return false;
        if ((C.JSString_methods._codeUnitAt$1(t1, 2) | 32) !== 118)
          return false;
        return C.JSString_methods._codeUnitAt$1(t1, 3) === 40;
      } else if (t2 === 109) {
        t2 = C.JSString_methods._codeUnitAt$1(t1, 1) | 32;
        if (t2 === 97) {
          if ((C.JSString_methods._codeUnitAt$1(t1, 2) | 32) !== 120)
            return false;
          return C.JSString_methods._codeUnitAt$1(t1, 3) === 40;
        } else if (t2 === 105) {
          if ((C.JSString_methods._codeUnitAt$1(t1, 2) | 32) !== 110)
            return false;
          return C.JSString_methods._codeUnitAt$1(t1, 3) === 40;
        } else
          return false;
      } else
        return false;
    },
    get$isVar: function() {
      if (this.hasQuotes)
        return false;
      var t1 = this.text;
      if (t1.length < 8)
        return false;
      return (J.getInterceptor$s(t1)._codeUnitAt$1(t1, 0) | 32) === 118 && (C.JSString_methods._codeUnitAt$1(t1, 1) | 32) === 97 && (C.JSString_methods._codeUnitAt$1(t1, 2) | 32) === 114 && C.JSString_methods._codeUnitAt$1(t1, 3) === 40;
    },
    get$isBlank: function() {
      return !this.hasQuotes && this.text.length === 0;
    },
    accept$1$1: function(visitor) {
      var t1 = visitor._quote && this.hasQuotes,
        t2 = this.text;
      if (t1)
        visitor._visitQuotedString$1(t2);
      else
        visitor._visitUnquotedString$1(t2);
      return;
    },
    accept$1: function(visitor) {
      return this.accept$1$1(visitor, null);
    },
    assertString$1: function($name) {
      return this;
    },
    plus$1: function(other) {
      var t1 = this.text,
        t2 = this.hasQuotes;
      if (other instanceof D.SassString)
        return new D.SassString(J.$add$ansx(t1, other.text), t2);
      else {
        other.toString;
        return new D.SassString(J.$add$ansx(t1, N.serializeValue(other, false, true)), t2);
      }
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return other instanceof D.SassString && this.text == other.text;
    },
    get$hashCode: function(_) {
      return J.get$hashCode$(this.text);
    }
  };
  E._EvaluateVisitor0.prototype = {
    _EvaluateVisitor$5$functions$importCache$logger$nodeImporter$sourceMap0: function(functions, importCache, logger, nodeImporter, sourceMap) {
      var t11, metaFunctions, _i, metaModule, module, $function, _this = this,
        _s20_ = "$name, $module: null",
        t1 = B.ArgumentDeclaration,
        t2 = [t1, {func: 1, ret: F.Value, args: [[P.List, F.Value]]}],
        t3 = [[S.Tuple2, B.ArgumentDeclaration, {func: 1, ret: F.Value, args: [[P.List, F.Value]]}]],
        t4 = H.setRuntimeTypeInfo([new S.Tuple2(B.ArgumentDeclaration_ArgumentDeclaration$parse(_s20_), new E._EvaluateVisitor_closure8(_this), t2)], t3),
        t5 = H.setRuntimeTypeInfo([new S.Tuple2(B.ArgumentDeclaration_ArgumentDeclaration$parse("$name"), new E._EvaluateVisitor_closure9(_this), t2)], t3),
        t6 = H.setRuntimeTypeInfo([new S.Tuple2(B.ArgumentDeclaration_ArgumentDeclaration$parse(_s20_), new E._EvaluateVisitor_closure10(_this), t2)], t3),
        t7 = H.setRuntimeTypeInfo([new S.Tuple2(B.ArgumentDeclaration_ArgumentDeclaration$parse(_s20_), new E._EvaluateVisitor_closure11(_this), t2)], t3),
        t8 = H.setRuntimeTypeInfo([new S.Tuple2(B.ArgumentDeclaration_ArgumentDeclaration$parse(""), new E._EvaluateVisitor_closure12(_this), t2)], t3),
        t9 = H.setRuntimeTypeInfo([new S.Tuple2(B.ArgumentDeclaration_ArgumentDeclaration$parse("$module"), new E._EvaluateVisitor_closure13(_this), t2)], t3),
        t10 = H.setRuntimeTypeInfo([new S.Tuple2(B.ArgumentDeclaration_ArgumentDeclaration$parse("$module"), new E._EvaluateVisitor_closure14(_this), t2)], t3);
      t3 = H.setRuntimeTypeInfo([new S.Tuple2(B.ArgumentDeclaration_ArgumentDeclaration$parse("$name, $css: false, $module: null"), new E._EvaluateVisitor_closure15(_this), t2)], t3);
      t2 = B.ArgumentDeclaration_ArgumentDeclaration$parse("$function, $args...");
      t11 = H.setRuntimeTypeInfo([], [[S.Tuple2, B.ArgumentDeclaration, {func: 1, ret: {futureOr: 1, type: F.Value}, args: [[P.List, F.Value]]}]]);
      t11.push(new S.Tuple2(t2, new E._EvaluateVisitor_closure16(_this), [t1, {func: 1, ret: {futureOr: 1, type: F.Value}, args: [[P.List, F.Value]]}]));
      metaFunctions = [new Q.BuiltInCallable("global-variable-exists", t4), new Q.BuiltInCallable("variable-exists", t5), new Q.BuiltInCallable("function-exists", t6), new Q.BuiltInCallable("mixin-exists", t7), new Q.BuiltInCallable("content-exists", t8), new Q.BuiltInCallable("module-variables", t9), new Q.BuiltInCallable("module-functions", t10), new Q.BuiltInCallable("get-function", t3), new S.AsyncBuiltInCallable("call", t11)];
      t11 = S.AsyncBuiltInCallable;
      t3 = H.setRuntimeTypeInfo([], [t11]);
      for (t1 = $.$get$global(), t1 = new H.ListIterator(t1, t1.get$length(t1)); t1.moveNext$0();)
        t3.push(t1.__internal$_current);
      for (_i = 0; _i < 9; ++_i)
        t3.push(metaFunctions[_i]);
      metaModule = Q.BuiltInModule$("meta", t3, t11);
      t1 = H.setRuntimeTypeInfo([], [[Q.BuiltInModule, S.AsyncBuiltInCallable]]);
      for (t2 = $.$get$coreModules(), t2 = new H.ListIterator(t2, t2.get$length(t2)); t2.moveNext$0();)
        t1.push(t2.__internal$_current);
      t1.push(metaModule);
      t2 = t1.length;
      t3 = _this._async_evaluate$_builtInModules;
      _i = 0;
      for (; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
        module = t1[_i];
        t3.$indexSet(0, module.url, module);
      }
      t1 = H.setRuntimeTypeInfo([], [B.AsyncCallable]);
      if (functions != null)
        for (t2 = functions.length, _i = 0; _i < functions.length; functions.length === t2 || (0, H.throwConcurrentModificationError)(functions), ++_i)
          t1.push(functions[_i]);
      for (t2 = $.$get$globalFunctions(), t2 = new H.ListIterator(t2, t2.get$length(t2)); t2.moveNext$0();)
        t1.push(t2.__internal$_current);
      for (_i = 0; _i < 9; ++_i)
        t1.push(metaFunctions[_i]);
      for (t2 = t1.length, t3 = _this._async_evaluate$_builtInFunctions, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
        $function = t1[_i];
        t3.$indexSet(0, $function.get$name(), $function);
      }
    },
    run$2: function(_, importer, node) {
      return this.run$body$_EvaluateVisitor(_, importer, node);
    },
    run$body$_EvaluateVisitor: function(_, importer, node) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(E.EvaluateResult),
        $async$returnValue, $async$self = this;
      var $async$run$2 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$returnValue = $async$self._async_evaluate$_withWarnCallback$1(new E._EvaluateVisitor_run_closure0($async$self, node, importer));
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$run$2, $async$completer);
    },
    _async_evaluate$_withWarnCallback$1$1: function(callback) {
      return N.withWarnCallback(new E._EvaluateVisitor__withWarnCallback_closure0(this), callback);
    },
    _async_evaluate$_withWarnCallback$1: function(callback) {
      return this._async_evaluate$_withWarnCallback$1$1(callback, null);
    },
    _async_evaluate$_loadModule$4: function(url, stackFrame, nodeForSpan, callback) {
      return this._loadModule$body$_EvaluateVisitor(url, stackFrame, nodeForSpan, callback);
    },
    _loadModule$body$_EvaluateVisitor: function(url, stackFrame, nodeForSpan, callback) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$returnValue, $async$self = this, builtInModule;
      var $async$_async_evaluate$_loadModule$4 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              builtInModule = $async$self._async_evaluate$_builtInModules.$index(0, url);
              if (builtInModule != null) {
                callback.call$1(builtInModule);
                // goto return
                $async$goto = 1;
                break;
              }
              $async$goto = 3;
              return P._asyncAwait($async$self._async_evaluate$_withStackFrame$1$3(stackFrame, nodeForSpan, new E._EvaluateVisitor__loadModule_closure0($async$self, url, nodeForSpan, callback), P.Null), $async$_async_evaluate$_loadModule$4);
            case 3:
              // returning from await.
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$_async_evaluate$_loadModule$4, $async$completer);
    },
    _async_evaluate$_execute$2: function(importer, stylesheet) {
      return B.putIfAbsentAsync(this._async_evaluate$_modules, stylesheet.span.file.url, new E._EvaluateVisitor__execute_closure0(this, importer, stylesheet), P.Uri, [G.Module, B.AsyncCallable]);
    },
    _async_evaluate$_addOutOfOrderImports$0: function() {
      var t1, t2, statements, _this = this;
      if (_this._async_evaluate$_outOfOrderImports == null)
        return _this._async_evaluate$_root.children;
      t1 = B.ModifiableCssNode;
      t2 = new Array(J.get$length$asx(_this._async_evaluate$_root.children._collection$_source) + _this._async_evaluate$_outOfOrderImports.length);
      t2.fixed$length = Array;
      statements = new G.FixedLengthListBuilder(H.setRuntimeTypeInfo(t2, [t1]), [t1]);
      statements.addRange$3(_this._async_evaluate$_root.children, 0, _this._async_evaluate$_endOfImports);
      statements.addAll$1(0, _this._async_evaluate$_outOfOrderImports);
      statements.addRange$2(_this._async_evaluate$_root.children, _this._async_evaluate$_endOfImports);
      return statements.build$0();
    },
    _async_evaluate$_combineCss$2$clone: function(root, clone) {
      var selectors, unsatisfiedExtension, sortedModules, t1, t2, imports, css, t3, statements, index, _this = this;
      if (!C.JSArray_methods.any$1(root.get$upstream(), new E._EvaluateVisitor__combineCss_closure2())) {
        selectors = root.get$extender().get$simpleSelectors();
        unsatisfiedExtension = B.firstOrNull(root.get$extender().extensionsWhereTarget$1(new E._EvaluateVisitor__combineCss_closure3(selectors)));
        if (unsatisfiedExtension != null)
          _this._async_evaluate$_throwForUnsatisfiedExtension$1(unsatisfiedExtension);
        return root.get$css(root);
      }
      sortedModules = _this._async_evaluate$_topologicalModules$1(root);
      if (clone)
        sortedModules = new H.MappedListIterable(sortedModules, new E._EvaluateVisitor__combineCss_closure4(), [H.getTypeArgumentByIndex(sortedModules, 0), [G.Module, B.AsyncCallable]]).toList$0(0);
      _this._async_evaluate$_extendModules$1(sortedModules);
      t1 = B.CssNode;
      t2 = [t1];
      imports = H.setRuntimeTypeInfo([], t2);
      css = H.setRuntimeTypeInfo([], t2);
      for (t2 = J.get$reversed$ax(sortedModules), t2 = new H.ListIterator(t2, t2.get$length(t2)); t2.moveNext$0();) {
        t3 = t2.__internal$_current;
        statements = t3.get$css(t3).get$children();
        index = _this._async_evaluate$_indexAfterImports$1(statements);
        t3 = J.getInterceptor$ax(statements);
        C.JSArray_methods.addAll$1(imports, t3.getRange$2(statements, 0, index));
        C.JSArray_methods.addAll$1(css, t3.getRange$2(statements, index, t3.get$length(statements)));
      }
      return new V.CssStylesheet(new P.UnmodifiableListView(C.JSArray_methods.$add(imports, css), [t1]), root.get$css(root).get$span());
    },
    _async_evaluate$_combineCss$1: function(root) {
      return this._async_evaluate$_combineCss$2$clone(root, false);
    },
    _async_evaluate$_extendModules$1: function(sortedModules) {
      var t1, t2, originalSelectors, extenders, t3, t4, _i,
        downstreamExtenders = P.LinkedHashMap_LinkedHashMap$_empty(P.Uri, [P.List, F.Extender]),
        unsatisfiedExtensions = new P._LinkedIdentityHashSet([S.Extension]);
      for (t1 = J.get$iterator$ax(sortedModules); t1.moveNext$0();) {
        t2 = t1.get$current(t1);
        originalSelectors = t2.get$extender().get$simpleSelectors().toSet$0(0);
        unsatisfiedExtensions.addAll$1(0, t2.get$extender().extensionsWhereTarget$1(new E._EvaluateVisitor__extendModules_closure1(originalSelectors)));
        extenders = downstreamExtenders.$index(0, t2.get$url());
        if (extenders != null)
          t2.get$extender().addExtensions$1(extenders);
        t3 = t2.get$extender();
        if (t3.get$isEmpty(t3))
          continue;
        for (t3 = t2.get$upstream(), t4 = t3.length, _i = 0; _i < t3.length; t3.length === t4 || (0, H.throwConcurrentModificationError)(t3), ++_i)
          J.add$1$ax(downstreamExtenders.putIfAbsent$2(t3[_i].get$url(), new E._EvaluateVisitor__extendModules_closure2()), t2.get$extender());
        unsatisfiedExtensions.removeAll$1(t2.get$extender().extensionsWhereTarget$1(originalSelectors.get$contains(originalSelectors)));
      }
      if (unsatisfiedExtensions._collection$_length !== 0)
        this._async_evaluate$_throwForUnsatisfiedExtension$1(unsatisfiedExtensions.get$first(unsatisfiedExtensions));
    },
    _async_evaluate$_throwForUnsatisfiedExtension$1: function(extension) {
      throw H.wrapException(E.SassException$('The target selector was not found.\nUse "@extend ' + H.S(extension.target) + ' !optional" to avoid this error.', extension.span));
    },
    _async_evaluate$_topologicalModules$1: function(root) {
      var t1 = [G.Module, B.AsyncCallable],
        seen = P.LinkedHashSet_LinkedHashSet(t1),
        sorted = Q.QueueList$(null, t1);
      new E._EvaluateVisitor__topologicalModules_visitModule0(seen, sorted).call$1(root);
      return sorted;
    },
    _async_evaluate$_indexAfterImports$1: function(statements) {
      var t1, lastImport, i, t2;
      for (t1 = J.getInterceptor$asx(statements), lastImport = -1, i = 0; i < t1.get$length(statements); ++i) {
        t2 = J.getInterceptor$(t1.$index(statements, i));
        if (!!t2.$isCssImport)
          lastImport = i;
        else if (!t2.$isCssComment)
          break;
      }
      return lastImport + 1;
    },
    visitStylesheet$1: function(node) {
      return this.visitStylesheet$body$_EvaluateVisitor(node);
    },
    visitStylesheet$body$_EvaluateVisitor: function(node) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(F.Value),
        $async$returnValue, $async$self = this, t1, t2, _i;
      var $async$visitStylesheet$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = node.children, t2 = t1.length, _i = 0;
            case 3:
              // for condition
              if (!(_i < t2)) {
                // goto after for
                $async$goto = 5;
                break;
              }
              $async$goto = 6;
              return P._asyncAwait(t1[_i].accept$1($async$self), $async$visitStylesheet$1);
            case 6:
              // returning from await.
            case 4:
              // for update
              ++_i;
              // goto for condition
              $async$goto = 3;
              break;
            case 5:
              // after for
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$visitStylesheet$1, $async$completer);
    },
    visitAtRootRule$1: function(node) {
      return this.visitAtRootRule$body$_EvaluateVisitor(node);
    },
    visitAtRootRule$body$_EvaluateVisitor: function(node) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(F.Value),
        $async$returnValue, $async$self = this, root, innerCopy, outerCopy, copy, t1, query, $parent, included, $async$temp1, $async$temp2;
      var $async$visitAtRootRule$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = node.query;
              $async$goto = t1 != null ? 3 : 5;
              break;
            case 3:
              // then
              $async$temp1 = t1;
              $async$temp2 = E;
              $async$goto = 6;
              return P._asyncAwait($async$self._async_evaluate$_performInterpolation$2$warnForColor(t1, true), $async$visitAtRootRule$1);
            case 6:
              // returning from await.
              $async$result = $async$self._async_evaluate$_adjustParseError$2($async$temp1, new $async$temp2._EvaluateVisitor_visitAtRootRule_closure2($async$self, $async$result));
              // goto join
              $async$goto = 4;
              break;
            case 5:
              // else
              $async$result = C.AtRootQuery_UsS;
            case 4:
              // join
              query = $async$result;
              $parent = $async$self._async_evaluate$_parent;
              included = H.setRuntimeTypeInfo([], [B.ModifiableCssParentNode]);
              for (; !J.getInterceptor$($parent).$isCssStylesheet;) {
                if (!query.excludes$1($parent))
                  included.push($parent);
                $parent = $parent._parent;
              }
              root = $async$self._async_evaluate$_trimIncluded$1(included);
              $async$goto = root == $async$self._async_evaluate$_parent ? 7 : 8;
              break;
            case 7:
              // then
              $async$goto = 9;
              return P._asyncAwait($async$self._async_evaluate$_environment.scope$1$2$when(new E._EvaluateVisitor_visitAtRootRule_closure3($async$self, node), node.hasDeclarations, P.Null), $async$visitAtRootRule$1);
            case 9:
              // returning from await.
              // goto return
              $async$goto = 1;
              break;
            case 8:
              // join
              innerCopy = included.length === 0 ? null : C.JSArray_methods.get$first(included).copyWithoutChildren$0();
              for (t1 = H.SubListIterable$(included, 1, null, H.getTypeArgumentByIndex(included, 0)), t1 = new H.ListIterator(t1, t1.get$length(t1)), outerCopy = innerCopy; t1.moveNext$0(); outerCopy = copy) {
                copy = t1.__internal$_current.copyWithoutChildren$0();
                copy.addChild$1(outerCopy);
              }
              if (outerCopy != null)
                root.addChild$1(outerCopy);
              $async$goto = 10;
              return P._asyncAwait($async$self._async_evaluate$_scopeForAtRoot$4(node, innerCopy == null ? root : innerCopy, query, included).call$1(new E._EvaluateVisitor_visitAtRootRule_closure4($async$self, node)), $async$visitAtRootRule$1);
            case 10:
              // returning from await.
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$visitAtRootRule$1, $async$completer);
    },
    _async_evaluate$_trimIncluded$1: function(nodes) {
      var $parent, innermostContiguous, i, t2, root,
        t1 = nodes.length;
      if (t1 === 0)
        return this._async_evaluate$_root;
      $parent = this._async_evaluate$_parent;
      for (innermostContiguous = null, i = 0; i < t1; ++i) {
        for (; $parent != nodes[i]; innermostContiguous = null)
          $parent = $parent._parent;
        if (innermostContiguous == null)
          innermostContiguous = i;
        $parent = $parent._parent;
      }
      t2 = this._async_evaluate$_root;
      if ($parent != t2)
        return t2;
      root = nodes[innermostContiguous];
      C.JSArray_methods.removeRange$2(nodes, innermostContiguous, t1);
      return root;
    },
    _async_evaluate$_scopeForAtRoot$4: function(node, newParent, query, included) {
      var _this = this,
        scope = new E._EvaluateVisitor__scopeForAtRoot_closure5(_this, newParent, node),
        t1 = query._all,
        t2 = t1 || query._at_root_query$_rule,
        t3 = query.include;
      if (t2 !== t3)
        scope = new E._EvaluateVisitor__scopeForAtRoot_closure6(_this, scope);
      if (t1 ? !t3 : query.names.contains$1(0, "media") !== t3)
        scope = new E._EvaluateVisitor__scopeForAtRoot_closure7(_this, scope);
      if (_this._async_evaluate$_inKeyframes && query.names.contains$1(0, "keyframes") !== t3)
        scope = new E._EvaluateVisitor__scopeForAtRoot_closure8(_this, scope);
      return _this._async_evaluate$_inUnknownAtRule && !C.JSArray_methods.any$1(included, new E._EvaluateVisitor__scopeForAtRoot_closure9()) ? new E._EvaluateVisitor__scopeForAtRoot_closure10(_this, scope) : scope;
    },
    visitContentBlock$1: function(node) {
      return H.throwExpression(P.UnsupportedError$("Evaluation handles @include and its content block together."));
    },
    visitContentRule$1: function(node) {
      return this.visitContentRule$body$_EvaluateVisitor(node);
    },
    visitContentRule$body$_EvaluateVisitor: function(node) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(F.Value),
        $async$returnValue, $async$self = this, $content;
      var $async$visitContentRule$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $content = $async$self._async_evaluate$_environment._async_environment$_content;
              if ($content == null) {
                // goto return
                $async$goto = 1;
                break;
              }
              $async$goto = 3;
              return P._asyncAwait($async$self._async_evaluate$_runUserDefinedCallable$4(node.$arguments, $content, node, new E._EvaluateVisitor_visitContentRule_closure0($async$self, $content)), $async$visitContentRule$1);
            case 3:
              // returning from await.
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$visitContentRule$1, $async$completer);
    },
    visitDebugRule$1: function(node) {
      return this.visitDebugRule$body$_EvaluateVisitor(node);
    },
    visitDebugRule$body$_EvaluateVisitor: function(node) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(F.Value),
        $async$returnValue, $async$self = this, value, t1;
      var $async$visitDebugRule$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              return P._asyncAwait(node.expression.accept$1($async$self), $async$visitDebugRule$1);
            case 3:
              // returning from await.
              value = $async$result;
              t1 = J.getInterceptor$(value);
              t1 = !!t1.$isSassString ? value.text : t1.toString$0(value);
              $async$self._async_evaluate$_logger.debug$2(t1, node.span);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$visitDebugRule$1, $async$completer);
    },
    visitDeclaration$1: function(node) {
      return this.visitDeclaration$body$_EvaluateVisitor(node);
    },
    visitDeclaration$body$_EvaluateVisitor: function(node) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(F.Value),
        $async$returnValue, $async$self = this, $name, t1, cssValue, t2, oldDeclarationName, $async$temp1;
      var $async$visitDeclaration$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              if (!($async$self._async_evaluate$_styleRule != null && !$async$self._async_evaluate$_atRootExcludingStyleRule) && !$async$self._async_evaluate$_inUnknownAtRule && !$async$self._async_evaluate$_inKeyframes)
                throw H.wrapException($async$self._async_evaluate$_exception$2("Declarations may only be used within style rules.", node.span));
              $async$goto = 3;
              return P._asyncAwait($async$self._async_evaluate$_interpolationToValue$2$warnForColor(node.name, true), $async$visitDeclaration$1);
            case 3:
              // returning from await.
              $name = $async$result;
              t1 = $async$self._async_evaluate$_declarationName;
              if (t1 != null)
                $name = new F.CssValue(t1 + "-" + H.S($name.get$value()), $name.get$span(), [P.String]);
              t1 = node.value;
              $async$goto = t1 == null ? 4 : 6;
              break;
            case 4:
              // then
              $async$result = null;
              // goto join
              $async$goto = 5;
              break;
            case 6:
              // else
              $async$temp1 = F;
              $async$goto = 7;
              return P._asyncAwait(t1.accept$1($async$self), $async$visitDeclaration$1);
            case 7:
              // returning from await.
              $async$result = new $async$temp1.CssValue($async$result, t1.get$span(), [F.Value]);
            case 5:
              // join
              cssValue = $async$result;
              if (cssValue != null) {
                t2 = cssValue.value;
                t2 = !t2.get$isBlank() || t2.get$asList().length === 0;
              } else
                t2 = false;
              if (t2) {
                t2 = $async$self._async_evaluate$_parent;
                t1 = $async$self._async_evaluate$_expressionNode$1(t1);
                t1 = t1 == null ? null : t1.get$span();
                t2.addChild$1(L.ModifiableCssDeclaration$($name, cssValue, node.span, t1));
              } else if (J.startsWith$1$s($name.get$value(), "--"))
                throw H.wrapException($async$self._async_evaluate$_exception$2("Custom property values may not be empty.", t1.get$span()));
              $async$goto = node.children != null ? 8 : 9;
              break;
            case 8:
              // then
              oldDeclarationName = $async$self._async_evaluate$_declarationName;
              $async$self._async_evaluate$_declarationName = $name.get$value();
              $async$goto = 10;
              return P._asyncAwait($async$self._async_evaluate$_environment.scope$1$2$when(new E._EvaluateVisitor_visitDeclaration_closure0($async$self, node), node.hasDeclarations, P.Null), $async$visitDeclaration$1);
            case 10:
              // returning from await.
              $async$self._async_evaluate$_declarationName = oldDeclarationName;
            case 9:
              // join
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$visitDeclaration$1, $async$completer);
    },
    visitEachRule$1: function(node) {
      return this.visitEachRule$body$_EvaluateVisitor(node);
    },
    visitEachRule$body$_EvaluateVisitor: function(node) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(F.Value),
        $async$returnValue, $async$self = this, t1, list, nodeForSpan, setVariables;
      var $async$visitEachRule$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = node.list;
              $async$goto = 3;
              return P._asyncAwait(t1.accept$1($async$self), $async$visitEachRule$1);
            case 3:
              // returning from await.
              list = $async$result;
              nodeForSpan = $async$self._async_evaluate$_expressionNode$1(t1);
              setVariables = node.variables.length === 1 ? new E._EvaluateVisitor_visitEachRule_closure2($async$self, node, nodeForSpan) : new E._EvaluateVisitor_visitEachRule_closure3($async$self, node, nodeForSpan);
              $async$returnValue = $async$self._async_evaluate$_environment.scope$1$2$semiGlobal(new E._EvaluateVisitor_visitEachRule_closure4($async$self, list, setVariables, node), true, F.Value);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$visitEachRule$1, $async$completer);
    },
    _async_evaluate$_setMultipleVariables$3: function(variables, value, nodeForSpan) {
      var i,
        list = value.get$asList(),
        t1 = variables.length,
        minLength = Math.min(t1, list.length);
      for (i = 0; i < minLength; ++i)
        this._async_evaluate$_environment.setLocalVariable$3(variables[i], list[i].withoutSlash$0(), nodeForSpan);
      for (i = minLength; i < t1; ++i)
        this._async_evaluate$_environment.setLocalVariable$3(variables[i], C.C_SassNull, nodeForSpan);
    },
    visitErrorRule$1: function(node) {
      return this.visitErrorRule$body$_EvaluateVisitor(node);
    },
    visitErrorRule$body$_EvaluateVisitor: function(node) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(F.Value),
        $async$self = this, $async$temp1, $async$temp2;
      var $async$visitErrorRule$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$temp1 = H;
              $async$temp2 = J;
              $async$goto = 2;
              return P._asyncAwait(node.expression.accept$1($async$self), $async$visitErrorRule$1);
            case 2:
              // returning from await.
              throw $async$temp1.wrapException($async$self._async_evaluate$_exception$2($async$temp2.toString$0$($async$result), node.span));
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$visitErrorRule$1, $async$completer);
    },
    visitExtendRule$1: function(node) {
      return this.visitExtendRule$body$_EvaluateVisitor(node);
    },
    visitExtendRule$body$_EvaluateVisitor: function(node) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(F.Value),
        $async$returnValue, $async$self = this, targetText, t1, t2, _i, t3;
      var $async$visitExtendRule$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              if (!($async$self._async_evaluate$_styleRule != null && !$async$self._async_evaluate$_atRootExcludingStyleRule) || $async$self._async_evaluate$_declarationName != null)
                throw H.wrapException($async$self._async_evaluate$_exception$2("@extend may only be used within style rules.", node.span));
              $async$goto = 3;
              return P._asyncAwait($async$self._async_evaluate$_interpolationToValue$2$warnForColor(node.selector, true), $async$visitExtendRule$1);
            case 3:
              // returning from await.
              targetText = $async$result;
              for (t1 = $async$self._async_evaluate$_adjustParseError$2(targetText, new E._EvaluateVisitor_visitExtendRule_closure0($async$self, targetText)).components, t2 = t1.length, _i = 0; _i < t2; ++_i) {
                t3 = t1[_i].components;
                if (t3.length !== 1 || !(C.JSArray_methods.get$first(t3) instanceof X.CompoundSelector))
                  throw H.wrapException(E.SassFormatException$("complex selectors may not be extended.", targetText.get$span()));
                t3 = H.interceptedTypeCast(C.JSArray_methods.get$first(t3), "$isCompoundSelector").components;
                if (t3.length !== 1)
                  throw H.wrapException(E.SassFormatException$("compound selectors may no longer be extended.\nConsider `@extend " + C.JSArray_methods.join$1(t3, ", ") + "` instead.\nSee http://bit.ly/ExtendCompound for details.\n", targetText.get$span()));
                $async$self._async_evaluate$_extender.addExtension$4($async$self._async_evaluate$_styleRule.selector, C.JSArray_methods.get$first(t3), node, $async$self._async_evaluate$_mediaQueries);
              }
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$visitExtendRule$1, $async$completer);
    },
    visitAtRule$1: function(node) {
      return this.visitAtRule$body$_EvaluateVisitor(node);
    },
    visitAtRule$body$_EvaluateVisitor: function(node) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(F.Value),
        $async$returnValue, $async$self = this, $name, t1, value, t2, t3, wasInKeyframes, wasInUnknownAtRule;
      var $async$visitAtRule$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              if ($async$self._async_evaluate$_declarationName != null)
                throw H.wrapException($async$self._async_evaluate$_exception$2("At-rules may not be used within nested declarations.", node.span));
              $async$goto = 3;
              return P._asyncAwait($async$self._async_evaluate$_interpolationToValue$1(node.name), $async$visitAtRule$1);
            case 3:
              // returning from await.
              $name = $async$result;
              t1 = node.value;
              $async$goto = t1 == null ? 4 : 6;
              break;
            case 4:
              // then
              $async$result = null;
              // goto join
              $async$goto = 5;
              break;
            case 6:
              // else
              $async$goto = 7;
              return P._asyncAwait($async$self._async_evaluate$_interpolationToValue$3$trim$warnForColor(t1, true, true), $async$visitAtRule$1);
            case 7:
              // returning from await.
            case 5:
              // join
              value = $async$result;
              if (node.children == null) {
                t1 = $async$self._async_evaluate$_parent;
                t2 = B.ModifiableCssNode;
                t3 = H.setRuntimeTypeInfo([], [t2]);
                t1.addChild$1(new U.ModifiableCssAtRule($name, value, true, node.span, new P.UnmodifiableListView(t3, [t2]), t3));
                // goto return
                $async$goto = 1;
                break;
              }
              wasInKeyframes = $async$self._async_evaluate$_inKeyframes;
              wasInUnknownAtRule = $async$self._async_evaluate$_inUnknownAtRule;
              if (B.unvendor($name.get$value()) === "keyframes")
                $async$self._async_evaluate$_inKeyframes = true;
              else
                $async$self._async_evaluate$_inUnknownAtRule = true;
              t1 = B.ModifiableCssNode;
              t2 = H.setRuntimeTypeInfo([], [t1]);
              $async$goto = 8;
              return P._asyncAwait($async$self._async_evaluate$_withParent$2$4$scopeWhen$through(new U.ModifiableCssAtRule($name, value, false, node.span, new P.UnmodifiableListView(t2, [t1]), t2), new E._EvaluateVisitor_visitAtRule_closure1($async$self, node), node.hasDeclarations, new E._EvaluateVisitor_visitAtRule_closure2(), U.ModifiableCssAtRule, P.Null), $async$visitAtRule$1);
            case 8:
              // returning from await.
              $async$self._async_evaluate$_inUnknownAtRule = wasInUnknownAtRule;
              $async$self._async_evaluate$_inKeyframes = wasInKeyframes;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$visitAtRule$1, $async$completer);
    },
    visitForRule$1: function(node) {
      return this.visitForRule$body$_EvaluateVisitor(node);
    },
    visitForRule$body$_EvaluateVisitor: function(node) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(F.Value),
        $async$returnValue, $async$self = this, t1, t2, t3, fromNumber, t4, toNumber, from, to, direction;
      var $async$visitForRule$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = {};
              t2 = node.from;
              t3 = T.SassNumber;
              $async$goto = 3;
              return P._asyncAwait($async$self._addExceptionSpanAsync$1$2(t2, new E._EvaluateVisitor_visitForRule_closure4($async$self, node), t3), $async$visitForRule$1);
            case 3:
              // returning from await.
              fromNumber = $async$result;
              t4 = node.to;
              $async$goto = 4;
              return P._asyncAwait($async$self._addExceptionSpanAsync$1$2(t4, new E._EvaluateVisitor_visitForRule_closure5($async$self, node), t3), $async$visitForRule$1);
            case 4:
              // returning from await.
              toNumber = $async$result;
              from = $async$self._async_evaluate$_addExceptionSpan$2(t2, new E._EvaluateVisitor_visitForRule_closure6(fromNumber, toNumber));
              to = t1.to = $async$self._async_evaluate$_addExceptionSpan$2(t4, new E._EvaluateVisitor_visitForRule_closure7(toNumber));
              direction = from > to ? -1 : 1;
              if (from === (!node.isExclusive ? t1.to = to + direction : to)) {
                // goto return
                $async$goto = 1;
                break;
              }
              $async$returnValue = $async$self._async_evaluate$_environment.scope$1$2$semiGlobal(new E._EvaluateVisitor_visitForRule_closure8(t1, $async$self, node, from, direction), true, F.Value);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$visitForRule$1, $async$completer);
    },
    visitForwardRule$1: function(node) {
      return this.visitForwardRule$body$_EvaluateVisitor(node);
    },
    visitForwardRule$body$_EvaluateVisitor: function(node) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(F.Value),
        $async$returnValue, $async$self = this;
      var $async$visitForwardRule$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              return P._asyncAwait($async$self._async_evaluate$_loadModule$4(node.url, "@forward", node, new E._EvaluateVisitor_visitForwardRule_closure0($async$self, node)), $async$visitForwardRule$1);
            case 3:
              // returning from await.
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$visitForwardRule$1, $async$completer);
    },
    visitFunctionRule$1: function(node) {
      return this.visitFunctionRule$body$_EvaluateVisitor(node);
    },
    visitFunctionRule$body$_EvaluateVisitor: function(node) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(F.Value),
        $async$returnValue, $async$self = this, t1, t2, t3, index, t4;
      var $async$visitFunctionRule$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self._async_evaluate$_environment;
              t2 = t1.closure$0();
              t3 = t1._async_environment$_functions;
              index = t3.length - 1;
              t4 = node.name;
              t1._async_environment$_functionIndices.$indexSet(0, t4, index);
              J.$indexSet$ax(t3[index], t4, new E.UserDefinedCallable(node, t2, [Q.AsyncEnvironment]));
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$visitFunctionRule$1, $async$completer);
    },
    visitIfRule$1: function(node) {
      return this.visitIfRule$body$_EvaluateVisitor(node);
    },
    visitIfRule$body$_EvaluateVisitor: function(node) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(F.Value),
        $async$returnValue, $async$self = this, t1, t2, _i, clauseToCheck, _box_0;
      var $async$visitIfRule$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              _box_0 = {};
              _box_0.clause = node.lastClause;
              t1 = node.clauses, t2 = t1.length, _i = 0;
            case 3:
              // for condition
              if (!(_i < t2)) {
                // goto after for
                $async$goto = 5;
                break;
              }
              clauseToCheck = t1[_i];
              $async$goto = 6;
              return P._asyncAwait(clauseToCheck.expression.accept$1($async$self), $async$visitIfRule$1);
            case 6:
              // returning from await.
              if ($async$result.get$isTruthy()) {
                _box_0.clause = clauseToCheck;
                // goto after for
                $async$goto = 5;
                break;
              }
            case 4:
              // for update
              ++_i;
              // goto for condition
              $async$goto = 3;
              break;
            case 5:
              // after for
              t1 = _box_0.clause;
              if (t1 == null) {
                // goto return
                $async$goto = 1;
                break;
              }
              $async$goto = 7;
              return P._asyncAwait($async$self._async_evaluate$_environment.scope$1$3$semiGlobal$when(new E._EvaluateVisitor_visitIfRule_closure0(_box_0, $async$self), true, t1.hasDeclarations, F.Value), $async$visitIfRule$1);
            case 7:
              // returning from await.
              $async$returnValue = $async$result;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$visitIfRule$1, $async$completer);
    },
    visitImportRule$1: function(node) {
      return this.visitImportRule$body$_EvaluateVisitor(node);
    },
    visitImportRule$body$_EvaluateVisitor: function(node) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(F.Value),
        $async$returnValue, $async$self = this, t1, t2, _i, $import;
      var $async$visitImportRule$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = node.imports, t2 = t1.length, _i = 0;
            case 3:
              // for condition
              if (!(_i < t2)) {
                // goto after for
                $async$goto = 5;
                break;
              }
              $import = t1[_i];
              $async$goto = $import instanceof B.DynamicImport ? 6 : 8;
              break;
            case 6:
              // then
              $async$goto = 9;
              return P._asyncAwait($async$self._async_evaluate$_visitDynamicImport$1($import), $async$visitImportRule$1);
            case 9:
              // returning from await.
              // goto join
              $async$goto = 7;
              break;
            case 8:
              // else
              $async$goto = 10;
              return P._asyncAwait($async$self._visitStaticImport$1(H.interceptedTypeCast($import, "$isStaticImport")), $async$visitImportRule$1);
            case 10:
              // returning from await.
            case 7:
              // join
            case 4:
              // for update
              ++_i;
              // goto for condition
              $async$goto = 3;
              break;
            case 5:
              // after for
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$visitImportRule$1, $async$completer);
    },
    _async_evaluate$_visitDynamicImport$1: function($import) {
      return this._async_evaluate$_withStackFrame$1$3("@import", $import, new E._EvaluateVisitor__visitDynamicImport_closure0(this, $import), -1);
    },
    _async_evaluate$_loadStylesheet$2: function(url, span) {
      return this._loadStylesheet$body$_EvaluateVisitor(url, span);
    },
    _loadStylesheet$body$_EvaluateVisitor: function(url, span) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter([S.Tuple2, B.AsyncImporter, V.Stylesheet]),
        $async$returnValue, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, stylesheet, tuple, error, error0, message, t1, t2, t3, exception, $async$exception;
      var $async$_async_evaluate$_loadStylesheet$2 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$currentError = $async$result;
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$handler = 4;
              $async$self._async_evaluate$_importSpan = span;
              $async$goto = $async$self._async_evaluate$_nodeImporter != null ? 7 : 9;
              break;
            case 7:
              // then
              $async$goto = 10;
              return P._asyncAwait($async$self._async_evaluate$_importLikeNode$1(url), $async$_async_evaluate$_loadStylesheet$2);
            case 10:
              // returning from await.
              stylesheet = $async$result;
              if (stylesheet != null) {
                $async$returnValue = new S.Tuple2(null, stylesheet, [B.AsyncImporter, V.Stylesheet]);
                $async$next = [1];
                // goto finally
                $async$goto = 5;
                break;
              }
              // goto join
              $async$goto = 8;
              break;
            case 9:
              // else
              t1 = P.Uri_parse(url);
              t2 = $async$self._async_evaluate$_importer;
              t3 = $async$self._async_evaluate$_stylesheet.span;
              $async$goto = 11;
              return P._asyncAwait($async$self._async_evaluate$_importCache.import$3(t1, t2, t3.file.url), $async$_async_evaluate$_loadStylesheet$2);
            case 11:
              // returning from await.
              tuple = $async$result;
              if (tuple != null) {
                $async$returnValue = tuple;
                $async$next = [1];
                // goto finally
                $async$goto = 5;
                break;
              }
            case 8:
              // join
              if (C.JSString_methods.startsWith$1(url, "package:") && true)
                throw H.wrapException('"package:" URLs aren\'t supported on this platform.');
              else
                throw H.wrapException("Can't find stylesheet to import.");
              $async$next.push(6);
              // goto finally
              $async$goto = 5;
              break;
            case 4:
              // catch
              $async$handler = 3;
              $async$exception = $async$currentError;
              t1 = H.unwrapException($async$exception);
              if (t1 instanceof E.SassException) {
                error = t1;
                t1 = $async$self._async_evaluate$_exception$2(error._span_exception$_message, error.get$span());
                throw H.wrapException(t1);
              } else {
                error0 = t1;
                message = null;
                try {
                  message = H.stringTypeCast(J.get$message$x(error0));
                } catch (exception) {
                  H.unwrapException($async$exception);
                  message = J.toString$0$(error0);
                }
                t1 = $async$self._async_evaluate$_exception$1(message);
                throw H.wrapException(t1);
              }
              $async$next.push(6);
              // goto finally
              $async$goto = 5;
              break;
            case 3:
              // uncaught
              $async$next = [2];
            case 5:
              // finally
              $async$handler = 2;
              $async$self._async_evaluate$_importSpan = null;
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 6:
              // after finally
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return P._asyncRethrow($async$currentError, $async$completer);
          }
      });
      return P._asyncStartSync($async$_async_evaluate$_loadStylesheet$2, $async$completer);
    },
    _async_evaluate$_importLikeNode$1: function(originalUrl) {
      return this._importLikeNode$body$_EvaluateVisitor(originalUrl);
    },
    _importLikeNode$body$_EvaluateVisitor: function(originalUrl) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(V.Stylesheet),
        $async$returnValue, $async$self = this, contents, url, t1, result;
      var $async$_async_evaluate$_importLikeNode$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self._async_evaluate$_stylesheet.span;
              $async$goto = 3;
              return P._asyncAwait($async$self._async_evaluate$_nodeImporter.loadAsync$2(originalUrl, t1.file.url), $async$_async_evaluate$_importLikeNode$1);
            case 3:
              // returning from await.
              result = $async$result;
              if (result == null) {
                // goto return
                $async$goto = 1;
                break;
              }
              contents = result.item1;
              url = result.item2;
              t1 = J.getInterceptor$s(url).startsWith$1(url, "file:") ? $.$get$context().style.pathFromUri$1(M._parseUri(url)) : url;
              $async$self._async_evaluate$_includedFiles.add$1(0, t1);
              t1 = C.JSString_methods.startsWith$1(url, "file") ? M.Syntax_forPath(url) : C.Syntax_SCSS;
              $async$returnValue = V.Stylesheet_Stylesheet$parse(contents, t1, $async$self._async_evaluate$_logger, url);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$_async_evaluate$_importLikeNode$1, $async$completer);
    },
    _visitStaticImport$1: function($import) {
      return this._visitStaticImport$body$_EvaluateVisitor($import);
    },
    _visitStaticImport$body$_EvaluateVisitor: function($import) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$returnValue, $async$self = this, resolvedSupports, t1, mediaQuery, node, t2, url, supports, $async$temp1, $async$temp2;
      var $async$_visitStaticImport$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              return P._asyncAwait($async$self._async_evaluate$_interpolationToValue$1($import.url), $async$_visitStaticImport$1);
            case 3:
              // returning from await.
              url = $async$result;
              supports = $import.supports;
              $async$goto = supports instanceof L.SupportsDeclaration ? 4 : 6;
              break;
            case 4:
              // then
              $async$temp1 = H;
              $async$goto = 7;
              return P._asyncAwait($async$self._evaluateToCss$1(supports.name), $async$_visitStaticImport$1);
            case 7:
              // returning from await.
              $async$temp1 = $async$temp1.S($async$result) + ": ";
              $async$temp2 = H;
              $async$goto = 8;
              return P._asyncAwait($async$self._evaluateToCss$1(supports.value), $async$_visitStaticImport$1);
            case 8:
              // returning from await.
              resolvedSupports = $async$temp1 + $async$temp2.S($async$result);
              // goto join
              $async$goto = 5;
              break;
            case 6:
              // else
              $async$goto = supports == null ? 9 : 11;
              break;
            case 9:
              // then
              $async$result = null;
              // goto join
              $async$goto = 10;
              break;
            case 11:
              // else
              $async$goto = 12;
              return P._asyncAwait($async$self._async_evaluate$_visitSupportsCondition$1(supports), $async$_visitStaticImport$1);
            case 12:
              // returning from await.
            case 10:
              // join
              resolvedSupports = $async$result;
            case 5:
              // join
              t1 = $import.media;
              $async$goto = t1 == null ? 13 : 15;
              break;
            case 13:
              // then
              $async$result = null;
              // goto join
              $async$goto = 14;
              break;
            case 15:
              // else
              $async$goto = 16;
              return P._asyncAwait($async$self._async_evaluate$_visitMediaQueries$1(t1), $async$_visitStaticImport$1);
            case 16:
              // returning from await.
            case 14:
              // join
              mediaQuery = $async$result;
              t1 = $import.span;
              node = F.ModifiableCssImport$(url, t1, mediaQuery, resolvedSupports == null ? null : new F.CssValue("supports(" + resolvedSupports + ")", supports.get$span(), [P.String]));
              t1 = $async$self._async_evaluate$_parent;
              t2 = $async$self._async_evaluate$_root;
              if (t1 != t2)
                t1.addChild$1(node);
              else if ($async$self._async_evaluate$_endOfImports === J.get$length$asx(t2.children._collection$_source)) {
                $async$self._async_evaluate$_root.addChild$1(node);
                $async$self._async_evaluate$_endOfImports = $async$self._async_evaluate$_endOfImports + 1;
              } else {
                t1 = $async$self._async_evaluate$_outOfOrderImports;
                (t1 == null ? $async$self._async_evaluate$_outOfOrderImports = H.setRuntimeTypeInfo([], [F.ModifiableCssImport]) : t1).push(node);
              }
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$_visitStaticImport$1, $async$completer);
    },
    visitIncludeRule$1: function(node) {
      return this.visitIncludeRule$body$_EvaluateVisitor(node);
    },
    visitIncludeRule$body$_EvaluateVisitor: function(node) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(F.Value),
        $async$returnValue, $async$self = this, t2, t3, contentCallable, t1, mixin;
      var $async$visitIncludeRule$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = [Q.AsyncEnvironment];
              mixin = H.subtypeCast($async$self._async_evaluate$_addExceptionSpan$2(node, new E._EvaluateVisitor_visitIncludeRule_closure1($async$self, node)), "$isUserDefinedCallable", t1, "$asUserDefinedCallable");
              if (mixin == null)
                throw H.wrapException($async$self._async_evaluate$_exception$2("Undefined mixin.", node.span));
              t2 = node.content;
              t3 = t2 == null;
              if (!t3 && !H.interceptedTypeCast(mixin.declaration, "$isMixinRule").hasContent)
                throw H.wrapException($async$self._async_evaluate$_exception$2("Mixin doesn't accept a content block.", node.span));
              contentCallable = t3 ? null : new E.UserDefinedCallable(t2, $async$self._async_evaluate$_environment.closure$0(), t1);
              $async$goto = 3;
              return P._asyncAwait($async$self._async_evaluate$_runUserDefinedCallable$4(node.$arguments, mixin, node, new E._EvaluateVisitor_visitIncludeRule_closure2($async$self, contentCallable, mixin)), $async$visitIncludeRule$1);
            case 3:
              // returning from await.
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$visitIncludeRule$1, $async$completer);
    },
    visitMixinRule$1: function(node) {
      return this.visitMixinRule$body$_EvaluateVisitor(node);
    },
    visitMixinRule$body$_EvaluateVisitor: function(node) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(F.Value),
        $async$returnValue, $async$self = this, t1, t2, t3, index, t4;
      var $async$visitMixinRule$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self._async_evaluate$_environment;
              t2 = t1.closure$0();
              t3 = t1._async_environment$_mixins;
              index = t3.length - 1;
              t4 = node.name;
              t1._async_environment$_mixinIndices.$indexSet(0, t4, index);
              J.$indexSet$ax(t3[index], t4, new E.UserDefinedCallable(node, t2, [Q.AsyncEnvironment]));
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$visitMixinRule$1, $async$completer);
    },
    visitLoudComment$1: function(node) {
      return this.visitLoudComment$body$_EvaluateVisitor(node);
    },
    visitLoudComment$body$_EvaluateVisitor: function(node) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(F.Value),
        $async$returnValue, $async$self = this, t1, t2, $async$temp1, $async$temp2;
      var $async$visitLoudComment$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              if ($async$self._async_evaluate$_inFunction) {
                // goto return
                $async$goto = 1;
                break;
              }
              t1 = $async$self._async_evaluate$_parent;
              t2 = $async$self._async_evaluate$_root;
              if (t1 == t2 && $async$self._async_evaluate$_endOfImports === J.get$length$asx(t2.children._collection$_source))
                $async$self._async_evaluate$_endOfImports = $async$self._async_evaluate$_endOfImports + 1;
              t1 = node.text;
              $async$temp1 = $async$self._async_evaluate$_parent;
              $async$temp2 = R;
              $async$goto = 3;
              return P._asyncAwait($async$self._async_evaluate$_performInterpolation$1(t1), $async$visitLoudComment$1);
            case 3:
              // returning from await.
              $async$temp1.addChild$1(new $async$temp2.ModifiableCssComment($async$result, t1.span));
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$visitLoudComment$1, $async$completer);
    },
    visitMediaRule$1: function(node) {
      return this.visitMediaRule$body$_EvaluateVisitor(node);
    },
    visitMediaRule$body$_EvaluateVisitor: function(node) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(F.Value),
        $async$returnValue, $async$self = this, queries, t1, mergedQueries;
      var $async$visitMediaRule$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              if ($async$self._async_evaluate$_declarationName != null)
                throw H.wrapException($async$self._async_evaluate$_exception$2("Media rules may not be used within nested declarations.", node.span));
              $async$goto = 3;
              return P._asyncAwait($async$self._async_evaluate$_visitMediaQueries$1(node.query), $async$visitMediaRule$1);
            case 3:
              // returning from await.
              queries = $async$result;
              t1 = $async$self._async_evaluate$_mediaQueries;
              mergedQueries = t1 == null ? null : $async$self._async_evaluate$_mergeMediaQueries$2(t1, queries);
              t1 = mergedQueries == null;
              if (!t1 && mergedQueries.length === 0) {
                // goto return
                $async$goto = 1;
                break;
              }
              t1 = t1 ? queries : mergedQueries;
              $async$goto = 4;
              return P._asyncAwait($async$self._async_evaluate$_withParent$2$4$scopeWhen$through(G.ModifiableCssMediaRule$(t1, node.span), new E._EvaluateVisitor_visitMediaRule_closure1($async$self, mergedQueries, queries, node), node.hasDeclarations, new E._EvaluateVisitor_visitMediaRule_closure2(mergedQueries), G.ModifiableCssMediaRule, P.Null), $async$visitMediaRule$1);
            case 4:
              // returning from await.
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$visitMediaRule$1, $async$completer);
    },
    _async_evaluate$_visitMediaQueries$1: function(interpolation) {
      return this._visitMediaQueries$body$_EvaluateVisitor(interpolation);
    },
    _visitMediaQueries$body$_EvaluateVisitor: function(interpolation) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter([P.List, F.CssMediaQuery]),
        $async$returnValue, $async$self = this, $async$temp1, $async$temp2;
      var $async$_async_evaluate$_visitMediaQueries$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$temp1 = interpolation;
              $async$temp2 = E;
              $async$goto = 3;
              return P._asyncAwait($async$self._async_evaluate$_performInterpolation$2$warnForColor(interpolation, true), $async$_async_evaluate$_visitMediaQueries$1);
            case 3:
              // returning from await.
              $async$returnValue = $async$self._async_evaluate$_adjustParseError$2($async$temp1, new $async$temp2._EvaluateVisitor__visitMediaQueries_closure0($async$self, $async$result));
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$_async_evaluate$_visitMediaQueries$1, $async$completer);
    },
    _async_evaluate$_mergeMediaQueries$2: function(queries1, queries2) {
      var t1, t2, t3, t4, result,
        queries = H.setRuntimeTypeInfo([], [F.CssMediaQuery]);
      for (t1 = J.get$iterator$ax(queries1), t2 = J.getInterceptor$ax(queries2); t1.moveNext$0();) {
        t3 = t1.get$current(t1);
        for (t4 = t2.get$iterator(queries2); t4.moveNext$0();) {
          result = t3.merge$1(t4.get$current(t4));
          if (result === C._SingletonCssMediaQueryMergeResult_empty)
            continue;
          if (result === C._SingletonCssMediaQueryMergeResult_unrepresentable)
            return;
          queries.push(H.interceptedTypeCast(result, "$isMediaQuerySuccessfulMergeResult").query);
        }
      }
      return queries;
    },
    visitReturnRule$1: function(node) {
      return node.expression.accept$1(this);
    },
    visitSilentComment$1: function(node) {
      return this.visitSilentComment$body$_EvaluateVisitor(node);
    },
    visitSilentComment$body$_EvaluateVisitor: function(node) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(F.Value),
        $async$returnValue;
      var $async$visitSilentComment$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$visitSilentComment$1, $async$completer);
    },
    visitStyleRule$1: function(node) {
      return this.visitStyleRule$body$_EvaluateVisitor(node);
    },
    visitStyleRule$body$_EvaluateVisitor: function(node) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(F.Value),
        $async$returnValue, $async$self = this, t2, selectorText, t3, t4, parsedSelector, rule, oldAtRootExcludingStyleRule, t1;
      var $async$visitStyleRule$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = {};
              if ($async$self._async_evaluate$_declarationName != null)
                throw H.wrapException($async$self._async_evaluate$_exception$2("Style rules may not be used within nested declarations.", node.span));
              t2 = node.selector;
              $async$goto = 3;
              return P._asyncAwait($async$self._async_evaluate$_interpolationToValue$3$trim$warnForColor(t2, true, true), $async$visitStyleRule$1);
            case 3:
              // returning from await.
              selectorText = $async$result;
              $async$goto = $async$self._async_evaluate$_inKeyframes ? 4 : 5;
              break;
            case 4:
              // then
              t1 = P.List_List$unmodifiable($async$self._async_evaluate$_adjustParseError$2(t2, new E._EvaluateVisitor_visitStyleRule_closure6($async$self, selectorText)), P.String);
              t3 = B.ModifiableCssNode;
              t4 = H.setRuntimeTypeInfo([], [t3]);
              $async$goto = 6;
              return P._asyncAwait($async$self._async_evaluate$_withParent$2$4$scopeWhen$through(new U.ModifiableCssKeyframeBlock(new F.CssValue(t1, t2.span, [[P.List, P.String]]), node.span, new P.UnmodifiableListView(t4, [t3]), t4), new E._EvaluateVisitor_visitStyleRule_closure7($async$self, node), node.hasDeclarations, new E._EvaluateVisitor_visitStyleRule_closure8(), U.ModifiableCssKeyframeBlock, P.Null), $async$visitStyleRule$1);
            case 6:
              // returning from await.
              // goto return
              $async$goto = 1;
              break;
            case 5:
              // join
              t1.parsedSelector = $async$self._async_evaluate$_adjustParseError$2(t2, new E._EvaluateVisitor_visitStyleRule_closure9($async$self, selectorText));
              parsedSelector = $async$self._async_evaluate$_addExceptionSpan$2(t2, new E._EvaluateVisitor_visitStyleRule_closure10(t1, $async$self));
              t1.parsedSelector = parsedSelector;
              rule = $async$self._async_evaluate$_extender.addSelector$4(parsedSelector, t2.span, node.span, $async$self._async_evaluate$_mediaQueries);
              oldAtRootExcludingStyleRule = $async$self._async_evaluate$_atRootExcludingStyleRule;
              $async$self._async_evaluate$_atRootExcludingStyleRule = false;
              $async$goto = 7;
              return P._asyncAwait($async$self._async_evaluate$_withParent$2$4$scopeWhen$through(rule, new E._EvaluateVisitor_visitStyleRule_closure11($async$self, rule, node), node.hasDeclarations, new E._EvaluateVisitor_visitStyleRule_closure12(), X.ModifiableCssStyleRule, P.Null), $async$visitStyleRule$1);
            case 7:
              // returning from await.
              $async$self._async_evaluate$_atRootExcludingStyleRule = oldAtRootExcludingStyleRule;
              if (!($async$self._async_evaluate$_styleRule != null && !oldAtRootExcludingStyleRule)) {
                t1 = $async$self._async_evaluate$_parent.children;
                t1 = !t1.get$isEmpty(t1);
              } else
                t1 = false;
              if (t1) {
                t1 = $async$self._async_evaluate$_parent.children;
                t1.get$last(t1).isGroupEnd = true;
              }
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$visitStyleRule$1, $async$completer);
    },
    visitSupportsRule$1: function(node) {
      return this.visitSupportsRule$body$_EvaluateVisitor(node);
    },
    visitSupportsRule$body$_EvaluateVisitor: function(node) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(F.Value),
        $async$returnValue, $async$self = this, t1, t2, t3, t4;
      var $async$visitSupportsRule$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              if ($async$self._async_evaluate$_declarationName != null)
                throw H.wrapException($async$self._async_evaluate$_exception$2("Supports rules may not be used within nested declarations.", node.span));
              t1 = node.condition;
              $async$goto = 3;
              return P._asyncAwait($async$self._async_evaluate$_visitSupportsCondition$1(t1), $async$visitSupportsRule$1);
            case 3:
              // returning from await.
              t2 = $async$result;
              t1 = t1.get$span();
              t3 = B.ModifiableCssNode;
              t4 = H.setRuntimeTypeInfo([], [t3]);
              $async$goto = 4;
              return P._asyncAwait($async$self._async_evaluate$_withParent$2$4$scopeWhen$through(new B.ModifiableCssSupportsRule(new F.CssValue(t2, t1, [P.String]), node.span, new P.UnmodifiableListView(t4, [t3]), t4), new E._EvaluateVisitor_visitSupportsRule_closure1($async$self, node), node.hasDeclarations, new E._EvaluateVisitor_visitSupportsRule_closure2(), B.ModifiableCssSupportsRule, P.Null), $async$visitSupportsRule$1);
            case 4:
              // returning from await.
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$visitSupportsRule$1, $async$completer);
    },
    _async_evaluate$_visitSupportsCondition$1: function(condition) {
      return this._visitSupportsCondition$body$_EvaluateVisitor(condition);
    },
    _visitSupportsCondition$body$_EvaluateVisitor: function(condition) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.String),
        $async$returnValue, $async$self = this, t2, t1, $async$temp1, $async$temp2;
      var $async$_async_evaluate$_visitSupportsCondition$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = J.getInterceptor$(condition);
              $async$goto = !!t1.$isSupportsOperation ? 3 : 5;
              break;
            case 3:
              // then
              t1 = condition.left;
              t2 = condition.operator;
              $async$temp1 = H;
              $async$goto = 6;
              return P._asyncAwait($async$self._async_evaluate$_parenthesize$2(t1, t2), $async$_async_evaluate$_visitSupportsCondition$1);
            case 6:
              // returning from await.
              $async$temp1 = $async$temp1.S($async$result) + " " + t2 + " ";
              $async$temp2 = H;
              $async$goto = 7;
              return P._asyncAwait($async$self._async_evaluate$_parenthesize$2(condition.right, t2), $async$_async_evaluate$_visitSupportsCondition$1);
            case 7:
              // returning from await.
              $async$returnValue = $async$temp1 + $async$temp2.S($async$result);
              // goto return
              $async$goto = 1;
              break;
              // goto join
              $async$goto = 4;
              break;
            case 5:
              // else
              $async$goto = !!t1.$isSupportsNegation ? 8 : 10;
              break;
            case 8:
              // then
              $async$temp1 = H;
              $async$goto = 11;
              return P._asyncAwait($async$self._async_evaluate$_parenthesize$1(condition.condition), $async$_async_evaluate$_visitSupportsCondition$1);
            case 11:
              // returning from await.
              $async$returnValue = "not " + $async$temp1.S($async$result);
              // goto return
              $async$goto = 1;
              break;
              // goto join
              $async$goto = 9;
              break;
            case 10:
              // else
              $async$goto = !!t1.$isSupportsInterpolation ? 12 : 14;
              break;
            case 12:
              // then
              $async$goto = 15;
              return P._asyncAwait($async$self._evaluateToCss$2$quote(condition.expression, false), $async$_async_evaluate$_visitSupportsCondition$1);
            case 15:
              // returning from await.
              $async$returnValue = $async$result;
              // goto return
              $async$goto = 1;
              break;
              // goto join
              $async$goto = 13;
              break;
            case 14:
              // else
              $async$goto = !!t1.$isSupportsDeclaration ? 16 : 18;
              break;
            case 16:
              // then
              $async$temp1 = H;
              $async$goto = 19;
              return P._asyncAwait($async$self._evaluateToCss$1(condition.name), $async$_async_evaluate$_visitSupportsCondition$1);
            case 19:
              // returning from await.
              $async$temp1 = "(" + $async$temp1.S($async$result) + ": ";
              $async$temp2 = H;
              $async$goto = 20;
              return P._asyncAwait($async$self._evaluateToCss$1(condition.value), $async$_async_evaluate$_visitSupportsCondition$1);
            case 20:
              // returning from await.
              $async$returnValue = $async$temp1 + $async$temp2.S($async$result) + ")";
              // goto return
              $async$goto = 1;
              break;
              // goto join
              $async$goto = 17;
              break;
            case 18:
              // else
              // goto return
              $async$goto = 1;
              break;
            case 17:
              // join
            case 13:
              // join
            case 9:
              // join
            case 4:
              // join
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$_async_evaluate$_visitSupportsCondition$1, $async$completer);
    },
    _async_evaluate$_parenthesize$2: function(condition, operator) {
      return this._parenthesize$body$_EvaluateVisitor(condition, operator);
    },
    _async_evaluate$_parenthesize$1: function(condition) {
      return this._async_evaluate$_parenthesize$2(condition, null);
    },
    _parenthesize$body$_EvaluateVisitor: function(condition, operator) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.String),
        $async$returnValue, $async$self = this, t1, $async$temp1;
      var $async$_async_evaluate$_parenthesize$2 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              if (!condition.$isSupportsNegation)
                if (!!condition.$isSupportsOperation)
                  t1 = operator == null || operator !== condition.operator;
                else
                  t1 = false;
              else
                t1 = true;
              $async$goto = t1 ? 3 : 5;
              break;
            case 3:
              // then
              $async$temp1 = H;
              $async$goto = 6;
              return P._asyncAwait($async$self._async_evaluate$_visitSupportsCondition$1(condition), $async$_async_evaluate$_parenthesize$2);
            case 6:
              // returning from await.
              $async$returnValue = "(" + $async$temp1.S($async$result) + ")";
              // goto return
              $async$goto = 1;
              break;
              // goto join
              $async$goto = 4;
              break;
            case 5:
              // else
              $async$goto = 7;
              return P._asyncAwait($async$self._async_evaluate$_visitSupportsCondition$1(condition), $async$_async_evaluate$_parenthesize$2);
            case 7:
              // returning from await.
              $async$returnValue = $async$result;
              // goto return
              $async$goto = 1;
              break;
            case 4:
              // join
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$_async_evaluate$_parenthesize$2, $async$completer);
    },
    visitVariableDeclaration$1: function(node) {
      return this.visitVariableDeclaration$body$_EvaluateVisitor(node);
    },
    visitVariableDeclaration$body$_EvaluateVisitor: function(node) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(F.Value),
        $async$returnValue, $async$self = this, value, t1, t2, $async$temp1, $async$temp2, $async$temp3;
      var $async$visitVariableDeclaration$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              if (node.isGuarded) {
                value = $async$self._async_evaluate$_addExceptionSpan$2(node, new E._EvaluateVisitor_visitVariableDeclaration_closure1($async$self, node));
                if (value != null && !value.$eq(0, C.C_SassNull)) {
                  // goto return
                  $async$goto = 1;
                  break;
                }
              }
              if (node.isGlobal && !$async$self._async_evaluate$_environment.globalVariableExists$1(node.name)) {
                t1 = $async$self._async_evaluate$_environment._async_environment$_variables.length === 1 ? "As of Dart Sass 2.0.0, !global assignments won't be able to\ndeclare new variables. Since this assignment is at the root of the stylesheet,\nthe !global flag is unnecessary and can safely be removed." : "As of Dart Sass 2.0.0, !global assignments won't be able to\ndeclare new variables. Consider adding `" + B.declarationName(node.span) + ": null` at the root of the\nstylesheet.";
                t2 = node.span;
                $async$self._async_evaluate$_logger.warn$4$deprecation$span$trace(t1, true, t2, $async$self._async_evaluate$_stackTrace$1(t2));
              }
              $async$temp1 = node;
              $async$temp2 = E;
              $async$temp3 = node;
              $async$goto = 3;
              return P._asyncAwait(node.expression.accept$1($async$self), $async$visitVariableDeclaration$1);
            case 3:
              // returning from await.
              $async$self._async_evaluate$_addExceptionSpan$2($async$temp1, new $async$temp2._EvaluateVisitor_visitVariableDeclaration_closure2($async$self, $async$temp3, $async$result.withoutSlash$0()));
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$visitVariableDeclaration$1, $async$completer);
    },
    visitUseRule$1: function(node) {
      return this.visitUseRule$body$_EvaluateVisitor(node);
    },
    visitUseRule$body$_EvaluateVisitor: function(node) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(F.Value),
        $async$returnValue, $async$self = this;
      var $async$visitUseRule$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              return P._asyncAwait($async$self._async_evaluate$_loadModule$4(node.url, "@use", node, new E._EvaluateVisitor_visitUseRule_closure0($async$self, node)), $async$visitUseRule$1);
            case 3:
              // returning from await.
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$visitUseRule$1, $async$completer);
    },
    visitWarnRule$1: function(node) {
      return this.visitWarnRule$body$_EvaluateVisitor(node);
    },
    visitWarnRule$body$_EvaluateVisitor: function(node) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(F.Value),
        $async$returnValue, $async$self = this, value, t1;
      var $async$visitWarnRule$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              return P._asyncAwait($async$self._addExceptionSpanAsync$1$2(node, new E._EvaluateVisitor_visitWarnRule_closure0($async$self, node), F.Value), $async$visitWarnRule$1);
            case 3:
              // returning from await.
              value = $async$result;
              t1 = value instanceof D.SassString ? value.text : $async$self._async_evaluate$_serialize$2(value, node.expression);
              $async$self._async_evaluate$_logger.warn$2$trace(t1, $async$self._async_evaluate$_stackTrace$1(node.span));
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$visitWarnRule$1, $async$completer);
    },
    visitWhileRule$1: function(node) {
      return this._async_evaluate$_environment.scope$1$3$semiGlobal$when(new E._EvaluateVisitor_visitWhileRule_closure0(this, node), true, node.hasDeclarations, F.Value);
    },
    visitBinaryOperationExpression$1: function(node) {
      return this._addExceptionSpanAsync$1$2(node, new E._EvaluateVisitor_visitBinaryOperationExpression_closure0(this, node), F.Value);
    },
    visitValueExpression$1: function(node) {
      return this.visitValueExpression$body$_EvaluateVisitor(node);
    },
    visitValueExpression$body$_EvaluateVisitor: function(node) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(F.Value),
        $async$returnValue;
      var $async$visitValueExpression$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$returnValue = node.value;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$visitValueExpression$1, $async$completer);
    },
    visitVariableExpression$1: function(node) {
      return this.visitVariableExpression$body$_EvaluateVisitor(node);
    },
    visitVariableExpression$body$_EvaluateVisitor: function(node) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(F.Value),
        $async$returnValue, $async$self = this, result;
      var $async$visitVariableExpression$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              result = $async$self._async_evaluate$_addExceptionSpan$2(node, new E._EvaluateVisitor_visitVariableExpression_closure0($async$self, node));
              if (result != null) {
                $async$returnValue = result;
                // goto return
                $async$goto = 1;
                break;
              }
              throw H.wrapException($async$self._async_evaluate$_exception$2("Undefined variable.", node.span));
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$visitVariableExpression$1, $async$completer);
    },
    visitUnaryOperationExpression$1: function(node) {
      return this.visitUnaryOperationExpression$body$_EvaluateVisitor(node);
    },
    visitUnaryOperationExpression$body$_EvaluateVisitor: function(node) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(F.Value),
        $async$returnValue, $async$self = this, operand, t1;
      var $async$visitUnaryOperationExpression$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          $async$outer:
            switch ($async$goto) {
              case 0:
                // Function start
                $async$goto = 3;
                return P._asyncAwait(node.operand.accept$1($async$self), $async$visitUnaryOperationExpression$1);
              case 3:
                // returning from await.
                operand = $async$result;
                t1 = node.operator;
                switch (t1) {
                  case C.UnaryOperator_j2w:
                    $async$returnValue = operand.unaryPlus$0();
                    // goto return
                    $async$goto = 1;
                    break $async$outer;
                  case C.UnaryOperator_U4G:
                    $async$returnValue = operand.unaryMinus$0();
                    // goto return
                    $async$goto = 1;
                    break $async$outer;
                  case C.UnaryOperator_zDx:
                    operand.toString;
                    $async$returnValue = new D.SassString("/" + N.serializeValue(operand, false, true), false);
                    // goto return
                    $async$goto = 1;
                    break $async$outer;
                  case C.UnaryOperator_not_not:
                    $async$returnValue = operand.unaryNot$0();
                    // goto return
                    $async$goto = 1;
                    break $async$outer;
                  default:
                    throw H.wrapException(P.StateError$("Unknown unary operator " + H.S(t1) + "."));
                }
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
      });
      return P._asyncStartSync($async$visitUnaryOperationExpression$1, $async$completer);
    },
    visitBooleanExpression$1: function(node) {
      return this.visitBooleanExpression$body$_EvaluateVisitor(node);
    },
    visitBooleanExpression$body$_EvaluateVisitor: function(node) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(Z.SassBoolean),
        $async$returnValue;
      var $async$visitBooleanExpression$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$returnValue = node.value ? C.SassBoolean_true : C.SassBoolean_false;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$visitBooleanExpression$1, $async$completer);
    },
    visitIfExpression$1: function(node) {
      return this.visitIfExpression$body$_EvaluateVisitor(node);
    },
    visitIfExpression$body$_EvaluateVisitor: function(node) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(F.Value),
        $async$returnValue, $async$self = this, condition, ifTrue, ifFalse, pair, positional, named, t1;
      var $async$visitIfExpression$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              return P._asyncAwait($async$self._async_evaluate$_evaluateMacroArguments$1(node), $async$visitIfExpression$1);
            case 3:
              // returning from await.
              pair = $async$result;
              positional = pair.item1;
              named = pair.item2;
              t1 = J.getInterceptor$asx(positional);
              $async$self._async_evaluate$_verifyArguments$4(t1.get$length(positional), named, $.$get$IfExpression_declaration(), node);
              condition = t1.get$length(positional) > 0 ? t1.$index(positional, 0) : named.$index(0, "condition");
              ifTrue = t1.get$length(positional) > 1 ? t1.$index(positional, 1) : named.$index(0, "if-true");
              ifFalse = t1.get$length(positional) > 2 ? t1.$index(positional, 2) : named.$index(0, "if-false");
              $async$goto = 5;
              return P._asyncAwait(condition.accept$1($async$self), $async$visitIfExpression$1);
            case 5:
              // returning from await.
              $async$goto = 4;
              return P._asyncAwait(($async$result.get$isTruthy() ? ifTrue : ifFalse).accept$1($async$self), $async$visitIfExpression$1);
            case 4:
              // returning from await.
              $async$returnValue = $async$result;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$visitIfExpression$1, $async$completer);
    },
    visitNullExpression$1: function(node) {
      return this.visitNullExpression$body$_EvaluateVisitor(node);
    },
    visitNullExpression$body$_EvaluateVisitor: function(node) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(O.SassNull),
        $async$returnValue;
      var $async$visitNullExpression$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$returnValue = C.C_SassNull;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$visitNullExpression$1, $async$completer);
    },
    visitNumberExpression$1: function(node) {
      return this.visitNumberExpression$body$_EvaluateVisitor(node);
    },
    visitNumberExpression$body$_EvaluateVisitor: function(node) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(T.SassNumber),
        $async$returnValue, t1;
      var $async$visitNumberExpression$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = node.unit;
              t1 = t1 == null ? null : H.setRuntimeTypeInfo([t1], [P.String]);
              t1 = t1 == null ? C.List_empty0 : P.List_List$unmodifiable(t1, P.String);
              $async$returnValue = new T.SassNumber(node.value, t1, C.List_empty0, null);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$visitNumberExpression$1, $async$completer);
    },
    visitParenthesizedExpression$1: function(node) {
      return node.expression.accept$1(this);
    },
    visitColorExpression$1: function(node) {
      return this.visitColorExpression$body$_EvaluateVisitor(node);
    },
    visitColorExpression$body$_EvaluateVisitor: function(node) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(K.SassColor),
        $async$returnValue;
      var $async$visitColorExpression$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$returnValue = node.value;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$visitColorExpression$1, $async$completer);
    },
    visitListExpression$1: function(node) {
      return this.visitListExpression$body$_EvaluateVisitor(node);
    },
    visitListExpression$body$_EvaluateVisitor: function(node) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(D.SassList),
        $async$returnValue, $async$self = this, $async$temp1;
      var $async$visitListExpression$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$temp1 = D;
              $async$goto = 3;
              return P._asyncAwait(B.mapAsync(node.contents, new E._EvaluateVisitor_visitListExpression_closure0($async$self), T.Expression, F.Value), $async$visitListExpression$1);
            case 3:
              // returning from await.
              $async$returnValue = $async$temp1.SassList$($async$result, node.separator, node.hasBrackets);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$visitListExpression$1, $async$completer);
    },
    visitMapExpression$1: function(node) {
      return this.visitMapExpression$body$_EvaluateVisitor(node);
    },
    visitMapExpression$body$_EvaluateVisitor: function(node) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(A.SassMap),
        $async$returnValue, $async$self = this, t2, t3, _i, pair, t4, keyValue, valueValue, t1, map;
      var $async$visitMapExpression$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = F.Value;
              map = P.LinkedHashMap_LinkedHashMap$_empty(t1, t1);
              t2 = node.pairs, t3 = t2.length, _i = 0;
            case 3:
              // for condition
              if (!(_i < t3)) {
                // goto after for
                $async$goto = 5;
                break;
              }
              pair = t2[_i];
              t4 = pair.item1;
              $async$goto = 6;
              return P._asyncAwait(t4.accept$1($async$self), $async$visitMapExpression$1);
            case 6:
              // returning from await.
              keyValue = $async$result;
              $async$goto = 7;
              return P._asyncAwait(pair.item2.accept$1($async$self), $async$visitMapExpression$1);
            case 7:
              // returning from await.
              valueValue = $async$result;
              if (map.containsKey$1(keyValue))
                throw H.wrapException($async$self._async_evaluate$_exception$2("Duplicate key.", t4.get$span()));
              map.$indexSet(0, keyValue, valueValue);
            case 4:
              // for update
              ++_i;
              // goto for condition
              $async$goto = 3;
              break;
            case 5:
              // after for
              $async$returnValue = new A.SassMap(H.ConstantMap_ConstantMap$from(map, t1, t1));
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$visitMapExpression$1, $async$completer);
    },
    visitFunctionExpression$1: function(node) {
      return this.visitFunctionExpression$body$_EvaluateVisitor(node);
    },
    visitFunctionExpression$body$_EvaluateVisitor: function(node) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(F.Value),
        $async$returnValue, $async$self = this, oldInFunction, result, t1, plainName, $function, $async$temp1;
      var $async$visitFunctionExpression$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = node.name;
              plainName = t1.get$asPlain();
              $function = plainName != null ? $async$self._async_evaluate$_addExceptionSpan$2(node, new E._EvaluateVisitor_visitFunctionExpression_closure0($async$self, node, plainName)) : null;
              $async$goto = $function == null ? 3 : 4;
              break;
            case 3:
              // then
              if (node.namespace != null)
                throw H.wrapException($async$self._async_evaluate$_exception$2("Undefined function.", node.span));
              $async$temp1 = L;
              $async$goto = 5;
              return P._asyncAwait($async$self._async_evaluate$_performInterpolation$1(t1), $async$visitFunctionExpression$1);
            case 5:
              // returning from await.
              $function = new $async$temp1.PlainCssCallable($async$result);
            case 4:
              // join
              oldInFunction = $async$self._async_evaluate$_inFunction;
              $async$self._async_evaluate$_inFunction = true;
              $async$goto = 6;
              return P._asyncAwait($async$self._async_evaluate$_runFunctionCallable$3(node.$arguments, $function, node), $async$visitFunctionExpression$1);
            case 6:
              // returning from await.
              result = $async$result;
              $async$self._async_evaluate$_inFunction = oldInFunction;
              $async$returnValue = result;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$visitFunctionExpression$1, $async$completer);
    },
    _async_evaluate$_getFunction$2$namespace: function($name, namespace) {
      var local = this._async_evaluate$_environment.getFunction$2$namespace($name, namespace);
      if (local != null || namespace != null)
        return local;
      return this._async_evaluate$_builtInFunctions.$index(0, $name);
    },
    _async_evaluate$_runUserDefinedCallable$4: function($arguments, callable, nodeWithSpan, run) {
      return this._runUserDefinedCallable$body$_EvaluateVisitor($arguments, callable, nodeWithSpan, run);
    },
    _runUserDefinedCallable$body$_EvaluateVisitor: function($arguments, callable, nodeWithSpan, run) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(F.Value),
        $async$returnValue, $async$self = this, evaluated, t1, $name;
      var $async$_async_evaluate$_runUserDefinedCallable$4 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              return P._asyncAwait($async$self._async_evaluate$_evaluateArguments$1($arguments), $async$_async_evaluate$_runUserDefinedCallable$4);
            case 3:
              // returning from await.
              evaluated = $async$result;
              t1 = callable.declaration.name;
              $name = t1 == null ? "@content" : t1 + "()";
              $async$goto = 4;
              return P._asyncAwait($async$self._async_evaluate$_withStackFrame$1$3($name, nodeWithSpan, new E._EvaluateVisitor__runUserDefinedCallable_closure0($async$self, callable, evaluated, nodeWithSpan, run), F.Value), $async$_async_evaluate$_runUserDefinedCallable$4);
            case 4:
              // returning from await.
              $async$returnValue = $async$result;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$_async_evaluate$_runUserDefinedCallable$4, $async$completer);
    },
    _async_evaluate$_runFunctionCallable$3: function($arguments, callable, nodeWithSpan) {
      return this._runFunctionCallable$body$_EvaluateVisitor($arguments, callable, nodeWithSpan);
    },
    _runFunctionCallable$body$_EvaluateVisitor: function($arguments, callable, nodeWithSpan) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(F.Value),
        $async$returnValue, $async$self = this, t1, t2, t3, first, _i, argument, rest, $async$temp1;
      var $async$_async_evaluate$_runFunctionCallable$3 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = !!callable.$isAsyncBuiltInCallable ? 3 : 5;
              break;
            case 3:
              // then
              $async$goto = 6;
              return P._asyncAwait($async$self._async_evaluate$_runBuiltInCallable$3($arguments, callable, nodeWithSpan), $async$_async_evaluate$_runFunctionCallable$3);
            case 6:
              // returning from await.
              $async$returnValue = $async$result.withoutSlash$0();
              // goto return
              $async$goto = 1;
              break;
              // goto join
              $async$goto = 4;
              break;
            case 5:
              // else
              $async$goto = H.checkSubtype(callable, "$isUserDefinedCallable", [Q.AsyncEnvironment], null) ? 7 : 9;
              break;
            case 7:
              // then
              $async$goto = 10;
              return P._asyncAwait($async$self._async_evaluate$_runUserDefinedCallable$4($arguments, callable, nodeWithSpan, new E._EvaluateVisitor__runFunctionCallable_closure0($async$self, callable)), $async$_async_evaluate$_runFunctionCallable$3);
            case 10:
              // returning from await.
              $async$returnValue = $async$result.withoutSlash$0();
              // goto return
              $async$goto = 1;
              break;
              // goto join
              $async$goto = 8;
              break;
            case 9:
              // else
              $async$goto = !!callable.$isPlainCssCallable ? 11 : 13;
              break;
            case 11:
              // then
              t1 = $arguments.named;
              if (t1.get$isNotEmpty(t1) || $arguments.keywordRest != null)
                throw H.wrapException($async$self._async_evaluate$_exception$2("Plain CSS functions don't support keyword arguments.", nodeWithSpan.span));
              t1 = H.S(callable.name) + "(";
              t2 = $arguments.positional, t3 = t2.length, first = true, _i = 0;
            case 14:
              // for condition
              if (!(_i < t3)) {
                // goto after for
                $async$goto = 16;
                break;
              }
              argument = t2[_i];
              if (first)
                first = false;
              else
                t1 += ", ";
              $async$temp1 = H;
              $async$goto = 17;
              return P._asyncAwait($async$self._evaluateToCss$1(argument), $async$_async_evaluate$_runFunctionCallable$3);
            case 17:
              // returning from await.
              t1 += $async$temp1.S($async$result);
            case 15:
              // for update
              ++_i;
              // goto for condition
              $async$goto = 14;
              break;
            case 16:
              // after for
              t2 = $arguments.rest;
              $async$goto = 18;
              return P._asyncAwait(t2 == null ? null : t2.accept$1($async$self), $async$_async_evaluate$_runFunctionCallable$3);
            case 18:
              // returning from await.
              rest = $async$result;
              if (rest != null) {
                if (!first)
                  t1 += ", ";
                t2 = t1 + H.S($async$self._async_evaluate$_serialize$2(rest, t2));
                t1 = t2;
              }
              t1 += H.Primitives_stringFromCharCode(41);
              $async$returnValue = new D.SassString(t1.charCodeAt(0) == 0 ? t1 : t1, false);
              // goto return
              $async$goto = 1;
              break;
              // goto join
              $async$goto = 12;
              break;
            case 13:
              // else
              // goto return
              $async$goto = 1;
              break;
            case 12:
              // join
            case 8:
              // join
            case 4:
              // join
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$_async_evaluate$_runFunctionCallable$3, $async$completer);
    },
    _async_evaluate$_runBuiltInCallable$3: function($arguments, callable, nodeWithSpan) {
      return this._runBuiltInCallable$body$_EvaluateVisitor($arguments, callable, nodeWithSpan);
    },
    _runBuiltInCallable$body$_EvaluateVisitor: function($arguments, callable, nodeWithSpan) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(F.Value),
        $async$returnValue, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, callback, result, error, message, t1, namedSet, tuple, overload, declaredArguments, i, t2, argument, t3, t4, rest, argumentList, exception, evaluated, oldCallableNode, $async$exception;
      var $async$_async_evaluate$_runBuiltInCallable$3 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$currentError = $async$result;
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              return P._asyncAwait($async$self._async_evaluate$_evaluateArguments$2$trackSpans($arguments, false), $async$_async_evaluate$_runBuiltInCallable$3);
            case 3:
              // returning from await.
              evaluated = $async$result;
              oldCallableNode = $async$self._async_evaluate$_callableNode;
              $async$self._async_evaluate$_callableNode = nodeWithSpan;
              t1 = P.String;
              namedSet = new M.MapKeySet(evaluated.named, [t1]);
              tuple = callable.callbackFor$2(evaluated.positional.length, namedSet);
              overload = tuple.item1;
              callback = tuple.item2;
              $async$self._async_evaluate$_addExceptionSpan$2(nodeWithSpan, new E._EvaluateVisitor__runBuiltInCallable_closure1(overload, evaluated, namedSet));
              declaredArguments = overload.$arguments;
              i = evaluated.positional.length, t2 = declaredArguments.length;
            case 4:
              // for condition
              if (!(i < t2)) {
                // goto after for
                $async$goto = 6;
                break;
              }
              argument = declaredArguments[i];
              t3 = evaluated.positional;
              t4 = evaluated.named.remove$1(0, argument.name);
              $async$goto = t4 == null ? 7 : 8;
              break;
            case 7:
              // then
              t4 = argument.defaultValue;
              $async$goto = 9;
              return P._asyncAwait(t4 == null ? null : t4.accept$1($async$self), $async$_async_evaluate$_runBuiltInCallable$3);
            case 9:
              // returning from await.
              t4 = $async$result;
            case 8:
              // join
              t3.push(t4);
            case 5:
              // for update
              ++i;
              // goto for condition
              $async$goto = 4;
              break;
            case 6:
              // after for
              if (overload.restArgument != null) {
                if (evaluated.positional.length > t2) {
                  rest = C.JSArray_methods.sublist$1(evaluated.positional, t2);
                  C.JSArray_methods.removeRange$2(evaluated.positional, t2, evaluated.positional.length);
                } else
                  rest = C.List_empty1;
                t2 = evaluated.named;
                t3 = evaluated.separator === C.ListSeparator_undecided ? C.ListSeparator_comma : evaluated.separator;
                t4 = F.Value;
                argumentList = new D.SassArgumentList(H.ConstantMap_ConstantMap$from(t2, t1, t4), P.List_List$unmodifiable(rest, t4), t3, false);
                argumentList.SassList$3$brackets(rest, t3, false);
                evaluated.positional.push(argumentList);
              } else
                argumentList = null;
              result = null;
              $async$handler = 11;
              $async$goto = 14;
              return P._asyncAwait(callback.call$1(evaluated.positional), $async$_async_evaluate$_runBuiltInCallable$3);
            case 14:
              // returning from await.
              result = $async$result;
              if (result == null)
                throw H.wrapException("Custom functions may not return Dart's null.");
              $async$handler = 2;
              // goto after finally
              $async$goto = 13;
              break;
            case 11:
              // catch
              $async$handler = 10;
              $async$exception = $async$currentError;
              error = H.unwrapException($async$exception);
              message = null;
              try {
                message = H.stringTypeCast(J.get$message$x(error));
              } catch (exception) {
                H.unwrapException($async$exception);
                message = J.toString$0$(error);
              }
              throw H.wrapException($async$self._async_evaluate$_exception$2(message, nodeWithSpan.span));
              // goto after finally
              $async$goto = 13;
              break;
            case 10:
              // uncaught
              // goto rethrow
              $async$goto = 2;
              break;
            case 13:
              // after finally
              $async$self._async_evaluate$_callableNode = oldCallableNode;
              if (argumentList == null) {
                $async$returnValue = result;
                // goto return
                $async$goto = 1;
                break;
              }
              t1 = evaluated.named;
              if (t1.get$isEmpty(t1)) {
                $async$returnValue = result;
                // goto return
                $async$goto = 1;
                break;
              }
              if (argumentList._wereKeywordsAccessed) {
                $async$returnValue = result;
                // goto return
                $async$goto = 1;
                break;
              }
              throw H.wrapException($async$self._async_evaluate$_exception$2("No " + B.pluralize("argument", J.get$length$asx(evaluated.named.get$keys()), null) + " named " + H.S(B.toSentence(J.map$1$1$ax(evaluated.named.get$keys(), new E._EvaluateVisitor__runBuiltInCallable_closure2(), P.Object), "or")) + ".", nodeWithSpan.span));
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return P._asyncRethrow($async$currentError, $async$completer);
          }
      });
      return P._asyncStartSync($async$_async_evaluate$_runBuiltInCallable$3, $async$completer);
    },
    _async_evaluate$_evaluateArguments$2$trackSpans: function($arguments, trackSpans) {
      return this._evaluateArguments$body$_EvaluateVisitor($arguments, trackSpans);
    },
    _async_evaluate$_evaluateArguments$1: function($arguments) {
      return this._async_evaluate$_evaluateArguments$2$trackSpans($arguments, null);
    },
    _evaluateArguments$body$_EvaluateVisitor: function($arguments, trackSpans) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(E._ArgumentResults0),
        $async$returnValue, $async$self = this, t1, t2, t3, t4, _i, t5, t6, t7, named, t8, positionalNodes, namedNodes, rest, restNodeForSpan, separator, keywordRest, keywordRestNodeForSpan, $async$temp1;
      var $async$_async_evaluate$_evaluateArguments$2$trackSpans = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              if (trackSpans == null)
                trackSpans = $async$self._async_evaluate$_sourceMap;
              t1 = F.Value;
              t2 = H.setRuntimeTypeInfo([], [t1]);
              t3 = $arguments.positional, t4 = t3.length, _i = 0;
            case 3:
              // for condition
              if (!(_i < t4)) {
                // goto after for
                $async$goto = 5;
                break;
              }
              $async$temp1 = t2;
              $async$goto = 6;
              return P._asyncAwait(t3[_i].accept$1($async$self), $async$_async_evaluate$_evaluateArguments$2$trackSpans);
            case 6:
              // returning from await.
              $async$temp1.push($async$result);
            case 4:
              // for update
              ++_i;
              // goto for condition
              $async$goto = 3;
              break;
            case 5:
              // after for
              t5 = $arguments.named;
              t6 = P.String;
              t7 = T.Expression;
              $async$goto = 7;
              return P._asyncAwait(B.mapMapAsync(t5, new E._EvaluateVisitor__evaluateArguments_closure6($async$self), t6, t7, t6, t1), $async$_async_evaluate$_evaluateArguments$2$trackSpans);
            case 7:
              // returning from await.
              named = $async$result;
              if (trackSpans) {
                t8 = H.setRuntimeTypeInfo([], [B.AstNode]);
                for (_i = 0; _i < t4; ++_i)
                  t8.push($async$self._async_evaluate$_expressionNode$1(t3[_i]));
                positionalNodes = t8;
              } else
                positionalNodes = null;
              namedNodes = trackSpans ? Y.mapMap(t5, null, new E._EvaluateVisitor__evaluateArguments_closure7($async$self), t6, t7, t6, B.AstNode) : null;
              t3 = $arguments.rest;
              if (t3 == null) {
                $async$returnValue = E._ArgumentResults$0(t2, named, C.ListSeparator_undecided, namedNodes, positionalNodes);
                // goto return
                $async$goto = 1;
                break;
              }
              $async$goto = 8;
              return P._asyncAwait(t3.accept$1($async$self), $async$_async_evaluate$_evaluateArguments$2$trackSpans);
            case 8:
              // returning from await.
              rest = $async$result;
              restNodeForSpan = trackSpans ? $async$self._async_evaluate$_expressionNode$1(t3) : null;
              t4 = J.getInterceptor$(rest);
              if (!!t4.$isSassMap) {
                $async$self._async_evaluate$_addRestMap$1$3(named, rest, t3, t1);
                if (namedNodes != null)
                  namedNodes.addAll$1(0, Y.mapMap(rest.contents, new E._EvaluateVisitor__evaluateArguments_closure8(), new E._EvaluateVisitor__evaluateArguments_closure9(restNodeForSpan), t1, t1, t6, B.AstNode));
                separator = C.ListSeparator_undecided;
              } else if (!!t4.$isSassList) {
                t3 = rest._list$_contents;
                C.JSArray_methods.addAll$1(t2, t3);
                if (positionalNodes != null)
                  C.JSArray_methods.addAll$1(positionalNodes, P.List_List$filled(t3.length, restNodeForSpan, B.AstNode));
                separator = rest.separator;
                if (!!rest.$isSassArgumentList) {
                  rest._wereKeywordsAccessed = true;
                  rest._keywords.forEach$1(0, new E._EvaluateVisitor__evaluateArguments_closure10(named, namedNodes, restNodeForSpan));
                }
              } else {
                t2.push(rest);
                if (positionalNodes != null)
                  positionalNodes.push(restNodeForSpan);
                separator = C.ListSeparator_undecided;
              }
              t3 = $arguments.keywordRest;
              if (t3 == null) {
                $async$returnValue = E._ArgumentResults$0(t2, named, separator, namedNodes, positionalNodes);
                // goto return
                $async$goto = 1;
                break;
              }
              $async$goto = 9;
              return P._asyncAwait(t3.accept$1($async$self), $async$_async_evaluate$_evaluateArguments$2$trackSpans);
            case 9:
              // returning from await.
              keywordRest = $async$result;
              keywordRestNodeForSpan = trackSpans ? $async$self._async_evaluate$_expressionNode$1(t3) : null;
              if (keywordRest instanceof A.SassMap) {
                $async$self._async_evaluate$_addRestMap$1$3(named, keywordRest, t3, t1);
                if (namedNodes != null)
                  namedNodes.addAll$1(0, Y.mapMap(keywordRest.contents, new E._EvaluateVisitor__evaluateArguments_closure11(), new E._EvaluateVisitor__evaluateArguments_closure12(keywordRestNodeForSpan), t1, t1, t6, B.AstNode));
                $async$returnValue = E._ArgumentResults$0(t2, named, separator, namedNodes, positionalNodes);
                // goto return
                $async$goto = 1;
                break;
              } else
                throw H.wrapException($async$self._async_evaluate$_exception$2("Variable keyword arguments must be a map (was " + H.S(keywordRest) + ").", t3.get$span()));
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$_async_evaluate$_evaluateArguments$2$trackSpans, $async$completer);
    },
    _async_evaluate$_evaluateMacroArguments$1: function(invocation) {
      return this._evaluateMacroArguments$body$_EvaluateVisitor(invocation);
    },
    _evaluateMacroArguments$body$_EvaluateVisitor: function(invocation) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter([S.Tuple2, [P.List, T.Expression], [P.Map, P.String, T.Expression]]),
        $async$returnValue, $async$self = this, t3, positional, named, rest, keywordRest, t1, t2;
      var $async$_async_evaluate$_evaluateMacroArguments$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = invocation.$arguments;
              t2 = t1.rest;
              if (t2 == null) {
                $async$returnValue = new S.Tuple2(t1.positional, t1.named, [[P.List, T.Expression], [P.Map, P.String, T.Expression]]);
                // goto return
                $async$goto = 1;
                break;
              }
              t3 = t1.positional;
              positional = H.setRuntimeTypeInfo(t3.slice(0), [H.getTypeArgumentByIndex(t3, 0)]);
              t3 = T.Expression;
              named = P.LinkedHashMap_LinkedHashMap$of(t1.named, P.String, t3);
              $async$goto = 3;
              return P._asyncAwait(t2.accept$1($async$self), $async$_async_evaluate$_evaluateMacroArguments$1);
            case 3:
              // returning from await.
              rest = $async$result;
              t2 = J.getInterceptor$(rest);
              if (!!t2.$isSassMap)
                $async$self._async_evaluate$_addRestMap$1$4(named, rest, invocation, new E._EvaluateVisitor__evaluateMacroArguments_closure3(), t3);
              else if (!!t2.$isSassList) {
                t2 = rest._list$_contents;
                C.JSArray_methods.addAll$1(positional, new H.MappedListIterable(t2, new E._EvaluateVisitor__evaluateMacroArguments_closure4(), [H.getTypeArgumentByIndex(t2, 0), t3]));
                if (!!rest.$isSassArgumentList) {
                  rest._wereKeywordsAccessed = true;
                  rest._keywords.forEach$1(0, new E._EvaluateVisitor__evaluateMacroArguments_closure5(named));
                }
              } else
                positional.push(new F.ValueExpression(rest, null));
              t1 = t1.keywordRest;
              if (t1 == null) {
                $async$returnValue = new S.Tuple2(positional, named, [[P.List, T.Expression], [P.Map, P.String, T.Expression]]);
                // goto return
                $async$goto = 1;
                break;
              }
              $async$goto = 4;
              return P._asyncAwait(t1.accept$1($async$self), $async$_async_evaluate$_evaluateMacroArguments$1);
            case 4:
              // returning from await.
              keywordRest = $async$result;
              if (keywordRest instanceof A.SassMap) {
                $async$self._async_evaluate$_addRestMap$1$4(named, keywordRest, invocation, new E._EvaluateVisitor__evaluateMacroArguments_closure6(), t3);
                $async$returnValue = new S.Tuple2(positional, named, [[P.List, T.Expression], [P.Map, P.String, T.Expression]]);
                // goto return
                $async$goto = 1;
                break;
              } else
                throw H.wrapException($async$self._async_evaluate$_exception$2("Variable keyword arguments must be a map (was " + H.S(keywordRest) + ").", invocation.span));
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$_async_evaluate$_evaluateMacroArguments$1, $async$completer);
    },
    _async_evaluate$_addRestMap$1$4: function(values, map, nodeForSpan, convert, $T) {
      var t1 = {};
      t1.convert = convert;
      if (convert == null)
        t1.convert = new E._EvaluateVisitor__addRestMap_closure1($T);
      map.contents.forEach$1(0, new E._EvaluateVisitor__addRestMap_closure2(t1, this, values, map, nodeForSpan));
    },
    _async_evaluate$_addRestMap$1$3: function(values, map, nodeForSpan, $T) {
      return this._async_evaluate$_addRestMap$1$4(values, map, nodeForSpan, null, $T);
    },
    _async_evaluate$_verifyArguments$4: function(positional, named, $arguments, nodeWithSpan) {
      return this._async_evaluate$_addExceptionSpan$2(nodeWithSpan, new E._EvaluateVisitor__verifyArguments_closure0($arguments, positional, named));
    },
    visitSelectorExpression$1: function(node) {
      return this.visitSelectorExpression$body$_EvaluateVisitor(node);
    },
    visitSelectorExpression$body$_EvaluateVisitor: function(node) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(F.Value),
        $async$returnValue, $async$self = this, t1;
      var $async$visitSelectorExpression$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self._async_evaluate$_styleRule;
              if (t1 == null) {
                $async$returnValue = C.C_SassNull;
                // goto return
                $async$goto = 1;
                break;
              }
              $async$returnValue = t1.originalSelector.get$asSassList();
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$visitSelectorExpression$1, $async$completer);
    },
    visitStringExpression$1: function(node) {
      return this.visitStringExpression$body$_EvaluateVisitor(node);
    },
    visitStringExpression$body$_EvaluateVisitor: function(node) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(D.SassString),
        $async$returnValue, $async$self = this, $async$temp1, $async$temp2;
      var $async$visitStringExpression$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$temp1 = D;
              $async$temp2 = J;
              $async$goto = 3;
              return P._asyncAwait(B.mapAsync(node.text.contents, new E._EvaluateVisitor_visitStringExpression_closure0($async$self), P.Object, P.String), $async$visitStringExpression$1);
            case 3:
              // returning from await.
              $async$returnValue = new $async$temp1.SassString($async$temp2.join$0$ax($async$result), node.hasQuotes);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$visitStringExpression$1, $async$completer);
    },
    visitCssAtRule$1: function(node) {
      return this.visitCssAtRule$body$_EvaluateVisitor(node);
    },
    visitCssAtRule$body$_EvaluateVisitor: function(node) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$returnValue, $async$self = this, t1, t2, t3, wasInKeyframes, wasInUnknownAtRule;
      var $async$visitCssAtRule$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              if ($async$self._async_evaluate$_declarationName != null)
                throw H.wrapException($async$self._async_evaluate$_exception$2("At-rules may not be used within nested declarations.", node.span));
              if (node.isChildless) {
                t1 = $async$self._async_evaluate$_parent;
                t2 = B.ModifiableCssNode;
                t3 = H.setRuntimeTypeInfo([], [t2]);
                t1.addChild$1(new U.ModifiableCssAtRule(node.name, node.value, true, node.span, new P.UnmodifiableListView(t3, [t2]), t3));
                // goto return
                $async$goto = 1;
                break;
              }
              wasInKeyframes = $async$self._async_evaluate$_inKeyframes;
              wasInUnknownAtRule = $async$self._async_evaluate$_inUnknownAtRule;
              t1 = node.name;
              if (B.unvendor(t1.get$value()) === "keyframes")
                $async$self._async_evaluate$_inKeyframes = true;
              else
                $async$self._async_evaluate$_inUnknownAtRule = true;
              t2 = B.ModifiableCssNode;
              t3 = H.setRuntimeTypeInfo([], [t2]);
              $async$goto = 3;
              return P._asyncAwait($async$self._async_evaluate$_withParent$2$4$scopeWhen$through(new U.ModifiableCssAtRule(t1, node.value, false, node.span, new P.UnmodifiableListView(t3, [t2]), t3), new E._EvaluateVisitor_visitCssAtRule_closure1($async$self, node), false, new E._EvaluateVisitor_visitCssAtRule_closure2(), U.ModifiableCssAtRule, P.Null), $async$visitCssAtRule$1);
            case 3:
              // returning from await.
              $async$self._async_evaluate$_inUnknownAtRule = wasInUnknownAtRule;
              $async$self._async_evaluate$_inKeyframes = wasInKeyframes;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$visitCssAtRule$1, $async$completer);
    },
    visitCssComment$1: function(node) {
      return this.visitCssComment$body$_EvaluateVisitor(node);
    },
    visitCssComment$body$_EvaluateVisitor: function(node) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$self = this, t1, t2;
      var $async$visitCssComment$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self._async_evaluate$_parent;
              t2 = $async$self._async_evaluate$_root;
              if (t1 == t2 && $async$self._async_evaluate$_endOfImports === J.get$length$asx(t2.children._collection$_source))
                $async$self._async_evaluate$_endOfImports = $async$self._async_evaluate$_endOfImports + 1;
              $async$self._async_evaluate$_parent.addChild$1(new R.ModifiableCssComment(node.text, node.span));
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$visitCssComment$1, $async$completer);
    },
    visitCssDeclaration$1: function(node) {
      return this.visitCssDeclaration$body$_EvaluateVisitor(node);
    },
    visitCssDeclaration$body$_EvaluateVisitor: function(node) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$self = this;
      var $async$visitCssDeclaration$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$self._async_evaluate$_parent.addChild$1(L.ModifiableCssDeclaration$(node.name, node.value, node.span, node.valueSpanForMap));
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$visitCssDeclaration$1, $async$completer);
    },
    visitCssImport$1: function(node) {
      return this.visitCssImport$body$_EvaluateVisitor(node);
    },
    visitCssImport$body$_EvaluateVisitor: function(node) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$self = this, modifiableNode, t1, t2;
      var $async$visitCssImport$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              modifiableNode = F.ModifiableCssImport$(node.url, node.span, node.media, node.supports);
              t1 = $async$self._async_evaluate$_parent;
              t2 = $async$self._async_evaluate$_root;
              if (t1 != t2)
                t1.addChild$1(modifiableNode);
              else if ($async$self._async_evaluate$_endOfImports === J.get$length$asx(t2.children._collection$_source)) {
                $async$self._async_evaluate$_root.addChild$1(modifiableNode);
                $async$self._async_evaluate$_endOfImports = $async$self._async_evaluate$_endOfImports + 1;
              } else {
                t1 = $async$self._async_evaluate$_outOfOrderImports;
                (t1 == null ? $async$self._async_evaluate$_outOfOrderImports = H.setRuntimeTypeInfo([], [F.ModifiableCssImport]) : t1).push(modifiableNode);
              }
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$visitCssImport$1, $async$completer);
    },
    visitCssKeyframeBlock$1: function(node) {
      return this.visitCssKeyframeBlock$body$_EvaluateVisitor(node);
    },
    visitCssKeyframeBlock$body$_EvaluateVisitor: function(node) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$self = this, t1, t2;
      var $async$visitCssKeyframeBlock$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = B.ModifiableCssNode;
              t2 = H.setRuntimeTypeInfo([], [t1]);
              $async$goto = 2;
              return P._asyncAwait($async$self._async_evaluate$_withParent$2$4$scopeWhen$through(new U.ModifiableCssKeyframeBlock(node.selector, node.span, new P.UnmodifiableListView(t2, [t1]), t2), new E._EvaluateVisitor_visitCssKeyframeBlock_closure1($async$self, node), false, new E._EvaluateVisitor_visitCssKeyframeBlock_closure2(), U.ModifiableCssKeyframeBlock, P.Null), $async$visitCssKeyframeBlock$1);
            case 2:
              // returning from await.
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$visitCssKeyframeBlock$1, $async$completer);
    },
    visitCssMediaRule$1: function(node) {
      return this.visitCssMediaRule$body$_EvaluateVisitor(node);
    },
    visitCssMediaRule$body$_EvaluateVisitor: function(node) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$returnValue, $async$self = this, t1, mergedQueries;
      var $async$visitCssMediaRule$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              if ($async$self._async_evaluate$_declarationName != null)
                throw H.wrapException($async$self._async_evaluate$_exception$2("Media rules may not be used within nested declarations.", node.span));
              t1 = $async$self._async_evaluate$_mediaQueries;
              mergedQueries = t1 == null ? null : $async$self._async_evaluate$_mergeMediaQueries$2(t1, node.queries);
              t1 = mergedQueries == null;
              if (!t1 && mergedQueries.length === 0) {
                // goto return
                $async$goto = 1;
                break;
              }
              t1 = t1 ? node.queries : mergedQueries;
              $async$goto = 3;
              return P._asyncAwait($async$self._async_evaluate$_withParent$2$4$scopeWhen$through(G.ModifiableCssMediaRule$(t1, node.span), new E._EvaluateVisitor_visitCssMediaRule_closure1($async$self, mergedQueries, node), false, new E._EvaluateVisitor_visitCssMediaRule_closure2(mergedQueries), G.ModifiableCssMediaRule, P.Null), $async$visitCssMediaRule$1);
            case 3:
              // returning from await.
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$visitCssMediaRule$1, $async$completer);
    },
    visitCssStyleRule$1: function(node) {
      return this.visitCssStyleRule$body$_EvaluateVisitor(node);
    },
    visitCssStyleRule$body$_EvaluateVisitor: function(node) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$self = this, t1, t2, t3, t4, rule, oldAtRootExcludingStyleRule;
      var $async$visitCssStyleRule$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              if ($async$self._async_evaluate$_declarationName != null)
                throw H.wrapException($async$self._async_evaluate$_exception$2("Style rules may not be used within nested declarations.", node.span));
              t1 = $async$self._async_evaluate$_extender;
              t2 = node.selector;
              t3 = t2.value;
              t4 = $async$self._async_evaluate$_styleRule;
              t4 = t4 == null ? null : t4.originalSelector;
              rule = t1.addSelector$4(t3.resolveParentSelectors$2$implicitParent(t4, !$async$self._async_evaluate$_atRootExcludingStyleRule), t2.span, node.span, $async$self._async_evaluate$_mediaQueries);
              oldAtRootExcludingStyleRule = $async$self._async_evaluate$_atRootExcludingStyleRule;
              $async$self._async_evaluate$_atRootExcludingStyleRule = false;
              $async$goto = 2;
              return P._asyncAwait($async$self._async_evaluate$_withParent$2$4$scopeWhen$through(rule, new E._EvaluateVisitor_visitCssStyleRule_closure1($async$self, rule, node), false, new E._EvaluateVisitor_visitCssStyleRule_closure2(), X.ModifiableCssStyleRule, P.Null), $async$visitCssStyleRule$1);
            case 2:
              // returning from await.
              $async$self._async_evaluate$_atRootExcludingStyleRule = oldAtRootExcludingStyleRule;
              if (!($async$self._async_evaluate$_styleRule != null && !oldAtRootExcludingStyleRule)) {
                t1 = $async$self._async_evaluate$_parent.children;
                t1 = !t1.get$isEmpty(t1);
              } else
                t1 = false;
              if (t1) {
                t1 = $async$self._async_evaluate$_parent.children;
                t1.get$last(t1).isGroupEnd = true;
              }
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$visitCssStyleRule$1, $async$completer);
    },
    visitCssStylesheet$1: function(node) {
      return this.visitCssStylesheet$body$_EvaluateVisitor(node);
    },
    visitCssStylesheet$body$_EvaluateVisitor: function(node) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$self = this, t1;
      var $async$visitCssStylesheet$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = J.get$iterator$ax(node.get$children());
            case 2:
              // for condition
              if (!t1.moveNext$0()) {
                // goto after for
                $async$goto = 3;
                break;
              }
              $async$goto = 4;
              return P._asyncAwait(t1.get$current(t1).accept$1($async$self), $async$visitCssStylesheet$1);
            case 4:
              // returning from await.
              // goto for condition
              $async$goto = 2;
              break;
            case 3:
              // after for
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$visitCssStylesheet$1, $async$completer);
    },
    visitCssSupportsRule$1: function(node) {
      return this.visitCssSupportsRule$body$_EvaluateVisitor(node);
    },
    visitCssSupportsRule$body$_EvaluateVisitor: function(node) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$self = this, t1, t2;
      var $async$visitCssSupportsRule$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              if ($async$self._async_evaluate$_declarationName != null)
                throw H.wrapException($async$self._async_evaluate$_exception$2("Supports rules may not be used within nested declarations.", node.span));
              t1 = B.ModifiableCssNode;
              t2 = H.setRuntimeTypeInfo([], [t1]);
              $async$goto = 2;
              return P._asyncAwait($async$self._async_evaluate$_withParent$2$4$scopeWhen$through(new B.ModifiableCssSupportsRule(node.condition, node.span, new P.UnmodifiableListView(t2, [t1]), t2), new E._EvaluateVisitor_visitCssSupportsRule_closure1($async$self, node), false, new E._EvaluateVisitor_visitCssSupportsRule_closure2(), B.ModifiableCssSupportsRule, P.Null), $async$visitCssSupportsRule$1);
            case 2:
              // returning from await.
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$visitCssSupportsRule$1, $async$completer);
    },
    _async_evaluate$_handleReturn$1$2: function(list, callback) {
      return this._handleReturn$body$_EvaluateVisitor(list, callback, null);
    },
    _async_evaluate$_handleReturn$2: function(list, callback) {
      return this._async_evaluate$_handleReturn$1$2(list, callback, null);
    },
    _handleReturn$body$_EvaluateVisitor: function(list, callback) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(F.Value),
        $async$returnValue, t1, _i, result;
      var $async$_async_evaluate$_handleReturn$1$2 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = list.length, _i = 0;
            case 3:
              // for condition
              if (!(_i < list.length)) {
                // goto after for
                $async$goto = 5;
                break;
              }
              $async$goto = 6;
              return P._asyncAwait(callback.call$1(list[_i]), $async$_async_evaluate$_handleReturn$1$2);
            case 6:
              // returning from await.
              result = $async$result;
              if (result != null) {
                $async$returnValue = result;
                // goto return
                $async$goto = 1;
                break;
              }
            case 4:
              // for update
              list.length === t1 || (0, H.throwConcurrentModificationError)(list), ++_i;
              // goto for condition
              $async$goto = 3;
              break;
            case 5:
              // after for
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$_async_evaluate$_handleReturn$1$2, $async$completer);
    },
    _async_evaluate$_withEnvironment$1$2: function(environment, callback, $T) {
      return this._withEnvironment$body$_EvaluateVisitor(environment, callback, $T, $T);
    },
    _withEnvironment$body$_EvaluateVisitor: function(environment, callback, $T, $async$type) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter($async$type),
        $async$returnValue, $async$self = this, result, oldEnvironment;
      var $async$_async_evaluate$_withEnvironment$1$2 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              oldEnvironment = $async$self._async_evaluate$_environment;
              $async$self._async_evaluate$_environment = environment;
              $async$goto = 3;
              return P._asyncAwait(callback.call$0(), $async$_async_evaluate$_withEnvironment$1$2);
            case 3:
              // returning from await.
              result = $async$result;
              $async$self._async_evaluate$_environment = oldEnvironment;
              $async$returnValue = result;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$_async_evaluate$_withEnvironment$1$2, $async$completer);
    },
    _async_evaluate$_interpolationToValue$3$trim$warnForColor: function(interpolation, trim, warnForColor) {
      return this._interpolationToValue$body$_EvaluateVisitor(interpolation, trim, warnForColor);
    },
    _async_evaluate$_interpolationToValue$1: function(interpolation) {
      return this._async_evaluate$_interpolationToValue$3$trim$warnForColor(interpolation, false, false);
    },
    _async_evaluate$_interpolationToValue$2$warnForColor: function(interpolation, warnForColor) {
      return this._async_evaluate$_interpolationToValue$3$trim$warnForColor(interpolation, false, warnForColor);
    },
    _interpolationToValue$body$_EvaluateVisitor: function(interpolation, trim, warnForColor) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter([F.CssValue, P.String]),
        $async$returnValue, $async$self = this, result, t1;
      var $async$_async_evaluate$_interpolationToValue$3$trim$warnForColor = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              return P._asyncAwait($async$self._async_evaluate$_performInterpolation$2$warnForColor(interpolation, warnForColor), $async$_async_evaluate$_interpolationToValue$3$trim$warnForColor);
            case 3:
              // returning from await.
              result = $async$result;
              t1 = trim ? B.trimAscii(result, true) : result;
              $async$returnValue = new F.CssValue(t1, interpolation.span, [P.String]);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$_async_evaluate$_interpolationToValue$3$trim$warnForColor, $async$completer);
    },
    _async_evaluate$_performInterpolation$2$warnForColor: function(interpolation, warnForColor) {
      return this._performInterpolation$body$_EvaluateVisitor(interpolation, warnForColor);
    },
    _async_evaluate$_performInterpolation$1: function(interpolation) {
      return this._async_evaluate$_performInterpolation$2$warnForColor(interpolation, false);
    },
    _performInterpolation$body$_EvaluateVisitor: function(interpolation, warnForColor) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.String),
        $async$returnValue, $async$self = this, $async$temp1;
      var $async$_async_evaluate$_performInterpolation$2$warnForColor = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$temp1 = J;
              $async$goto = 3;
              return P._asyncAwait(B.mapAsync(interpolation.contents, new E._EvaluateVisitor__performInterpolation_closure0($async$self, warnForColor), P.Object, P.String), $async$_async_evaluate$_performInterpolation$2$warnForColor);
            case 3:
              // returning from await.
              $async$returnValue = $async$temp1.join$0$ax($async$result);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$_async_evaluate$_performInterpolation$2$warnForColor, $async$completer);
    },
    _evaluateToCss$2$quote: function(expression, quote) {
      return this._evaluateToCss$body$_EvaluateVisitor(expression, quote);
    },
    _evaluateToCss$1: function(expression) {
      return this._evaluateToCss$2$quote(expression, true);
    },
    _evaluateToCss$body$_EvaluateVisitor: function(expression, quote) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.String),
        $async$returnValue, $async$self = this;
      var $async$_evaluateToCss$2$quote = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              return P._asyncAwait(expression.accept$1($async$self), $async$_evaluateToCss$2$quote);
            case 3:
              // returning from await.
              $async$returnValue = $async$self._async_evaluate$_serialize$3$quote($async$result, expression, quote);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$_evaluateToCss$2$quote, $async$completer);
    },
    _async_evaluate$_serialize$3$quote: function(value, nodeWithSpan, quote) {
      return this._async_evaluate$_addExceptionSpan$2(nodeWithSpan, new E._EvaluateVisitor__serialize_closure0(value, quote));
    },
    _async_evaluate$_serialize$2: function(value, nodeWithSpan) {
      return this._async_evaluate$_serialize$3$quote(value, nodeWithSpan, true);
    },
    _async_evaluate$_expressionNode$1: function(expression) {
      if (!this._async_evaluate$_sourceMap)
        return;
      if (expression instanceof S.VariableExpression)
        return this._async_evaluate$_environment.getVariableNode$2$namespace(expression.name, expression.namespace);
      else
        return expression;
    },
    _async_evaluate$_withParent$2$4$scopeWhen$through: function(node, callback, scopeWhen, through, $S, $T) {
      return this._withParent$body$_EvaluateVisitor(node, callback, scopeWhen, through, $S, $T, $T);
    },
    _async_evaluate$_withParent$2$2: function(node, callback, $S, $T) {
      return this._async_evaluate$_withParent$2$4$scopeWhen$through(node, callback, true, null, $S, $T);
    },
    _async_evaluate$_withParent$2$3$scopeWhen: function(node, callback, scopeWhen, $S, $T) {
      return this._async_evaluate$_withParent$2$4$scopeWhen$through(node, callback, scopeWhen, null, $S, $T);
    },
    _withParent$body$_EvaluateVisitor: function(node, callback, scopeWhen, through, $S, $T, $async$type) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter($async$type),
        $async$returnValue, $async$self = this, oldParent, result;
      var $async$_async_evaluate$_withParent$2$4$scopeWhen$through = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$self._async_evaluate$_addChild$2$through(node, through);
              oldParent = $async$self._async_evaluate$_parent;
              $async$self._async_evaluate$_parent = node;
              $async$goto = 3;
              return P._asyncAwait($async$self._async_evaluate$_environment.scope$1$2$when(callback, scopeWhen, $T), $async$_async_evaluate$_withParent$2$4$scopeWhen$through);
            case 3:
              // returning from await.
              result = $async$result;
              $async$self._async_evaluate$_parent = oldParent;
              $async$returnValue = result;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$_async_evaluate$_withParent$2$4$scopeWhen$through, $async$completer);
    },
    _async_evaluate$_addChild$2$through: function(node, through) {
      var grandparent,
        $parent = this._async_evaluate$_parent;
      if (through != null) {
        for (; through.call$1($parent);)
          $parent = $parent._parent;
        if ($parent.get$hasFollowingSibling()) {
          grandparent = $parent._parent;
          $parent = $parent.copyWithoutChildren$0();
          grandparent.addChild$1($parent);
        }
      }
      $parent.addChild$1(node);
    },
    _async_evaluate$_addChild$1: function(node) {
      return this._async_evaluate$_addChild$2$through(node, null);
    },
    _async_evaluate$_withStyleRule$1$2: function(rule, callback, $T) {
      return this._withStyleRule$body$_EvaluateVisitor(rule, callback, $T, $T);
    },
    _withStyleRule$body$_EvaluateVisitor: function(rule, callback, $T, $async$type) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter($async$type),
        $async$returnValue, $async$self = this, result, oldRule;
      var $async$_async_evaluate$_withStyleRule$1$2 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              oldRule = $async$self._async_evaluate$_styleRule;
              $async$self._async_evaluate$_styleRule = rule;
              $async$goto = 3;
              return P._asyncAwait(callback.call$0(), $async$_async_evaluate$_withStyleRule$1$2);
            case 3:
              // returning from await.
              result = $async$result;
              $async$self._async_evaluate$_styleRule = oldRule;
              $async$returnValue = result;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$_async_evaluate$_withStyleRule$1$2, $async$completer);
    },
    _async_evaluate$_withMediaQueries$1$2: function(queries, callback, $T) {
      return this._withMediaQueries$body$_EvaluateVisitor(queries, callback, $T, $T);
    },
    _withMediaQueries$body$_EvaluateVisitor: function(queries, callback, $T, $async$type) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter($async$type),
        $async$returnValue, $async$self = this, result, oldMediaQueries;
      var $async$_async_evaluate$_withMediaQueries$1$2 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              oldMediaQueries = $async$self._async_evaluate$_mediaQueries;
              $async$self._async_evaluate$_mediaQueries = queries;
              $async$goto = 3;
              return P._asyncAwait(callback.call$0(), $async$_async_evaluate$_withMediaQueries$1$2);
            case 3:
              // returning from await.
              result = $async$result;
              $async$self._async_evaluate$_mediaQueries = oldMediaQueries;
              $async$returnValue = result;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$_async_evaluate$_withMediaQueries$1$2, $async$completer);
    },
    _async_evaluate$_withStackFrame$1$3: function(member, nodeWithSpan, callback, $T) {
      return this._withStackFrame$body$_EvaluateVisitor(member, nodeWithSpan, callback, $T, $T);
    },
    _withStackFrame$body$_EvaluateVisitor: function(member, nodeWithSpan, callback, $T, $async$type) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter($async$type),
        $async$returnValue, $async$self = this, oldMember, result, t1;
      var $async$_async_evaluate$_withStackFrame$1$3 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self._async_evaluate$_stack;
              t1.push(new S.Tuple2($async$self._async_evaluate$_member, nodeWithSpan, [P.String, B.AstNode]));
              oldMember = $async$self._async_evaluate$_member;
              $async$self._async_evaluate$_member = member;
              $async$goto = 3;
              return P._asyncAwait(callback.call$0(), $async$_async_evaluate$_withStackFrame$1$3);
            case 3:
              // returning from await.
              result = $async$result;
              $async$self._async_evaluate$_member = oldMember;
              t1.pop();
              $async$returnValue = result;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$_async_evaluate$_withStackFrame$1$3, $async$completer);
    },
    _async_evaluate$_stackFrame$2: function(member, span) {
      var url = span.file.url;
      return B.frameForSpan(span, member, url != null && this._async_evaluate$_importCache != null ? this._async_evaluate$_importCache.humanize$1(url) : url);
    },
    _async_evaluate$_stackTrace$1: function(span) {
      var t3, _this = this,
        t1 = A.Frame,
        t2 = H.setRuntimeTypeInfo([], [t1]);
      for (t3 = _this._async_evaluate$_stack, t3 = new H.MappedListIterable(t3, new E._EvaluateVisitor__stackTrace_closure0(_this), [H.getTypeArgumentByIndex(t3, 0), t1]), t3 = new H.ListIterator(t3, t3.get$length(t3)); t3.moveNext$0();)
        t2.push(t3.__internal$_current);
      if (span != null)
        t2.push(_this._async_evaluate$_stackFrame$2(_this._async_evaluate$_member, span));
      return new Y.Trace(P.List_List$unmodifiable(new H.ReversedListIterable(t2, [H.getTypeArgumentByIndex(t2, 0)]), t1), new P._StringStackTrace(null));
    },
    _async_evaluate$_warn$3$deprecation: function(message, span, deprecation) {
      return this._async_evaluate$_logger.warn$4$deprecation$span$trace(message, deprecation, span, this._async_evaluate$_stackTrace$1(span));
    },
    _async_evaluate$_warn$2: function(message, span) {
      return this._async_evaluate$_warn$3$deprecation(message, span, false);
    },
    _async_evaluate$_exception$2: function(message, span) {
      var t1 = span == null ? C.JSArray_methods.get$last(this._async_evaluate$_stack).item2.get$span() : span;
      return new E.SassRuntimeException(this._async_evaluate$_stackTrace$1(span), message, t1);
    },
    _async_evaluate$_exception$1: function(message) {
      return this._async_evaluate$_exception$2(message, null);
    },
    _async_evaluate$_adjustParseError$1$2: function(nodeWithSpan, callback) {
      var error, errorText, span, syntheticFile, syntheticSpan, t1, exception, t2, t3, t4, t5, _null = null;
      try {
        t1 = callback.call$0();
        return t1;
      } catch (exception) {
        t1 = H.unwrapException(exception);
        if (t1 instanceof E.SassFormatException) {
          error = t1;
          t1 = error;
          errorText = P.String_String$fromCharCodes(C.NativeUint32List_methods.sublist$2(G.SourceSpanException.prototype.get$span.call(t1).file._decodedChars, 0, _null), 0, _null);
          span = nodeWithSpan.get$span();
          t1 = span;
          t2 = span;
          syntheticFile = C.JSString_methods.replaceRange$3(P.String_String$fromCharCodes(C.NativeUint32List_methods.sublist$2(span.file._decodedChars, 0, _null), 0, _null), Y.FileLocation$_(t1.file, t1._start).offset, Y.FileLocation$_(t2.file, t2._end).offset, errorText);
          t2 = syntheticFile;
          t1 = span.file.url;
          t2.toString;
          t2 = new H.CodeUnits(t2);
          t3 = H.setRuntimeTypeInfo([0], [P.int]);
          t3 = new Y.SourceFile(t1, t3, new Uint32Array(H._ensureNativeList(t2.toList$0(t2))));
          t3.SourceFile$decoded$2$url(t2, t1);
          t1 = span;
          t1 = Y.FileLocation$_(t1.file, t1._start);
          t2 = error;
          t2 = G.SourceSpanException.prototype.get$span.call(t2);
          t2 = Y.FileLocation$_(t2.file, t2._start);
          t4 = span;
          t4 = Y.FileLocation$_(t4.file, t4._start);
          t5 = error;
          t5 = G.SourceSpanException.prototype.get$span.call(t5);
          syntheticSpan = t3.span$2(t1.offset + t2.offset, t4.offset + Y.FileLocation$_(t5.file, t5._end).offset);
          throw H.wrapException(this._async_evaluate$_exception$2(error._span_exception$_message, syntheticSpan));
        } else
          throw exception;
      }
    },
    _async_evaluate$_adjustParseError$2: function(nodeWithSpan, callback) {
      return this._async_evaluate$_adjustParseError$1$2(nodeWithSpan, callback, null);
    },
    _async_evaluate$_addExceptionSpan$1$2: function(nodeWithSpan, callback) {
      var error, t1, exception;
      try {
        t1 = callback.call$0();
        return t1;
      } catch (exception) {
        t1 = H.unwrapException(exception);
        if (t1 instanceof E.SassScriptException) {
          error = t1;
          throw H.wrapException(this._async_evaluate$_exception$2(error.message, nodeWithSpan.get$span()));
        } else
          throw exception;
      }
    },
    _async_evaluate$_addExceptionSpan$2: function(nodeWithSpan, callback) {
      return this._async_evaluate$_addExceptionSpan$1$2(nodeWithSpan, callback, null);
    },
    _addExceptionSpanAsync$1$2: function(nodeWithSpan, callback, $T) {
      return this._addExceptionSpanAsync$body$_EvaluateVisitor(nodeWithSpan, callback, $T, $T);
    },
    _addExceptionSpanAsync$body$_EvaluateVisitor: function(nodeWithSpan, callback, $T, $async$type) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter($async$type),
        $async$returnValue, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, error, t1, exception, $async$exception;
      var $async$_addExceptionSpanAsync$1$2 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$currentError = $async$result;
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$handler = 4;
              $async$goto = 7;
              return P._asyncAwait(callback.call$0(), $async$_addExceptionSpanAsync$1$2);
            case 7:
              // returning from await.
              t1 = $async$result;
              $async$returnValue = t1;
              // goto return
              $async$goto = 1;
              break;
              $async$handler = 2;
              // goto after finally
              $async$goto = 6;
              break;
            case 4:
              // catch
              $async$handler = 3;
              $async$exception = $async$currentError;
              t1 = H.unwrapException($async$exception);
              if (t1 instanceof E.SassScriptException) {
                error = t1;
                throw H.wrapException($async$self._async_evaluate$_exception$2(error.message, nodeWithSpan.get$span()));
              } else
                throw $async$exception;
              // goto after finally
              $async$goto = 6;
              break;
            case 3:
              // uncaught
              // goto rethrow
              $async$goto = 2;
              break;
            case 6:
              // after finally
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return P._asyncRethrow($async$currentError, $async$completer);
          }
      });
      return P._asyncStartSync($async$_addExceptionSpanAsync$1$2, $async$completer);
    }
  };
  E._EvaluateVisitor_closure8.prototype = {
    call$1: function($arguments) {
      var module, t2,
        t1 = J.getInterceptor$asx($arguments),
        variable = t1.$index($arguments, 0).assertString$1("name");
      t1 = t1.$index($arguments, 1).get$realNull();
      module = t1 == null ? null : t1.assertString$1("module");
      t1 = this.$this._async_evaluate$_environment;
      t2 = variable.text;
      t2.toString;
      t2 = H.stringReplaceAllUnchecked(t2, "_", "-");
      return t1.globalVariableExists$2$namespace(t2, module == null ? null : module.text) ? C.SassBoolean_true : C.SassBoolean_false;
    },
    $signature: 3
  };
  E._EvaluateVisitor_closure9.prototype = {
    call$1: function($arguments) {
      var variable = J.$index$asx($arguments, 0).assertString$1("name"),
        t1 = this.$this._async_evaluate$_environment,
        t2 = variable.text;
      t2.toString;
      return t1.getVariable$1(H.stringReplaceAllUnchecked(t2, "_", "-")) != null ? C.SassBoolean_true : C.SassBoolean_false;
    },
    $signature: 3
  };
  E._EvaluateVisitor_closure10.prototype = {
    call$1: function($arguments) {
      var module, t2, t3, t4,
        t1 = J.getInterceptor$asx($arguments),
        variable = t1.$index($arguments, 0).assertString$1("name");
      t1 = t1.$index($arguments, 1).get$realNull();
      module = t1 == null ? null : t1.assertString$1("module");
      t1 = this.$this;
      t2 = t1._async_evaluate$_environment;
      t3 = variable.text;
      t3.toString;
      t4 = H.stringReplaceAllUnchecked(t3, "_", "-");
      return t2.getFunction$2$namespace(t4, module == null ? null : module.text) != null || t1._async_evaluate$_builtInFunctions.containsKey$1(t3) ? C.SassBoolean_true : C.SassBoolean_false;
    },
    $signature: 3
  };
  E._EvaluateVisitor_closure11.prototype = {
    call$1: function($arguments) {
      var module, t2,
        t1 = J.getInterceptor$asx($arguments),
        variable = t1.$index($arguments, 0).assertString$1("name");
      t1 = t1.$index($arguments, 1).get$realNull();
      module = t1 == null ? null : t1.assertString$1("module");
      t1 = this.$this._async_evaluate$_environment;
      t2 = variable.text;
      t2.toString;
      t2 = H.stringReplaceAllUnchecked(t2, "_", "-");
      return t1.getMixin$2$namespace(t2, module == null ? null : module.text) != null ? C.SassBoolean_true : C.SassBoolean_false;
    },
    $signature: 3
  };
  E._EvaluateVisitor_closure12.prototype = {
    call$1: function($arguments) {
      var t1 = this.$this._async_evaluate$_environment;
      if (!t1._async_environment$_inMixin)
        throw H.wrapException(E.SassScriptException$("content-exists() may only be called within a mixin."));
      return t1._async_environment$_content != null ? C.SassBoolean_true : C.SassBoolean_false;
    },
    $signature: 3
  };
  E._EvaluateVisitor_closure13.prototype = {
    call$1: function($arguments) {
      var t2, t3, t4,
        t1 = J.$index$asx($arguments, 0).assertString$1("module").text,
        module = this.$this._async_evaluate$_environment._async_environment$_modules.$index(0, t1);
      if (module == null)
        throw H.wrapException('There is no module with namespace "' + H.S(t1) + '".');
      t1 = F.Value;
      t2 = P.LinkedHashMap_LinkedHashMap$_empty(t1, t1);
      for (t3 = module.get$variables().get$entries(), t3 = t3.get$iterator(t3); t3.moveNext$0();) {
        t4 = t3.get$current(t3);
        t2.$indexSet(0, new D.SassString(t4.key, true), t4.value);
      }
      return new A.SassMap(H.ConstantMap_ConstantMap$from(t2, t1, t1));
    },
    $signature: 9
  };
  E._EvaluateVisitor_closure14.prototype = {
    call$1: function($arguments) {
      var t2, t3, t4,
        t1 = J.$index$asx($arguments, 0).assertString$1("module").text,
        module = this.$this._async_evaluate$_environment._async_environment$_modules.$index(0, t1);
      if (module == null)
        throw H.wrapException('There is no module with namespace "' + H.S(t1) + '".');
      t1 = F.Value;
      t2 = P.LinkedHashMap_LinkedHashMap$_empty(t1, t1);
      for (t3 = module.get$functions(module).get$entries(), t3 = t3.get$iterator(t3); t3.moveNext$0();) {
        t4 = t3.get$current(t3);
        t2.$indexSet(0, new D.SassString(t4.key, true), new F.SassFunction(t4.value));
      }
      return new A.SassMap(H.ConstantMap_ConstantMap$from(t2, t1, t1));
    },
    $signature: 9
  };
  E._EvaluateVisitor_closure15.prototype = {
    call$1: function($arguments) {
      var module, callable,
        t1 = J.getInterceptor$asx($arguments),
        $name = t1.$index($arguments, 0).assertString$1("name"),
        css = t1.$index($arguments, 1).get$isTruthy();
      t1 = t1.$index($arguments, 2).get$realNull();
      module = t1 == null ? null : t1.assertString$1("module");
      if (css && module != null)
        throw H.wrapException("$css and $module may not both be passed at once.");
      if (css)
        callable = new L.PlainCssCallable($name.text);
      else {
        t1 = this.$this;
        callable = t1._async_evaluate$_addExceptionSpan$2(t1._async_evaluate$_callableNode, new E._EvaluateVisitor__closure4(t1, $name, module));
      }
      if (callable != null)
        return new F.SassFunction(callable);
      throw H.wrapException("Function not found: " + $name.toString$0(0));
    },
    $signature: 33
  };
  E._EvaluateVisitor__closure4.prototype = {
    call$0: function() {
      var t2,
        t1 = this.name.text;
      t1.toString;
      t1 = H.stringReplaceAllUnchecked(t1, "_", "-");
      t2 = this.module;
      t2 = t2 == null ? null : t2.text;
      return this.$this._async_evaluate$_getFunction$2$namespace(t1, t2);
    }
  };
  E._EvaluateVisitor_closure16.prototype = {
    call$1: function($arguments) {
      return this.$call$body$_EvaluateVisitor_closure($arguments);
    },
    $call$body$_EvaluateVisitor_closure: function($arguments) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(F.Value),
        $async$returnValue, $async$self = this, t2, t3, t4, t5, t6, t7, invocation, callable, t1, $function, args;
      var $async$call$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = J.getInterceptor$asx($arguments);
              $function = t1.$index($arguments, 0);
              args = H.interceptedTypeCast(t1.$index($arguments, 1), "$isSassArgumentList");
              t1 = T.Expression;
              t2 = H.setRuntimeTypeInfo([], [t1]);
              t3 = P.String;
              t4 = $async$self.$this;
              t5 = t4._async_evaluate$_callableNode.span;
              args._wereKeywordsAccessed = true;
              t6 = args._keywords;
              if (t6.get$isEmpty(t6))
                t6 = null;
              else {
                args._wereKeywordsAccessed = true;
                t7 = F.Value;
                t7 = new F.ValueExpression(new A.SassMap(H.ConstantMap_ConstantMap$from(Y.mapMap(t6, new E._EvaluateVisitor__closure2(), new E._EvaluateVisitor__closure3(), t3, t7, t7, t7), t7, t7)), t4._async_evaluate$_callableNode.span);
                t6 = t7;
              }
              invocation = X.ArgumentInvocation$(t2, P.LinkedHashMap_LinkedHashMap$_empty(t3, t1), t5, t6, new F.ValueExpression(args, t5));
              $async$goto = $function instanceof D.SassString ? 3 : 4;
              break;
            case 3:
              // then
              N.warn("Passing a string to call() is deprecated and will be illegal\nin Dart Sass 2.0.0. Use call(get-function(" + $function.toString$0(0) + ")) instead.", true);
              $async$goto = 5;
              return P._asyncAwait(t4.visitFunctionExpression$1(new F.FunctionExpression(null, X.Interpolation$(H.setRuntimeTypeInfo([$function.text], [P.Object]), t4._async_evaluate$_callableNode.span), invocation, t4._async_evaluate$_callableNode.span)), $async$call$1);
            case 5:
              // returning from await.
              $async$returnValue = $async$result;
              // goto return
              $async$goto = 1;
              break;
            case 4:
              // join
              callable = $function.assertFunction$1("function").callable;
              $async$goto = !!J.getInterceptor$(callable).$isAsyncCallable ? 6 : 8;
              break;
            case 6:
              // then
              $async$goto = 9;
              return P._asyncAwait(t4._async_evaluate$_runFunctionCallable$3(invocation, callable, t4._async_evaluate$_callableNode), $async$call$1);
            case 9:
              // returning from await.
              $async$returnValue = $async$result;
              // goto return
              $async$goto = 1;
              break;
              // goto join
              $async$goto = 7;
              break;
            case 8:
              // else
              throw H.wrapException(E.SassScriptException$("The function " + H.S(callable.get$name()) + " is asynchronous.\nThis is probably caused by a bug in a Sass plugin."));
            case 7:
              // join
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$1, $async$completer);
    }
  };
  E._EvaluateVisitor__closure2.prototype = {
    call$2: function(key, _) {
      return new D.SassString(key, false);
    }
  };
  E._EvaluateVisitor__closure3.prototype = {
    call$2: function(_, value) {
      return value;
    }
  };
  E._EvaluateVisitor_run_closure0.prototype = {
    call$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(E.EvaluateResult),
        $async$returnValue, $async$self = this, t2, t1, url, $async$temp1, $async$temp2;
      var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.node;
              url = t1.span.file.url;
              if (url != null) {
                t2 = $async$self.$this;
                t2._async_evaluate$_activeModules.add$1(0, url);
                if (t2._async_evaluate$_nodeImporter != null)
                  if (url.get$scheme() === "file")
                    t2._async_evaluate$_includedFiles.add$1(0, $.$get$context().style.pathFromUri$1(M._parseUri(url)));
                  else if (url.toString$0(0) !== "stdin")
                    t2._async_evaluate$_includedFiles.add$1(0, url.toString$0(0));
              }
              t2 = $async$self.$this;
              $async$temp1 = E;
              $async$temp2 = t2;
              $async$goto = 3;
              return P._asyncAwait(t2._async_evaluate$_execute$2($async$self.importer, t1), $async$call$0);
            case 3:
              // returning from await.
              $async$returnValue = new $async$temp1.EvaluateResult($async$temp2._async_evaluate$_combineCss$1($async$result), t2._async_evaluate$_includedFiles);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$0, $async$completer);
    }
  };
  E._EvaluateVisitor__withWarnCallback_closure0.prototype = {
    call$2: function(message, deprecation) {
      var t1 = this.$this,
        t2 = t1._async_evaluate$_importSpan;
      return t1._async_evaluate$_warn$3$deprecation(message, t2 == null ? t1._async_evaluate$_callableNode.span : t2, deprecation);
    },
    "call*": "call$2",
    $requiredArgCount: 2
  };
  E._EvaluateVisitor__loadModule_closure0.prototype = {
    call$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Null),
        $async$handler = 1, $async$currentError, $async$next = [], $async$self = this, module, error, exception, t1, result, importer, stylesheet, canonicalUrl, t2, $async$exception;
      var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$currentError = $async$result;
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.$this;
              $async$goto = 2;
              return P._asyncAwait(B.inUseRuleAsync(new E._EvaluateVisitor__loadModule__closure0(t1, $async$self.url, $async$self.nodeForSpan), [S.Tuple2, B.AsyncImporter, V.Stylesheet]), $async$call$0);
            case 2:
              // returning from await.
              result = $async$result;
              importer = result.item1;
              stylesheet = result.item2;
              canonicalUrl = stylesheet.span.file.url;
              t2 = t1._async_evaluate$_activeModules;
              if (t2.contains$1(0, canonicalUrl))
                throw H.wrapException(t1._async_evaluate$_exception$1("Module loop: this module is already being loaded."));
              t2.add$1(0, canonicalUrl);
              module = null;
              $async$handler = 3;
              $async$goto = 6;
              return P._asyncAwait(t1._async_evaluate$_execute$2(importer, stylesheet), $async$call$0);
            case 6:
              // returning from await.
              module = $async$result;
              $async$next.push(5);
              // goto finally
              $async$goto = 4;
              break;
            case 3:
              // uncaught
              $async$next = [1];
            case 4:
              // finally
              $async$handler = 1;
              t2.remove$1(0, canonicalUrl);
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 5:
              // after finally
              $async$handler = 8;
              $async$goto = 11;
              return P._asyncAwait($async$self.callback.call$1(module), $async$call$0);
            case 11:
              // returning from await.
              $async$handler = 1;
              // goto after finally
              $async$goto = 10;
              break;
            case 8:
              // catch
              $async$handler = 7;
              $async$exception = $async$currentError;
              t2 = H.unwrapException($async$exception);
              if (t2 instanceof E.SassScriptException) {
                error = t2;
                throw H.wrapException(t1._async_evaluate$_exception$1(error.message));
              } else
                throw $async$exception;
              // goto after finally
              $async$goto = 10;
              break;
            case 7:
              // uncaught
              // goto rethrow
              $async$goto = 1;
              break;
            case 10:
              // after finally
              // implicit return
              return P._asyncReturn(null, $async$completer);
            case 1:
              // rethrow
              return P._asyncRethrow($async$currentError, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$0, $async$completer);
    }
  };
  E._EvaluateVisitor__loadModule__closure0.prototype = {
    call$0: function() {
      return this.$this._async_evaluate$_loadStylesheet$2(J.toString$0$(this.url), this.nodeForSpan.get$span());
    }
  };
  E._EvaluateVisitor__execute_closure0.prototype = {
    call$0: function() {
      return this.$call$body$_EvaluateVisitor__execute_closure();
    },
    $call$body$_EvaluateVisitor__execute_closure: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter([G.Module, B.AsyncCallable]),
        $async$returnValue, $async$self = this, extender, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, environment;
      var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = {};
              t2 = $async$self.$this;
              t3 = P.String;
              t4 = [G.Module, B.AsyncCallable];
              t5 = H.setRuntimeTypeInfo([], [t4]);
              t6 = H.setRuntimeTypeInfo([P.LinkedHashMap_LinkedHashMap$_empty(t3, F.Value)], [[P.Map, P.String, F.Value]]);
              t7 = t2._async_evaluate$_sourceMap ? H.setRuntimeTypeInfo([P.LinkedHashMap_LinkedHashMap$_empty(t3, B.AstNode)], [[P.Map, P.String, B.AstNode]]) : null;
              t8 = P.int;
              t9 = B.AsyncCallable;
              t10 = [[P.Map, P.String, B.AsyncCallable]];
              environment = new Q.AsyncEnvironment(P.LinkedHashMap_LinkedHashMap$_empty(t3, t4), null, null, t5, t6, t7, P.LinkedHashMap_LinkedHashMap$_empty(t3, t8), H.setRuntimeTypeInfo([P.LinkedHashMap_LinkedHashMap$_empty(t3, t9)], t10), P.LinkedHashMap_LinkedHashMap$_empty(t3, t8), H.setRuntimeTypeInfo([P.LinkedHashMap_LinkedHashMap$_empty(t3, t9)], t10), P.LinkedHashMap_LinkedHashMap$_empty(t3, t8), null);
              t1.css = null;
              t3 = M.SimpleSelector;
              extender = new F.Extender(P.LinkedHashMap_LinkedHashMap$_empty(t3, [P.Set, X.ModifiableCssStyleRule]), P.LinkedHashMap_LinkedHashMap$_empty(t3, [P.Map, S.ComplexSelector, S.Extension]), P.LinkedHashMap_LinkedHashMap$_empty(t3, [P.List, S.Extension]), P.LinkedHashMap_LinkedHashMap$_empty(X.CssStyleRule, [P.List, F.CssMediaQuery]), P._LinkedIdentityHashMap__LinkedIdentityHashMap$es6(t3, t8), new P._LinkedIdentityHashSet([S.ComplexSelector]), C.ExtendMode_normal);
              $async$goto = 3;
              return P._asyncAwait(t2._async_evaluate$_withEnvironment$1$2(environment, new E._EvaluateVisitor__execute__closure0(t1, t2, $async$self.importer, $async$self.stylesheet, extender), P.Null), $async$call$0);
            case 3:
              // returning from await.
              $async$returnValue = Q._EnvironmentModule__EnvironmentModule0(environment, t1.css, extender, environment._async_environment$_forwardedModules);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$0, $async$completer);
    }
  };
  E._EvaluateVisitor__execute__closure0.prototype = {
    call$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Null),
        $async$self = this, t2, t3, t4, t5, css, t1, oldImporter, oldStylesheet, oldRoot, oldParent, oldEndOfImports, oldOutOfOrderImports, oldExtender, oldStyleRule, oldMediaQueries, oldDeclarationName, oldInUnknownAtRule, oldAtRootExcludingStyleRule, oldInKeyframes;
      var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.$this;
              oldImporter = t1._async_evaluate$_importer;
              oldStylesheet = t1._async_evaluate$_stylesheet;
              oldRoot = t1._async_evaluate$_root;
              oldParent = t1._async_evaluate$_parent;
              oldEndOfImports = t1._async_evaluate$_endOfImports;
              oldOutOfOrderImports = t1._async_evaluate$_outOfOrderImports;
              oldExtender = t1._async_evaluate$_extender;
              oldStyleRule = t1._async_evaluate$_styleRule;
              oldMediaQueries = t1._async_evaluate$_mediaQueries;
              oldDeclarationName = t1._async_evaluate$_declarationName;
              oldInUnknownAtRule = t1._async_evaluate$_inUnknownAtRule;
              oldAtRootExcludingStyleRule = t1._async_evaluate$_atRootExcludingStyleRule;
              oldInKeyframes = t1._async_evaluate$_inKeyframes;
              t1._async_evaluate$_importer = $async$self.importer;
              t2 = t1._async_evaluate$_stylesheet = $async$self.stylesheet;
              t3 = t2.span;
              t4 = B.ModifiableCssNode;
              t5 = H.setRuntimeTypeInfo([], [t4]);
              t1._async_evaluate$_parent = t1._async_evaluate$_root = new V.ModifiableCssStylesheet(t3, new P.UnmodifiableListView(t5, [t4]), t5);
              t1._async_evaluate$_endOfImports = 0;
              t1._async_evaluate$_outOfOrderImports = null;
              t1._async_evaluate$_extender = $async$self.extender;
              t1._async_evaluate$_declarationName = t1._async_evaluate$_mediaQueries = t1._async_evaluate$_styleRule = null;
              t1._async_evaluate$_inKeyframes = t1._async_evaluate$_atRootExcludingStyleRule = t1._async_evaluate$_inUnknownAtRule = false;
              $async$goto = 2;
              return P._asyncAwait(t1.visitStylesheet$1(t2), $async$call$0);
            case 2:
              // returning from await.
              css = t1._async_evaluate$_outOfOrderImports == null ? t1._async_evaluate$_root : new V.CssStylesheet(new P.UnmodifiableListView(t1._async_evaluate$_addOutOfOrderImports$0(), [B.CssNode]), t3);
              $async$self._box_0.css = css;
              t1._async_evaluate$_importer = oldImporter;
              t1._async_evaluate$_stylesheet = oldStylesheet;
              t1._async_evaluate$_root = oldRoot;
              t1._async_evaluate$_parent = oldParent;
              t1._async_evaluate$_endOfImports = oldEndOfImports;
              t1._async_evaluate$_outOfOrderImports = oldOutOfOrderImports;
              t1._async_evaluate$_extender = oldExtender;
              t1._async_evaluate$_styleRule = oldStyleRule;
              t1._async_evaluate$_mediaQueries = oldMediaQueries;
              t1._async_evaluate$_declarationName = oldDeclarationName;
              t1._async_evaluate$_inUnknownAtRule = oldInUnknownAtRule;
              t1._async_evaluate$_atRootExcludingStyleRule = oldAtRootExcludingStyleRule;
              t1._async_evaluate$_inKeyframes = oldInKeyframes;
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$0, $async$completer);
    }
  };
  E._EvaluateVisitor__combineCss_closure2.prototype = {
    call$1: function(module) {
      return module.get$transitivelyContainsCss();
    }
  };
  E._EvaluateVisitor__combineCss_closure3.prototype = {
    call$1: function(target) {
      return !this.selectors.contains$1(0, target);
    }
  };
  E._EvaluateVisitor__combineCss_closure4.prototype = {
    call$1: function(module) {
      return module.cloneCss$0();
    }
  };
  E._EvaluateVisitor__extendModules_closure1.prototype = {
    call$1: function(target) {
      return !this.originalSelectors.contains$1(0, target);
    }
  };
  E._EvaluateVisitor__extendModules_closure2.prototype = {
    call$0: function() {
      return H.setRuntimeTypeInfo([], [F.Extender]);
    }
  };
  E._EvaluateVisitor__topologicalModules_visitModule0.prototype = {
    call$1: function(module) {
      var t1, t2, t3, _i, upstream;
      for (t1 = module.get$upstream(), t2 = t1.length, t3 = this.seen, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
        upstream = t1[_i];
        if (upstream.get$transitivelyContainsCss() && t3.add$1(0, upstream))
          this.call$1(upstream);
      }
      this.sorted.addFirst$1(module);
    }
  };
  E._EvaluateVisitor_visitAtRootRule_closure2.prototype = {
    call$0: function() {
      var t1 = S.SpanScanner$(this.resolved, null);
      return new V.AtRootQueryParser(t1, this.$this._async_evaluate$_logger).parse$0();
    }
  };
  E._EvaluateVisitor_visitAtRootRule_closure3.prototype = {
    call$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Null),
        $async$self = this, t1, t2, t3, _i;
      var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.node.children, t2 = t1.length, t3 = $async$self.$this, _i = 0;
            case 2:
              // for condition
              if (!(_i < t2)) {
                // goto after for
                $async$goto = 4;
                break;
              }
              $async$goto = 5;
              return P._asyncAwait(t1[_i].accept$1(t3), $async$call$0);
            case 5:
              // returning from await.
            case 3:
              // for update
              ++_i;
              // goto for condition
              $async$goto = 2;
              break;
            case 4:
              // after for
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$0, $async$completer);
    }
  };
  E._EvaluateVisitor_visitAtRootRule_closure4.prototype = {
    call$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Null),
        $async$self = this, t1, t2, t3, _i;
      var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.node.children, t2 = t1.length, t3 = $async$self.$this, _i = 0;
            case 2:
              // for condition
              if (!(_i < t2)) {
                // goto after for
                $async$goto = 4;
                break;
              }
              $async$goto = 5;
              return P._asyncAwait(t1[_i].accept$1(t3), $async$call$0);
            case 5:
              // returning from await.
            case 3:
              // for update
              ++_i;
              // goto for condition
              $async$goto = 2;
              break;
            case 4:
              // after for
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$0, $async$completer);
    },
    "call*": "call$0",
    $requiredArgCount: 0
  };
  E._EvaluateVisitor__scopeForAtRoot_closure5.prototype = {
    call$1: function(callback) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Null),
        $async$self = this, t1, oldParent;
      var $async$call$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.$this;
              oldParent = t1._async_evaluate$_parent;
              t1._async_evaluate$_parent = $async$self.newParent;
              $async$goto = 2;
              return P._asyncAwait(t1._async_evaluate$_environment.scope$1$2$when(callback, $async$self.node.hasDeclarations, -1), $async$call$1);
            case 2:
              // returning from await.
              t1._async_evaluate$_parent = oldParent;
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$1, $async$completer);
    }
  };
  E._EvaluateVisitor__scopeForAtRoot_closure6.prototype = {
    call$1: function(callback) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Null),
        $async$self = this, t1, oldAtRootExcludingStyleRule;
      var $async$call$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.$this;
              oldAtRootExcludingStyleRule = t1._async_evaluate$_atRootExcludingStyleRule;
              t1._async_evaluate$_atRootExcludingStyleRule = true;
              $async$goto = 2;
              return P._asyncAwait($async$self.innerScope.call$1(callback), $async$call$1);
            case 2:
              // returning from await.
              t1._async_evaluate$_atRootExcludingStyleRule = oldAtRootExcludingStyleRule;
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$1, $async$completer);
    }
  };
  E._EvaluateVisitor__scopeForAtRoot_closure7.prototype = {
    call$1: function(callback) {
      return this.$this._async_evaluate$_withMediaQueries$1$2(null, new E._EvaluateVisitor__scopeForAtRoot__closure0(this.innerScope, callback), P.Null);
    }
  };
  E._EvaluateVisitor__scopeForAtRoot__closure0.prototype = {
    call$0: function() {
      return this.innerScope.call$1(this.callback);
    }
  };
  E._EvaluateVisitor__scopeForAtRoot_closure8.prototype = {
    call$1: function(callback) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Null),
        $async$self = this, t1, wasInKeyframes;
      var $async$call$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.$this;
              wasInKeyframes = t1._async_evaluate$_inKeyframes;
              t1._async_evaluate$_inKeyframes = false;
              $async$goto = 2;
              return P._asyncAwait($async$self.innerScope.call$1(callback), $async$call$1);
            case 2:
              // returning from await.
              t1._async_evaluate$_inKeyframes = wasInKeyframes;
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$1, $async$completer);
    }
  };
  E._EvaluateVisitor__scopeForAtRoot_closure9.prototype = {
    call$1: function($parent) {
      return !!J.getInterceptor$($parent).$isCssAtRule;
    }
  };
  E._EvaluateVisitor__scopeForAtRoot_closure10.prototype = {
    call$1: function(callback) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Null),
        $async$self = this, t1, wasInUnknownAtRule;
      var $async$call$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.$this;
              wasInUnknownAtRule = t1._async_evaluate$_inUnknownAtRule;
              t1._async_evaluate$_inUnknownAtRule = false;
              $async$goto = 2;
              return P._asyncAwait($async$self.innerScope.call$1(callback), $async$call$1);
            case 2:
              // returning from await.
              t1._async_evaluate$_inUnknownAtRule = wasInUnknownAtRule;
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$1, $async$completer);
    }
  };
  E._EvaluateVisitor_visitContentRule_closure0.prototype = {
    call$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Null),
        $async$returnValue, $async$self = this, t1, t2, t3, _i;
      var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.content.declaration.children, t2 = t1.length, t3 = $async$self.$this, _i = 0;
            case 3:
              // for condition
              if (!(_i < t2)) {
                // goto after for
                $async$goto = 5;
                break;
              }
              $async$goto = 6;
              return P._asyncAwait(t1[_i].accept$1(t3), $async$call$0);
            case 6:
              // returning from await.
            case 4:
              // for update
              ++_i;
              // goto for condition
              $async$goto = 3;
              break;
            case 5:
              // after for
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$0, $async$completer);
    }
  };
  E._EvaluateVisitor_visitDeclaration_closure0.prototype = {
    call$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Null),
        $async$self = this, t1, t2, t3, _i;
      var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.node.children, t2 = t1.length, t3 = $async$self.$this, _i = 0;
            case 2:
              // for condition
              if (!(_i < t2)) {
                // goto after for
                $async$goto = 4;
                break;
              }
              $async$goto = 5;
              return P._asyncAwait(t1[_i].accept$1(t3), $async$call$0);
            case 5:
              // returning from await.
            case 3:
              // for update
              ++_i;
              // goto for condition
              $async$goto = 2;
              break;
            case 4:
              // after for
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$0, $async$completer);
    }
  };
  E._EvaluateVisitor_visitEachRule_closure2.prototype = {
    call$1: function(value) {
      return this.$this._async_evaluate$_environment.setLocalVariable$3(C.JSArray_methods.get$first(this.node.variables), value.withoutSlash$0(), this.nodeForSpan);
    }
  };
  E._EvaluateVisitor_visitEachRule_closure3.prototype = {
    call$1: function(value) {
      return this.$this._async_evaluate$_setMultipleVariables$3(this.node.variables, value, this.nodeForSpan);
    }
  };
  E._EvaluateVisitor_visitEachRule_closure4.prototype = {
    call$0: function() {
      var _this = this,
        t1 = _this.$this;
      return t1._async_evaluate$_handleReturn$2(_this.list.get$asList(), new E._EvaluateVisitor_visitEachRule__closure0(t1, _this.setVariables, _this.node));
    }
  };
  E._EvaluateVisitor_visitEachRule__closure0.prototype = {
    call$1: function(element) {
      var t1;
      this.setVariables.call$1(element);
      t1 = this.$this;
      return t1._async_evaluate$_handleReturn$2(this.node.children, new E._EvaluateVisitor_visitEachRule___closure0(t1));
    }
  };
  E._EvaluateVisitor_visitEachRule___closure0.prototype = {
    call$1: function(child) {
      return child.accept$1(this.$this);
    }
  };
  E._EvaluateVisitor_visitExtendRule_closure0.prototype = {
    call$0: function() {
      return D.SelectorList_SelectorList$parse(B.trimAscii(this.targetText.get$value(), true), false, true, this.$this._async_evaluate$_logger);
    }
  };
  E._EvaluateVisitor_visitAtRule_closure1.prototype = {
    call$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Null),
        $async$self = this, t3, _i, t1, t2;
      var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.$this;
              t2 = t1._async_evaluate$_styleRule;
              $async$goto = !(t2 != null && !t1._async_evaluate$_atRootExcludingStyleRule) || t1._async_evaluate$_inKeyframes ? 2 : 4;
              break;
            case 2:
              // then
              t2 = $async$self.node.children, t3 = t2.length, _i = 0;
            case 5:
              // for condition
              if (!(_i < t3)) {
                // goto after for
                $async$goto = 7;
                break;
              }
              $async$goto = 8;
              return P._asyncAwait(t2[_i].accept$1(t1), $async$call$0);
            case 8:
              // returning from await.
            case 6:
              // for update
              ++_i;
              // goto for condition
              $async$goto = 5;
              break;
            case 7:
              // after for
              // goto join
              $async$goto = 3;
              break;
            case 4:
              // else
              $async$goto = 9;
              return P._asyncAwait(t1._async_evaluate$_withParent$2$3$scopeWhen(X.ModifiableCssStyleRule$(t2.selector, t2.span, t2.originalSelector), new E._EvaluateVisitor_visitAtRule__closure0(t1, $async$self.node), false, X.ModifiableCssStyleRule, P.Null), $async$call$0);
            case 9:
              // returning from await.
            case 3:
              // join
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$0, $async$completer);
    }
  };
  E._EvaluateVisitor_visitAtRule__closure0.prototype = {
    call$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Null),
        $async$self = this, t1, t2, t3, _i;
      var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.node.children, t2 = t1.length, t3 = $async$self.$this, _i = 0;
            case 2:
              // for condition
              if (!(_i < t2)) {
                // goto after for
                $async$goto = 4;
                break;
              }
              $async$goto = 5;
              return P._asyncAwait(t1[_i].accept$1(t3), $async$call$0);
            case 5:
              // returning from await.
            case 3:
              // for update
              ++_i;
              // goto for condition
              $async$goto = 2;
              break;
            case 4:
              // after for
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$0, $async$completer);
    }
  };
  E._EvaluateVisitor_visitAtRule_closure2.prototype = {
    call$1: function(node) {
      return !!J.getInterceptor$(node).$isCssStyleRule;
    }
  };
  E._EvaluateVisitor_visitForRule_closure4.prototype = {
    call$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(T.SassNumber),
        $async$returnValue, $async$self = this;
      var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              return P._asyncAwait($async$self.node.from.accept$1($async$self.$this), $async$call$0);
            case 3:
              // returning from await.
              $async$returnValue = $async$result.assertNumber$0();
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$0, $async$completer);
    }
  };
  E._EvaluateVisitor_visitForRule_closure5.prototype = {
    call$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(T.SassNumber),
        $async$returnValue, $async$self = this;
      var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              return P._asyncAwait($async$self.node.to.accept$1($async$self.$this), $async$call$0);
            case 3:
              // returning from await.
              $async$returnValue = $async$result.assertNumber$0();
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$0, $async$completer);
    }
  };
  E._EvaluateVisitor_visitForRule_closure6.prototype = {
    call$0: function() {
      var t1 = this.toNumber,
        t2 = t1.numeratorUnits;
      t1 = t1.denominatorUnits;
      return T.SassNumber$withUnits(this.fromNumber.valueInUnits$2(t2, t1), t1, t2).assertInt$0();
    }
  };
  E._EvaluateVisitor_visitForRule_closure7.prototype = {
    call$0: function() {
      return this.toNumber.assertInt$0();
    }
  };
  E._EvaluateVisitor_visitForRule_closure8.prototype = {
    call$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(F.Value),
        $async$returnValue, $async$self = this, i, t3, t4, t5, t6, result, t1, t2, nodeForSpan;
      var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.$this;
              t2 = $async$self.node;
              nodeForSpan = t1._async_evaluate$_expressionNode$1(t2.from);
              i = $async$self.from, t3 = $async$self._box_0, t4 = $async$self.direction, t5 = t2.children, t2 = t2.variable;
            case 3:
              // for condition
              if (!(i !== t3.to)) {
                // goto after for
                $async$goto = 5;
                break;
              }
              t6 = t1._async_evaluate$_environment;
              t6.setLocalVariable$3(t2, new T.SassNumber(i, C.List_empty0, C.List_empty0, null), nodeForSpan);
              $async$goto = 6;
              return P._asyncAwait(t1._async_evaluate$_handleReturn$2(t5, new E._EvaluateVisitor_visitForRule__closure0(t1)), $async$call$0);
            case 6:
              // returning from await.
              result = $async$result;
              if (result != null) {
                $async$returnValue = result;
                // goto return
                $async$goto = 1;
                break;
              }
            case 4:
              // for update
              i += t4;
              // goto for condition
              $async$goto = 3;
              break;
            case 5:
              // after for
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$0, $async$completer);
    }
  };
  E._EvaluateVisitor_visitForRule__closure0.prototype = {
    call$1: function(child) {
      return child.accept$1(this.$this);
    }
  };
  E._EvaluateVisitor_visitForwardRule_closure0.prototype = {
    call$1: function(module) {
      this.$this._async_evaluate$_environment.forwardModule$2(module, this.node);
    }
  };
  E._EvaluateVisitor_visitIfRule_closure0.prototype = {
    call$0: function() {
      var t1 = this.$this;
      return t1._async_evaluate$_handleReturn$2(this._box_0.clause.children, new E._EvaluateVisitor_visitIfRule__closure0(t1));
    }
  };
  E._EvaluateVisitor_visitIfRule__closure0.prototype = {
    call$1: function(child) {
      return child.accept$1(this.$this);
    }
  };
  E._EvaluateVisitor__visitDynamicImport_closure0.prototype = {
    call$0: function() {
      return this.$call$body$_EvaluateVisitor__visitDynamicImport_closure();
    },
    $call$body$_EvaluateVisitor__visitDynamicImport_closure: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Null),
        $async$returnValue, $async$self = this, url, t3, t4, environment, module, visitor, _box_0, t1, t2, result, importer, stylesheet;
      var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              _box_0 = {};
              t1 = $async$self.$this;
              t2 = $async$self.$import;
              $async$goto = 3;
              return P._asyncAwait(t1._async_evaluate$_loadStylesheet$2(t2.url, t2.span), $async$call$0);
            case 3:
              // returning from await.
              result = $async$result;
              importer = result.item1;
              stylesheet = result.item2;
              t2 = stylesheet.span;
              url = t2.file.url;
              t3 = t1._async_evaluate$_activeModules;
              if (!t3.add$1(0, url))
                throw H.wrapException(t1._async_evaluate$_exception$1("This file is already being loaded."));
              t3.add$1(0, url);
              t4 = new P.UnmodifiableListView(stylesheet._uses, [T.UseRule]);
              if (t4.get$length(t4) === 0) {
                t4 = new P.UnmodifiableListView(stylesheet._forwards, [L.ForwardRule]);
                t4 = t4.get$length(t4) === 0;
              } else
                t4 = false;
              $async$goto = t4 ? 4 : 5;
              break;
            case 4:
              // then
              $async$goto = 6;
              return P._asyncAwait(t1._async_evaluate$_withEnvironment$1$2(t1._async_evaluate$_environment.global$0(), new E._EvaluateVisitor__visitDynamicImport__closure1(t1, importer, stylesheet), P.Null), $async$call$0);
            case 6:
              // returning from await.
              t3.remove$1(0, url);
              // goto return
              $async$goto = 1;
              break;
            case 5:
              // join
              _box_0.children = null;
              environment = t1._async_evaluate$_environment.global$0();
              $async$goto = 7;
              return P._asyncAwait(t1._async_evaluate$_withEnvironment$1$2(environment, new E._EvaluateVisitor__visitDynamicImport__closure2(_box_0, t1, importer, stylesheet), P.Null), $async$call$0);
            case 7:
              // returning from await.
              module = Q._EnvironmentModule__EnvironmentModule0(environment, new V.CssStylesheet(new P.UnmodifiableListView(C.List_empty3, [B.CssNode]), t2), C.C_EmptyExtender, environment._async_environment$_forwardedModules);
              t1._async_evaluate$_environment.importForwards$1(module);
              $async$goto = module.transitivelyContainsCss ? 8 : 9;
              break;
            case 8:
              // then
              $async$goto = 10;
              return P._asyncAwait(t1._async_evaluate$_combineCss$2$clone(module, module.transitivelyContainsExtensions).accept$1(t1), $async$call$0);
            case 10:
              // returning from await.
            case 9:
              // join
              visitor = new E._ImportedCssVisitor0(t1);
              for (t1 = J.get$iterator$ax(_box_0.children); t1.moveNext$0();)
                t1.get$current(t1).accept$1(visitor);
              t3.remove$1(0, url);
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$0, $async$completer);
    }
  };
  E._EvaluateVisitor__visitDynamicImport__closure1.prototype = {
    call$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Null),
        $async$self = this, t2, t1, oldImporter, oldStylesheet;
      var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.$this;
              oldImporter = t1._async_evaluate$_importer;
              oldStylesheet = t1._async_evaluate$_stylesheet;
              t1._async_evaluate$_importer = $async$self.importer;
              t2 = $async$self.stylesheet;
              t1._async_evaluate$_stylesheet = t2;
              $async$goto = 2;
              return P._asyncAwait(t1.visitStylesheet$1(t2), $async$call$0);
            case 2:
              // returning from await.
              t1._async_evaluate$_importer = oldImporter;
              t1._async_evaluate$_stylesheet = oldStylesheet;
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$0, $async$completer);
    }
  };
  E._EvaluateVisitor__visitDynamicImport__closure2.prototype = {
    call$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Null),
        $async$self = this, t2, t3, t4, t1, oldImporter, oldStylesheet, oldRoot, oldParent, oldEndOfImports, oldOutOfOrderImports;
      var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.$this;
              oldImporter = t1._async_evaluate$_importer;
              oldStylesheet = t1._async_evaluate$_stylesheet;
              oldRoot = t1._async_evaluate$_root;
              oldParent = t1._async_evaluate$_parent;
              oldEndOfImports = t1._async_evaluate$_endOfImports;
              oldOutOfOrderImports = t1._async_evaluate$_outOfOrderImports;
              t1._async_evaluate$_importer = $async$self.importer;
              t2 = t1._async_evaluate$_stylesheet = $async$self.stylesheet;
              t3 = B.ModifiableCssNode;
              t4 = H.setRuntimeTypeInfo([], [t3]);
              t1._async_evaluate$_parent = t1._async_evaluate$_root = new V.ModifiableCssStylesheet(t2.span, new P.UnmodifiableListView(t4, [t3]), t4);
              t1._async_evaluate$_endOfImports = 0;
              t1._async_evaluate$_outOfOrderImports = null;
              $async$goto = 2;
              return P._asyncAwait(t1.visitStylesheet$1(t2), $async$call$0);
            case 2:
              // returning from await.
              $async$self._box_0.children = t1._async_evaluate$_addOutOfOrderImports$0();
              t1._async_evaluate$_importer = oldImporter;
              t1._async_evaluate$_stylesheet = oldStylesheet;
              t1._async_evaluate$_root = oldRoot;
              t1._async_evaluate$_parent = oldParent;
              t1._async_evaluate$_endOfImports = oldEndOfImports;
              t1._async_evaluate$_outOfOrderImports = oldOutOfOrderImports;
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$0, $async$completer);
    }
  };
  E._EvaluateVisitor_visitIncludeRule_closure1.prototype = {
    call$0: function() {
      var t1 = this.node;
      return this.$this._async_evaluate$_environment.getMixin$2$namespace(t1.name, t1.namespace);
    }
  };
  E._EvaluateVisitor_visitIncludeRule_closure2.prototype = {
    call$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Null),
        $async$returnValue, $async$self = this, t1;
      var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.$this;
              $async$goto = 3;
              return P._asyncAwait(t1._async_evaluate$_environment.withContent$2($async$self.contentCallable, new E._EvaluateVisitor_visitIncludeRule__closure0(t1, $async$self.mixin)), $async$call$0);
            case 3:
              // returning from await.
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$0, $async$completer);
    }
  };
  E._EvaluateVisitor_visitIncludeRule__closure0.prototype = {
    call$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Null),
        $async$returnValue, $async$self = this, t1;
      var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.$this;
              $async$goto = 3;
              return P._asyncAwait(t1._async_evaluate$_environment.asMixin$1(new E._EvaluateVisitor_visitIncludeRule___closure0(t1, $async$self.mixin)), $async$call$0);
            case 3:
              // returning from await.
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$0, $async$completer);
    }
  };
  E._EvaluateVisitor_visitIncludeRule___closure0.prototype = {
    call$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Null),
        $async$self = this, t1, t2, t3, _i;
      var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.mixin.declaration.children, t2 = t1.length, t3 = $async$self.$this, _i = 0;
            case 2:
              // for condition
              if (!(_i < t2)) {
                // goto after for
                $async$goto = 4;
                break;
              }
              $async$goto = 5;
              return P._asyncAwait(t1[_i].accept$1(t3), $async$call$0);
            case 5:
              // returning from await.
            case 3:
              // for update
              ++_i;
              // goto for condition
              $async$goto = 2;
              break;
            case 4:
              // after for
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$0, $async$completer);
    }
  };
  E._EvaluateVisitor_visitMediaRule_closure1.prototype = {
    call$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Null),
        $async$self = this, t1, t2;
      var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.$this;
              t2 = $async$self.mergedQueries;
              if (t2 == null)
                t2 = $async$self.queries;
              $async$goto = 2;
              return P._asyncAwait(t1._async_evaluate$_withMediaQueries$1$2(t2, new E._EvaluateVisitor_visitMediaRule__closure0(t1, $async$self.node), P.Null), $async$call$0);
            case 2:
              // returning from await.
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$0, $async$completer);
    }
  };
  E._EvaluateVisitor_visitMediaRule__closure0.prototype = {
    call$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Null),
        $async$self = this, t3, _i, t1, t2;
      var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.$this;
              t2 = t1._async_evaluate$_styleRule;
              $async$goto = !(t2 != null && !t1._async_evaluate$_atRootExcludingStyleRule) ? 2 : 4;
              break;
            case 2:
              // then
              t2 = $async$self.node.children, t3 = t2.length, _i = 0;
            case 5:
              // for condition
              if (!(_i < t3)) {
                // goto after for
                $async$goto = 7;
                break;
              }
              $async$goto = 8;
              return P._asyncAwait(t2[_i].accept$1(t1), $async$call$0);
            case 8:
              // returning from await.
            case 6:
              // for update
              ++_i;
              // goto for condition
              $async$goto = 5;
              break;
            case 7:
              // after for
              // goto join
              $async$goto = 3;
              break;
            case 4:
              // else
              $async$goto = 9;
              return P._asyncAwait(t1._async_evaluate$_withParent$2$3$scopeWhen(X.ModifiableCssStyleRule$(t2.selector, t2.span, t2.originalSelector), new E._EvaluateVisitor_visitMediaRule___closure0(t1, $async$self.node), false, X.ModifiableCssStyleRule, P.Null), $async$call$0);
            case 9:
              // returning from await.
            case 3:
              // join
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$0, $async$completer);
    }
  };
  E._EvaluateVisitor_visitMediaRule___closure0.prototype = {
    call$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Null),
        $async$self = this, t1, t2, t3, _i;
      var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.node.children, t2 = t1.length, t3 = $async$self.$this, _i = 0;
            case 2:
              // for condition
              if (!(_i < t2)) {
                // goto after for
                $async$goto = 4;
                break;
              }
              $async$goto = 5;
              return P._asyncAwait(t1[_i].accept$1(t3), $async$call$0);
            case 5:
              // returning from await.
            case 3:
              // for update
              ++_i;
              // goto for condition
              $async$goto = 2;
              break;
            case 4:
              // after for
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$0, $async$completer);
    }
  };
  E._EvaluateVisitor_visitMediaRule_closure2.prototype = {
    call$1: function(node) {
      var t1 = J.getInterceptor$(node);
      if (!t1.$isCssStyleRule)
        t1 = this.mergedQueries != null && !!t1.$isCssMediaRule;
      else
        t1 = true;
      return t1;
    }
  };
  E._EvaluateVisitor__visitMediaQueries_closure0.prototype = {
    call$0: function() {
      var t1 = S.SpanScanner$(this.resolved, null);
      return new F.MediaQueryParser(t1, this.$this._async_evaluate$_logger).parse$0();
    }
  };
  E._EvaluateVisitor_visitStyleRule_closure6.prototype = {
    call$0: function() {
      var t1 = S.SpanScanner$(this.selectorText.get$value(), null);
      return new E.KeyframeSelectorParser(t1, this.$this._async_evaluate$_logger).parse$0();
    }
  };
  E._EvaluateVisitor_visitStyleRule_closure7.prototype = {
    call$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Null),
        $async$self = this, t1, t2, t3, _i;
      var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.node.children, t2 = t1.length, t3 = $async$self.$this, _i = 0;
            case 2:
              // for condition
              if (!(_i < t2)) {
                // goto after for
                $async$goto = 4;
                break;
              }
              $async$goto = 5;
              return P._asyncAwait(t1[_i].accept$1(t3), $async$call$0);
            case 5:
              // returning from await.
            case 3:
              // for update
              ++_i;
              // goto for condition
              $async$goto = 2;
              break;
            case 4:
              // after for
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$0, $async$completer);
    }
  };
  E._EvaluateVisitor_visitStyleRule_closure8.prototype = {
    call$1: function(node) {
      return !!J.getInterceptor$(node).$isCssStyleRule;
    }
  };
  E._EvaluateVisitor_visitStyleRule_closure9.prototype = {
    call$0: function() {
      var t1 = this.selectorText.get$value(),
        t2 = this.$this,
        t3 = !t2._async_evaluate$_stylesheet.plainCss;
      return D.SelectorList_SelectorList$parse(t1, t3, t3, t2._async_evaluate$_logger);
    }
  };
  E._EvaluateVisitor_visitStyleRule_closure10.prototype = {
    call$0: function() {
      var t1 = this._box_0.parsedSelector,
        t2 = this.$this,
        t3 = t2._async_evaluate$_styleRule;
      t3 = t3 == null ? null : t3.originalSelector;
      return t1.resolveParentSelectors$2$implicitParent(t3, !t2._async_evaluate$_atRootExcludingStyleRule);
    }
  };
  E._EvaluateVisitor_visitStyleRule_closure11.prototype = {
    call$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Null),
        $async$self = this, t1;
      var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.$this;
              $async$goto = 2;
              return P._asyncAwait(t1._async_evaluate$_withStyleRule$1$2($async$self.rule, new E._EvaluateVisitor_visitStyleRule__closure0(t1, $async$self.node), P.Null), $async$call$0);
            case 2:
              // returning from await.
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$0, $async$completer);
    }
  };
  E._EvaluateVisitor_visitStyleRule__closure0.prototype = {
    call$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Null),
        $async$self = this, t1, t2, t3, _i;
      var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.node.children, t2 = t1.length, t3 = $async$self.$this, _i = 0;
            case 2:
              // for condition
              if (!(_i < t2)) {
                // goto after for
                $async$goto = 4;
                break;
              }
              $async$goto = 5;
              return P._asyncAwait(t1[_i].accept$1(t3), $async$call$0);
            case 5:
              // returning from await.
            case 3:
              // for update
              ++_i;
              // goto for condition
              $async$goto = 2;
              break;
            case 4:
              // after for
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$0, $async$completer);
    }
  };
  E._EvaluateVisitor_visitStyleRule_closure12.prototype = {
    call$1: function(node) {
      return !!J.getInterceptor$(node).$isCssStyleRule;
    }
  };
  E._EvaluateVisitor_visitSupportsRule_closure1.prototype = {
    call$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Null),
        $async$self = this, t3, _i, t1, t2;
      var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.$this;
              t2 = t1._async_evaluate$_styleRule;
              $async$goto = !(t2 != null && !t1._async_evaluate$_atRootExcludingStyleRule) ? 2 : 4;
              break;
            case 2:
              // then
              t2 = $async$self.node.children, t3 = t2.length, _i = 0;
            case 5:
              // for condition
              if (!(_i < t3)) {
                // goto after for
                $async$goto = 7;
                break;
              }
              $async$goto = 8;
              return P._asyncAwait(t2[_i].accept$1(t1), $async$call$0);
            case 8:
              // returning from await.
            case 6:
              // for update
              ++_i;
              // goto for condition
              $async$goto = 5;
              break;
            case 7:
              // after for
              // goto join
              $async$goto = 3;
              break;
            case 4:
              // else
              $async$goto = 9;
              return P._asyncAwait(t1._async_evaluate$_withParent$2$2(X.ModifiableCssStyleRule$(t2.selector, t2.span, t2.originalSelector), new E._EvaluateVisitor_visitSupportsRule__closure0(t1, $async$self.node), X.ModifiableCssStyleRule, P.Null), $async$call$0);
            case 9:
              // returning from await.
            case 3:
              // join
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$0, $async$completer);
    }
  };
  E._EvaluateVisitor_visitSupportsRule__closure0.prototype = {
    call$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Null),
        $async$self = this, t1, t2, t3, _i;
      var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.node.children, t2 = t1.length, t3 = $async$self.$this, _i = 0;
            case 2:
              // for condition
              if (!(_i < t2)) {
                // goto after for
                $async$goto = 4;
                break;
              }
              $async$goto = 5;
              return P._asyncAwait(t1[_i].accept$1(t3), $async$call$0);
            case 5:
              // returning from await.
            case 3:
              // for update
              ++_i;
              // goto for condition
              $async$goto = 2;
              break;
            case 4:
              // after for
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$0, $async$completer);
    }
  };
  E._EvaluateVisitor_visitSupportsRule_closure2.prototype = {
    call$1: function(node) {
      return !!J.getInterceptor$(node).$isCssStyleRule;
    }
  };
  E._EvaluateVisitor_visitVariableDeclaration_closure1.prototype = {
    call$0: function() {
      var t1 = this.node;
      return this.$this._async_evaluate$_environment.getVariable$2$namespace(t1.name, t1.namespace);
    }
  };
  E._EvaluateVisitor_visitVariableDeclaration_closure2.prototype = {
    call$0: function() {
      var t1 = this.$this,
        t2 = this.node;
      t1._async_evaluate$_environment.setVariable$5$global$namespace(t2.name, this.value, t1._async_evaluate$_expressionNode$1(t2.expression), t2.isGlobal, t2.namespace);
    }
  };
  E._EvaluateVisitor_visitUseRule_closure0.prototype = {
    call$1: function(module) {
      this.$this._async_evaluate$_environment.addModule$2$namespace(module, this.node.namespace);
    }
  };
  E._EvaluateVisitor_visitWarnRule_closure0.prototype = {
    call$0: function() {
      return this.node.expression.accept$1(this.$this);
    }
  };
  E._EvaluateVisitor_visitWhileRule_closure0.prototype = {
    call$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(F.Value),
        $async$returnValue, $async$self = this, t1, t2, t3, result;
      var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.node, t2 = t1.condition, t3 = $async$self.$this, t1 = t1.children;
            case 3:
              // for condition
              $async$goto = 5;
              return P._asyncAwait(t2.accept$1(t3), $async$call$0);
            case 5:
              // returning from await.
              if (!$async$result.get$isTruthy()) {
                // goto after for
                $async$goto = 4;
                break;
              }
              $async$goto = 6;
              return P._asyncAwait(t3._async_evaluate$_handleReturn$2(t1, new E._EvaluateVisitor_visitWhileRule__closure0(t3)), $async$call$0);
            case 6:
              // returning from await.
              result = $async$result;
              if (result != null) {
                $async$returnValue = result;
                // goto return
                $async$goto = 1;
                break;
              }
              // goto for condition
              $async$goto = 3;
              break;
            case 4:
              // after for
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$0, $async$completer);
    }
  };
  E._EvaluateVisitor_visitWhileRule__closure0.prototype = {
    call$1: function(child) {
      return child.accept$1(this.$this);
    }
  };
  E._EvaluateVisitor_visitBinaryOperationExpression_closure0.prototype = {
    call$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(F.Value),
        $async$returnValue, $async$self = this, right, result, t1, t2, left, $async$temp1, $async$temp2;
      var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.node;
              t2 = $async$self.$this;
              $async$goto = 3;
              return P._asyncAwait(t1.left.accept$1(t2), $async$call$0);
            case 3:
              // returning from await.
              left = $async$result;
            case 4:
              // switch
              switch (t1.operator) {
                case C.BinaryOperator_kjl:
                  // goto case
                  $async$goto = 6;
                  break;
                case C.BinaryOperator_or_or_1:
                  // goto case
                  $async$goto = 7;
                  break;
                case C.BinaryOperator_and_and_2:
                  // goto case
                  $async$goto = 8;
                  break;
                case C.BinaryOperator_YlX:
                  // goto case
                  $async$goto = 9;
                  break;
                case C.BinaryOperator_i5H:
                  // goto case
                  $async$goto = 10;
                  break;
                case C.BinaryOperator_AcR:
                  // goto case
                  $async$goto = 11;
                  break;
                case C.BinaryOperator_1da:
                  // goto case
                  $async$goto = 12;
                  break;
                case C.BinaryOperator_8qt:
                  // goto case
                  $async$goto = 13;
                  break;
                case C.BinaryOperator_33h:
                  // goto case
                  $async$goto = 14;
                  break;
                case C.BinaryOperator_AcR0:
                  // goto case
                  $async$goto = 15;
                  break;
                case C.BinaryOperator_iyO:
                  // goto case
                  $async$goto = 16;
                  break;
                case C.BinaryOperator_O1M:
                  // goto case
                  $async$goto = 17;
                  break;
                case C.BinaryOperator_RTB:
                  // goto case
                  $async$goto = 18;
                  break;
                case C.BinaryOperator_2ad:
                  // goto case
                  $async$goto = 19;
                  break;
                default:
                  // goto default
                  $async$goto = 20;
                  break;
              }
              break;
            case 6:
              // case
              $async$goto = 21;
              return P._asyncAwait(t1.right.accept$1(t2), $async$call$0);
            case 21:
              // returning from await.
              right = $async$result;
              left.toString;
              t1 = N.serializeValue(left, false, true) + "=";
              right.toString;
              $async$returnValue = new D.SassString(t1 + N.serializeValue(right, false, true), false);
              // goto return
              $async$goto = 1;
              break;
            case 7:
              // case
              $async$goto = left.get$isTruthy() ? 22 : 24;
              break;
            case 22:
              // then
              $async$result = left;
              // goto join
              $async$goto = 23;
              break;
            case 24:
              // else
              $async$goto = 25;
              return P._asyncAwait(t1.right.accept$1(t2), $async$call$0);
            case 25:
              // returning from await.
            case 23:
              // join
              $async$returnValue = $async$result;
              // goto return
              $async$goto = 1;
              break;
            case 8:
              // case
              $async$goto = left.get$isTruthy() ? 26 : 28;
              break;
            case 26:
              // then
              $async$goto = 29;
              return P._asyncAwait(t1.right.accept$1(t2), $async$call$0);
            case 29:
              // returning from await.
              // goto join
              $async$goto = 27;
              break;
            case 28:
              // else
              $async$result = left;
            case 27:
              // join
              $async$returnValue = $async$result;
              // goto return
              $async$goto = 1;
              break;
            case 9:
              // case
              $async$temp1 = J;
              $async$temp2 = left;
              $async$goto = 30;
              return P._asyncAwait(t1.right.accept$1(t2), $async$call$0);
            case 30:
              // returning from await.
              $async$returnValue = $async$temp1.$eq$($async$temp2, $async$result) ? C.SassBoolean_true : C.SassBoolean_false;
              // goto return
              $async$goto = 1;
              break;
            case 10:
              // case
              $async$temp1 = J;
              $async$temp2 = left;
              $async$goto = 31;
              return P._asyncAwait(t1.right.accept$1(t2), $async$call$0);
            case 31:
              // returning from await.
              $async$returnValue = !$async$temp1.$eq$($async$temp2, $async$result) ? C.SassBoolean_true : C.SassBoolean_false;
              // goto return
              $async$goto = 1;
              break;
            case 11:
              // case
              $async$temp1 = left;
              $async$goto = 32;
              return P._asyncAwait(t1.right.accept$1(t2), $async$call$0);
            case 32:
              // returning from await.
              $async$returnValue = $async$temp1.greaterThan$1($async$result);
              // goto return
              $async$goto = 1;
              break;
            case 12:
              // case
              $async$temp1 = left;
              $async$goto = 33;
              return P._asyncAwait(t1.right.accept$1(t2), $async$call$0);
            case 33:
              // returning from await.
              $async$returnValue = $async$temp1.greaterThanOrEquals$1($async$result);
              // goto return
              $async$goto = 1;
              break;
            case 13:
              // case
              $async$temp1 = left;
              $async$goto = 34;
              return P._asyncAwait(t1.right.accept$1(t2), $async$call$0);
            case 34:
              // returning from await.
              $async$returnValue = $async$temp1.lessThan$1($async$result);
              // goto return
              $async$goto = 1;
              break;
            case 14:
              // case
              $async$temp1 = left;
              $async$goto = 35;
              return P._asyncAwait(t1.right.accept$1(t2), $async$call$0);
            case 35:
              // returning from await.
              $async$returnValue = $async$temp1.lessThanOrEquals$1($async$result);
              // goto return
              $async$goto = 1;
              break;
            case 15:
              // case
              $async$temp1 = left;
              $async$goto = 36;
              return P._asyncAwait(t1.right.accept$1(t2), $async$call$0);
            case 36:
              // returning from await.
              $async$returnValue = $async$temp1.plus$1($async$result);
              // goto return
              $async$goto = 1;
              break;
            case 16:
              // case
              $async$temp1 = left;
              $async$goto = 37;
              return P._asyncAwait(t1.right.accept$1(t2), $async$call$0);
            case 37:
              // returning from await.
              $async$returnValue = $async$temp1.minus$1($async$result);
              // goto return
              $async$goto = 1;
              break;
            case 17:
              // case
              $async$temp1 = left;
              $async$goto = 38;
              return P._asyncAwait(t1.right.accept$1(t2), $async$call$0);
            case 38:
              // returning from await.
              $async$returnValue = $async$temp1.times$1($async$result);
              // goto return
              $async$goto = 1;
              break;
            case 18:
              // case
              $async$goto = 39;
              return P._asyncAwait(t1.right.accept$1(t2), $async$call$0);
            case 39:
              // returning from await.
              right = $async$result;
              result = left.dividedBy$1(right);
              if (t1.allowsSlash && !!left.$isSassNumber && right instanceof T.SassNumber) {
                $async$returnValue = H.interceptedTypeCast(result, "$isSassNumber").withSlash$2(left, right);
                // goto return
                $async$goto = 1;
                break;
              } else {
                $async$returnValue = result;
                // goto return
                $async$goto = 1;
                break;
              }
            case 19:
              // case
              $async$temp1 = left;
              $async$goto = 40;
              return P._asyncAwait(t1.right.accept$1(t2), $async$call$0);
            case 40:
              // returning from await.
              $async$returnValue = $async$temp1.modulo$1($async$result);
              // goto return
              $async$goto = 1;
              break;
            case 20:
              // default
              // goto return
              $async$goto = 1;
              break;
            case 5:
              // after switch
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$0, $async$completer);
    }
  };
  E._EvaluateVisitor_visitVariableExpression_closure0.prototype = {
    call$0: function() {
      var t1 = this.node;
      return this.$this._async_evaluate$_environment.getVariable$2$namespace(t1.name, t1.namespace);
    }
  };
  E._EvaluateVisitor_visitListExpression_closure0.prototype = {
    call$1: function(expression) {
      return expression.accept$1(this.$this);
    }
  };
  E._EvaluateVisitor_visitFunctionExpression_closure0.prototype = {
    call$0: function() {
      var t1 = this.node.namespace,
        t2 = this.plainName;
      if (t1 == null)
        t2 = H.stringReplaceAllUnchecked(t2, "_", "-");
      return this.$this._async_evaluate$_getFunction$2$namespace(t2, t1);
    }
  };
  E._EvaluateVisitor__runUserDefinedCallable_closure0.prototype = {
    call$0: function() {
      var _this = this,
        t1 = _this.$this,
        t2 = _this.callable;
      return t1._async_evaluate$_withEnvironment$1$2(t2.environment.closure$0(), new E._EvaluateVisitor__runUserDefinedCallable__closure0(t1, _this.evaluated, t2, _this.nodeWithSpan, _this.run), F.Value);
    }
  };
  E._EvaluateVisitor__runUserDefinedCallable__closure0.prototype = {
    call$0: function() {
      var _this = this,
        t1 = _this.$this;
      return t1._async_evaluate$_environment.scope$1$1(new E._EvaluateVisitor__runUserDefinedCallable___closure0(t1, _this.evaluated, _this.callable, _this.nodeWithSpan, _this.run), F.Value);
    }
  };
  E._EvaluateVisitor__runUserDefinedCallable___closure0.prototype = {
    call$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(F.Value),
        $async$returnValue, $async$self = this, declaredArguments, minLength, t8, i, t9, t10, t11, argument, value, t12, rest, argumentList, result, argumentWord, argumentNames, t1, t2, t3, t4, t5, t6, t7;
      var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.$this;
              t2 = $async$self.evaluated;
              t3 = t2.positional;
              t4 = t3.length;
              t5 = t2.named;
              t6 = $async$self.callable.declaration.$arguments;
              t7 = $async$self.nodeWithSpan;
              t1._async_evaluate$_verifyArguments$4(t4, t5, t6, t7);
              declaredArguments = t6.$arguments;
              t4 = declaredArguments.length;
              minLength = Math.min(t3.length, t4);
              for (t8 = t1._async_evaluate$_sourceMap, i = 0; i < minLength; ++i) {
                t9 = t1._async_evaluate$_environment;
                t10 = declaredArguments[i].name;
                t11 = t3[i].withoutSlash$0();
                t9.setLocalVariable$3(t10, t11, t8 ? t2.positionalNodes[i] : null);
              }
              i = t3.length;
            case 3:
              // for condition
              if (!(i < t4)) {
                // goto after for
                $async$goto = 5;
                break;
              }
              argument = declaredArguments[i];
              t9 = argument.name;
              value = t5.remove$1(0, t9);
              $async$goto = value == null ? 6 : 7;
              break;
            case 6:
              // then
              $async$goto = 8;
              return P._asyncAwait(argument.defaultValue.accept$1(t1), $async$call$0);
            case 8:
              // returning from await.
              value = $async$result;
            case 7:
              // join
              t10 = t1._async_evaluate$_environment;
              t11 = value.withoutSlash$0();
              if (t8) {
                t12 = t2.namedNodes.$index(0, t9);
                if (t12 == null)
                  t12 = t1._async_evaluate$_expressionNode$1(argument.defaultValue);
              } else
                t12 = null;
              t10.setLocalVariable$3(t9, t11, t12);
            case 4:
              // for update
              ++i;
              // goto for condition
              $async$goto = 3;
              break;
            case 5:
              // after for
              t6 = t6.restArgument;
              if (t6 != null) {
                rest = t3.length > t4 ? C.JSArray_methods.sublist$1(t3, t4) : C.List_empty1;
                t2 = t2.separator;
                if (t2 === C.ListSeparator_undecided)
                  t2 = C.ListSeparator_comma;
                t3 = F.Value;
                argumentList = new D.SassArgumentList(H.ConstantMap_ConstantMap$from(t5, P.String, t3), P.List_List$unmodifiable(rest, t3), t2, false);
                argumentList.SassList$3$brackets(rest, t2, false);
                t1._async_evaluate$_environment.setLocalVariable$3(t6, argumentList, t7);
              } else
                argumentList = null;
              $async$goto = 9;
              return P._asyncAwait($async$self.run.call$0(), $async$call$0);
            case 9:
              // returning from await.
              result = $async$result;
              if (argumentList == null) {
                $async$returnValue = result;
                // goto return
                $async$goto = 1;
                break;
              }
              if (t5.get$isEmpty(t5)) {
                $async$returnValue = result;
                // goto return
                $async$goto = 1;
                break;
              }
              if (argumentList._wereKeywordsAccessed) {
                $async$returnValue = result;
                // goto return
                $async$goto = 1;
                break;
              }
              argumentWord = B.pluralize("argument", J.get$length$asx(t5.get$keys()), null);
              argumentNames = B.toSentence(J.map$1$1$ax(t5.get$keys(), new E._EvaluateVisitor__runUserDefinedCallable____closure0(), P.Object), "or");
              throw H.wrapException(t1._async_evaluate$_exception$2("No " + argumentWord + " named " + H.S(argumentNames) + ".", t7.get$span()));
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$0, $async$completer);
    }
  };
  E._EvaluateVisitor__runUserDefinedCallable____closure0.prototype = {
    call$1: function($name) {
      return "$" + H.S($name);
    }
  };
  E._EvaluateVisitor__runFunctionCallable_closure0.prototype = {
    call$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(F.Value),
        $async$returnValue, $async$self = this, t1, t2, t3, t4, _i, $returnValue;
      var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.callable.declaration, t2 = t1.children, t3 = t2.length, t4 = $async$self.$this, _i = 0;
            case 3:
              // for condition
              if (!(_i < t3)) {
                // goto after for
                $async$goto = 5;
                break;
              }
              $async$goto = 6;
              return P._asyncAwait(t2[_i].accept$1(t4), $async$call$0);
            case 6:
              // returning from await.
              $returnValue = $async$result;
              if ($returnValue instanceof F.Value) {
                $async$returnValue = $returnValue;
                // goto return
                $async$goto = 1;
                break;
              }
            case 4:
              // for update
              ++_i;
              // goto for condition
              $async$goto = 3;
              break;
            case 5:
              // after for
              throw H.wrapException(t4._async_evaluate$_exception$2("Function finished without @return.", t1.span));
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$0, $async$completer);
    }
  };
  E._EvaluateVisitor__runBuiltInCallable_closure1.prototype = {
    call$0: function() {
      return this.overload.verify$2(this.evaluated.positional.length, this.namedSet);
    }
  };
  E._EvaluateVisitor__runBuiltInCallable_closure2.prototype = {
    call$1: function($name) {
      return "$" + H.S($name);
    }
  };
  E._EvaluateVisitor__evaluateArguments_closure6.prototype = {
    call$2: function(_, expression) {
      return expression.accept$1(this.$this);
    }
  };
  E._EvaluateVisitor__evaluateArguments_closure7.prototype = {
    call$2: function(_, expression) {
      return this.$this._async_evaluate$_expressionNode$1(expression);
    }
  };
  E._EvaluateVisitor__evaluateArguments_closure8.prototype = {
    call$2: function(key, _) {
      return H.interceptedTypeCast(key, "$isSassString").text;
    },
    $signature: 15
  };
  E._EvaluateVisitor__evaluateArguments_closure9.prototype = {
    call$2: function(_, __) {
      return this.restNodeForSpan;
    },
    $signature: 22
  };
  E._EvaluateVisitor__evaluateArguments_closure10.prototype = {
    call$2: function(key, value) {
      var t1;
      this.named.$indexSet(0, key, value);
      t1 = this.namedNodes;
      if (t1 != null)
        t1.$indexSet(0, key, this.restNodeForSpan);
    }
  };
  E._EvaluateVisitor__evaluateArguments_closure11.prototype = {
    call$2: function(key, _) {
      return H.interceptedTypeCast(key, "$isSassString").text;
    },
    $signature: 15
  };
  E._EvaluateVisitor__evaluateArguments_closure12.prototype = {
    call$2: function(_, __) {
      return this.keywordRestNodeForSpan;
    },
    $signature: 22
  };
  E._EvaluateVisitor__evaluateMacroArguments_closure3.prototype = {
    call$1: function(value) {
      return new F.ValueExpression(value, null);
    }
  };
  E._EvaluateVisitor__evaluateMacroArguments_closure4.prototype = {
    call$1: function(value) {
      return new F.ValueExpression(value, null);
    }
  };
  E._EvaluateVisitor__evaluateMacroArguments_closure5.prototype = {
    call$2: function(key, value) {
      this.named.$indexSet(0, key, new F.ValueExpression(value, null));
    }
  };
  E._EvaluateVisitor__evaluateMacroArguments_closure6.prototype = {
    call$1: function(value) {
      return new F.ValueExpression(value, null);
    }
  };
  E._EvaluateVisitor__addRestMap_closure1.prototype = {
    call$1: function(value) {
      return H.subtypeOfRuntimeTypeCast(value, this.T);
    }
  };
  E._EvaluateVisitor__addRestMap_closure2.prototype = {
    call$2: function(key, value) {
      var _this = this;
      if (key instanceof D.SassString)
        _this.values.$indexSet(0, key.text, _this._box_0.convert.call$1(value));
      else
        throw H.wrapException(_this.$this._async_evaluate$_exception$2("Variable keyword argument map must have string keys.\n" + H.S(key) + " is not a string in " + _this.map.toString$0(0) + ".", _this.nodeForSpan.get$span()));
    }
  };
  E._EvaluateVisitor__verifyArguments_closure0.prototype = {
    call$0: function() {
      return this.$arguments.verify$2(this.positional, new M.MapKeySet(this.named, [P.String]));
    }
  };
  E._EvaluateVisitor_visitStringExpression_closure0.prototype = {
    call$1: function(value) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.String),
        $async$returnValue, $async$self = this, t1, result;
      var $async$call$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              if (typeof value === "string") {
                $async$returnValue = value;
                // goto return
                $async$goto = 1;
                break;
              }
              H.interceptedTypeCast(value, "$isExpression");
              t1 = $async$self.$this;
              $async$goto = 3;
              return P._asyncAwait(value.accept$1(t1), $async$call$1);
            case 3:
              // returning from await.
              result = $async$result;
              $async$returnValue = result instanceof D.SassString ? result.text : t1._async_evaluate$_serialize$3$quote(result, value, false);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$1, $async$completer);
    },
    $signature: 35
  };
  E._EvaluateVisitor_visitCssAtRule_closure1.prototype = {
    call$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Null),
        $async$self = this, t1, t2;
      var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.node.children, t1 = new H.ListIterator(t1, t1.get$length(t1)), t2 = $async$self.$this;
            case 2:
              // for condition
              if (!t1.moveNext$0()) {
                // goto after for
                $async$goto = 3;
                break;
              }
              $async$goto = 4;
              return P._asyncAwait(t1.__internal$_current.accept$1(t2), $async$call$0);
            case 4:
              // returning from await.
              // goto for condition
              $async$goto = 2;
              break;
            case 3:
              // after for
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$0, $async$completer);
    }
  };
  E._EvaluateVisitor_visitCssAtRule_closure2.prototype = {
    call$1: function(node) {
      return !!J.getInterceptor$(node).$isCssStyleRule;
    }
  };
  E._EvaluateVisitor_visitCssKeyframeBlock_closure1.prototype = {
    call$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Null),
        $async$self = this, t1, t2;
      var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.node.children, t1 = new H.ListIterator(t1, t1.get$length(t1)), t2 = $async$self.$this;
            case 2:
              // for condition
              if (!t1.moveNext$0()) {
                // goto after for
                $async$goto = 3;
                break;
              }
              $async$goto = 4;
              return P._asyncAwait(t1.__internal$_current.accept$1(t2), $async$call$0);
            case 4:
              // returning from await.
              // goto for condition
              $async$goto = 2;
              break;
            case 3:
              // after for
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$0, $async$completer);
    }
  };
  E._EvaluateVisitor_visitCssKeyframeBlock_closure2.prototype = {
    call$1: function(node) {
      return !!J.getInterceptor$(node).$isCssStyleRule;
    }
  };
  E._EvaluateVisitor_visitCssMediaRule_closure1.prototype = {
    call$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Null),
        $async$self = this, t1, t2;
      var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.$this;
              t2 = $async$self.mergedQueries;
              if (t2 == null)
                t2 = $async$self.node.queries;
              $async$goto = 2;
              return P._asyncAwait(t1._async_evaluate$_withMediaQueries$1$2(t2, new E._EvaluateVisitor_visitCssMediaRule__closure0(t1, $async$self.node), P.Null), $async$call$0);
            case 2:
              // returning from await.
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$0, $async$completer);
    }
  };
  E._EvaluateVisitor_visitCssMediaRule__closure0.prototype = {
    call$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Null),
        $async$self = this, t1, t2;
      var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.$this;
              t2 = t1._async_evaluate$_styleRule;
              $async$goto = !(t2 != null && !t1._async_evaluate$_atRootExcludingStyleRule) ? 2 : 4;
              break;
            case 2:
              // then
              t2 = $async$self.node.children, t2 = new H.ListIterator(t2, t2.get$length(t2));
            case 5:
              // for condition
              if (!t2.moveNext$0()) {
                // goto after for
                $async$goto = 6;
                break;
              }
              $async$goto = 7;
              return P._asyncAwait(t2.__internal$_current.accept$1(t1), $async$call$0);
            case 7:
              // returning from await.
              // goto for condition
              $async$goto = 5;
              break;
            case 6:
              // after for
              // goto join
              $async$goto = 3;
              break;
            case 4:
              // else
              $async$goto = 8;
              return P._asyncAwait(t1._async_evaluate$_withParent$2$3$scopeWhen(X.ModifiableCssStyleRule$(t2.selector, t2.span, t2.originalSelector), new E._EvaluateVisitor_visitCssMediaRule___closure0(t1, $async$self.node), false, X.ModifiableCssStyleRule, P.Null), $async$call$0);
            case 8:
              // returning from await.
            case 3:
              // join
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$0, $async$completer);
    }
  };
  E._EvaluateVisitor_visitCssMediaRule___closure0.prototype = {
    call$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Null),
        $async$self = this, t1, t2;
      var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.node.children, t1 = new H.ListIterator(t1, t1.get$length(t1)), t2 = $async$self.$this;
            case 2:
              // for condition
              if (!t1.moveNext$0()) {
                // goto after for
                $async$goto = 3;
                break;
              }
              $async$goto = 4;
              return P._asyncAwait(t1.__internal$_current.accept$1(t2), $async$call$0);
            case 4:
              // returning from await.
              // goto for condition
              $async$goto = 2;
              break;
            case 3:
              // after for
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$0, $async$completer);
    }
  };
  E._EvaluateVisitor_visitCssMediaRule_closure2.prototype = {
    call$1: function(node) {
      var t1 = J.getInterceptor$(node);
      if (!t1.$isCssStyleRule)
        t1 = this.mergedQueries != null && !!t1.$isCssMediaRule;
      else
        t1 = true;
      return t1;
    }
  };
  E._EvaluateVisitor_visitCssStyleRule_closure1.prototype = {
    call$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Null),
        $async$self = this, t1;
      var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.$this;
              $async$goto = 2;
              return P._asyncAwait(t1._async_evaluate$_withStyleRule$1$2($async$self.rule, new E._EvaluateVisitor_visitCssStyleRule__closure0(t1, $async$self.node), P.Null), $async$call$0);
            case 2:
              // returning from await.
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$0, $async$completer);
    }
  };
  E._EvaluateVisitor_visitCssStyleRule__closure0.prototype = {
    call$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Null),
        $async$self = this, t1, t2;
      var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.node.children, t1 = new H.ListIterator(t1, t1.get$length(t1)), t2 = $async$self.$this;
            case 2:
              // for condition
              if (!t1.moveNext$0()) {
                // goto after for
                $async$goto = 3;
                break;
              }
              $async$goto = 4;
              return P._asyncAwait(t1.__internal$_current.accept$1(t2), $async$call$0);
            case 4:
              // returning from await.
              // goto for condition
              $async$goto = 2;
              break;
            case 3:
              // after for
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$0, $async$completer);
    }
  };
  E._EvaluateVisitor_visitCssStyleRule_closure2.prototype = {
    call$1: function(node) {
      return !!J.getInterceptor$(node).$isCssStyleRule;
    }
  };
  E._EvaluateVisitor_visitCssSupportsRule_closure1.prototype = {
    call$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Null),
        $async$self = this, t1, t2;
      var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.$this;
              t2 = t1._async_evaluate$_styleRule;
              $async$goto = !(t2 != null && !t1._async_evaluate$_atRootExcludingStyleRule) ? 2 : 4;
              break;
            case 2:
              // then
              t2 = $async$self.node.children, t2 = new H.ListIterator(t2, t2.get$length(t2));
            case 5:
              // for condition
              if (!t2.moveNext$0()) {
                // goto after for
                $async$goto = 6;
                break;
              }
              $async$goto = 7;
              return P._asyncAwait(t2.__internal$_current.accept$1(t1), $async$call$0);
            case 7:
              // returning from await.
              // goto for condition
              $async$goto = 5;
              break;
            case 6:
              // after for
              // goto join
              $async$goto = 3;
              break;
            case 4:
              // else
              $async$goto = 8;
              return P._asyncAwait(t1._async_evaluate$_withParent$2$2(X.ModifiableCssStyleRule$(t2.selector, t2.span, t2.originalSelector), new E._EvaluateVisitor_visitCssSupportsRule__closure0(t1, $async$self.node), X.ModifiableCssStyleRule, P.Null), $async$call$0);
            case 8:
              // returning from await.
            case 3:
              // join
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$0, $async$completer);
    }
  };
  E._EvaluateVisitor_visitCssSupportsRule__closure0.prototype = {
    call$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Null),
        $async$self = this, t1, t2;
      var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.node.children, t1 = new H.ListIterator(t1, t1.get$length(t1)), t2 = $async$self.$this;
            case 2:
              // for condition
              if (!t1.moveNext$0()) {
                // goto after for
                $async$goto = 3;
                break;
              }
              $async$goto = 4;
              return P._asyncAwait(t1.__internal$_current.accept$1(t2), $async$call$0);
            case 4:
              // returning from await.
              // goto for condition
              $async$goto = 2;
              break;
            case 3:
              // after for
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$0, $async$completer);
    }
  };
  E._EvaluateVisitor_visitCssSupportsRule_closure2.prototype = {
    call$1: function(node) {
      return !!J.getInterceptor$(node).$isCssStyleRule;
    }
  };
  E._EvaluateVisitor__performInterpolation_closure0.prototype = {
    call$1: function(value) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.String),
        $async$returnValue, $async$self = this, t1, result, t2, t3;
      var $async$call$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              if (typeof value === "string") {
                $async$returnValue = value;
                // goto return
                $async$goto = 1;
                break;
              }
              H.interceptedTypeCast(value, "$isExpression");
              t1 = $async$self.$this;
              $async$goto = 3;
              return P._asyncAwait(value.accept$1(t1), $async$call$1);
            case 3:
              // returning from await.
              result = $async$result;
              if ($async$self.warnForColor && result instanceof K.SassColor && $.$get$namesByColor().containsKey$1(result)) {
                t2 = X.Interpolation$(H.setRuntimeTypeInfo([""], [P.Object]), null);
                t3 = $.$get$namesByColor();
                t1._async_evaluate$_warn$2("You probably don't mean to use the color value " + H.S(t3.$index(0, result)) + " in interpolation here.\nIt may end up represented as " + H.S(result) + ', which will likely produce invalid CSS.\nAlways quote color names when using them as strings or map keys (for example, "' + H.S(t3.$index(0, result)) + "\").\nIf you really want to use the color value here, use '" + new V.BinaryOperationExpression(C.BinaryOperator_AcR0, new D.StringExpression(t2, true), value, false).toString$0(0) + "'.", value.get$span());
              }
              $async$returnValue = t1._async_evaluate$_serialize$3$quote(result, value, false);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$1, $async$completer);
    },
    $signature: 35
  };
  E._EvaluateVisitor__serialize_closure0.prototype = {
    call$0: function() {
      var t1 = this.value;
      t1.toString;
      return N.serializeValue(t1, false, this.quote);
    }
  };
  E._EvaluateVisitor__stackTrace_closure0.prototype = {
    call$1: function(tuple) {
      return this.$this._async_evaluate$_stackFrame$2(tuple.item1, tuple.item2.get$span());
    }
  };
  E._ImportedCssVisitor0.prototype = {
    visitCssAtRule$1: function(node) {
      var t1 = node.isChildless ? null : new E._ImportedCssVisitor_visitCssAtRule_closure0();
      this._async_evaluate$_visitor._async_evaluate$_addChild$2$through(node, t1);
    },
    visitCssComment$1: function(node) {
      return this._async_evaluate$_visitor._async_evaluate$_addChild$1(node);
    },
    visitCssDeclaration$1: function(node) {
    },
    visitCssImport$1: function(node) {
      var t1 = this._async_evaluate$_visitor,
        t2 = t1._async_evaluate$_parent,
        t3 = t1._async_evaluate$_root;
      if (t2 != t3)
        t1._async_evaluate$_addChild$1(node);
      else if (t1._async_evaluate$_endOfImports === J.get$length$asx(t3.children._collection$_source)) {
        t1._async_evaluate$_addChild$1(node);
        t1._async_evaluate$_endOfImports = t1._async_evaluate$_endOfImports + 1;
      } else {
        t2 = t1._async_evaluate$_outOfOrderImports;
        (t2 == null ? t1._async_evaluate$_outOfOrderImports = H.setRuntimeTypeInfo([], [F.ModifiableCssImport]) : t2).push(node);
      }
    },
    visitCssKeyframeBlock$1: function(node) {
    },
    visitCssMediaRule$1: function(node) {
      var t1 = this._async_evaluate$_visitor,
        t2 = t1._async_evaluate$_mediaQueries;
      t1._async_evaluate$_addChild$2$through(node, new E._ImportedCssVisitor_visitCssMediaRule_closure0(t2 == null || t1._async_evaluate$_mergeMediaQueries$2(t2, node.queries) != null));
    },
    visitCssStyleRule$1: function(node) {
      return this._async_evaluate$_visitor._async_evaluate$_addChild$2$through(node, new E._ImportedCssVisitor_visitCssStyleRule_closure0());
    },
    visitCssStylesheet$1: function(node) {
      var t1;
      for (t1 = node.children, t1 = new H.ListIterator(t1, t1.get$length(t1)); t1.moveNext$0();)
        t1.__internal$_current.accept$1(this);
    },
    visitCssSupportsRule$1: function(node) {
      return this._async_evaluate$_visitor._async_evaluate$_addChild$2$through(node, new E._ImportedCssVisitor_visitCssSupportsRule_closure0());
    }
  };
  E._ImportedCssVisitor_visitCssAtRule_closure0.prototype = {
    call$1: function(node) {
      return !!J.getInterceptor$(node).$isCssStyleRule;
    }
  };
  E._ImportedCssVisitor_visitCssMediaRule_closure0.prototype = {
    call$1: function(node) {
      var t1 = J.getInterceptor$(node);
      if (!t1.$isCssStyleRule)
        t1 = this.hasBeenMerged && !!t1.$isCssMediaRule;
      else
        t1 = true;
      return t1;
    }
  };
  E._ImportedCssVisitor_visitCssStyleRule_closure0.prototype = {
    call$1: function(node) {
      return !!J.getInterceptor$(node).$isCssStyleRule;
    }
  };
  E._ImportedCssVisitor_visitCssSupportsRule_closure0.prototype = {
    call$1: function(node) {
      return !!J.getInterceptor$(node).$isCssStyleRule;
    }
  };
  E.EvaluateResult.prototype = {};
  E._ArgumentResults0.prototype = {};
  V._CloneCssVisitor.prototype = {
    visitCssAtRule$1: function(node) {
      var t1 = node.isChildless,
        t2 = B.ModifiableCssNode,
        t3 = H.setRuntimeTypeInfo([], [t2]),
        rule = new U.ModifiableCssAtRule(node.name, node.value, t1, node.span, new P.UnmodifiableListView(t3, [t2]), t3);
      return t1 ? rule : this._visitChildren$2(rule, node);
    },
    visitCssComment$1: function(node) {
      return new R.ModifiableCssComment(node.text, node.span);
    },
    visitCssDeclaration$1: function(node) {
      return L.ModifiableCssDeclaration$(node.name, node.value, node.span, node.valueSpanForMap);
    },
    visitCssImport$1: function(node) {
      return F.ModifiableCssImport$(node.url, node.span, node.media, node.supports);
    },
    visitCssKeyframeBlock$1: function(node) {
      var t1 = B.ModifiableCssNode,
        t2 = H.setRuntimeTypeInfo([], [t1]);
      return this._visitChildren$2(new U.ModifiableCssKeyframeBlock(node.selector, node.span, new P.UnmodifiableListView(t2, [t1]), t2), node);
    },
    visitCssMediaRule$1: function(node) {
      return this._visitChildren$2(G.ModifiableCssMediaRule$(node.queries, node.span), node);
    },
    visitCssStyleRule$1: function(node) {
      var newRule = this._oldToNewRules.$index(0, node);
      if (newRule == null)
        throw H.wrapException(P.StateError$("The Extender and CssStylesheet passed to cloneCssStylesheet() must come from the same compilation."));
      return this._visitChildren$2(newRule, node);
    },
    visitCssStylesheet$1: function(node) {
      var t1 = node.get$span(),
        t2 = B.ModifiableCssNode,
        t3 = H.setRuntimeTypeInfo([], [t2]);
      return this._visitChildren$2(new V.ModifiableCssStylesheet(t1, new P.UnmodifiableListView(t3, [t2]), t3), node);
    },
    visitCssSupportsRule$1: function(node) {
      var t1 = B.ModifiableCssNode,
        t2 = H.setRuntimeTypeInfo([], [t1]);
      return this._visitChildren$2(new B.ModifiableCssSupportsRule(node.condition, node.span, new P.UnmodifiableListView(t2, [t1]), t2), node);
    },
    _visitChildren$1$2: function(newParent, oldParent) {
      var t1, t2, newChild;
      for (t1 = J.get$iterator$ax(oldParent.get$children()); t1.moveNext$0();) {
        t2 = t1.get$current(t1);
        newChild = t2.accept$1(this);
        newChild.isGroupEnd = t2.get$isGroupEnd();
        newParent.addChild$1(newChild);
      }
      return newParent;
    },
    _visitChildren$2: function(newParent, oldParent) {
      return this._visitChildren$1$2(newParent, oldParent, B.ModifiableCssParentNode);
    }
  };
  R._EvaluateVisitor.prototype = {
    _EvaluateVisitor$5$functions$importCache$logger$nodeImporter$sourceMap: function(functions, importCache, logger, nodeImporter, sourceMap) {
      var t3, _i, metaModule, module, $function, _this = this,
        _s20_ = "$name, $module: null",
        t1 = [B.ArgumentDeclaration, {func: 1, ret: F.Value, args: [[P.List, F.Value]]}],
        t2 = [[S.Tuple2, B.ArgumentDeclaration, {func: 1, ret: F.Value, args: [[P.List, F.Value]]}]],
        metaFunctions = [new Q.BuiltInCallable("global-variable-exists", H.setRuntimeTypeInfo([new S.Tuple2(B.ArgumentDeclaration_ArgumentDeclaration$parse(_s20_), new R._EvaluateVisitor_closure(_this), t1)], t2)), new Q.BuiltInCallable("variable-exists", H.setRuntimeTypeInfo([new S.Tuple2(B.ArgumentDeclaration_ArgumentDeclaration$parse("$name"), new R._EvaluateVisitor_closure0(_this), t1)], t2)), new Q.BuiltInCallable("function-exists", H.setRuntimeTypeInfo([new S.Tuple2(B.ArgumentDeclaration_ArgumentDeclaration$parse(_s20_), new R._EvaluateVisitor_closure1(_this), t1)], t2)), new Q.BuiltInCallable("mixin-exists", H.setRuntimeTypeInfo([new S.Tuple2(B.ArgumentDeclaration_ArgumentDeclaration$parse(_s20_), new R._EvaluateVisitor_closure2(_this), t1)], t2)), new Q.BuiltInCallable("content-exists", H.setRuntimeTypeInfo([new S.Tuple2(B.ArgumentDeclaration_ArgumentDeclaration$parse(""), new R._EvaluateVisitor_closure3(_this), t1)], t2)), new Q.BuiltInCallable("module-variables", H.setRuntimeTypeInfo([new S.Tuple2(B.ArgumentDeclaration_ArgumentDeclaration$parse("$module"), new R._EvaluateVisitor_closure4(_this), t1)], t2)), new Q.BuiltInCallable("module-functions", H.setRuntimeTypeInfo([new S.Tuple2(B.ArgumentDeclaration_ArgumentDeclaration$parse("$module"), new R._EvaluateVisitor_closure5(_this), t1)], t2)), new Q.BuiltInCallable("get-function", H.setRuntimeTypeInfo([new S.Tuple2(B.ArgumentDeclaration_ArgumentDeclaration$parse("$name, $css: false, $module: null"), new R._EvaluateVisitor_closure6(_this), t1)], t2)), new Q.BuiltInCallable("call", H.setRuntimeTypeInfo([new S.Tuple2(B.ArgumentDeclaration_ArgumentDeclaration$parse("$function, $args..."), new R._EvaluateVisitor_closure7(_this), t1)], t2))];
      t2 = Q.BuiltInCallable;
      t1 = H.setRuntimeTypeInfo([], [t2]);
      for (t3 = $.$get$global(), t3 = new H.ListIterator(t3, t3.get$length(t3)); t3.moveNext$0();)
        t1.push(t3.__internal$_current);
      for (_i = 0; _i < 9; ++_i)
        t1.push(metaFunctions[_i]);
      metaModule = Q.BuiltInModule$("meta", t1, t2);
      t1 = H.setRuntimeTypeInfo([], [[Q.BuiltInModule, Q.BuiltInCallable]]);
      for (t2 = $.$get$coreModules(), t2 = new H.ListIterator(t2, t2.get$length(t2)); t2.moveNext$0();)
        t1.push(t2.__internal$_current);
      t1.push(metaModule);
      t2 = t1.length;
      t3 = _this._builtInModules;
      _i = 0;
      for (; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
        module = t1[_i];
        t3.$indexSet(0, module.url, module);
      }
      t1 = H.setRuntimeTypeInfo([], [D.Callable]);
      if (functions != null)
        for (t2 = new H.ListIterator(functions, functions.get$length(functions)); t2.moveNext$0();)
          t1.push(t2.__internal$_current);
      for (t2 = $.$get$globalFunctions(), t2 = new H.ListIterator(t2, t2.get$length(t2)); t2.moveNext$0();)
        t1.push(t2.__internal$_current);
      for (_i = 0; _i < 9; ++_i)
        t1.push(metaFunctions[_i]);
      for (t2 = t1.length, t3 = _this._builtInFunctions, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
        $function = t1[_i];
        t3.$indexSet(0, $function.get$name(), $function);
      }
    },
    run$2: function(_, importer, node) {
      return this._withWarnCallback$1(new R._EvaluateVisitor_run_closure(this, node, importer));
    },
    runExpression$2$variables: function(expression, variables) {
      return this._withWarnCallback$1(new R._EvaluateVisitor_runExpression_closure(this, variables, expression));
    },
    _withWarnCallback$1$1: function(callback) {
      return N.withWarnCallback(new R._EvaluateVisitor__withWarnCallback_closure(this), callback);
    },
    _withWarnCallback$1: function(callback) {
      return this._withWarnCallback$1$1(callback, null);
    },
    _loadModule$4: function(url, stackFrame, nodeForSpan, callback) {
      var builtInModule = this._builtInModules.$index(0, url);
      if (builtInModule != null) {
        callback.call$1(builtInModule);
        return;
      }
      this._withStackFrame$3(stackFrame, nodeForSpan, new R._EvaluateVisitor__loadModule_closure(this, url, nodeForSpan, callback));
    },
    _execute$2: function(importer, stylesheet) {
      return this._modules.putIfAbsent$2(stylesheet.span.file.url, new R._EvaluateVisitor__execute_closure(this, importer, stylesheet));
    },
    _addOutOfOrderImports$0: function() {
      var t1, t2, statements, _this = this;
      if (_this._outOfOrderImports == null)
        return _this._root.children;
      t1 = B.ModifiableCssNode;
      t2 = new Array(J.get$length$asx(_this._root.children._collection$_source) + _this._outOfOrderImports.length);
      t2.fixed$length = Array;
      statements = new G.FixedLengthListBuilder(H.setRuntimeTypeInfo(t2, [t1]), [t1]);
      statements.addRange$3(_this._root.children, 0, _this._endOfImports);
      statements.addAll$1(0, _this._outOfOrderImports);
      statements.addRange$2(_this._root.children, _this._endOfImports);
      return statements.build$0();
    },
    _combineCss$2$clone: function(root, clone) {
      var selectors, unsatisfiedExtension, sortedModules, t1, t2, imports, css, t3, statements, index, _this = this;
      if (!C.JSArray_methods.any$1(root.get$upstream(), new R._EvaluateVisitor__combineCss_closure())) {
        selectors = root.get$extender().get$simpleSelectors();
        unsatisfiedExtension = B.firstOrNull(root.get$extender().extensionsWhereTarget$1(new R._EvaluateVisitor__combineCss_closure0(selectors)));
        if (unsatisfiedExtension != null)
          _this._throwForUnsatisfiedExtension$1(unsatisfiedExtension);
        return root.get$css(root);
      }
      sortedModules = _this._topologicalModules$1(root);
      if (clone)
        sortedModules = new H.MappedListIterable(sortedModules, new R._EvaluateVisitor__combineCss_closure1(), [H.getTypeArgumentByIndex(sortedModules, 0), [G.Module, D.Callable]]).toList$0(0);
      _this._extendModules$1(sortedModules);
      t1 = B.CssNode;
      t2 = [t1];
      imports = H.setRuntimeTypeInfo([], t2);
      css = H.setRuntimeTypeInfo([], t2);
      for (t2 = J.get$reversed$ax(sortedModules), t2 = new H.ListIterator(t2, t2.get$length(t2)); t2.moveNext$0();) {
        t3 = t2.__internal$_current;
        statements = t3.get$css(t3).get$children();
        index = _this._indexAfterImports$1(statements);
        t3 = J.getInterceptor$ax(statements);
        C.JSArray_methods.addAll$1(imports, t3.getRange$2(statements, 0, index));
        C.JSArray_methods.addAll$1(css, t3.getRange$2(statements, index, t3.get$length(statements)));
      }
      return new V.CssStylesheet(new P.UnmodifiableListView(C.JSArray_methods.$add(imports, css), [t1]), root.get$css(root).get$span());
    },
    _combineCss$1: function(root) {
      return this._combineCss$2$clone(root, false);
    },
    _extendModules$1: function(sortedModules) {
      var t1, t2, originalSelectors, extenders, t3, t4, _i,
        downstreamExtenders = P.LinkedHashMap_LinkedHashMap$_empty(P.Uri, [P.List, F.Extender]),
        unsatisfiedExtensions = new P._LinkedIdentityHashSet([S.Extension]);
      for (t1 = J.get$iterator$ax(sortedModules); t1.moveNext$0();) {
        t2 = t1.get$current(t1);
        originalSelectors = t2.get$extender().get$simpleSelectors().toSet$0(0);
        unsatisfiedExtensions.addAll$1(0, t2.get$extender().extensionsWhereTarget$1(new R._EvaluateVisitor__extendModules_closure(originalSelectors)));
        extenders = downstreamExtenders.$index(0, t2.get$url());
        if (extenders != null)
          t2.get$extender().addExtensions$1(extenders);
        t3 = t2.get$extender();
        if (t3.get$isEmpty(t3))
          continue;
        for (t3 = t2.get$upstream(), t4 = t3.length, _i = 0; _i < t3.length; t3.length === t4 || (0, H.throwConcurrentModificationError)(t3), ++_i)
          J.add$1$ax(downstreamExtenders.putIfAbsent$2(t3[_i].get$url(), new R._EvaluateVisitor__extendModules_closure0()), t2.get$extender());
        unsatisfiedExtensions.removeAll$1(t2.get$extender().extensionsWhereTarget$1(originalSelectors.get$contains(originalSelectors)));
      }
      if (unsatisfiedExtensions._collection$_length !== 0)
        this._throwForUnsatisfiedExtension$1(unsatisfiedExtensions.get$first(unsatisfiedExtensions));
    },
    _throwForUnsatisfiedExtension$1: function(extension) {
      throw H.wrapException(E.SassException$('The target selector was not found.\nUse "@extend ' + H.S(extension.target) + ' !optional" to avoid this error.', extension.span));
    },
    _topologicalModules$1: function(root) {
      var t1 = [G.Module, D.Callable],
        seen = P.LinkedHashSet_LinkedHashSet(t1),
        sorted = Q.QueueList$(null, t1);
      new R._EvaluateVisitor__topologicalModules_visitModule(seen, sorted).call$1(root);
      return sorted;
    },
    _indexAfterImports$1: function(statements) {
      var t1, lastImport, i, t2;
      for (t1 = J.getInterceptor$asx(statements), lastImport = -1, i = 0; i < t1.get$length(statements); ++i) {
        t2 = J.getInterceptor$(t1.$index(statements, i));
        if (!!t2.$isCssImport)
          lastImport = i;
        else if (!t2.$isCssComment)
          break;
      }
      return lastImport + 1;
    },
    visitStylesheet$1: function(node) {
      var t1, t2, _i;
      for (t1 = node.children, t2 = t1.length, _i = 0; _i < t2; ++_i)
        t1[_i].accept$1(this);
      return;
    },
    visitAtRootRule$1: function(node) {
      var root, innerCopy, outerCopy, copy, _this = this,
        t1 = node.query,
        query = t1 != null ? _this._adjustParseError$2(t1, new R._EvaluateVisitor_visitAtRootRule_closure(_this, _this._performInterpolation$2$warnForColor(t1, true))) : C.AtRootQuery_UsS,
        $parent = _this._evaluate$_parent,
        included = H.setRuntimeTypeInfo([], [B.ModifiableCssParentNode]);
      for (; !J.getInterceptor$($parent).$isCssStylesheet;) {
        if (!query.excludes$1($parent))
          included.push($parent);
        $parent = $parent._parent;
      }
      root = _this._trimIncluded$1(included);
      if (root == _this._evaluate$_parent) {
        _this._evaluate$_environment.scope$1$2$when(new R._EvaluateVisitor_visitAtRootRule_closure0(_this, node), node.hasDeclarations, P.Null);
        return;
      }
      innerCopy = included.length === 0 ? null : C.JSArray_methods.get$first(included).copyWithoutChildren$0();
      for (t1 = H.SubListIterable$(included, 1, null, H.getTypeArgumentByIndex(included, 0)), t1 = new H.ListIterator(t1, t1.get$length(t1)), outerCopy = innerCopy; t1.moveNext$0(); outerCopy = copy) {
        copy = t1.__internal$_current.copyWithoutChildren$0();
        copy.addChild$1(outerCopy);
      }
      if (outerCopy != null)
        root.addChild$1(outerCopy);
      _this._scopeForAtRoot$4(node, innerCopy == null ? root : innerCopy, query, included).call$1(new R._EvaluateVisitor_visitAtRootRule_closure1(_this, node));
      return;
    },
    _trimIncluded$1: function(nodes) {
      var $parent, innermostContiguous, i, t2, root,
        t1 = nodes.length;
      if (t1 === 0)
        return this._root;
      $parent = this._evaluate$_parent;
      for (innermostContiguous = null, i = 0; i < t1; ++i) {
        for (; $parent != nodes[i]; innermostContiguous = null)
          $parent = $parent._parent;
        if (innermostContiguous == null)
          innermostContiguous = i;
        $parent = $parent._parent;
      }
      t2 = this._root;
      if ($parent != t2)
        return t2;
      root = nodes[innermostContiguous];
      C.JSArray_methods.removeRange$2(nodes, innermostContiguous, t1);
      return root;
    },
    _scopeForAtRoot$4: function(node, newParent, query, included) {
      var _this = this,
        scope = new R._EvaluateVisitor__scopeForAtRoot_closure(_this, newParent, node),
        t1 = query._all,
        t2 = t1 || query._at_root_query$_rule,
        t3 = query.include;
      if (t2 !== t3)
        scope = new R._EvaluateVisitor__scopeForAtRoot_closure0(_this, scope);
      if (t1 ? !t3 : query.names.contains$1(0, "media") !== t3)
        scope = new R._EvaluateVisitor__scopeForAtRoot_closure1(_this, scope);
      if (_this._inKeyframes && query.names.contains$1(0, "keyframes") !== t3)
        scope = new R._EvaluateVisitor__scopeForAtRoot_closure2(_this, scope);
      return _this._inUnknownAtRule && !C.JSArray_methods.any$1(included, new R._EvaluateVisitor__scopeForAtRoot_closure3()) ? new R._EvaluateVisitor__scopeForAtRoot_closure4(_this, scope) : scope;
    },
    visitContentBlock$1: function(node) {
      return H.throwExpression(P.UnsupportedError$("Evaluation handles @include and its content block together."));
    },
    visitContentRule$1: function(node) {
      var $content = this._evaluate$_environment._content;
      if ($content == null)
        return;
      this._runUserDefinedCallable$4(node.$arguments, $content, node, new R._EvaluateVisitor_visitContentRule_closure(this, $content));
      return;
    },
    visitDebugRule$1: function(node) {
      var value = node.expression.accept$1(this),
        t1 = J.getInterceptor$(value);
      t1 = !!t1.$isSassString ? value.text : t1.toString$0(value);
      this._logger.debug$2(t1, node.span);
      return;
    },
    visitDeclaration$1: function(node) {
      var $name, t1, cssValue, t2, oldDeclarationName, _this = this;
      if (!(_this._styleRule != null && !_this._atRootExcludingStyleRule) && !_this._inUnknownAtRule && !_this._inKeyframes)
        throw H.wrapException(_this._evaluate$_exception$2("Declarations may only be used within style rules.", node.span));
      $name = _this._interpolationToValue$2$warnForColor(node.name, true);
      t1 = _this._declarationName;
      if (t1 != null)
        $name = new F.CssValue(t1 + "-" + H.S($name.value), $name.span, [P.String]);
      t1 = node.value;
      cssValue = t1 == null ? null : new F.CssValue(t1.accept$1(_this), t1.get$span(), [F.Value]);
      if (cssValue != null) {
        t2 = cssValue.value;
        t2 = !t2.get$isBlank() || t2.get$asList().length === 0;
      } else
        t2 = false;
      if (t2) {
        t2 = _this._evaluate$_parent;
        t1 = _this._expressionNode$1(t1);
        t1 = t1 == null ? null : t1.get$span();
        t2.addChild$1(L.ModifiableCssDeclaration$($name, cssValue, node.span, t1));
      } else if (J.startsWith$1$s($name.value, "--"))
        throw H.wrapException(_this._evaluate$_exception$2("Custom property values may not be empty.", t1.get$span()));
      if (node.children != null) {
        oldDeclarationName = _this._declarationName;
        _this._declarationName = $name.value;
        _this._evaluate$_environment.scope$1$2$when(new R._EvaluateVisitor_visitDeclaration_closure(_this, node), node.hasDeclarations, P.Null);
        _this._declarationName = oldDeclarationName;
      }
      return;
    },
    visitEachRule$1: function(node) {
      var _this = this,
        t1 = node.list,
        list = t1.accept$1(_this),
        nodeForSpan = _this._expressionNode$1(t1),
        setVariables = node.variables.length === 1 ? new R._EvaluateVisitor_visitEachRule_closure(_this, node, nodeForSpan) : new R._EvaluateVisitor_visitEachRule_closure0(_this, node, nodeForSpan);
      return _this._evaluate$_environment.scope$1$2$semiGlobal(new R._EvaluateVisitor_visitEachRule_closure1(_this, list, setVariables, node), true, F.Value);
    },
    _setMultipleVariables$3: function(variables, value, nodeForSpan) {
      var i,
        list = value.get$asList(),
        t1 = variables.length,
        minLength = Math.min(t1, list.length);
      for (i = 0; i < minLength; ++i)
        this._evaluate$_environment.setLocalVariable$3(variables[i], list[i].withoutSlash$0(), nodeForSpan);
      for (i = minLength; i < t1; ++i)
        this._evaluate$_environment.setLocalVariable$3(variables[i], C.C_SassNull, nodeForSpan);
    },
    visitErrorRule$1: function(node) {
      throw H.wrapException(this._evaluate$_exception$2(J.toString$0$(node.expression.accept$1(this)), node.span));
    },
    visitExtendRule$1: function(node) {
      var targetText, t1, t2, _i, t3, _this = this;
      if (!(_this._styleRule != null && !_this._atRootExcludingStyleRule) || _this._declarationName != null)
        throw H.wrapException(_this._evaluate$_exception$2("@extend may only be used within style rules.", node.span));
      targetText = _this._interpolationToValue$2$warnForColor(node.selector, true);
      for (t1 = _this._adjustParseError$2(targetText, new R._EvaluateVisitor_visitExtendRule_closure(_this, targetText)).components, t2 = t1.length, _i = 0; _i < t2; ++_i) {
        t3 = t1[_i].components;
        if (t3.length !== 1 || !(C.JSArray_methods.get$first(t3) instanceof X.CompoundSelector))
          throw H.wrapException(E.SassFormatException$("complex selectors may not be extended.", targetText.span));
        t3 = H.interceptedTypeCast(C.JSArray_methods.get$first(t3), "$isCompoundSelector").components;
        if (t3.length !== 1)
          throw H.wrapException(E.SassFormatException$("compound selectors may no longer be extended.\nConsider `@extend " + C.JSArray_methods.join$1(t3, ", ") + "` instead.\nSee http://bit.ly/ExtendCompound for details.\n", targetText.span));
        _this._extender.addExtension$4(_this._styleRule.selector, C.JSArray_methods.get$first(t3), node, _this._mediaQueries);
      }
      return;
    },
    visitAtRule$1: function(node) {
      var $name, t1, value, t2, t3, wasInKeyframes, wasInUnknownAtRule, _this = this;
      if (_this._declarationName != null)
        throw H.wrapException(_this._evaluate$_exception$2("At-rules may not be used within nested declarations.", node.span));
      $name = _this._interpolationToValue$1(node.name);
      t1 = node.value;
      value = t1 == null ? null : _this._interpolationToValue$3$trim$warnForColor(t1, true, true);
      if (node.children == null) {
        t1 = _this._evaluate$_parent;
        t2 = B.ModifiableCssNode;
        t3 = H.setRuntimeTypeInfo([], [t2]);
        t1.addChild$1(new U.ModifiableCssAtRule($name, value, true, node.span, new P.UnmodifiableListView(t3, [t2]), t3));
        return;
      }
      wasInKeyframes = _this._inKeyframes;
      wasInUnknownAtRule = _this._inUnknownAtRule;
      if (B.unvendor($name.value) === "keyframes")
        _this._inKeyframes = true;
      else
        _this._inUnknownAtRule = true;
      t1 = B.ModifiableCssNode;
      t2 = H.setRuntimeTypeInfo([], [t1]);
      _this._withParent$2$4$scopeWhen$through(new U.ModifiableCssAtRule($name, value, false, node.span, new P.UnmodifiableListView(t2, [t1]), t2), new R._EvaluateVisitor_visitAtRule_closure(_this, node), node.hasDeclarations, new R._EvaluateVisitor_visitAtRule_closure0(), U.ModifiableCssAtRule, P.Null);
      _this._inUnknownAtRule = wasInUnknownAtRule;
      _this._inKeyframes = wasInKeyframes;
      return;
    },
    visitForRule$1: function(node) {
      var _this = this, t1 = {},
        t2 = node.from,
        fromNumber = _this._addExceptionSpan$2(t2, new R._EvaluateVisitor_visitForRule_closure(_this, node)),
        t3 = node.to,
        toNumber = _this._addExceptionSpan$2(t3, new R._EvaluateVisitor_visitForRule_closure0(_this, node)),
        from = _this._addExceptionSpan$2(t2, new R._EvaluateVisitor_visitForRule_closure1(fromNumber, toNumber)),
        to = t1.to = _this._addExceptionSpan$2(t3, new R._EvaluateVisitor_visitForRule_closure2(toNumber)),
        direction = from > to ? -1 : 1;
      if (from === (!node.isExclusive ? t1.to = to + direction : to))
        return;
      return _this._evaluate$_environment.scope$1$2$semiGlobal(new R._EvaluateVisitor_visitForRule_closure3(t1, _this, node, from, direction), true, F.Value);
    },
    visitForwardRule$1: function(node) {
      this._loadModule$4(node.url, "@forward", node, new R._EvaluateVisitor_visitForwardRule_closure(this, node));
      return;
    },
    visitFunctionRule$1: function(node) {
      var t1 = this._evaluate$_environment,
        t2 = t1.closure$0(),
        t3 = t1._functions,
        index = t3.length - 1,
        t4 = node.name;
      t1._functionIndices.$indexSet(0, t4, index);
      J.$indexSet$ax(t3[index], t4, new E.UserDefinedCallable(node, t2, [O.Environment]));
      return;
    },
    visitIfRule$1: function(node) {
      var t1, t2, _i, clauseToCheck, _box_0 = {};
      _box_0.clause = node.lastClause;
      for (t1 = node.clauses, t2 = t1.length, _i = 0; _i < t2; ++_i) {
        clauseToCheck = t1[_i];
        if (clauseToCheck.expression.accept$1(this).get$isTruthy()) {
          _box_0.clause = clauseToCheck;
          break;
        }
      }
      t1 = _box_0.clause;
      if (t1 == null)
        return;
      return this._evaluate$_environment.scope$1$3$semiGlobal$when(new R._EvaluateVisitor_visitIfRule_closure(_box_0, this), true, t1.hasDeclarations, F.Value);
    },
    visitImportRule$1: function(node) {
      var t1, t2, t3, t4, t5, _i, $import, t6, result, supports, t7, t8, resolvedSupports, mediaQuery, t9, result0, _this = this, _null = null;
      for (t1 = node.imports, t2 = t1.length, t3 = F.CssMediaQuery, t4 = [P.String], t5 = [F.ModifiableCssImport], _i = 0; _i < t2; ++_i) {
        $import = t1[_i];
        if ($import instanceof B.DynamicImport)
          _this._visitDynamicImport$1($import);
        else {
          H.interceptedTypeCast($import, "$isStaticImport");
          t6 = $import.url;
          result = _this._performInterpolation$2$warnForColor(t6, false);
          supports = $import.supports;
          if (supports instanceof L.SupportsDeclaration) {
            t7 = supports.name;
            t7 = H.S(_this._evaluate$_serialize$3$quote(t7.accept$1(_this), t7, true)) + ": ";
            t8 = supports.value;
            resolvedSupports = t7 + H.S(_this._evaluate$_serialize$3$quote(t8.accept$1(_this), t8, true));
          } else
            resolvedSupports = supports == null ? _null : _this._visitSupportsCondition$1(supports);
          t7 = $import.media;
          mediaQuery = t7 == null ? _null : _this._visitMediaQueries$1(t7);
          t7 = $import.span;
          t8 = resolvedSupports == null ? _null : new F.CssValue("supports(" + resolvedSupports + ")", supports.get$span(), t4);
          if (mediaQuery == null)
            t9 = _null;
          else {
            result0 = P.List_List$from(mediaQuery, false, t3);
            result0.fixed$length = Array;
            result0.immutable$list = Array;
            t9 = result0;
          }
          node = new F.ModifiableCssImport(new F.CssValue(result, t6.span, t4), t8, t9, t7);
          t6 = _this._evaluate$_parent;
          t7 = _this._root;
          if (t6 != t7)
            t6.addChild$1(node);
          else if (_this._endOfImports === J.get$length$asx(t7.children._collection$_source)) {
            t6 = _this._root;
            t6.toString;
            node._parent = t6;
            t6 = t6._children;
            node._indexInParent = t6.length;
            t6.push(node);
            _this._endOfImports = _this._endOfImports + 1;
          } else {
            t6 = _this._outOfOrderImports;
            (t6 == null ? _this._outOfOrderImports = H.setRuntimeTypeInfo([], t5) : t6).push(node);
          }
        }
      }
      return;
    },
    _visitDynamicImport$1: function($import) {
      return this._withStackFrame$3("@import", $import, new R._EvaluateVisitor__visitDynamicImport_closure(this, $import));
    },
    _loadStylesheet$2: function(url, span) {
      var stylesheet, tuple, error, error0, message, t1, t2, t3, exception, _this = this;
      try {
        _this._importSpan = span;
        if (_this._nodeImporter != null) {
          stylesheet = _this._importLikeNode$1(url);
          if (stylesheet != null)
            return new S.Tuple2(null, stylesheet, [M.Importer, V.Stylesheet]);
        } else {
          t1 = P.Uri_parse(url);
          t2 = _this._importer;
          t3 = _this._stylesheet.span;
          tuple = _this._importCache.import$3(t1, t2, t3.file.url);
          if (tuple != null)
            return tuple;
        }
        if (C.JSString_methods.startsWith$1(url, "package:") && true)
          throw H.wrapException('"package:" URLs aren\'t supported on this platform.');
        else
          throw H.wrapException("Can't find stylesheet to import.");
      } catch (exception) {
        t1 = H.unwrapException(exception);
        if (t1 instanceof E.SassException) {
          error = t1;
          t1 = _this._evaluate$_exception$2(error._span_exception$_message, error.get$span());
          throw H.wrapException(t1);
        } else {
          error0 = t1;
          message = null;
          try {
            message = H.stringTypeCast(J.get$message$x(error0));
          } catch (exception) {
            H.unwrapException(exception);
            message = J.toString$0$(error0);
          }
          t1 = _this._evaluate$_exception$1(message);
          throw H.wrapException(t1);
        }
      } finally {
        _this._importSpan = null;
      }
    },
    _importLikeNode$1: function(originalUrl) {
      var contents, url, _this = this,
        t1 = _this._stylesheet.span,
        result = _this._nodeImporter.load$2(originalUrl, t1.file.url);
      if (result == null)
        return;
      contents = result.item1;
      url = result.item2;
      t1 = J.getInterceptor$s(url).startsWith$1(url, "file:") ? $.$get$context().style.pathFromUri$1(M._parseUri(url)) : url;
      _this._includedFiles.add$1(0, t1);
      t1 = C.JSString_methods.startsWith$1(url, "file") ? M.Syntax_forPath(url) : C.Syntax_SCSS;
      return V.Stylesheet_Stylesheet$parse(contents, t1, _this._logger, url);
    },
    visitIncludeRule$1: function(node) {
      var t2, t3, contentCallable, _this = this,
        t1 = [O.Environment],
        mixin = H.subtypeCast(_this._addExceptionSpan$2(node, new R._EvaluateVisitor_visitIncludeRule_closure(_this, node)), "$isUserDefinedCallable", t1, "$asUserDefinedCallable");
      if (mixin == null)
        throw H.wrapException(_this._evaluate$_exception$2("Undefined mixin.", node.span));
      t2 = node.content;
      t3 = t2 == null;
      if (!t3 && !H.interceptedTypeCast(mixin.declaration, "$isMixinRule").hasContent)
        throw H.wrapException(_this._evaluate$_exception$2("Mixin doesn't accept a content block.", node.span));
      contentCallable = t3 ? null : new E.UserDefinedCallable(t2, _this._evaluate$_environment.closure$0(), t1);
      _this._runUserDefinedCallable$4(node.$arguments, mixin, node, new R._EvaluateVisitor_visitIncludeRule_closure0(_this, contentCallable, mixin));
      return;
    },
    visitMixinRule$1: function(node) {
      var t1 = this._evaluate$_environment,
        t2 = t1.closure$0(),
        t3 = t1._mixins,
        index = t3.length - 1,
        t4 = node.name;
      t1._mixinIndices.$indexSet(0, t4, index);
      J.$indexSet$ax(t3[index], t4, new E.UserDefinedCallable(node, t2, [O.Environment]));
      return;
    },
    visitLoudComment$1: function(node) {
      var t1, t2, _this = this;
      if (_this._inFunction)
        return;
      t1 = _this._evaluate$_parent;
      t2 = _this._root;
      if (t1 == t2 && _this._endOfImports === J.get$length$asx(t2.children._collection$_source))
        _this._endOfImports = _this._endOfImports + 1;
      t1 = node.text;
      _this._evaluate$_parent.addChild$1(new R.ModifiableCssComment(_this._performInterpolation$1(t1), t1.span));
      return;
    },
    visitMediaRule$1: function(node) {
      var queries, t1, mergedQueries, _this = this;
      if (_this._declarationName != null)
        throw H.wrapException(_this._evaluate$_exception$2("Media rules may not be used within nested declarations.", node.span));
      queries = _this._visitMediaQueries$1(node.query);
      t1 = _this._mediaQueries;
      mergedQueries = t1 == null ? null : _this._mergeMediaQueries$2(t1, queries);
      t1 = mergedQueries == null;
      if (!t1 && mergedQueries.length === 0)
        return;
      t1 = t1 ? queries : mergedQueries;
      _this._withParent$2$4$scopeWhen$through(G.ModifiableCssMediaRule$(t1, node.span), new R._EvaluateVisitor_visitMediaRule_closure(_this, mergedQueries, queries, node), node.hasDeclarations, new R._EvaluateVisitor_visitMediaRule_closure0(mergedQueries), G.ModifiableCssMediaRule, P.Null);
      return;
    },
    _visitMediaQueries$1: function(interpolation) {
      return this._adjustParseError$2(interpolation, new R._EvaluateVisitor__visitMediaQueries_closure(this, this._performInterpolation$2$warnForColor(interpolation, true)));
    },
    _mergeMediaQueries$2: function(queries1, queries2) {
      var t1, t2, t3, t4, result,
        queries = H.setRuntimeTypeInfo([], [F.CssMediaQuery]);
      for (t1 = J.get$iterator$ax(queries1), t2 = J.getInterceptor$ax(queries2); t1.moveNext$0();) {
        t3 = t1.get$current(t1);
        for (t4 = t2.get$iterator(queries2); t4.moveNext$0();) {
          result = t3.merge$1(t4.get$current(t4));
          if (result === C._SingletonCssMediaQueryMergeResult_empty)
            continue;
          if (result === C._SingletonCssMediaQueryMergeResult_unrepresentable)
            return;
          queries.push(H.interceptedTypeCast(result, "$isMediaQuerySuccessfulMergeResult").query);
        }
      }
      return queries;
    },
    visitReturnRule$1: function(node) {
      return node.expression.accept$1(this);
    },
    visitSilentComment$1: function(node) {
      return;
    },
    visitStyleRule$1: function(node) {
      var t2, selectorText, t3, t4, parsedSelector, rule, oldAtRootExcludingStyleRule, _this = this, t1 = {};
      if (_this._declarationName != null)
        throw H.wrapException(_this._evaluate$_exception$2("Style rules may not be used within nested declarations.", node.span));
      t2 = node.selector;
      selectorText = _this._interpolationToValue$3$trim$warnForColor(t2, true, true);
      if (_this._inKeyframes) {
        t1 = P.List_List$unmodifiable(_this._adjustParseError$2(t2, new R._EvaluateVisitor_visitStyleRule_closure(_this, selectorText)), P.String);
        t3 = B.ModifiableCssNode;
        t4 = H.setRuntimeTypeInfo([], [t3]);
        _this._withParent$2$4$scopeWhen$through(new U.ModifiableCssKeyframeBlock(new F.CssValue(t1, t2.span, [[P.List, P.String]]), node.span, new P.UnmodifiableListView(t4, [t3]), t4), new R._EvaluateVisitor_visitStyleRule_closure0(_this, node), node.hasDeclarations, new R._EvaluateVisitor_visitStyleRule_closure1(), U.ModifiableCssKeyframeBlock, P.Null);
        return;
      }
      t1.parsedSelector = _this._adjustParseError$2(t2, new R._EvaluateVisitor_visitStyleRule_closure2(_this, selectorText));
      parsedSelector = _this._addExceptionSpan$2(t2, new R._EvaluateVisitor_visitStyleRule_closure3(t1, _this));
      t1.parsedSelector = parsedSelector;
      rule = _this._extender.addSelector$4(parsedSelector, t2.span, node.span, _this._mediaQueries);
      oldAtRootExcludingStyleRule = _this._atRootExcludingStyleRule;
      _this._atRootExcludingStyleRule = false;
      _this._withParent$2$4$scopeWhen$through(rule, new R._EvaluateVisitor_visitStyleRule_closure4(_this, rule, node), node.hasDeclarations, new R._EvaluateVisitor_visitStyleRule_closure5(), X.ModifiableCssStyleRule, P.Null);
      _this._atRootExcludingStyleRule = oldAtRootExcludingStyleRule;
      if (!(_this._styleRule != null && !oldAtRootExcludingStyleRule)) {
        t1 = _this._evaluate$_parent.children;
        t1 = !t1.get$isEmpty(t1);
      } else
        t1 = false;
      if (t1) {
        t1 = _this._evaluate$_parent.children;
        t1.get$last(t1).isGroupEnd = true;
      }
      return;
    },
    visitSupportsRule$1: function(node) {
      var t1, t2, t3, t4, _this = this;
      if (_this._declarationName != null)
        throw H.wrapException(_this._evaluate$_exception$2("Supports rules may not be used within nested declarations.", node.span));
      t1 = node.condition;
      t2 = _this._visitSupportsCondition$1(t1);
      t1 = t1.get$span();
      t3 = B.ModifiableCssNode;
      t4 = H.setRuntimeTypeInfo([], [t3]);
      _this._withParent$2$4$scopeWhen$through(new B.ModifiableCssSupportsRule(new F.CssValue(t2, t1, [P.String]), node.span, new P.UnmodifiableListView(t4, [t3]), t4), new R._EvaluateVisitor_visitSupportsRule_closure(_this, node), node.hasDeclarations, new R._EvaluateVisitor_visitSupportsRule_closure0(), B.ModifiableCssSupportsRule, P.Null);
      return;
    },
    _visitSupportsCondition$1: function(condition) {
      var t2, _this = this,
        t1 = J.getInterceptor$(condition);
      if (!!t1.$isSupportsOperation) {
        t1 = condition.left;
        t2 = condition.operator;
        return H.S(_this._parenthesize$2(t1, t2)) + " " + t2 + " " + H.S(_this._parenthesize$2(condition.right, t2));
      } else if (!!t1.$isSupportsNegation)
        return "not " + H.S(_this._parenthesize$1(condition.condition));
      else if (!!t1.$isSupportsInterpolation) {
        t1 = condition.expression;
        return _this._evaluate$_serialize$3$quote(t1.accept$1(_this), t1, false);
      } else if (!!t1.$isSupportsDeclaration) {
        t1 = condition.name;
        t1 = "(" + H.S(_this._evaluate$_serialize$3$quote(t1.accept$1(_this), t1, true)) + ": ";
        t2 = condition.value;
        return t1 + H.S(_this._evaluate$_serialize$3$quote(t2.accept$1(_this), t2, true)) + ")";
      } else
        return;
    },
    _parenthesize$2: function(condition, operator) {
      var t1;
      if (!condition.$isSupportsNegation)
        if (!!condition.$isSupportsOperation)
          t1 = operator == null || operator !== condition.operator;
        else
          t1 = false;
      else
        t1 = true;
      if (t1)
        return "(" + H.S(this._visitSupportsCondition$1(condition)) + ")";
      else
        return this._visitSupportsCondition$1(condition);
    },
    _parenthesize$1: function(condition) {
      return this._parenthesize$2(condition, null);
    },
    visitVariableDeclaration$1: function(node) {
      var value, t1, t2, _this = this;
      if (node.isGuarded) {
        value = _this._addExceptionSpan$2(node, new R._EvaluateVisitor_visitVariableDeclaration_closure(_this, node));
        if (value != null && !value.$eq(0, C.C_SassNull))
          return;
      }
      if (node.isGlobal && !_this._evaluate$_environment.globalVariableExists$1(node.name)) {
        t1 = _this._evaluate$_environment._variables.length === 1 ? "As of Dart Sass 2.0.0, !global assignments won't be able to\ndeclare new variables. Since this assignment is at the root of the stylesheet,\nthe !global flag is unnecessary and can safely be removed." : "As of Dart Sass 2.0.0, !global assignments won't be able to\ndeclare new variables. Consider adding `" + B.declarationName(node.span) + ": null` at the root of the\nstylesheet.";
        t2 = node.span;
        _this._logger.warn$4$deprecation$span$trace(t1, true, t2, _this._stackTrace$1(t2));
      }
      _this._addExceptionSpan$2(node, new R._EvaluateVisitor_visitVariableDeclaration_closure0(_this, node, node.expression.accept$1(_this).withoutSlash$0()));
      return;
    },
    visitUseRule$1: function(node) {
      this._loadModule$4(node.url, "@use", node, new R._EvaluateVisitor_visitUseRule_closure(this, node));
      return;
    },
    visitWarnRule$1: function(node) {
      var _this = this,
        value = _this._addExceptionSpan$2(node, new R._EvaluateVisitor_visitWarnRule_closure(_this, node)),
        t1 = value instanceof D.SassString ? value.text : _this._evaluate$_serialize$2(value, node.expression);
      _this._logger.warn$2$trace(t1, _this._stackTrace$1(node.span));
      return;
    },
    visitWhileRule$1: function(node) {
      return this._evaluate$_environment.scope$1$3$semiGlobal$when(new R._EvaluateVisitor_visitWhileRule_closure(this, node), true, node.hasDeclarations, F.Value);
    },
    visitBinaryOperationExpression$1: function(node) {
      return this._addExceptionSpan$2(node, new R._EvaluateVisitor_visitBinaryOperationExpression_closure(this, node));
    },
    visitValueExpression$1: function(node) {
      return node.value;
    },
    visitVariableExpression$1: function(node) {
      var result = this._addExceptionSpan$2(node, new R._EvaluateVisitor_visitVariableExpression_closure(this, node));
      if (result != null)
        return result;
      throw H.wrapException(this._evaluate$_exception$2("Undefined variable.", node.span));
    },
    visitUnaryOperationExpression$1: function(node) {
      var operand = node.operand.accept$1(this),
        t1 = node.operator;
      switch (t1) {
        case C.UnaryOperator_j2w:
          return operand.unaryPlus$0();
        case C.UnaryOperator_U4G:
          return operand.unaryMinus$0();
        case C.UnaryOperator_zDx:
          operand.toString;
          return new D.SassString("/" + N.serializeValue(operand, false, true), false);
        case C.UnaryOperator_not_not:
          return operand.unaryNot$0();
        default:
          throw H.wrapException(P.StateError$("Unknown unary operator " + H.S(t1) + "."));
      }
    },
    visitBooleanExpression$1: function(node) {
      return node.value ? C.SassBoolean_true : C.SassBoolean_false;
    },
    visitIfExpression$1: function(node) {
      var condition, ifTrue, ifFalse, _this = this,
        pair = _this._evaluateMacroArguments$1(node),
        positional = pair.item1,
        named = pair.item2,
        t1 = J.getInterceptor$asx(positional);
      _this._verifyArguments$4(t1.get$length(positional), named, $.$get$IfExpression_declaration(), node);
      condition = t1.get$length(positional) > 0 ? t1.$index(positional, 0) : named.$index(0, "condition");
      ifTrue = t1.get$length(positional) > 1 ? t1.$index(positional, 1) : named.$index(0, "if-true");
      ifFalse = t1.get$length(positional) > 2 ? t1.$index(positional, 2) : named.$index(0, "if-false");
      return (condition.accept$1(_this).get$isTruthy() ? ifTrue : ifFalse).accept$1(_this);
    },
    visitNullExpression$1: function(node) {
      return C.C_SassNull;
    },
    visitNumberExpression$1: function(node) {
      var t1 = node.unit;
      t1 = t1 == null ? null : H.setRuntimeTypeInfo([t1], [P.String]);
      t1 = t1 == null ? C.List_empty0 : P.List_List$unmodifiable(t1, P.String);
      return new T.SassNumber(node.value, t1, C.List_empty0, null);
    },
    visitParenthesizedExpression$1: function(node) {
      return node.expression.accept$1(this);
    },
    visitColorExpression$1: function(node) {
      return node.value;
    },
    visitListExpression$1: function(node) {
      var t1 = node.contents;
      return D.SassList$(new H.MappedListIterable(t1, new R._EvaluateVisitor_visitListExpression_closure(this), [H.getTypeArgumentByIndex(t1, 0), F.Value]), node.separator, node.hasBrackets);
    },
    visitMapExpression$1: function(node) {
      var t2, t3, _i, pair, t4, keyValue, valueValue,
        t1 = F.Value,
        map = P.LinkedHashMap_LinkedHashMap$_empty(t1, t1);
      for (t2 = node.pairs, t3 = t2.length, _i = 0; _i < t3; ++_i) {
        pair = t2[_i];
        t4 = pair.item1;
        keyValue = t4.accept$1(this);
        valueValue = pair.item2.accept$1(this);
        if (map.containsKey$1(keyValue))
          throw H.wrapException(this._evaluate$_exception$2("Duplicate key.", t4.get$span()));
        map.$indexSet(0, keyValue, valueValue);
      }
      return new A.SassMap(H.ConstantMap_ConstantMap$from(map, t1, t1));
    },
    visitFunctionExpression$1: function(node) {
      var oldInFunction, result, _this = this,
        t1 = node.name,
        plainName = t1.get$asPlain(),
        $function = plainName != null ? _this._addExceptionSpan$2(node, new R._EvaluateVisitor_visitFunctionExpression_closure(_this, node, plainName)) : null;
      if ($function == null) {
        if (node.namespace != null)
          throw H.wrapException(_this._evaluate$_exception$2("Undefined function.", node.span));
        $function = new L.PlainCssCallable(_this._performInterpolation$1(t1));
      }
      oldInFunction = _this._inFunction;
      _this._inFunction = true;
      result = _this._runFunctionCallable$3(node.$arguments, $function, node);
      _this._inFunction = oldInFunction;
      return result;
    },
    _getFunction$2$namespace: function($name, namespace) {
      var local = this._evaluate$_environment.getFunction$2$namespace($name, namespace);
      if (local != null || namespace != null)
        return local;
      return this._builtInFunctions.$index(0, $name);
    },
    _runUserDefinedCallable$4: function($arguments, callable, nodeWithSpan, run) {
      var evaluated = this._evaluateArguments$1($arguments),
        t1 = callable.declaration.name,
        $name = t1 == null ? "@content" : t1 + "()";
      return this._withStackFrame$3($name, nodeWithSpan, new R._EvaluateVisitor__runUserDefinedCallable_closure(this, callable, evaluated, nodeWithSpan, run));
    },
    _runFunctionCallable$3: function($arguments, callable, nodeWithSpan) {
      var t1, t2, t3, first, _i, argument, rest, _this = this;
      if (!!callable.$isBuiltInCallable)
        return _this._runBuiltInCallable$3($arguments, callable, nodeWithSpan).withoutSlash$0();
      else if (H.checkSubtype(callable, "$isUserDefinedCallable", [O.Environment], null))
        return _this._runUserDefinedCallable$4($arguments, callable, nodeWithSpan, new R._EvaluateVisitor__runFunctionCallable_closure(_this, callable)).withoutSlash$0();
      else if (!!callable.$isPlainCssCallable) {
        t1 = $arguments.named;
        if (t1.get$isNotEmpty(t1) || $arguments.keywordRest != null)
          throw H.wrapException(_this._evaluate$_exception$2("Plain CSS functions don't support keyword arguments.", nodeWithSpan.span));
        t1 = H.S(callable.name) + "(";
        for (t2 = $arguments.positional, t3 = t2.length, first = true, _i = 0; _i < t3; ++_i) {
          argument = t2[_i];
          if (first)
            first = false;
          else
            t1 += ", ";
          t1 += H.S(_this._evaluate$_serialize$3$quote(argument.accept$1(_this), argument, true));
        }
        t2 = $arguments.rest;
        rest = t2 == null ? null : t2.accept$1(_this);
        if (rest != null) {
          if (!first)
            t1 += ", ";
          t2 = t1 + H.S(_this._evaluate$_serialize$2(rest, t2));
          t1 = t2;
        }
        t1 += H.Primitives_stringFromCharCode(41);
        return new D.SassString(t1.charCodeAt(0) == 0 ? t1 : t1, false);
      } else
        return;
    },
    _runBuiltInCallable$3: function($arguments, callable, nodeWithSpan) {
      var callback, result, error, message, t1, namedSet, tuple, overload, declaredArguments, i, t2, argument, t3, t4, rest, argumentList, exception, _this = this,
        evaluated = _this._evaluateArguments$2$trackSpans($arguments, false),
        oldCallableNode = _this._callableNode;
      _this._callableNode = nodeWithSpan;
      t1 = P.String;
      namedSet = new M.MapKeySet(evaluated.named, [t1]);
      tuple = callable.callbackFor$2(evaluated.positional.length, namedSet);
      overload = tuple.item1;
      callback = tuple.item2;
      _this._addExceptionSpan$2(nodeWithSpan, new R._EvaluateVisitor__runBuiltInCallable_closure(overload, evaluated, namedSet));
      declaredArguments = overload.$arguments;
      for (i = evaluated.positional.length, t2 = declaredArguments.length; i < t2; ++i) {
        argument = declaredArguments[i];
        t3 = evaluated.positional;
        t4 = evaluated.named.remove$1(0, argument.name);
        if (t4 == null) {
          t4 = argument.defaultValue;
          t4 = t4 == null ? null : t4.accept$1(_this);
        }
        t3.push(t4);
      }
      if (overload.restArgument != null) {
        if (evaluated.positional.length > t2) {
          rest = C.JSArray_methods.sublist$1(evaluated.positional, t2);
          C.JSArray_methods.removeRange$2(evaluated.positional, t2, evaluated.positional.length);
        } else
          rest = C.List_empty1;
        t2 = evaluated.named;
        t3 = evaluated.separator === C.ListSeparator_undecided ? C.ListSeparator_comma : evaluated.separator;
        t4 = F.Value;
        argumentList = new D.SassArgumentList(H.ConstantMap_ConstantMap$from(t2, t1, t4), P.List_List$unmodifiable(rest, t4), t3, false);
        argumentList.SassList$3$brackets(rest, t3, false);
        evaluated.positional.push(argumentList);
      } else
        argumentList = null;
      result = null;
      try {
        result = callback.call$1(evaluated.positional);
        if (result == null)
          throw H.wrapException("Custom functions may not return Dart's null.");
      } catch (exception) {
        error = H.unwrapException(exception);
        message = null;
        try {
          message = H.stringTypeCast(J.get$message$x(error));
        } catch (exception) {
          H.unwrapException(exception);
          message = J.toString$0$(error);
        }
        throw H.wrapException(_this._evaluate$_exception$2(message, nodeWithSpan.span));
      }
      _this._callableNode = oldCallableNode;
      if (argumentList == null)
        return result;
      t1 = evaluated.named;
      if (t1.get$isEmpty(t1))
        return result;
      if (argumentList._wereKeywordsAccessed)
        return result;
      t1 = evaluated.named.get$keys();
      throw H.wrapException(_this._evaluate$_exception$2("No " + B.pluralize("argument", t1.get$length(t1), null) + " named " + H.S(B.toSentence(evaluated.named.get$keys().map$1$1(0, new R._EvaluateVisitor__runBuiltInCallable_closure0(), P.Object), "or")) + ".", nodeWithSpan.span));
    },
    _evaluateArguments$2$trackSpans: function($arguments, trackSpans) {
      var t1, t2, t3, t4, _i, t5, t6, t7, named, t8, positionalNodes, namedNodes, rest, restNodeForSpan, separator, keywordRest, keywordRestNodeForSpan, _this = this, _null = null;
      if (trackSpans == null)
        trackSpans = _this._sourceMap;
      t1 = F.Value;
      t2 = H.setRuntimeTypeInfo([], [t1]);
      for (t3 = $arguments.positional, t4 = t3.length, _i = 0; _i < t4; ++_i)
        t2.push(t3[_i].accept$1(_this));
      t5 = $arguments.named;
      t6 = P.String;
      t7 = T.Expression;
      named = Y.mapMap(t5, _null, new R._EvaluateVisitor__evaluateArguments_closure(_this), t6, t7, t6, t1);
      if (trackSpans) {
        t8 = H.setRuntimeTypeInfo([], [B.AstNode]);
        for (_i = 0; _i < t4; ++_i)
          t8.push(_this._expressionNode$1(t3[_i]));
        positionalNodes = t8;
      } else
        positionalNodes = _null;
      namedNodes = trackSpans ? Y.mapMap(t5, _null, new R._EvaluateVisitor__evaluateArguments_closure0(_this), t6, t7, t6, B.AstNode) : _null;
      t3 = $arguments.rest;
      if (t3 == null)
        return R._ArgumentResults$(t2, named, C.ListSeparator_undecided, namedNodes, positionalNodes);
      rest = t3.accept$1(_this);
      restNodeForSpan = trackSpans ? _this._expressionNode$1(t3) : _null;
      t4 = J.getInterceptor$(rest);
      if (!!t4.$isSassMap) {
        _this._addRestMap$1$3(named, rest, t3, t1);
        if (namedNodes != null)
          namedNodes.addAll$1(0, Y.mapMap(rest.contents, new R._EvaluateVisitor__evaluateArguments_closure1(), new R._EvaluateVisitor__evaluateArguments_closure2(restNodeForSpan), t1, t1, t6, B.AstNode));
        separator = C.ListSeparator_undecided;
      } else if (!!t4.$isSassList) {
        t3 = rest._list$_contents;
        C.JSArray_methods.addAll$1(t2, t3);
        if (positionalNodes != null)
          C.JSArray_methods.addAll$1(positionalNodes, P.List_List$filled(t3.length, restNodeForSpan, B.AstNode));
        separator = rest.separator;
        if (!!rest.$isSassArgumentList) {
          rest._wereKeywordsAccessed = true;
          rest._keywords.forEach$1(0, new R._EvaluateVisitor__evaluateArguments_closure3(named, namedNodes, restNodeForSpan));
        }
      } else {
        t2.push(rest);
        if (positionalNodes != null)
          positionalNodes.push(restNodeForSpan);
        separator = C.ListSeparator_undecided;
      }
      t3 = $arguments.keywordRest;
      if (t3 == null)
        return R._ArgumentResults$(t2, named, separator, namedNodes, positionalNodes);
      keywordRest = t3.accept$1(_this);
      keywordRestNodeForSpan = trackSpans ? _this._expressionNode$1(t3) : _null;
      if (keywordRest instanceof A.SassMap) {
        _this._addRestMap$1$3(named, keywordRest, t3, t1);
        if (namedNodes != null)
          namedNodes.addAll$1(0, Y.mapMap(keywordRest.contents, new R._EvaluateVisitor__evaluateArguments_closure4(), new R._EvaluateVisitor__evaluateArguments_closure5(keywordRestNodeForSpan), t1, t1, t6, B.AstNode));
        return R._ArgumentResults$(t2, named, separator, namedNodes, positionalNodes);
      } else
        throw H.wrapException(_this._evaluate$_exception$2("Variable keyword arguments must be a map (was " + H.S(keywordRest) + ").", t3.get$span()));
    },
    _evaluateArguments$1: function($arguments) {
      return this._evaluateArguments$2$trackSpans($arguments, null);
    },
    _evaluateMacroArguments$1: function(invocation) {
      var t3, positional, named, rest, keywordRest, _this = this,
        t1 = invocation.$arguments,
        t2 = t1.rest;
      if (t2 == null)
        return new S.Tuple2(t1.positional, t1.named, [[P.List, T.Expression], [P.Map, P.String, T.Expression]]);
      t3 = t1.positional;
      positional = H.setRuntimeTypeInfo(t3.slice(0), [H.getTypeArgumentByIndex(t3, 0)]);
      t3 = T.Expression;
      named = P.LinkedHashMap_LinkedHashMap$of(t1.named, P.String, t3);
      rest = t2.accept$1(_this);
      t2 = J.getInterceptor$(rest);
      if (!!t2.$isSassMap)
        _this._addRestMap$1$4(named, rest, invocation, new R._EvaluateVisitor__evaluateMacroArguments_closure(), t3);
      else if (!!t2.$isSassList) {
        t2 = rest._list$_contents;
        C.JSArray_methods.addAll$1(positional, new H.MappedListIterable(t2, new R._EvaluateVisitor__evaluateMacroArguments_closure0(), [H.getTypeArgumentByIndex(t2, 0), t3]));
        if (!!rest.$isSassArgumentList) {
          rest._wereKeywordsAccessed = true;
          rest._keywords.forEach$1(0, new R._EvaluateVisitor__evaluateMacroArguments_closure1(named));
        }
      } else
        positional.push(new F.ValueExpression(rest, null));
      t1 = t1.keywordRest;
      if (t1 == null)
        return new S.Tuple2(positional, named, [[P.List, T.Expression], [P.Map, P.String, T.Expression]]);
      keywordRest = t1.accept$1(_this);
      if (keywordRest instanceof A.SassMap) {
        _this._addRestMap$1$4(named, keywordRest, invocation, new R._EvaluateVisitor__evaluateMacroArguments_closure2(), t3);
        return new S.Tuple2(positional, named, [[P.List, T.Expression], [P.Map, P.String, T.Expression]]);
      } else
        throw H.wrapException(_this._evaluate$_exception$2("Variable keyword arguments must be a map (was " + H.S(keywordRest) + ").", invocation.span));
    },
    _addRestMap$1$4: function(values, map, nodeForSpan, convert, $T) {
      var t1 = {};
      t1.convert = convert;
      if (convert == null)
        t1.convert = new R._EvaluateVisitor__addRestMap_closure($T);
      map.contents.forEach$1(0, new R._EvaluateVisitor__addRestMap_closure0(t1, this, values, map, nodeForSpan));
    },
    _addRestMap$1$3: function(values, map, nodeForSpan, $T) {
      return this._addRestMap$1$4(values, map, nodeForSpan, null, $T);
    },
    _verifyArguments$4: function(positional, named, $arguments, nodeWithSpan) {
      return this._addExceptionSpan$2(nodeWithSpan, new R._EvaluateVisitor__verifyArguments_closure($arguments, positional, named));
    },
    visitSelectorExpression$1: function(node) {
      var t1 = this._styleRule;
      if (t1 == null)
        return C.C_SassNull;
      return t1.originalSelector.get$asSassList();
    },
    visitStringExpression$1: function(node) {
      var t1 = node.text.contents;
      return new D.SassString(new H.MappedListIterable(t1, new R._EvaluateVisitor_visitStringExpression_closure(this), [H.getTypeArgumentByIndex(t1, 0), P.String]).join$0(0), node.hasQuotes);
    },
    visitCssAtRule$1: function(node) {
      var t1, t2, t3, wasInKeyframes, wasInUnknownAtRule, _this = this;
      if (_this._declarationName != null)
        throw H.wrapException(_this._evaluate$_exception$2("At-rules may not be used within nested declarations.", node.span));
      if (node.isChildless) {
        t1 = _this._evaluate$_parent;
        t2 = B.ModifiableCssNode;
        t3 = H.setRuntimeTypeInfo([], [t2]);
        t1.addChild$1(new U.ModifiableCssAtRule(node.name, node.value, true, node.span, new P.UnmodifiableListView(t3, [t2]), t3));
        return;
      }
      wasInKeyframes = _this._inKeyframes;
      wasInUnknownAtRule = _this._inUnknownAtRule;
      t1 = node.name;
      if (B.unvendor(t1.get$value()) === "keyframes")
        _this._inKeyframes = true;
      else
        _this._inUnknownAtRule = true;
      t2 = B.ModifiableCssNode;
      t3 = H.setRuntimeTypeInfo([], [t2]);
      _this._withParent$2$4$scopeWhen$through(new U.ModifiableCssAtRule(t1, node.value, false, node.span, new P.UnmodifiableListView(t3, [t2]), t3), new R._EvaluateVisitor_visitCssAtRule_closure(_this, node), false, new R._EvaluateVisitor_visitCssAtRule_closure0(), U.ModifiableCssAtRule, P.Null);
      _this._inUnknownAtRule = wasInUnknownAtRule;
      _this._inKeyframes = wasInKeyframes;
    },
    visitCssComment$1: function(node) {
      var _this = this,
        t1 = _this._evaluate$_parent,
        t2 = _this._root;
      if (t1 == t2 && _this._endOfImports === J.get$length$asx(t2.children._collection$_source))
        _this._endOfImports = _this._endOfImports + 1;
      _this._evaluate$_parent.addChild$1(new R.ModifiableCssComment(node.text, node.span));
    },
    visitCssDeclaration$1: function(node) {
      this._evaluate$_parent.addChild$1(L.ModifiableCssDeclaration$(node.name, node.value, node.span, node.valueSpanForMap));
    },
    visitCssImport$1: function(node) {
      var _this = this,
        modifiableNode = F.ModifiableCssImport$(node.url, node.span, node.media, node.supports),
        t1 = _this._evaluate$_parent,
        t2 = _this._root;
      if (t1 != t2)
        t1.addChild$1(modifiableNode);
      else if (_this._endOfImports === J.get$length$asx(t2.children._collection$_source)) {
        _this._root.addChild$1(modifiableNode);
        _this._endOfImports = _this._endOfImports + 1;
      } else {
        t1 = _this._outOfOrderImports;
        (t1 == null ? _this._outOfOrderImports = H.setRuntimeTypeInfo([], [F.ModifiableCssImport]) : t1).push(modifiableNode);
      }
    },
    visitCssKeyframeBlock$1: function(node) {
      var t1 = B.ModifiableCssNode,
        t2 = H.setRuntimeTypeInfo([], [t1]);
      this._withParent$2$4$scopeWhen$through(new U.ModifiableCssKeyframeBlock(node.selector, node.span, new P.UnmodifiableListView(t2, [t1]), t2), new R._EvaluateVisitor_visitCssKeyframeBlock_closure(this, node), false, new R._EvaluateVisitor_visitCssKeyframeBlock_closure0(), U.ModifiableCssKeyframeBlock, P.Null);
    },
    visitCssMediaRule$1: function(node) {
      var t1, mergedQueries, _this = this;
      if (_this._declarationName != null)
        throw H.wrapException(_this._evaluate$_exception$2("Media rules may not be used within nested declarations.", node.span));
      t1 = _this._mediaQueries;
      mergedQueries = t1 == null ? null : _this._mergeMediaQueries$2(t1, node.queries);
      t1 = mergedQueries == null;
      if (!t1 && mergedQueries.length === 0)
        return;
      t1 = t1 ? node.queries : mergedQueries;
      _this._withParent$2$4$scopeWhen$through(G.ModifiableCssMediaRule$(t1, node.span), new R._EvaluateVisitor_visitCssMediaRule_closure(_this, mergedQueries, node), false, new R._EvaluateVisitor_visitCssMediaRule_closure0(mergedQueries), G.ModifiableCssMediaRule, P.Null);
    },
    visitCssStyleRule$1: function(node) {
      var t1, t2, t3, t4, rule, oldAtRootExcludingStyleRule, _this = this;
      if (_this._declarationName != null)
        throw H.wrapException(_this._evaluate$_exception$2("Style rules may not be used within nested declarations.", node.span));
      t1 = _this._extender;
      t2 = node.selector;
      t3 = t2.value;
      t4 = _this._styleRule;
      t4 = t4 == null ? null : t4.originalSelector;
      rule = t1.addSelector$4(t3.resolveParentSelectors$2$implicitParent(t4, !_this._atRootExcludingStyleRule), t2.span, node.span, _this._mediaQueries);
      oldAtRootExcludingStyleRule = _this._atRootExcludingStyleRule;
      _this._atRootExcludingStyleRule = false;
      _this._withParent$2$4$scopeWhen$through(rule, new R._EvaluateVisitor_visitCssStyleRule_closure(_this, rule, node), false, new R._EvaluateVisitor_visitCssStyleRule_closure0(), X.ModifiableCssStyleRule, P.Null);
      _this._atRootExcludingStyleRule = oldAtRootExcludingStyleRule;
      if (!(_this._styleRule != null && !oldAtRootExcludingStyleRule)) {
        t1 = _this._evaluate$_parent.children;
        t1 = !t1.get$isEmpty(t1);
      } else
        t1 = false;
      if (t1) {
        t1 = _this._evaluate$_parent.children;
        t1.get$last(t1).isGroupEnd = true;
      }
    },
    visitCssStylesheet$1: function(node) {
      var t1;
      for (t1 = J.get$iterator$ax(node.get$children()); t1.moveNext$0();)
        t1.get$current(t1).accept$1(this);
    },
    visitCssSupportsRule$1: function(node) {
      var t1, t2, _this = this;
      if (_this._declarationName != null)
        throw H.wrapException(_this._evaluate$_exception$2("Supports rules may not be used within nested declarations.", node.span));
      t1 = B.ModifiableCssNode;
      t2 = H.setRuntimeTypeInfo([], [t1]);
      _this._withParent$2$4$scopeWhen$through(new B.ModifiableCssSupportsRule(node.condition, node.span, new P.UnmodifiableListView(t2, [t1]), t2), new R._EvaluateVisitor_visitCssSupportsRule_closure(_this, node), false, new R._EvaluateVisitor_visitCssSupportsRule_closure0(), B.ModifiableCssSupportsRule, P.Null);
    },
    _handleReturn$1$2: function(list, callback) {
      var t1, _i, result;
      for (t1 = list.length, _i = 0; _i < list.length; list.length === t1 || (0, H.throwConcurrentModificationError)(list), ++_i) {
        result = callback.call$1(list[_i]);
        if (result != null)
          return result;
      }
      return;
    },
    _handleReturn$2: function(list, callback) {
      return this._handleReturn$1$2(list, callback, null);
    },
    _withEnvironment$1$2: function(environment, callback) {
      var result,
        oldEnvironment = this._evaluate$_environment;
      this._evaluate$_environment = environment;
      result = callback.call$0();
      this._evaluate$_environment = oldEnvironment;
      return result;
    },
    _withEnvironment$2: function(environment, callback) {
      return this._withEnvironment$1$2(environment, callback, null);
    },
    _interpolationToValue$3$trim$warnForColor: function(interpolation, trim, warnForColor) {
      var result = this._performInterpolation$2$warnForColor(interpolation, warnForColor),
        t1 = trim ? B.trimAscii(result, true) : result;
      return new F.CssValue(t1, interpolation.span, [P.String]);
    },
    _interpolationToValue$1: function(interpolation) {
      return this._interpolationToValue$3$trim$warnForColor(interpolation, false, false);
    },
    _interpolationToValue$2$warnForColor: function(interpolation, warnForColor) {
      return this._interpolationToValue$3$trim$warnForColor(interpolation, false, warnForColor);
    },
    _performInterpolation$2$warnForColor: function(interpolation, warnForColor) {
      var t1 = interpolation.contents;
      return new H.MappedListIterable(t1, new R._EvaluateVisitor__performInterpolation_closure(this, warnForColor), [H.getTypeArgumentByIndex(t1, 0), P.String]).join$0(0);
    },
    _performInterpolation$1: function(interpolation) {
      return this._performInterpolation$2$warnForColor(interpolation, false);
    },
    _evaluate$_serialize$3$quote: function(value, nodeWithSpan, quote) {
      return this._addExceptionSpan$2(nodeWithSpan, new R._EvaluateVisitor__serialize_closure(value, quote));
    },
    _evaluate$_serialize$2: function(value, nodeWithSpan) {
      return this._evaluate$_serialize$3$quote(value, nodeWithSpan, true);
    },
    _expressionNode$1: function(expression) {
      if (!this._sourceMap)
        return;
      if (expression instanceof S.VariableExpression)
        return this._evaluate$_environment.getVariableNode$2$namespace(expression.name, expression.namespace);
      else
        return expression;
    },
    _withParent$2$4$scopeWhen$through: function(node, callback, scopeWhen, through, $S, $T) {
      var oldParent, result, _this = this;
      _this._addChild$2$through(node, through);
      oldParent = _this._evaluate$_parent;
      _this._evaluate$_parent = node;
      result = _this._evaluate$_environment.scope$1$2$when(callback, scopeWhen, $T);
      _this._evaluate$_parent = oldParent;
      return result;
    },
    _withParent$2$3$scopeWhen: function(node, callback, scopeWhen, $S, $T) {
      return this._withParent$2$4$scopeWhen$through(node, callback, scopeWhen, null, $S, $T);
    },
    _withParent$2$2: function(node, callback, $S, $T) {
      return this._withParent$2$4$scopeWhen$through(node, callback, true, null, $S, $T);
    },
    _addChild$2$through: function(node, through) {
      var grandparent,
        $parent = this._evaluate$_parent;
      if (through != null) {
        for (; through.call$1($parent);)
          $parent = $parent._parent;
        if ($parent.get$hasFollowingSibling()) {
          grandparent = $parent._parent;
          $parent = $parent.copyWithoutChildren$0();
          grandparent.addChild$1($parent);
        }
      }
      $parent.addChild$1(node);
    },
    _addChild$1: function(node) {
      return this._addChild$2$through(node, null);
    },
    _withStyleRule$1$2: function(rule, callback) {
      var result,
        oldRule = this._styleRule;
      this._styleRule = rule;
      result = callback.call$0();
      this._styleRule = oldRule;
      return result;
    },
    _withStyleRule$2: function(rule, callback) {
      return this._withStyleRule$1$2(rule, callback, null);
    },
    _withMediaQueries$1$2: function(queries, callback) {
      var result,
        oldMediaQueries = this._mediaQueries;
      this._mediaQueries = queries;
      result = callback.call$0();
      this._mediaQueries = oldMediaQueries;
      return result;
    },
    _withMediaQueries$2: function(queries, callback) {
      return this._withMediaQueries$1$2(queries, callback, null);
    },
    _withStackFrame$1$3: function(member, nodeWithSpan, callback) {
      var oldMember, result, _this = this,
        t1 = _this._stack;
      t1.push(new S.Tuple2(_this._member, nodeWithSpan, [P.String, B.AstNode]));
      oldMember = _this._member;
      _this._member = member;
      result = callback.call$0();
      _this._member = oldMember;
      t1.pop();
      return result;
    },
    _withStackFrame$3: function(member, nodeWithSpan, callback) {
      return this._withStackFrame$1$3(member, nodeWithSpan, callback, null);
    },
    _stackFrame$2: function(member, span) {
      var url = span.file.url;
      return B.frameForSpan(span, member, url != null && this._importCache != null ? this._importCache.humanize$1(url) : url);
    },
    _stackTrace$1: function(span) {
      var t3, _this = this,
        t1 = A.Frame,
        t2 = H.setRuntimeTypeInfo([], [t1]);
      for (t3 = _this._stack, t3 = new H.MappedListIterable(t3, new R._EvaluateVisitor__stackTrace_closure(_this), [H.getTypeArgumentByIndex(t3, 0), t1]), t3 = new H.ListIterator(t3, t3.get$length(t3)); t3.moveNext$0();)
        t2.push(t3.__internal$_current);
      if (span != null)
        t2.push(_this._stackFrame$2(_this._member, span));
      return new Y.Trace(P.List_List$unmodifiable(new H.ReversedListIterable(t2, [H.getTypeArgumentByIndex(t2, 0)]), t1), new P._StringStackTrace(null));
    },
    _warn$3$deprecation: function(message, span, deprecation) {
      return this._logger.warn$4$deprecation$span$trace(message, deprecation, span, this._stackTrace$1(span));
    },
    _warn$2: function(message, span) {
      return this._warn$3$deprecation(message, span, false);
    },
    _evaluate$_exception$2: function(message, span) {
      var t1 = span == null ? C.JSArray_methods.get$last(this._stack).item2.get$span() : span;
      return new E.SassRuntimeException(this._stackTrace$1(span), message, t1);
    },
    _evaluate$_exception$1: function(message) {
      return this._evaluate$_exception$2(message, null);
    },
    _adjustParseError$1$2: function(nodeWithSpan, callback) {
      var error, errorText, span, syntheticFile, syntheticSpan, t1, exception, t2, t3, t4, t5, _null = null;
      try {
        t1 = callback.call$0();
        return t1;
      } catch (exception) {
        t1 = H.unwrapException(exception);
        if (t1 instanceof E.SassFormatException) {
          error = t1;
          t1 = error;
          errorText = P.String_String$fromCharCodes(C.NativeUint32List_methods.sublist$2(G.SourceSpanException.prototype.get$span.call(t1).file._decodedChars, 0, _null), 0, _null);
          span = nodeWithSpan.get$span();
          t1 = span;
          t2 = span;
          syntheticFile = C.JSString_methods.replaceRange$3(P.String_String$fromCharCodes(C.NativeUint32List_methods.sublist$2(span.file._decodedChars, 0, _null), 0, _null), Y.FileLocation$_(t1.file, t1._start).offset, Y.FileLocation$_(t2.file, t2._end).offset, errorText);
          t2 = syntheticFile;
          t1 = span.file.url;
          t2.toString;
          t2 = new H.CodeUnits(t2);
          t3 = H.setRuntimeTypeInfo([0], [P.int]);
          t3 = new Y.SourceFile(t1, t3, new Uint32Array(H._ensureNativeList(t2.toList$0(t2))));
          t3.SourceFile$decoded$2$url(t2, t1);
          t1 = span;
          t1 = Y.FileLocation$_(t1.file, t1._start);
          t2 = error;
          t2 = G.SourceSpanException.prototype.get$span.call(t2);
          t2 = Y.FileLocation$_(t2.file, t2._start);
          t4 = span;
          t4 = Y.FileLocation$_(t4.file, t4._start);
          t5 = error;
          t5 = G.SourceSpanException.prototype.get$span.call(t5);
          syntheticSpan = t3.span$2(t1.offset + t2.offset, t4.offset + Y.FileLocation$_(t5.file, t5._end).offset);
          throw H.wrapException(this._evaluate$_exception$2(error._span_exception$_message, syntheticSpan));
        } else
          throw exception;
      }
    },
    _adjustParseError$2: function(nodeWithSpan, callback) {
      return this._adjustParseError$1$2(nodeWithSpan, callback, null);
    },
    _addExceptionSpan$1$2: function(nodeWithSpan, callback) {
      var error, t1, exception;
      try {
        t1 = callback.call$0();
        return t1;
      } catch (exception) {
        t1 = H.unwrapException(exception);
        if (t1 instanceof E.SassScriptException) {
          error = t1;
          throw H.wrapException(this._evaluate$_exception$2(error.message, nodeWithSpan.get$span()));
        } else
          throw exception;
      }
    },
    _addExceptionSpan$2: function(nodeWithSpan, callback) {
      return this._addExceptionSpan$1$2(nodeWithSpan, callback, null);
    }
  };
  R._EvaluateVisitor_closure.prototype = {
    call$1: function($arguments) {
      var module, t2,
        t1 = J.getInterceptor$asx($arguments),
        variable = t1.$index($arguments, 0).assertString$1("name");
      t1 = t1.$index($arguments, 1).get$realNull();
      module = t1 == null ? null : t1.assertString$1("module");
      t1 = this.$this._evaluate$_environment;
      t2 = variable.text;
      t2.toString;
      t2 = H.stringReplaceAllUnchecked(t2, "_", "-");
      return t1.globalVariableExists$2$namespace(t2, module == null ? null : module.text) ? C.SassBoolean_true : C.SassBoolean_false;
    },
    $signature: 3
  };
  R._EvaluateVisitor_closure0.prototype = {
    call$1: function($arguments) {
      var variable = J.$index$asx($arguments, 0).assertString$1("name"),
        t1 = this.$this._evaluate$_environment,
        t2 = variable.text;
      t2.toString;
      return t1.getVariable$1(H.stringReplaceAllUnchecked(t2, "_", "-")) != null ? C.SassBoolean_true : C.SassBoolean_false;
    },
    $signature: 3
  };
  R._EvaluateVisitor_closure1.prototype = {
    call$1: function($arguments) {
      var module, t2, t3, t4,
        t1 = J.getInterceptor$asx($arguments),
        variable = t1.$index($arguments, 0).assertString$1("name");
      t1 = t1.$index($arguments, 1).get$realNull();
      module = t1 == null ? null : t1.assertString$1("module");
      t1 = this.$this;
      t2 = t1._evaluate$_environment;
      t3 = variable.text;
      t3.toString;
      t4 = H.stringReplaceAllUnchecked(t3, "_", "-");
      return t2.getFunction$2$namespace(t4, module == null ? null : module.text) != null || t1._builtInFunctions.containsKey$1(t3) ? C.SassBoolean_true : C.SassBoolean_false;
    },
    $signature: 3
  };
  R._EvaluateVisitor_closure2.prototype = {
    call$1: function($arguments) {
      var module, t2,
        t1 = J.getInterceptor$asx($arguments),
        variable = t1.$index($arguments, 0).assertString$1("name");
      t1 = t1.$index($arguments, 1).get$realNull();
      module = t1 == null ? null : t1.assertString$1("module");
      t1 = this.$this._evaluate$_environment;
      t2 = variable.text;
      t2.toString;
      t2 = H.stringReplaceAllUnchecked(t2, "_", "-");
      return t1.getMixin$2$namespace(t2, module == null ? null : module.text) != null ? C.SassBoolean_true : C.SassBoolean_false;
    },
    $signature: 3
  };
  R._EvaluateVisitor_closure3.prototype = {
    call$1: function($arguments) {
      var t1 = this.$this._evaluate$_environment;
      if (!t1._inMixin)
        throw H.wrapException(E.SassScriptException$("content-exists() may only be called within a mixin."));
      return t1._content != null ? C.SassBoolean_true : C.SassBoolean_false;
    },
    $signature: 3
  };
  R._EvaluateVisitor_closure4.prototype = {
    call$1: function($arguments) {
      var t2, t3, t4,
        t1 = J.$index$asx($arguments, 0).assertString$1("module").text,
        module = this.$this._evaluate$_environment._environment$_modules.$index(0, t1);
      if (module == null)
        throw H.wrapException('There is no module with namespace "' + H.S(t1) + '".');
      t1 = F.Value;
      t2 = P.LinkedHashMap_LinkedHashMap$_empty(t1, t1);
      for (t3 = module.get$variables().get$entries(), t3 = t3.get$iterator(t3); t3.moveNext$0();) {
        t4 = t3.get$current(t3);
        t2.$indexSet(0, new D.SassString(t4.key, true), t4.value);
      }
      return new A.SassMap(H.ConstantMap_ConstantMap$from(t2, t1, t1));
    },
    $signature: 9
  };
  R._EvaluateVisitor_closure5.prototype = {
    call$1: function($arguments) {
      var t2, t3, t4,
        t1 = J.$index$asx($arguments, 0).assertString$1("module").text,
        module = this.$this._evaluate$_environment._environment$_modules.$index(0, t1);
      if (module == null)
        throw H.wrapException('There is no module with namespace "' + H.S(t1) + '".');
      t1 = F.Value;
      t2 = P.LinkedHashMap_LinkedHashMap$_empty(t1, t1);
      for (t3 = module.get$functions(module).get$entries(), t3 = t3.get$iterator(t3); t3.moveNext$0();) {
        t4 = t3.get$current(t3);
        t2.$indexSet(0, new D.SassString(t4.key, true), new F.SassFunction(t4.value));
      }
      return new A.SassMap(H.ConstantMap_ConstantMap$from(t2, t1, t1));
    },
    $signature: 9
  };
  R._EvaluateVisitor_closure6.prototype = {
    call$1: function($arguments) {
      var module, callable,
        t1 = J.getInterceptor$asx($arguments),
        $name = t1.$index($arguments, 0).assertString$1("name"),
        css = t1.$index($arguments, 1).get$isTruthy();
      t1 = t1.$index($arguments, 2).get$realNull();
      module = t1 == null ? null : t1.assertString$1("module");
      if (css && module != null)
        throw H.wrapException("$css and $module may not both be passed at once.");
      if (css)
        callable = new L.PlainCssCallable($name.text);
      else {
        t1 = this.$this;
        callable = t1._addExceptionSpan$2(t1._callableNode, new R._EvaluateVisitor__closure1(t1, $name, module));
      }
      if (callable != null)
        return new F.SassFunction(callable);
      throw H.wrapException("Function not found: " + $name.toString$0(0));
    },
    $signature: 33
  };
  R._EvaluateVisitor__closure1.prototype = {
    call$0: function() {
      var t2,
        t1 = this.name.text;
      t1.toString;
      t1 = H.stringReplaceAllUnchecked(t1, "_", "-");
      t2 = this.module;
      t2 = t2 == null ? null : t2.text;
      return this.$this._getFunction$2$namespace(t1, t2);
    }
  };
  R._EvaluateVisitor_closure7.prototype = {
    call$1: function($arguments) {
      var t2, t3, t4, t5, t6, t7, invocation, callable,
        t1 = J.getInterceptor$asx($arguments),
        $function = t1.$index($arguments, 0),
        args = H.interceptedTypeCast(t1.$index($arguments, 1), "$isSassArgumentList");
      t1 = T.Expression;
      t2 = H.setRuntimeTypeInfo([], [t1]);
      t3 = P.String;
      t4 = this.$this;
      t5 = t4._callableNode.span;
      args._wereKeywordsAccessed = true;
      t6 = args._keywords;
      if (t6.get$isEmpty(t6))
        t6 = null;
      else {
        args._wereKeywordsAccessed = true;
        t7 = F.Value;
        t7 = new F.ValueExpression(new A.SassMap(H.ConstantMap_ConstantMap$from(Y.mapMap(t6, new R._EvaluateVisitor__closure(), new R._EvaluateVisitor__closure0(), t3, t7, t7, t7), t7, t7)), t4._callableNode.span);
        t6 = t7;
      }
      invocation = X.ArgumentInvocation$(t2, P.LinkedHashMap_LinkedHashMap$_empty(t3, t1), t5, t6, new F.ValueExpression(args, t5));
      if ($function instanceof D.SassString) {
        N.warn("Passing a string to call() is deprecated and will be illegal\nin Dart Sass 2.0.0. Use call(get-function(" + $function.toString$0(0) + ")) instead.", true);
        return t4.visitFunctionExpression$1(new F.FunctionExpression(null, X.Interpolation$(H.setRuntimeTypeInfo([$function.text], [P.Object]), t4._callableNode.span), invocation, t4._callableNode.span));
      }
      callable = $function.assertFunction$1("function").callable;
      if (!!J.getInterceptor$(callable).$isCallable)
        return t4._runFunctionCallable$3(invocation, callable, t4._callableNode);
      else
        throw H.wrapException(E.SassScriptException$("The function " + H.S(callable.get$name()) + " is asynchronous.\nThis is probably caused by a bug in a Sass plugin."));
    },
    $signature: 0
  };
  R._EvaluateVisitor__closure.prototype = {
    call$2: function(key, _) {
      return new D.SassString(key, false);
    }
  };
  R._EvaluateVisitor__closure0.prototype = {
    call$2: function(_, value) {
      return value;
    }
  };
  R._EvaluateVisitor_run_closure.prototype = {
    call$0: function() {
      var t2, _this = this,
        t1 = _this.node,
        url = t1.span.file.url;
      if (url != null) {
        t2 = _this.$this;
        t2._activeModules.add$1(0, url);
        if (t2._nodeImporter != null)
          if (url.get$scheme() === "file")
            t2._includedFiles.add$1(0, $.$get$context().style.pathFromUri$1(M._parseUri(url)));
          else if (url.toString$0(0) !== "stdin")
            t2._includedFiles.add$1(0, url.toString$0(0));
      }
      t2 = _this.$this;
      return new E.EvaluateResult(t2._combineCss$1(t2._execute$2(_this.importer, t1)), t2._includedFiles);
    }
  };
  R._EvaluateVisitor_runExpression_closure.prototype = {
    call$0: function() {
      var t2, t3, t4,
        t1 = this.$this;
      t1._evaluate$_environment = O.Environment$(t1._sourceMap);
      t2 = this.variables;
      t3 = t2.get$keys();
      t3 = J.get$iterator$ax(t3);
      for (; t3.moveNext$0();) {
        t4 = t3.get$current(t3);
        t1._evaluate$_environment.setVariable$4$global(t4, t2.$index(0, t4), null, true);
      }
      return this.expression.accept$1(t1);
    }
  };
  R._EvaluateVisitor__withWarnCallback_closure.prototype = {
    call$2: function(message, deprecation) {
      var t1 = this.$this,
        t2 = t1._importSpan;
      return t1._warn$3$deprecation(message, t2 == null ? t1._callableNode.span : t2, deprecation);
    },
    "call*": "call$2",
    $requiredArgCount: 2
  };
  R._EvaluateVisitor__loadModule_closure.prototype = {
    call$0: function() {
      var module, error, exception, _this = this,
        t1 = _this.$this,
        result = B.inUseRule(new R._EvaluateVisitor__loadModule__closure(t1, _this.url, _this.nodeForSpan)),
        importer = result.item1,
        stylesheet = result.item2,
        canonicalUrl = stylesheet.span.file.url,
        t2 = t1._activeModules;
      if (t2.contains$1(0, canonicalUrl))
        throw H.wrapException(t1._evaluate$_exception$1("Module loop: this module is already being loaded."));
      t2.add$1(0, canonicalUrl);
      module = null;
      try {
        module = t1._execute$2(importer, stylesheet);
      } finally {
        t2.remove$1(0, canonicalUrl);
      }
      try {
        _this.callback.call$1(module);
      } catch (exception) {
        t2 = H.unwrapException(exception);
        if (t2 instanceof E.SassScriptException) {
          error = t2;
          throw H.wrapException(t1._evaluate$_exception$1(error.message));
        } else
          throw exception;
      }
    }
  };
  R._EvaluateVisitor__loadModule__closure.prototype = {
    call$0: function() {
      return this.$this._loadStylesheet$2(J.toString$0$(this.url), this.nodeForSpan.get$span());
    }
  };
  R._EvaluateVisitor__execute_closure.prototype = {
    call$0: function() {
      var t3, extender, t1 = {},
        t2 = this.$this,
        environment = O.Environment$(t2._sourceMap);
      t1.css = null;
      t3 = M.SimpleSelector;
      extender = new F.Extender(P.LinkedHashMap_LinkedHashMap$_empty(t3, [P.Set, X.ModifiableCssStyleRule]), P.LinkedHashMap_LinkedHashMap$_empty(t3, [P.Map, S.ComplexSelector, S.Extension]), P.LinkedHashMap_LinkedHashMap$_empty(t3, [P.List, S.Extension]), P.LinkedHashMap_LinkedHashMap$_empty(X.CssStyleRule, [P.List, F.CssMediaQuery]), P._LinkedIdentityHashMap__LinkedIdentityHashMap$es6(t3, P.int), new P._LinkedIdentityHashSet([S.ComplexSelector]), C.ExtendMode_normal);
      t2._withEnvironment$2(environment, new R._EvaluateVisitor__execute__closure(t1, t2, this.importer, this.stylesheet, extender));
      return O._EnvironmentModule__EnvironmentModule(environment, t1.css, extender, environment._forwardedModules);
    }
  };
  R._EvaluateVisitor__execute__closure.prototype = {
    call$0: function() {
      var t2, t3, t4, t5, css, _this = this,
        t1 = _this.$this,
        oldImporter = t1._importer,
        oldStylesheet = t1._stylesheet,
        oldRoot = t1._root,
        oldParent = t1._evaluate$_parent,
        oldEndOfImports = t1._endOfImports,
        oldOutOfOrderImports = t1._outOfOrderImports,
        oldExtender = t1._extender,
        oldStyleRule = t1._styleRule,
        oldMediaQueries = t1._mediaQueries,
        oldDeclarationName = t1._declarationName,
        oldInUnknownAtRule = t1._inUnknownAtRule,
        oldAtRootExcludingStyleRule = t1._atRootExcludingStyleRule,
        oldInKeyframes = t1._inKeyframes;
      t1._importer = _this.importer;
      t2 = t1._stylesheet = _this.stylesheet;
      t3 = t2.span;
      t4 = B.ModifiableCssNode;
      t5 = H.setRuntimeTypeInfo([], [t4]);
      t1._evaluate$_parent = t1._root = new V.ModifiableCssStylesheet(t3, new P.UnmodifiableListView(t5, [t4]), t5);
      t1._endOfImports = 0;
      t1._outOfOrderImports = null;
      t1._extender = _this.extender;
      t1._declarationName = t1._mediaQueries = t1._styleRule = null;
      t1._inKeyframes = t1._atRootExcludingStyleRule = t1._inUnknownAtRule = false;
      t1.visitStylesheet$1(t2);
      css = t1._outOfOrderImports == null ? t1._root : new V.CssStylesheet(new P.UnmodifiableListView(t1._addOutOfOrderImports$0(), [B.CssNode]), t3);
      _this._box_0.css = css;
      t1._importer = oldImporter;
      t1._stylesheet = oldStylesheet;
      t1._root = oldRoot;
      t1._evaluate$_parent = oldParent;
      t1._endOfImports = oldEndOfImports;
      t1._outOfOrderImports = oldOutOfOrderImports;
      t1._extender = oldExtender;
      t1._styleRule = oldStyleRule;
      t1._mediaQueries = oldMediaQueries;
      t1._declarationName = oldDeclarationName;
      t1._inUnknownAtRule = oldInUnknownAtRule;
      t1._atRootExcludingStyleRule = oldAtRootExcludingStyleRule;
      t1._inKeyframes = oldInKeyframes;
    }
  };
  R._EvaluateVisitor__combineCss_closure.prototype = {
    call$1: function(module) {
      return module.get$transitivelyContainsCss();
    }
  };
  R._EvaluateVisitor__combineCss_closure0.prototype = {
    call$1: function(target) {
      return !this.selectors.contains$1(0, target);
    }
  };
  R._EvaluateVisitor__combineCss_closure1.prototype = {
    call$1: function(module) {
      return module.cloneCss$0();
    }
  };
  R._EvaluateVisitor__extendModules_closure.prototype = {
    call$1: function(target) {
      return !this.originalSelectors.contains$1(0, target);
    }
  };
  R._EvaluateVisitor__extendModules_closure0.prototype = {
    call$0: function() {
      return H.setRuntimeTypeInfo([], [F.Extender]);
    }
  };
  R._EvaluateVisitor__topologicalModules_visitModule.prototype = {
    call$1: function(module) {
      var t1, t2, t3, _i, upstream;
      for (t1 = module.get$upstream(), t2 = t1.length, t3 = this.seen, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
        upstream = t1[_i];
        if (upstream.get$transitivelyContainsCss() && t3.add$1(0, upstream))
          this.call$1(upstream);
      }
      this.sorted.addFirst$1(module);
    }
  };
  R._EvaluateVisitor_visitAtRootRule_closure.prototype = {
    call$0: function() {
      var t1 = S.SpanScanner$(this.resolved, null);
      return new V.AtRootQueryParser(t1, this.$this._logger).parse$0();
    }
  };
  R._EvaluateVisitor_visitAtRootRule_closure0.prototype = {
    call$0: function() {
      var t1, t2, t3, _i;
      for (t1 = this.node.children, t2 = t1.length, t3 = this.$this, _i = 0; _i < t2; ++_i)
        t1[_i].accept$1(t3);
    }
  };
  R._EvaluateVisitor_visitAtRootRule_closure1.prototype = {
    call$0: function() {
      var t1, t2, t3, _i;
      for (t1 = this.node.children, t2 = t1.length, t3 = this.$this, _i = 0; _i < t2; ++_i)
        t1[_i].accept$1(t3);
    },
    "call*": "call$0",
    $requiredArgCount: 0
  };
  R._EvaluateVisitor__scopeForAtRoot_closure.prototype = {
    call$1: function(callback) {
      var t1 = this.$this,
        oldParent = t1._evaluate$_parent;
      t1._evaluate$_parent = this.newParent;
      t1._evaluate$_environment.scope$1$2$when(callback, this.node.hasDeclarations, -1);
      t1._evaluate$_parent = oldParent;
    }
  };
  R._EvaluateVisitor__scopeForAtRoot_closure0.prototype = {
    call$1: function(callback) {
      var t1 = this.$this,
        oldAtRootExcludingStyleRule = t1._atRootExcludingStyleRule;
      t1._atRootExcludingStyleRule = true;
      this.innerScope.call$1(callback);
      t1._atRootExcludingStyleRule = oldAtRootExcludingStyleRule;
    }
  };
  R._EvaluateVisitor__scopeForAtRoot_closure1.prototype = {
    call$1: function(callback) {
      return this.$this._withMediaQueries$2(null, new R._EvaluateVisitor__scopeForAtRoot__closure(this.innerScope, callback));
    }
  };
  R._EvaluateVisitor__scopeForAtRoot__closure.prototype = {
    call$0: function() {
      return this.innerScope.call$1(this.callback);
    }
  };
  R._EvaluateVisitor__scopeForAtRoot_closure2.prototype = {
    call$1: function(callback) {
      var t1 = this.$this,
        wasInKeyframes = t1._inKeyframes;
      t1._inKeyframes = false;
      this.innerScope.call$1(callback);
      t1._inKeyframes = wasInKeyframes;
    }
  };
  R._EvaluateVisitor__scopeForAtRoot_closure3.prototype = {
    call$1: function($parent) {
      return !!J.getInterceptor$($parent).$isCssAtRule;
    }
  };
  R._EvaluateVisitor__scopeForAtRoot_closure4.prototype = {
    call$1: function(callback) {
      var t1 = this.$this,
        wasInUnknownAtRule = t1._inUnknownAtRule;
      t1._inUnknownAtRule = false;
      this.innerScope.call$1(callback);
      t1._inUnknownAtRule = wasInUnknownAtRule;
    }
  };
  R._EvaluateVisitor_visitContentRule_closure.prototype = {
    call$0: function() {
      var t1, t2, t3, _i;
      for (t1 = this.content.declaration.children, t2 = t1.length, t3 = this.$this, _i = 0; _i < t2; ++_i)
        t1[_i].accept$1(t3);
      return;
    }
  };
  R._EvaluateVisitor_visitDeclaration_closure.prototype = {
    call$0: function() {
      var t1, t2, t3, _i;
      for (t1 = this.node.children, t2 = t1.length, t3 = this.$this, _i = 0; _i < t2; ++_i)
        t1[_i].accept$1(t3);
    }
  };
  R._EvaluateVisitor_visitEachRule_closure.prototype = {
    call$1: function(value) {
      return this.$this._evaluate$_environment.setLocalVariable$3(C.JSArray_methods.get$first(this.node.variables), value.withoutSlash$0(), this.nodeForSpan);
    }
  };
  R._EvaluateVisitor_visitEachRule_closure0.prototype = {
    call$1: function(value) {
      return this.$this._setMultipleVariables$3(this.node.variables, value, this.nodeForSpan);
    }
  };
  R._EvaluateVisitor_visitEachRule_closure1.prototype = {
    call$0: function() {
      var _this = this,
        t1 = _this.$this;
      return t1._handleReturn$2(_this.list.get$asList(), new R._EvaluateVisitor_visitEachRule__closure(t1, _this.setVariables, _this.node));
    }
  };
  R._EvaluateVisitor_visitEachRule__closure.prototype = {
    call$1: function(element) {
      var t1;
      this.setVariables.call$1(element);
      t1 = this.$this;
      return t1._handleReturn$2(this.node.children, new R._EvaluateVisitor_visitEachRule___closure(t1));
    }
  };
  R._EvaluateVisitor_visitEachRule___closure.prototype = {
    call$1: function(child) {
      return child.accept$1(this.$this);
    }
  };
  R._EvaluateVisitor_visitExtendRule_closure.prototype = {
    call$0: function() {
      return D.SelectorList_SelectorList$parse(B.trimAscii(this.targetText.value, true), false, true, this.$this._logger);
    }
  };
  R._EvaluateVisitor_visitAtRule_closure.prototype = {
    call$0: function() {
      var t3, _i,
        t1 = this.$this,
        t2 = t1._styleRule;
      if (!(t2 != null && !t1._atRootExcludingStyleRule) || t1._inKeyframes)
        for (t2 = this.node.children, t3 = t2.length, _i = 0; _i < t3; ++_i)
          t2[_i].accept$1(t1);
      else
        t1._withParent$2$3$scopeWhen(X.ModifiableCssStyleRule$(t2.selector, t2.span, t2.originalSelector), new R._EvaluateVisitor_visitAtRule__closure(t1, this.node), false, X.ModifiableCssStyleRule, P.Null);
    }
  };
  R._EvaluateVisitor_visitAtRule__closure.prototype = {
    call$0: function() {
      var t1, t2, t3, _i;
      for (t1 = this.node.children, t2 = t1.length, t3 = this.$this, _i = 0; _i < t2; ++_i)
        t1[_i].accept$1(t3);
    }
  };
  R._EvaluateVisitor_visitAtRule_closure0.prototype = {
    call$1: function(node) {
      return !!J.getInterceptor$(node).$isCssStyleRule;
    }
  };
  R._EvaluateVisitor_visitForRule_closure.prototype = {
    call$0: function() {
      return this.node.from.accept$1(this.$this).assertNumber$0();
    }
  };
  R._EvaluateVisitor_visitForRule_closure0.prototype = {
    call$0: function() {
      return this.node.to.accept$1(this.$this).assertNumber$0();
    }
  };
  R._EvaluateVisitor_visitForRule_closure1.prototype = {
    call$0: function() {
      var t1 = this.toNumber,
        t2 = t1.numeratorUnits;
      t1 = t1.denominatorUnits;
      return T.SassNumber$withUnits(this.fromNumber.valueInUnits$2(t2, t1), t1, t2).assertInt$0();
    }
  };
  R._EvaluateVisitor_visitForRule_closure2.prototype = {
    call$0: function() {
      return this.toNumber.assertInt$0();
    }
  };
  R._EvaluateVisitor_visitForRule_closure3.prototype = {
    call$0: function() {
      var i, t3, t4, t5, t6, result, _this = this,
        t1 = _this.$this,
        t2 = _this.node,
        nodeForSpan = t1._expressionNode$1(t2.from);
      for (i = _this.from, t3 = _this._box_0, t4 = _this.direction, t5 = t2.children, t2 = t2.variable; i !== t3.to; i += t4) {
        t6 = t1._evaluate$_environment;
        t6.setLocalVariable$3(t2, new T.SassNumber(i, C.List_empty0, C.List_empty0, null), nodeForSpan);
        result = t1._handleReturn$2(t5, new R._EvaluateVisitor_visitForRule__closure(t1));
        if (result != null)
          return result;
      }
      return;
    }
  };
  R._EvaluateVisitor_visitForRule__closure.prototype = {
    call$1: function(child) {
      return child.accept$1(this.$this);
    }
  };
  R._EvaluateVisitor_visitForwardRule_closure.prototype = {
    call$1: function(module) {
      this.$this._evaluate$_environment.forwardModule$2(module, this.node);
    }
  };
  R._EvaluateVisitor_visitIfRule_closure.prototype = {
    call$0: function() {
      var t1 = this.$this;
      return t1._handleReturn$2(this._box_0.clause.children, new R._EvaluateVisitor_visitIfRule__closure(t1));
    }
  };
  R._EvaluateVisitor_visitIfRule__closure.prototype = {
    call$1: function(child) {
      return child.accept$1(this.$this);
    }
  };
  R._EvaluateVisitor__visitDynamicImport_closure.prototype = {
    call$0: function() {
      var url, t3, t4, environment, module, visitor, _box_0 = {},
        t1 = this.$this,
        t2 = this.$import,
        result = t1._loadStylesheet$2(t2.url, t2.span),
        importer = result.item1,
        stylesheet = result.item2;
      t2 = stylesheet.span;
      url = t2.file.url;
      t3 = t1._activeModules;
      if (!t3.add$1(0, url))
        throw H.wrapException(t1._evaluate$_exception$1("This file is already being loaded."));
      t3.add$1(0, url);
      t4 = new P.UnmodifiableListView(stylesheet._uses, [T.UseRule]);
      if (t4.get$length(t4) === 0) {
        t4 = new P.UnmodifiableListView(stylesheet._forwards, [L.ForwardRule]);
        t4 = t4.get$length(t4) === 0;
      } else
        t4 = false;
      if (t4) {
        t1._withEnvironment$2(t1._evaluate$_environment.global$0(), new R._EvaluateVisitor__visitDynamicImport__closure(t1, importer, stylesheet));
        t3.remove$1(0, url);
        return;
      }
      _box_0.children = null;
      environment = t1._evaluate$_environment.global$0();
      t1._withEnvironment$2(environment, new R._EvaluateVisitor__visitDynamicImport__closure0(_box_0, t1, importer, stylesheet));
      module = O._EnvironmentModule__EnvironmentModule(environment, new V.CssStylesheet(new P.UnmodifiableListView(C.List_empty3, [B.CssNode]), t2), C.C_EmptyExtender, environment._forwardedModules);
      t1._evaluate$_environment.importForwards$1(module);
      if (module.transitivelyContainsCss)
        t1._combineCss$2$clone(module, module.transitivelyContainsExtensions).accept$1(t1);
      visitor = new R._ImportedCssVisitor(t1);
      for (t1 = J.get$iterator$ax(_box_0.children); t1.moveNext$0();)
        t1.get$current(t1).accept$1(visitor);
      t3.remove$1(0, url);
    }
  };
  R._EvaluateVisitor__visitDynamicImport__closure.prototype = {
    call$0: function() {
      var t2,
        t1 = this.$this,
        oldImporter = t1._importer,
        oldStylesheet = t1._stylesheet;
      t1._importer = this.importer;
      t2 = this.stylesheet;
      t1._stylesheet = t2;
      t1.visitStylesheet$1(t2);
      t1._importer = oldImporter;
      t1._stylesheet = oldStylesheet;
    }
  };
  R._EvaluateVisitor__visitDynamicImport__closure0.prototype = {
    call$0: function() {
      var t2, t3, t4, _this = this,
        t1 = _this.$this,
        oldImporter = t1._importer,
        oldStylesheet = t1._stylesheet,
        oldRoot = t1._root,
        oldParent = t1._evaluate$_parent,
        oldEndOfImports = t1._endOfImports,
        oldOutOfOrderImports = t1._outOfOrderImports;
      t1._importer = _this.importer;
      t2 = t1._stylesheet = _this.stylesheet;
      t3 = B.ModifiableCssNode;
      t4 = H.setRuntimeTypeInfo([], [t3]);
      t1._evaluate$_parent = t1._root = new V.ModifiableCssStylesheet(t2.span, new P.UnmodifiableListView(t4, [t3]), t4);
      t1._endOfImports = 0;
      t1._outOfOrderImports = null;
      t1.visitStylesheet$1(t2);
      _this._box_0.children = t1._addOutOfOrderImports$0();
      t1._importer = oldImporter;
      t1._stylesheet = oldStylesheet;
      t1._root = oldRoot;
      t1._evaluate$_parent = oldParent;
      t1._endOfImports = oldEndOfImports;
      t1._outOfOrderImports = oldOutOfOrderImports;
    }
  };
  R._EvaluateVisitor_visitIncludeRule_closure.prototype = {
    call$0: function() {
      var t1 = this.node;
      return this.$this._evaluate$_environment.getMixin$2$namespace(t1.name, t1.namespace);
    }
  };
  R._EvaluateVisitor_visitIncludeRule_closure0.prototype = {
    call$0: function() {
      var t1 = this.$this,
        t2 = t1._evaluate$_environment,
        oldContent = t2._content;
      t2._content = this.contentCallable;
      new R._EvaluateVisitor_visitIncludeRule__closure(t1, this.mixin).call$0();
      t2._content = oldContent;
      return;
    }
  };
  R._EvaluateVisitor_visitIncludeRule__closure.prototype = {
    call$0: function() {
      var t1 = this.$this,
        t2 = t1._evaluate$_environment,
        oldInMixin = t2._inMixin;
      t2._inMixin = true;
      new R._EvaluateVisitor_visitIncludeRule___closure(t1, this.mixin).call$0();
      t2._inMixin = oldInMixin;
      return;
    }
  };
  R._EvaluateVisitor_visitIncludeRule___closure.prototype = {
    call$0: function() {
      var t1, t2, t3, _i;
      for (t1 = this.mixin.declaration.children, t2 = t1.length, t3 = this.$this, _i = 0; _i < t2; ++_i)
        t1[_i].accept$1(t3);
    }
  };
  R._EvaluateVisitor_visitMediaRule_closure.prototype = {
    call$0: function() {
      var _this = this,
        t1 = _this.$this,
        t2 = _this.mergedQueries;
      if (t2 == null)
        t2 = _this.queries;
      t1._withMediaQueries$2(t2, new R._EvaluateVisitor_visitMediaRule__closure(t1, _this.node));
    }
  };
  R._EvaluateVisitor_visitMediaRule__closure.prototype = {
    call$0: function() {
      var t3, _i,
        t1 = this.$this,
        t2 = t1._styleRule;
      if (!(t2 != null && !t1._atRootExcludingStyleRule))
        for (t2 = this.node.children, t3 = t2.length, _i = 0; _i < t3; ++_i)
          t2[_i].accept$1(t1);
      else
        t1._withParent$2$3$scopeWhen(X.ModifiableCssStyleRule$(t2.selector, t2.span, t2.originalSelector), new R._EvaluateVisitor_visitMediaRule___closure(t1, this.node), false, X.ModifiableCssStyleRule, P.Null);
    }
  };
  R._EvaluateVisitor_visitMediaRule___closure.prototype = {
    call$0: function() {
      var t1, t2, t3, _i;
      for (t1 = this.node.children, t2 = t1.length, t3 = this.$this, _i = 0; _i < t2; ++_i)
        t1[_i].accept$1(t3);
    }
  };
  R._EvaluateVisitor_visitMediaRule_closure0.prototype = {
    call$1: function(node) {
      var t1 = J.getInterceptor$(node);
      if (!t1.$isCssStyleRule)
        t1 = this.mergedQueries != null && !!t1.$isCssMediaRule;
      else
        t1 = true;
      return t1;
    }
  };
  R._EvaluateVisitor__visitMediaQueries_closure.prototype = {
    call$0: function() {
      var t1 = S.SpanScanner$(this.resolved, null);
      return new F.MediaQueryParser(t1, this.$this._logger).parse$0();
    }
  };
  R._EvaluateVisitor_visitStyleRule_closure.prototype = {
    call$0: function() {
      var t1 = S.SpanScanner$(this.selectorText.value, null);
      return new E.KeyframeSelectorParser(t1, this.$this._logger).parse$0();
    }
  };
  R._EvaluateVisitor_visitStyleRule_closure0.prototype = {
    call$0: function() {
      var t1, t2, t3, _i;
      for (t1 = this.node.children, t2 = t1.length, t3 = this.$this, _i = 0; _i < t2; ++_i)
        t1[_i].accept$1(t3);
    }
  };
  R._EvaluateVisitor_visitStyleRule_closure1.prototype = {
    call$1: function(node) {
      return !!J.getInterceptor$(node).$isCssStyleRule;
    }
  };
  R._EvaluateVisitor_visitStyleRule_closure2.prototype = {
    call$0: function() {
      var t1 = this.$this,
        t2 = !t1._stylesheet.plainCss;
      return D.SelectorList_SelectorList$parse(this.selectorText.value, t2, t2, t1._logger);
    }
  };
  R._EvaluateVisitor_visitStyleRule_closure3.prototype = {
    call$0: function() {
      var t1 = this._box_0.parsedSelector,
        t2 = this.$this,
        t3 = t2._styleRule;
      t3 = t3 == null ? null : t3.originalSelector;
      return t1.resolveParentSelectors$2$implicitParent(t3, !t2._atRootExcludingStyleRule);
    }
  };
  R._EvaluateVisitor_visitStyleRule_closure4.prototype = {
    call$0: function() {
      var t1 = this.$this;
      t1._withStyleRule$2(this.rule, new R._EvaluateVisitor_visitStyleRule__closure(t1, this.node));
    }
  };
  R._EvaluateVisitor_visitStyleRule__closure.prototype = {
    call$0: function() {
      var t1, t2, t3, _i;
      for (t1 = this.node.children, t2 = t1.length, t3 = this.$this, _i = 0; _i < t2; ++_i)
        t1[_i].accept$1(t3);
    }
  };
  R._EvaluateVisitor_visitStyleRule_closure5.prototype = {
    call$1: function(node) {
      return !!J.getInterceptor$(node).$isCssStyleRule;
    }
  };
  R._EvaluateVisitor_visitSupportsRule_closure.prototype = {
    call$0: function() {
      var t3, _i,
        t1 = this.$this,
        t2 = t1._styleRule;
      if (!(t2 != null && !t1._atRootExcludingStyleRule))
        for (t2 = this.node.children, t3 = t2.length, _i = 0; _i < t3; ++_i)
          t2[_i].accept$1(t1);
      else
        t1._withParent$2$2(X.ModifiableCssStyleRule$(t2.selector, t2.span, t2.originalSelector), new R._EvaluateVisitor_visitSupportsRule__closure(t1, this.node), X.ModifiableCssStyleRule, P.Null);
    }
  };
  R._EvaluateVisitor_visitSupportsRule__closure.prototype = {
    call$0: function() {
      var t1, t2, t3, _i;
      for (t1 = this.node.children, t2 = t1.length, t3 = this.$this, _i = 0; _i < t2; ++_i)
        t1[_i].accept$1(t3);
    }
  };
  R._EvaluateVisitor_visitSupportsRule_closure0.prototype = {
    call$1: function(node) {
      return !!J.getInterceptor$(node).$isCssStyleRule;
    }
  };
  R._EvaluateVisitor_visitVariableDeclaration_closure.prototype = {
    call$0: function() {
      var t1 = this.node;
      return this.$this._evaluate$_environment.getVariable$2$namespace(t1.name, t1.namespace);
    }
  };
  R._EvaluateVisitor_visitVariableDeclaration_closure0.prototype = {
    call$0: function() {
      var t1 = this.$this,
        t2 = this.node;
      t1._evaluate$_environment.setVariable$5$global$namespace(t2.name, this.value, t1._expressionNode$1(t2.expression), t2.isGlobal, t2.namespace);
    }
  };
  R._EvaluateVisitor_visitUseRule_closure.prototype = {
    call$1: function(module) {
      this.$this._evaluate$_environment.addModule$2$namespace(module, this.node.namespace);
    }
  };
  R._EvaluateVisitor_visitWarnRule_closure.prototype = {
    call$0: function() {
      return this.node.expression.accept$1(this.$this);
    }
  };
  R._EvaluateVisitor_visitWhileRule_closure.prototype = {
    call$0: function() {
      var t1, t2, t3, result;
      for (t1 = this.node, t2 = t1.condition, t3 = this.$this, t1 = t1.children; t2.accept$1(t3).get$isTruthy();) {
        result = t3._handleReturn$2(t1, new R._EvaluateVisitor_visitWhileRule__closure(t3));
        if (result != null)
          return result;
      }
      return;
    }
  };
  R._EvaluateVisitor_visitWhileRule__closure.prototype = {
    call$1: function(child) {
      return child.accept$1(this.$this);
    }
  };
  R._EvaluateVisitor_visitBinaryOperationExpression_closure.prototype = {
    call$0: function() {
      var right, result,
        t1 = this.node,
        t2 = this.$this,
        left = t1.left.accept$1(t2);
      switch (t1.operator) {
        case C.BinaryOperator_kjl:
          right = t1.right.accept$1(t2);
          left.toString;
          t1 = N.serializeValue(left, false, true) + "=";
          right.toString;
          return new D.SassString(t1 + N.serializeValue(right, false, true), false);
        case C.BinaryOperator_or_or_1:
          return left.get$isTruthy() ? left : t1.right.accept$1(t2);
        case C.BinaryOperator_and_and_2:
          return left.get$isTruthy() ? t1.right.accept$1(t2) : left;
        case C.BinaryOperator_YlX:
          return J.$eq$(left, t1.right.accept$1(t2)) ? C.SassBoolean_true : C.SassBoolean_false;
        case C.BinaryOperator_i5H:
          return !J.$eq$(left, t1.right.accept$1(t2)) ? C.SassBoolean_true : C.SassBoolean_false;
        case C.BinaryOperator_AcR:
          return left.greaterThan$1(t1.right.accept$1(t2));
        case C.BinaryOperator_1da:
          return left.greaterThanOrEquals$1(t1.right.accept$1(t2));
        case C.BinaryOperator_8qt:
          return left.lessThan$1(t1.right.accept$1(t2));
        case C.BinaryOperator_33h:
          return left.lessThanOrEquals$1(t1.right.accept$1(t2));
        case C.BinaryOperator_AcR0:
          return left.plus$1(t1.right.accept$1(t2));
        case C.BinaryOperator_iyO:
          return left.minus$1(t1.right.accept$1(t2));
        case C.BinaryOperator_O1M:
          return left.times$1(t1.right.accept$1(t2));
        case C.BinaryOperator_RTB:
          right = t1.right.accept$1(t2);
          result = left.dividedBy$1(right);
          if (t1.allowsSlash && !!left.$isSassNumber && right instanceof T.SassNumber)
            return H.interceptedTypeCast(result, "$isSassNumber").withSlash$2(left, right);
          else
            return result;
        case C.BinaryOperator_2ad:
          return left.modulo$1(t1.right.accept$1(t2));
        default:
          return;
      }
    }
  };
  R._EvaluateVisitor_visitVariableExpression_closure.prototype = {
    call$0: function() {
      var t1 = this.node;
      return this.$this._evaluate$_environment.getVariable$2$namespace(t1.name, t1.namespace);
    }
  };
  R._EvaluateVisitor_visitListExpression_closure.prototype = {
    call$1: function(expression) {
      return expression.accept$1(this.$this);
    }
  };
  R._EvaluateVisitor_visitFunctionExpression_closure.prototype = {
    call$0: function() {
      var t1 = this.node.namespace,
        t2 = this.plainName;
      if (t1 == null)
        t2 = H.stringReplaceAllUnchecked(t2, "_", "-");
      return this.$this._getFunction$2$namespace(t2, t1);
    }
  };
  R._EvaluateVisitor__runUserDefinedCallable_closure.prototype = {
    call$0: function() {
      var _this = this,
        t1 = _this.$this,
        t2 = _this.callable;
      return t1._withEnvironment$2(t2.environment.closure$0(), new R._EvaluateVisitor__runUserDefinedCallable__closure(t1, _this.evaluated, t2, _this.nodeWithSpan, _this.run));
    }
  };
  R._EvaluateVisitor__runUserDefinedCallable__closure.prototype = {
    call$0: function() {
      var _this = this,
        t1 = _this.$this;
      return t1._evaluate$_environment.scope$1$1(new R._EvaluateVisitor__runUserDefinedCallable___closure(t1, _this.evaluated, _this.callable, _this.nodeWithSpan, _this.run), F.Value);
    }
  };
  R._EvaluateVisitor__runUserDefinedCallable___closure.prototype = {
    call$0: function() {
      var declaredArguments, minLength, t8, t9, i, t10, t11, t12, argument, value, t13, rest, argumentList, result, argumentWord, argumentNames, _this = this, _null = null,
        t1 = _this.$this,
        t2 = _this.evaluated,
        t3 = t2.positional,
        t4 = t3.length,
        t5 = t2.named,
        t6 = _this.callable.declaration.$arguments,
        t7 = _this.nodeWithSpan;
      t1._verifyArguments$4(t4, t5, t6, t7);
      declaredArguments = t6.$arguments;
      t4 = declaredArguments.length;
      minLength = Math.min(t3.length, t4);
      for (t8 = t1._sourceMap, t9 = t2.positionalNodes, i = 0; i < minLength; ++i) {
        t10 = t1._evaluate$_environment;
        t11 = declaredArguments[i].name;
        t12 = t3[i].withoutSlash$0();
        t10.setLocalVariable$3(t11, t12, t8 ? t9[i] : _null);
      }
      for (i = t3.length, t9 = t2.namedNodes; i < t4; ++i) {
        argument = declaredArguments[i];
        t10 = argument.name;
        value = t5.remove$1(0, t10);
        if (value == null)
          value = argument.defaultValue.accept$1(t1);
        t11 = t1._evaluate$_environment;
        t12 = value.withoutSlash$0();
        if (t8) {
          t13 = t9.$index(0, t10);
          if (t13 == null)
            t13 = t1._expressionNode$1(argument.defaultValue);
        } else
          t13 = _null;
        t11.setLocalVariable$3(t10, t12, t13);
      }
      t6 = t6.restArgument;
      if (t6 != null) {
        rest = t3.length > t4 ? C.JSArray_methods.sublist$1(t3, t4) : C.List_empty1;
        t2 = t2.separator;
        if (t2 === C.ListSeparator_undecided)
          t2 = C.ListSeparator_comma;
        t3 = F.Value;
        argumentList = new D.SassArgumentList(H.ConstantMap_ConstantMap$from(t5, P.String, t3), P.List_List$unmodifiable(rest, t3), t2, false);
        argumentList.SassList$3$brackets(rest, t2, false);
        t1._evaluate$_environment.setLocalVariable$3(t6, argumentList, t7);
      } else
        argumentList = _null;
      result = _this.run.call$0();
      if (argumentList == null)
        return result;
      if (t5.get$isEmpty(t5))
        return result;
      if (argumentList._wereKeywordsAccessed)
        return result;
      t2 = t5.get$keys();
      argumentWord = B.pluralize("argument", t2.get$length(t2), _null);
      t5 = t5.get$keys();
      argumentNames = B.toSentence(H.MappedIterable_MappedIterable(t5, new R._EvaluateVisitor__runUserDefinedCallable____closure(), H.getRuntimeTypeArgument(t5, "Iterable", 0), P.Object), "or");
      throw H.wrapException(t1._evaluate$_exception$2("No " + argumentWord + " named " + H.S(argumentNames) + ".", t7.get$span()));
    }
  };
  R._EvaluateVisitor__runUserDefinedCallable____closure.prototype = {
    call$1: function($name) {
      return "$" + H.S($name);
    }
  };
  R._EvaluateVisitor__runFunctionCallable_closure.prototype = {
    call$0: function() {
      var t1, t2, t3, t4, _i, $returnValue;
      for (t1 = this.callable.declaration, t2 = t1.children, t3 = t2.length, t4 = this.$this, _i = 0; _i < t3; ++_i) {
        $returnValue = t2[_i].accept$1(t4);
        if ($returnValue instanceof F.Value)
          return $returnValue;
      }
      throw H.wrapException(t4._evaluate$_exception$2("Function finished without @return.", t1.span));
    }
  };
  R._EvaluateVisitor__runBuiltInCallable_closure.prototype = {
    call$0: function() {
      return this.overload.verify$2(this.evaluated.positional.length, this.namedSet);
    }
  };
  R._EvaluateVisitor__runBuiltInCallable_closure0.prototype = {
    call$1: function($name) {
      return "$" + H.S($name);
    }
  };
  R._EvaluateVisitor__evaluateArguments_closure.prototype = {
    call$2: function(_, expression) {
      return expression.accept$1(this.$this);
    }
  };
  R._EvaluateVisitor__evaluateArguments_closure0.prototype = {
    call$2: function(_, expression) {
      return this.$this._expressionNode$1(expression);
    }
  };
  R._EvaluateVisitor__evaluateArguments_closure1.prototype = {
    call$2: function(key, _) {
      return H.interceptedTypeCast(key, "$isSassString").text;
    },
    $signature: 15
  };
  R._EvaluateVisitor__evaluateArguments_closure2.prototype = {
    call$2: function(_, __) {
      return this.restNodeForSpan;
    },
    $signature: 22
  };
  R._EvaluateVisitor__evaluateArguments_closure3.prototype = {
    call$2: function(key, value) {
      var t1;
      this.named.$indexSet(0, key, value);
      t1 = this.namedNodes;
      if (t1 != null)
        t1.$indexSet(0, key, this.restNodeForSpan);
    }
  };
  R._EvaluateVisitor__evaluateArguments_closure4.prototype = {
    call$2: function(key, _) {
      return H.interceptedTypeCast(key, "$isSassString").text;
    },
    $signature: 15
  };
  R._EvaluateVisitor__evaluateArguments_closure5.prototype = {
    call$2: function(_, __) {
      return this.keywordRestNodeForSpan;
    },
    $signature: 22
  };
  R._EvaluateVisitor__evaluateMacroArguments_closure.prototype = {
    call$1: function(value) {
      return new F.ValueExpression(value, null);
    }
  };
  R._EvaluateVisitor__evaluateMacroArguments_closure0.prototype = {
    call$1: function(value) {
      return new F.ValueExpression(value, null);
    }
  };
  R._EvaluateVisitor__evaluateMacroArguments_closure1.prototype = {
    call$2: function(key, value) {
      this.named.$indexSet(0, key, new F.ValueExpression(value, null));
    }
  };
  R._EvaluateVisitor__evaluateMacroArguments_closure2.prototype = {
    call$1: function(value) {
      return new F.ValueExpression(value, null);
    }
  };
  R._EvaluateVisitor__addRestMap_closure.prototype = {
    call$1: function(value) {
      return H.subtypeOfRuntimeTypeCast(value, this.T);
    }
  };
  R._EvaluateVisitor__addRestMap_closure0.prototype = {
    call$2: function(key, value) {
      var _this = this;
      if (key instanceof D.SassString)
        _this.values.$indexSet(0, key.text, _this._box_0.convert.call$1(value));
      else
        throw H.wrapException(_this.$this._evaluate$_exception$2("Variable keyword argument map must have string keys.\n" + H.S(key) + " is not a string in " + _this.map.toString$0(0) + ".", _this.nodeForSpan.get$span()));
    }
  };
  R._EvaluateVisitor__verifyArguments_closure.prototype = {
    call$0: function() {
      return this.$arguments.verify$2(this.positional, new M.MapKeySet(this.named, [P.String]));
    }
  };
  R._EvaluateVisitor_visitStringExpression_closure.prototype = {
    call$1: function(value) {
      var t1, result;
      if (typeof value === "string")
        return value;
      H.interceptedTypeCast(value, "$isExpression");
      t1 = this.$this;
      result = value.accept$1(t1);
      return result instanceof D.SassString ? result.text : t1._evaluate$_serialize$3$quote(result, value, false);
    },
    $signature: 21
  };
  R._EvaluateVisitor_visitCssAtRule_closure.prototype = {
    call$0: function() {
      var t1, t2;
      for (t1 = this.node.children, t1 = new H.ListIterator(t1, t1.get$length(t1)), t2 = this.$this; t1.moveNext$0();)
        t1.__internal$_current.accept$1(t2);
    }
  };
  R._EvaluateVisitor_visitCssAtRule_closure0.prototype = {
    call$1: function(node) {
      return !!J.getInterceptor$(node).$isCssStyleRule;
    }
  };
  R._EvaluateVisitor_visitCssKeyframeBlock_closure.prototype = {
    call$0: function() {
      var t1, t2;
      for (t1 = this.node.children, t1 = new H.ListIterator(t1, t1.get$length(t1)), t2 = this.$this; t1.moveNext$0();)
        t1.__internal$_current.accept$1(t2);
    }
  };
  R._EvaluateVisitor_visitCssKeyframeBlock_closure0.prototype = {
    call$1: function(node) {
      return !!J.getInterceptor$(node).$isCssStyleRule;
    }
  };
  R._EvaluateVisitor_visitCssMediaRule_closure.prototype = {
    call$0: function() {
      var _this = this,
        t1 = _this.$this,
        t2 = _this.mergedQueries;
      if (t2 == null)
        t2 = _this.node.queries;
      t1._withMediaQueries$2(t2, new R._EvaluateVisitor_visitCssMediaRule__closure(t1, _this.node));
    }
  };
  R._EvaluateVisitor_visitCssMediaRule__closure.prototype = {
    call$0: function() {
      var t1 = this.$this,
        t2 = t1._styleRule;
      if (!(t2 != null && !t1._atRootExcludingStyleRule))
        for (t2 = this.node.children, t2 = new H.ListIterator(t2, t2.get$length(t2)); t2.moveNext$0();)
          t2.__internal$_current.accept$1(t1);
      else
        t1._withParent$2$3$scopeWhen(X.ModifiableCssStyleRule$(t2.selector, t2.span, t2.originalSelector), new R._EvaluateVisitor_visitCssMediaRule___closure(t1, this.node), false, X.ModifiableCssStyleRule, P.Null);
    }
  };
  R._EvaluateVisitor_visitCssMediaRule___closure.prototype = {
    call$0: function() {
      var t1, t2;
      for (t1 = this.node.children, t1 = new H.ListIterator(t1, t1.get$length(t1)), t2 = this.$this; t1.moveNext$0();)
        t1.__internal$_current.accept$1(t2);
    }
  };
  R._EvaluateVisitor_visitCssMediaRule_closure0.prototype = {
    call$1: function(node) {
      var t1 = J.getInterceptor$(node);
      if (!t1.$isCssStyleRule)
        t1 = this.mergedQueries != null && !!t1.$isCssMediaRule;
      else
        t1 = true;
      return t1;
    }
  };
  R._EvaluateVisitor_visitCssStyleRule_closure.prototype = {
    call$0: function() {
      var t1 = this.$this;
      t1._withStyleRule$2(this.rule, new R._EvaluateVisitor_visitCssStyleRule__closure(t1, this.node));
    }
  };
  R._EvaluateVisitor_visitCssStyleRule__closure.prototype = {
    call$0: function() {
      var t1, t2;
      for (t1 = this.node.children, t1 = new H.ListIterator(t1, t1.get$length(t1)), t2 = this.$this; t1.moveNext$0();)
        t1.__internal$_current.accept$1(t2);
    }
  };
  R._EvaluateVisitor_visitCssStyleRule_closure0.prototype = {
    call$1: function(node) {
      return !!J.getInterceptor$(node).$isCssStyleRule;
    }
  };
  R._EvaluateVisitor_visitCssSupportsRule_closure.prototype = {
    call$0: function() {
      var t1 = this.$this,
        t2 = t1._styleRule;
      if (!(t2 != null && !t1._atRootExcludingStyleRule))
        for (t2 = this.node.children, t2 = new H.ListIterator(t2, t2.get$length(t2)); t2.moveNext$0();)
          t2.__internal$_current.accept$1(t1);
      else
        t1._withParent$2$2(X.ModifiableCssStyleRule$(t2.selector, t2.span, t2.originalSelector), new R._EvaluateVisitor_visitCssSupportsRule__closure(t1, this.node), X.ModifiableCssStyleRule, P.Null);
    }
  };
  R._EvaluateVisitor_visitCssSupportsRule__closure.prototype = {
    call$0: function() {
      var t1, t2;
      for (t1 = this.node.children, t1 = new H.ListIterator(t1, t1.get$length(t1)), t2 = this.$this; t1.moveNext$0();)
        t1.__internal$_current.accept$1(t2);
    }
  };
  R._EvaluateVisitor_visitCssSupportsRule_closure0.prototype = {
    call$1: function(node) {
      return !!J.getInterceptor$(node).$isCssStyleRule;
    }
  };
  R._EvaluateVisitor__performInterpolation_closure.prototype = {
    call$1: function(value) {
      var t1, result, t2, t3;
      if (typeof value === "string")
        return value;
      H.interceptedTypeCast(value, "$isExpression");
      t1 = this.$this;
      result = value.accept$1(t1);
      if (this.warnForColor && result instanceof K.SassColor && $.$get$namesByColor().containsKey$1(result)) {
        t2 = X.Interpolation$(H.setRuntimeTypeInfo([""], [P.Object]), null);
        t3 = $.$get$namesByColor();
        t1._warn$2("You probably don't mean to use the color value " + H.S(t3.$index(0, result)) + " in interpolation here.\nIt may end up represented as " + H.S(result) + ', which will likely produce invalid CSS.\nAlways quote color names when using them as strings or map keys (for example, "' + H.S(t3.$index(0, result)) + "\").\nIf you really want to use the color value here, use '" + new V.BinaryOperationExpression(C.BinaryOperator_AcR0, new D.StringExpression(t2, true), value, false).toString$0(0) + "'.", value.get$span());
      }
      return t1._evaluate$_serialize$3$quote(result, value, false);
    },
    $signature: 21
  };
  R._EvaluateVisitor__serialize_closure.prototype = {
    call$0: function() {
      var t1 = this.value;
      t1.toString;
      return N.serializeValue(t1, false, this.quote);
    }
  };
  R._EvaluateVisitor__stackTrace_closure.prototype = {
    call$1: function(tuple) {
      return this.$this._stackFrame$2(tuple.item1, tuple.item2.get$span());
    }
  };
  R._ImportedCssVisitor.prototype = {
    visitCssAtRule$1: function(node) {
      var t1 = node.isChildless ? null : new R._ImportedCssVisitor_visitCssAtRule_closure();
      this._visitor._addChild$2$through(node, t1);
    },
    visitCssComment$1: function(node) {
      return this._visitor._addChild$1(node);
    },
    visitCssDeclaration$1: function(node) {
    },
    visitCssImport$1: function(node) {
      var t1 = this._visitor,
        t2 = t1._evaluate$_parent,
        t3 = t1._root;
      if (t2 != t3)
        t1._addChild$1(node);
      else if (t1._endOfImports === J.get$length$asx(t3.children._collection$_source)) {
        t1._addChild$1(node);
        t1._endOfImports = t1._endOfImports + 1;
      } else {
        t2 = t1._outOfOrderImports;
        (t2 == null ? t1._outOfOrderImports = H.setRuntimeTypeInfo([], [F.ModifiableCssImport]) : t2).push(node);
      }
    },
    visitCssKeyframeBlock$1: function(node) {
    },
    visitCssMediaRule$1: function(node) {
      var t1 = this._visitor,
        t2 = t1._mediaQueries;
      t1._addChild$2$through(node, new R._ImportedCssVisitor_visitCssMediaRule_closure(t2 == null || t1._mergeMediaQueries$2(t2, node.queries) != null));
    },
    visitCssStyleRule$1: function(node) {
      return this._visitor._addChild$2$through(node, new R._ImportedCssVisitor_visitCssStyleRule_closure());
    },
    visitCssStylesheet$1: function(node) {
      var t1;
      for (t1 = node.children, t1 = new H.ListIterator(t1, t1.get$length(t1)); t1.moveNext$0();)
        t1.__internal$_current.accept$1(this);
    },
    visitCssSupportsRule$1: function(node) {
      return this._visitor._addChild$2$through(node, new R._ImportedCssVisitor_visitCssSupportsRule_closure());
    }
  };
  R._ImportedCssVisitor_visitCssAtRule_closure.prototype = {
    call$1: function(node) {
      return !!J.getInterceptor$(node).$isCssStyleRule;
    }
  };
  R._ImportedCssVisitor_visitCssMediaRule_closure.prototype = {
    call$1: function(node) {
      var t1 = J.getInterceptor$(node);
      if (!t1.$isCssStyleRule)
        t1 = this.hasBeenMerged && !!t1.$isCssMediaRule;
      else
        t1 = true;
      return t1;
    }
  };
  R._ImportedCssVisitor_visitCssStyleRule_closure.prototype = {
    call$1: function(node) {
      return !!J.getInterceptor$(node).$isCssStyleRule;
    }
  };
  R._ImportedCssVisitor_visitCssSupportsRule_closure.prototype = {
    call$1: function(node) {
      return !!J.getInterceptor$(node).$isCssStyleRule;
    }
  };
  R._ArgumentResults.prototype = {};
  L._FindImportsVisitor.prototype = {
    visitEachRule$1: function(node) {
    },
    visitForRule$1: function(node) {
    },
    visitIfRule$1: function(node) {
    },
    visitWhileRule$1: function(node) {
    },
    visitUseRule$1: function(node) {
      this._imports.push(new B.DynamicImport(J.toString$0$(node.url), node.span));
    },
    visitImportRule$1: function(node) {
      var t1, t2, t3, _i, $import;
      for (t1 = node.imports, t2 = t1.length, t3 = this._imports, _i = 0; _i < t2; ++_i) {
        $import = t1[_i];
        if ($import instanceof B.DynamicImport)
          t3.push($import);
      }
    }
  };
  D.RecursiveStatementVisitor.prototype = {
    visitAtRootRule$1: function(node) {
      return this.visitChildren$1(node);
    },
    visitAtRule$1: function(node) {
      return node.children == null ? null : this.visitChildren$1(node);
    },
    visitContentBlock$1: function(node) {
      return;
    },
    visitContentRule$1: function(node) {
      this.visitArgumentInvocation$1(node.$arguments);
      return;
    },
    visitDebugRule$1: function(node) {
      return;
    },
    visitDeclaration$1: function(node) {
      return node.children == null ? null : this.visitChildren$1(node);
    },
    visitErrorRule$1: function(node) {
      return;
    },
    visitExtendRule$1: function(node) {
      return;
    },
    visitForwardRule$1: function(node) {
      return;
    },
    visitFunctionRule$1: function(node) {
      return;
    },
    visitIncludeRule$1: function(node) {
      this.visitArgumentInvocation$1(node.$arguments);
      return;
    },
    visitLoudComment$1: function(node) {
      return;
    },
    visitMediaRule$1: function(node) {
      return this.visitChildren$1(node);
    },
    visitMixinRule$1: function(node) {
      return;
    },
    visitReturnRule$1: function(node) {
      return;
    },
    visitSilentComment$1: function(node) {
      return;
    },
    visitStyleRule$1: function(node) {
      return this.visitChildren$1(node);
    },
    visitStylesheet$1: function(node) {
      return this.visitChildren$1(node);
    },
    visitSupportsRule$1: function(node) {
      return this.visitChildren$1(node);
    },
    visitVariableDeclaration$1: function(node) {
      return;
    },
    visitWarnRule$1: function(node) {
      return;
    },
    visitArgumentInvocation$1: function(invocation) {
      var t1, _i;
      for (t1 = invocation.positional.length, _i = 0; _i < t1; ++_i)
        ;
      for (t1 = invocation.named.get$values(), t1 = t1.get$iterator(t1); t1.moveNext$0();)
        t1.get$current(t1);
    },
    visitChildren$1: function(node) {
      var t1, t2, _i;
      for (t1 = node.children, t2 = t1.length, _i = 0; _i < t2; ++_i)
        t1[_i].accept$1(this);
      return;
    }
  };
  N.serialize_closure.prototype = {
    call$1: function(codeUnit) {
      return codeUnit > 127;
    },
    $signature: 13
  };
  N._SerializeVisitor.prototype = {
    visitCssStylesheet$1: function(node) {
      var t1, t2, t3, previous, i, child, _this = this;
      for (t1 = _this._style !== C.OutputStyle_compressed, t2 = _this._buffer, t3 = _this._lineFeed.text, previous = null, i = 0; i < J.get$length$asx(node.get$children()); ++i) {
        child = J.$index$asx(node.get$children(), i);
        if (_this._isInvisible$1(child))
          continue;
        if (previous != null) {
          if (!!previous.$isCssParentNode ? previous.get$isChildless() : !previous.$isCssComment)
            t2.writeCharCode$1(59);
          if (t1)
            t2.write$1(0, t3);
          if (previous.get$isGroupEnd())
            if (t1)
              t2.write$1(0, t3);
        }
        child.accept$1(_this);
        previous = child;
      }
      if (previous != null)
        t1 = (!!previous.$isCssParentNode ? previous.get$isChildless() : !previous.$isCssComment) && t1;
      else
        t1 = false;
      if (t1)
        t2.writeCharCode$1(59);
    },
    visitCssComment$1: function(node) {
      this._buffer.forSpan$2(node.span, new N._SerializeVisitor_visitCssComment_closure(this, node));
    },
    visitCssAtRule$1: function(node) {
      var t1, _this = this;
      _this._writeIndentation$0();
      t1 = _this._buffer;
      t1.forSpan$2(node.span, new N._SerializeVisitor_visitCssAtRule_closure(_this, node));
      if (!node.isChildless) {
        if (_this._style !== C.OutputStyle_compressed)
          t1.writeCharCode$1(32);
        _this._serialize$_visitChildren$1(node.children);
      }
    },
    visitCssMediaRule$1: function(node) {
      var t1, _this = this;
      _this._writeIndentation$0();
      t1 = _this._buffer;
      t1.forSpan$2(node.span, new N._SerializeVisitor_visitCssMediaRule_closure(_this, node));
      if (_this._style !== C.OutputStyle_compressed)
        t1.writeCharCode$1(32);
      _this._serialize$_visitChildren$1(node.children);
    },
    visitCssImport$1: function(node) {
      this._writeIndentation$0();
      this._buffer.forSpan$2(node.span, new N._SerializeVisitor_visitCssImport_closure(this, node));
    },
    _writeImportUrl$1: function(url) {
      var urlContents, maybeQuote, _this = this;
      if (_this._style !== C.OutputStyle_compressed || J._codeUnitAt$1$s(url, 0) !== 117) {
        _this._buffer.write$1(0, url);
        return;
      }
      urlContents = J.substring$2$s(url, 4, url.length - 1);
      maybeQuote = C.JSString_methods._codeUnitAt$1(urlContents, 0);
      if (maybeQuote === 39 || maybeQuote === 34)
        _this._buffer.write$1(0, urlContents);
      else
        _this._visitQuotedString$1(urlContents);
    },
    visitCssKeyframeBlock$1: function(node) {
      var t1, _this = this;
      _this._writeIndentation$0();
      t1 = _this._buffer;
      t1.forSpan$2(node.selector.span, new N._SerializeVisitor_visitCssKeyframeBlock_closure(_this, node));
      if (_this._style !== C.OutputStyle_compressed)
        t1.writeCharCode$1(32);
      _this._serialize$_visitChildren$1(node.children);
    },
    _visitMediaQuery$1: function(query) {
      var t2, t3, _this = this,
        t1 = query.modifier;
      if (t1 != null) {
        t2 = _this._buffer;
        t2.write$1(0, t1);
        t2.writeCharCode$1(32);
      }
      t1 = query.type;
      if (t1 != null) {
        t2 = _this._buffer;
        t2.write$1(0, t1);
        if (query.features.length !== 0)
          t2.write$1(0, " and ");
      }
      t1 = query.features;
      t2 = _this._style === C.OutputStyle_compressed ? "and " : " and ";
      t3 = _this._buffer;
      _this._writeBetween$3(t1, t2, t3.get$write(t3));
    },
    visitCssStyleRule$1: function(node) {
      var t1, _this = this;
      _this._writeIndentation$0();
      t1 = _this._buffer;
      t1.forSpan$2(node.selector.span, new N._SerializeVisitor_visitCssStyleRule_closure(_this, node));
      if (_this._style !== C.OutputStyle_compressed)
        t1.writeCharCode$1(32);
      _this._serialize$_visitChildren$1(node.children);
    },
    visitCssSupportsRule$1: function(node) {
      var t1, _this = this;
      _this._writeIndentation$0();
      t1 = _this._buffer;
      t1.forSpan$2(node.span, new N._SerializeVisitor_visitCssSupportsRule_closure(_this, node));
      if (_this._style !== C.OutputStyle_compressed)
        t1.writeCharCode$1(32);
      _this._serialize$_visitChildren$1(node.children);
    },
    visitCssDeclaration$1: function(node) {
      var error, t1, exception, _this = this;
      _this._writeIndentation$0();
      _this._write$1(node.name);
      t1 = _this._buffer;
      t1.writeCharCode$1(58);
      if (_this._isParsedCustomProperty$1(node))
        t1.forSpan$2(node.value.span, new N._SerializeVisitor_visitCssDeclaration_closure(_this, node));
      else {
        if (_this._style !== C.OutputStyle_compressed)
          t1.writeCharCode$1(32);
        try {
          t1.forSpan$2(node.valueSpanForMap, new N._SerializeVisitor_visitCssDeclaration_closure0(_this, node));
        } catch (exception) {
          t1 = H.unwrapException(exception);
          if (t1 instanceof E.SassScriptException) {
            error = t1;
            throw H.wrapException(E.SassException$(error.message, node.value.span));
          } else
            throw exception;
        }
      }
    },
    _isParsedCustomProperty$1: function(node) {
      var value;
      if (!J.startsWith$1$s(node.name.get$value(), "--"))
        return false;
      value = node.value.value;
      return value instanceof D.SassString && !value.hasQuotes;
    },
    _writeFoldedValue$1: function(node) {
      var t1, t2, next, t3,
        scanner = X.StringScanner$(H.interceptedTypeCast(node.value.value, "$isSassString").text, null, null);
      for (t1 = scanner.string.length, t2 = this._buffer; scanner._string_scanner$_position !== t1;) {
        next = scanner.readChar$0();
        if (next !== 10) {
          t2.writeCharCode$1(next);
          continue;
        }
        t2.writeCharCode$1(32);
        while (true) {
          t3 = scanner.peekChar$0();
          if (!(t3 === 32 || t3 === 9 || t3 === 10 || t3 === 13 || t3 === 12))
            break;
          scanner.readChar$0();
        }
      }
    },
    _writeReindentedValue$1: function(node) {
      var _this = this,
        t1 = node.value,
        value = H.interceptedTypeCast(t1.value, "$isSassString").text,
        minimumIndentation = _this._minimumIndentation$1(value);
      if (minimumIndentation == null) {
        _this._buffer.write$1(0, value);
        return;
      } else if (minimumIndentation === -1) {
        t1 = _this._buffer;
        t1.write$1(0, B.trimAsciiRight(value, true));
        t1.writeCharCode$1(32);
        return;
      }
      if (t1.span != null) {
        t1 = node.name.get$span();
        t1 = Y.FileLocation$_(t1.file, t1._start);
        minimumIndentation = Math.min(minimumIndentation, t1.file.getColumn$1(t1.offset));
      }
      _this._writeWithIndent$2(value, minimumIndentation);
    },
    _minimumIndentation$1: function(text) {
      var character, t2, min, next, min0,
        scanner = new Z.LineScanner(null, text),
        t1 = text.length;
      while (true) {
        if (scanner._string_scanner$_position !== t1) {
          character = scanner.super$StringScanner$readChar();
          scanner._adjustLineAndColumn$1(character);
          t2 = character !== 10;
        } else
          t2 = false;
        if (!t2)
          break;
      }
      if (scanner._string_scanner$_position === t1)
        return scanner.peekChar$1(-1) === 10 ? -1 : null;
      for (min = null; scanner._string_scanner$_position !== t1;) {
        for (; scanner._string_scanner$_position !== t1;) {
          next = scanner.peekChar$0();
          if (next !== 32 && next !== 9)
            break;
          scanner._adjustLineAndColumn$1(scanner.super$StringScanner$readChar());
        }
        if (scanner._string_scanner$_position === t1 || scanner.scanChar$1(10))
          continue;
        min0 = scanner._line_scanner$_column;
        min = min == null ? min0 : Math.min(min, min0);
        while (true) {
          if (scanner._string_scanner$_position !== t1) {
            character = scanner.super$StringScanner$readChar();
            scanner._adjustLineAndColumn$1(character);
            t2 = character !== 10;
          } else
            t2 = false;
          if (!t2)
            break;
        }
      }
      return min == null ? -1 : min;
    },
    _writeWithIndent$2: function(text, minimumIndentation) {
      var t1, t2, character, t3, lineStart, newlines, end,
        scanner = new Z.LineScanner(null, text);
      for (t1 = text.length, t2 = this._buffer; scanner._string_scanner$_position !== t1;) {
        character = scanner.super$StringScanner$readChar();
        scanner._adjustLineAndColumn$1(character);
        if (character === 10)
          break;
        t2.writeCharCode$1(character);
      }
      for (t3 = J.getInterceptor$s(text); true;) {
        lineStart = scanner._string_scanner$_position;
        for (newlines = 1; true;) {
          if (scanner._string_scanner$_position === t1) {
            t2.writeCharCode$1(32);
            return;
          }
          character = scanner.super$StringScanner$readChar();
          scanner._adjustLineAndColumn$1(character);
          if (character === 32 || character === 9)
            continue;
          if (character !== 10)
            break;
          lineStart = scanner._string_scanner$_position;
          ++newlines;
        }
        this._writeTimes$2(10, newlines);
        this._writeIndentation$0();
        end = scanner._string_scanner$_position;
        t2.write$1(0, t3.substring$2(text, lineStart + minimumIndentation, end));
        for (; true;) {
          if (scanner._string_scanner$_position === t1)
            return;
          character = scanner.super$StringScanner$readChar();
          scanner._adjustLineAndColumn$1(character);
          if (character === 10)
            break;
          t2.writeCharCode$1(character);
        }
      }
    },
    visitColor$1: function(value) {
      var $name, hexLength, t2, t3, _this = this,
        t1 = _this._style === C.OutputStyle_compressed;
      if (t1 && Math.abs(value.alpha - 1) < $.$get$epsilon()) {
        $name = $.$get$namesByColor().$index(0, value);
        hexLength = _this._canUseShortHex$1(value) ? 4 : 7;
        if ($name != null && $name.length <= hexLength)
          _this._buffer.write$1(0, $name);
        else {
          t1 = _this._buffer;
          if (_this._canUseShortHex$1(value)) {
            t1.writeCharCode$1(35);
            t1.writeCharCode$1(T.hexCharFor(value.get$red() & 15));
            t1.writeCharCode$1(T.hexCharFor(value.get$green() & 15));
            t1.writeCharCode$1(T.hexCharFor(value.get$blue() & 15));
          } else {
            t1.writeCharCode$1(35);
            _this._writeHexComponent$1(value.get$red());
            _this._writeHexComponent$1(value.get$green());
            _this._writeHexComponent$1(value.get$blue());
          }
        }
        return;
      }
      if (value.get$original() != null)
        _this._buffer.write$1(0, value.get$original());
      else {
        t2 = $.$get$namesByColor();
        if (t2.containsKey$1(value) && !(Math.abs(value.alpha - 0) < $.$get$epsilon()))
          _this._buffer.write$1(0, t2.$index(0, value));
        else {
          t2 = value.alpha;
          t3 = _this._buffer;
          if (Math.abs(t2 - 1) < $.$get$epsilon()) {
            t3.writeCharCode$1(35);
            _this._writeHexComponent$1(value.get$red());
            _this._writeHexComponent$1(value.get$green());
            _this._writeHexComponent$1(value.get$blue());
          } else {
            t3.write$1(0, "rgba(" + H.S(value.get$red()));
            t3.write$1(0, t1 ? "," : ", ");
            t3.write$1(0, value.get$green());
            t3.write$1(0, t1 ? "," : ", ");
            t3.write$1(0, value.get$blue());
            t3.write$1(0, t1 ? "," : ", ");
            _this._writeNumber$1(t2);
            t3.writeCharCode$1(41);
          }
        }
      }
    },
    _canUseShortHex$1: function(color) {
      var t1 = color.get$red();
      if ((t1 & 15) === C.JSInt_methods._shrOtherPositive$1(t1, 4)) {
        t1 = color.get$green();
        if ((t1 & 15) === C.JSInt_methods._shrOtherPositive$1(t1, 4)) {
          t1 = color.get$blue();
          t1 = (t1 & 15) === C.JSInt_methods._shrOtherPositive$1(t1, 4);
        } else
          t1 = false;
      } else
        t1 = false;
      return t1;
    },
    _writeHexComponent$1: function(color) {
      var t1 = this._buffer;
      t1.writeCharCode$1(T.hexCharFor(C.JSInt_methods._shrOtherPositive$1(color, 4)));
      t1.writeCharCode$1(T.hexCharFor(color & 15));
    },
    visitList$1: function(value) {
      var t2, singleton, t3, t4, _this = this,
        t1 = value.hasBrackets;
      if (t1)
        _this._buffer.writeCharCode$1(91);
      else if (value._list$_contents.length === 0) {
        if (!_this._inspect)
          throw H.wrapException(E.SassScriptException$("() isn't a valid CSS value."));
        _this._buffer.write$1(0, "()");
        return;
      }
      t2 = _this._inspect;
      singleton = t2 && value._list$_contents.length === 1 && value.separator === C.ListSeparator_comma;
      if (singleton && !t1)
        _this._buffer.writeCharCode$1(40);
      t3 = value._list$_contents;
      t3 = t2 ? t3 : new H.WhereIterable(t3, new N._SerializeVisitor_visitList_closure(), [H.getTypeArgumentByIndex(t3, 0)]);
      if (value.separator === C.ListSeparator_space)
        t4 = " ";
      else
        t4 = _this._style === C.OutputStyle_compressed ? "," : ", ";
      _this._writeBetween$3(t3, t4, t2 ? new N._SerializeVisitor_visitList_closure0(_this, value) : new N._SerializeVisitor_visitList_closure1(_this));
      if (singleton) {
        t2 = _this._buffer;
        t2.writeCharCode$1(44);
        if (!t1)
          t2.writeCharCode$1(41);
      }
      if (t1)
        _this._buffer.writeCharCode$1(93);
    },
    _elementNeedsParens$2: function(separator, value) {
      var t1;
      if (value instanceof D.SassList) {
        if (value._list$_contents.length < 2)
          return false;
        if (value.hasBrackets)
          return false;
        t1 = value.separator;
        return separator === C.ListSeparator_comma ? t1 === C.ListSeparator_comma : t1 !== C.ListSeparator_undecided;
      }
      return false;
    },
    visitMap$1: function(map) {
      var t1, _this = this;
      if (!_this._inspect)
        throw H.wrapException(E.SassScriptException$(map.toString$0(0) + " isn't a valid CSS value."));
      t1 = _this._buffer;
      t1.writeCharCode$1(40);
      _this._writeBetween$3(map.contents.get$keys(), ", ", new N._SerializeVisitor_visitMap_closure(_this, map));
      t1.writeCharCode$1(41);
    },
    _writeMapElement$1: function(value) {
      var needsParens = value instanceof D.SassList && value.separator === C.ListSeparator_comma && !value.hasBrackets;
      if (needsParens)
        this._buffer.writeCharCode$1(40);
      value.accept$1(this);
      if (needsParens)
        this._buffer.writeCharCode$1(41);
    },
    visitNumber$1: function(value) {
      var t2, _this = this,
        t1 = value.asSlash;
      if (t1 != null) {
        _this.visitNumber$1(t1.item1);
        _this._buffer.writeCharCode$1(47);
        _this.visitNumber$1(t1.item2);
        return;
      }
      _this._writeNumber$1(value.value);
      if (!_this._inspect) {
        t1 = value.numeratorUnits;
        t2 = t1.length;
        if (t2 > 1 || value.denominatorUnits.length !== 0)
          throw H.wrapException(E.SassScriptException$(H.S(value) + " isn't a valid CSS value."));
        if (t2 !== 0)
          _this._buffer.write$1(0, C.JSArray_methods.get$first(t1));
      } else
        _this._buffer.write$1(0, value.get$unitString());
    },
    _writeNumber$1: function(number) {
      var t1, text, text0, _this = this,
        integer = T.fuzzyIsInt(number) ? J.round$0$n(number) : null;
      if (integer != null) {
        t1 = integer >= 1e21 ? _this._removeExponent$1(C.JSInt_methods.toString$0(integer)) : C.JSInt_methods.toString$0(integer);
        _this._buffer.write$1(0, t1);
        return;
      }
      text = number >= 1e21 ? _this._removeExponent$1(C.JSNumber_methods.toString$0(number)) : C.JSNumber_methods.toString$0(number);
      text0 = _this._style === C.OutputStyle_compressed && C.JSString_methods._codeUnitAt$1(text, 0) === 48 ? C.JSString_methods.substring$1(text, 1) : text;
      if (text.length < 12) {
        _this._buffer.write$1(0, text0);
        return;
      }
      _this._writeDecimal$1(text0);
    },
    _removeExponent$1: function(text) {
      var exponent, buffer, t2, additionalZeroes, negative, _null = null,
        t1 = text.length,
        i = 0;
      while (true) {
        if (!(i < t1)) {
          exponent = _null;
          buffer = exponent;
          break;
        }
        c$0: {
          if (C.JSString_methods._codeUnitAt$1(text, i) !== 101)
            break c$0;
          buffer = new P.StringBuffer("");
          t2 = H.Primitives_stringFromCharCode(C.JSString_methods._codeUnitAt$1(text, 0));
          buffer._contents = t2;
          if (i > 2)
            buffer._contents = t2 + C.JSString_methods.substring$2(text, 2, i);
          exponent = P.int_parse(C.JSString_methods.substring$2(text, i + 1, t1), _null, _null);
          break;
        }
        ++i;
      }
      if (buffer == null)
        return text;
      if (exponent > 0) {
        t1 = buffer._contents;
        additionalZeroes = exponent - (t1.length - 1);
        for (i = 0; i < additionalZeroes; ++i)
          t1 = buffer._contents += H.Primitives_stringFromCharCode(48);
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      } else {
        negative = C.JSString_methods._codeUnitAt$1(text, 0) === 45;
        t1 = (negative ? H.Primitives_stringFromCharCode(45) : "") + "0.";
        for (i = -1; i > exponent; --i)
          t1 += H.Primitives_stringFromCharCode(48);
        if (negative) {
          t2 = buffer._contents;
          t2 = C.JSString_methods.substring$1(t2.charCodeAt(0) == 0 ? t2 : t2, 1);
        } else
          t2 = buffer;
        t2 = t1 + H.S(t2);
        return t2.charCodeAt(0) == 0 ? t2 : t2;
      }
    },
    _writeDecimal$1: function(text) {
      var t1, t2, textIndex, codeUnit, digits, t3, digitsIndex, digitsIndex0, textIndex0, newDigit, i;
      for (t1 = text.length, t2 = this._buffer, textIndex = 0; textIndex < t1; ++textIndex) {
        codeUnit = C.JSString_methods._codeUnitAt$1(text, textIndex);
        if (codeUnit === 46) {
          if (textIndex === t1 - 2 && C.JSString_methods.codeUnitAt$1(text, t1 - 1) === 48)
            return;
          t2.writeCharCode$1(codeUnit);
          ++textIndex;
          break;
        }
        t2.writeCharCode$1(codeUnit);
      }
      if (textIndex === t1)
        return;
      digits = new Uint8Array(10);
      t3 = digits.length;
      digitsIndex = 0;
      while (true) {
        if (!(textIndex < t1 && digitsIndex < t3))
          break;
        digitsIndex0 = digitsIndex + 1;
        textIndex0 = textIndex + 1;
        digits[digitsIndex] = C.JSString_methods._codeUnitAt$1(text, textIndex) - 48;
        digitsIndex = digitsIndex0;
        textIndex = textIndex0;
      }
      if (textIndex !== t1 && C.JSString_methods._codeUnitAt$1(text, textIndex) - 48 >= 5)
        for (; digitsIndex >= 0; digitsIndex = digitsIndex0) {
          digitsIndex0 = digitsIndex - 1;
          newDigit = digits[digitsIndex0] + 1;
          digits[digitsIndex0] = newDigit;
          if (newDigit !== 10)
            break;
        }
      while (true) {
        if (!(digitsIndex > 0 && digits[digitsIndex - 1] === 0))
          break;
        --digitsIndex;
      }
      for (i = 0; i < digitsIndex; ++i)
        t2.writeCharCode$1(48 + digits[i]);
    },
    _visitQuotedString$2$forceDoubleQuote: function(string, forceDoubleQuote) {
      var t1, includesSingleQuote, includesDoubleQuote, i, char, t2, next, quote, _this = this,
        buffer = forceDoubleQuote ? _this._buffer : new P.StringBuffer("");
      if (forceDoubleQuote)
        buffer.writeCharCode$1(34);
      for (t1 = string.length, includesSingleQuote = false, includesDoubleQuote = false, i = 0; i < t1; ++i) {
        char = C.JSString_methods._codeUnitAt$1(string, i);
        switch (char) {
          case 39:
            if (forceDoubleQuote)
              buffer.writeCharCode$1(39);
            else {
              if (includesDoubleQuote) {
                _this._visitQuotedString$2$forceDoubleQuote(string, true);
                return;
              } else
                buffer.writeCharCode$1(39);
              includesSingleQuote = true;
            }
            break;
          case 34:
            if (forceDoubleQuote) {
              buffer.writeCharCode$1(92);
              buffer.writeCharCode$1(34);
            } else {
              if (includesSingleQuote) {
                _this._visitQuotedString$2$forceDoubleQuote(string, true);
                return;
              } else
                buffer.writeCharCode$1(34);
              includesDoubleQuote = true;
            }
            break;
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
          case 8:
          case 10:
          case 11:
          case 12:
          case 13:
          case 14:
          case 15:
          case 16:
          case 17:
          case 18:
          case 19:
          case 20:
          case 21:
          case 22:
          case 23:
          case 24:
          case 25:
          case 26:
          case 27:
          case 28:
          case 29:
          case 30:
          case 31:
            buffer.writeCharCode$1(92);
            if (char > 15) {
              t2 = char >>> 4;
              buffer.writeCharCode$1(t2 < 10 ? 48 + t2 : 87 + t2);
            }
            t2 = char & 15;
            buffer.writeCharCode$1(t2 < 10 ? 48 + t2 : 87 + t2);
            t2 = i + 1;
            if (t1 === t2)
              break;
            next = C.JSString_methods._codeUnitAt$1(string, t2);
            if (T.isHex(next) || next === 32 || next === 9)
              buffer.writeCharCode$1(32);
            break;
          case 92:
            buffer.writeCharCode$1(92);
            buffer.writeCharCode$1(92);
            break;
          default:
            buffer.writeCharCode$1(char);
            break;
        }
      }
      if (forceDoubleQuote)
        buffer.writeCharCode$1(34);
      else {
        quote = includesDoubleQuote ? 39 : 34;
        t1 = _this._buffer;
        t1.writeCharCode$1(quote);
        t1.write$1(0, buffer);
        t1.writeCharCode$1(quote);
      }
    },
    _visitQuotedString$1: function(string) {
      return this._visitQuotedString$2$forceDoubleQuote(string, false);
    },
    _visitUnquotedString$1: function(string) {
      var t1, t2, afterNewline, i, char;
      for (t1 = string.length, t2 = this._buffer, afterNewline = false, i = 0; i < t1; ++i) {
        char = C.JSString_methods._codeUnitAt$1(string, i);
        switch (char) {
          case 10:
            t2.writeCharCode$1(32);
            afterNewline = true;
            break;
          case 32:
            if (!afterNewline)
              t2.writeCharCode$1(32);
            break;
          default:
            t2.writeCharCode$1(char);
            afterNewline = false;
            break;
        }
      }
    },
    visitComplexSelector$1: function(complex) {
      var t1, t2, t3, t4, lastComponent, _i, component, t5;
      for (t1 = complex.components, t2 = t1.length, t3 = this._buffer, t4 = this._style === C.OutputStyle_compressed, lastComponent = null, _i = 0; _i < t2; ++_i, lastComponent = component) {
        component = t1[_i];
        if (lastComponent != null)
          if (!(t4 && !!lastComponent.$isCombinator))
            t5 = !(t4 && component instanceof S.Combinator);
          else
            t5 = false;
        else
          t5 = false;
        if (t5)
          t3.write$1(0, " ");
        if (component instanceof X.CompoundSelector)
          this.visitCompoundSelector$1(component);
        else
          t3.write$1(0, component);
      }
    },
    visitCompoundSelector$1: function(compound) {
      var t2, t3, _i,
        t1 = this._buffer,
        start = t1.get$length(t1);
      for (t2 = compound.components, t3 = t2.length, _i = 0; _i < t3; ++_i)
        t2[_i].accept$1(this);
      if (t1.get$length(t1) === start)
        t1.writeCharCode$1(42);
    },
    visitSelectorList$1: function(list) {
      var complexes, t1, t2, t3, t4, first, t5, _this = this;
      if (_this._inspect)
        complexes = list.components;
      else {
        t1 = list.components;
        complexes = new H.WhereIterable(t1, new N._SerializeVisitor_visitSelectorList_closure(), [H.getTypeArgumentByIndex(t1, 0)]);
      }
      for (t1 = J.get$iterator$ax(complexes), t2 = _this._style !== C.OutputStyle_compressed, t3 = _this._buffer, t4 = _this._lineFeed.text, first = true; t1.moveNext$0();) {
        t5 = t1.get$current(t1);
        if (first)
          first = false;
        else {
          t3.writeCharCode$1(44);
          if (t5.lineBreak) {
            if (t2)
              t3.write$1(0, t4);
          } else if (t2)
            t3.writeCharCode$1(32);
        }
        _this.visitComplexSelector$1(t5);
      }
    },
    visitPseudoSelector$1: function(pseudo) {
      var t4, t5, t6,
        t1 = pseudo.selector,
        t2 = t1 == null,
        t3 = !t2;
      if (t3 && pseudo.name === "not" && t1.get$isInvisible())
        return;
      t4 = this._buffer;
      t4.writeCharCode$1(58);
      if (!pseudo.isSyntacticClass)
        t4.writeCharCode$1(58);
      t4.write$1(0, pseudo.name);
      t5 = pseudo.argument;
      t6 = t5 == null;
      if (t6 && t2)
        return;
      t4.writeCharCode$1(40);
      if (!t6) {
        t4.write$1(0, t5);
        if (t3)
          t4.writeCharCode$1(32);
      }
      if (t3)
        this.visitSelectorList$1(t1);
      t4.writeCharCode$1(41);
    },
    _write$1: function(value) {
      return this._buffer.forSpan$2(value.get$span(), new N._SerializeVisitor__write_closure(this, value));
    },
    _serialize$_visitChildren$1: function(children) {
      var t3, _this = this, t1 = {},
        t2 = _this._buffer;
      t2.writeCharCode$1(123);
      if (children.every$1(children, _this.get$_isInvisible())) {
        t2.writeCharCode$1(125);
        return;
      }
      _this._writeLineFeed$0();
      t1.previous = null;
      ++_this._indentation;
      new N._SerializeVisitor__visitChildren_closure(t1, _this, children).call$0();
      --_this._indentation;
      t1 = t1.previous;
      t3 = J.getInterceptor$(t1);
      if ((!!t3.$isCssParentNode ? t1.get$isChildless() : !t3.$isCssComment) && _this._style !== C.OutputStyle_compressed)
        t2.writeCharCode$1(59);
      _this._writeLineFeed$0();
      _this._writeIndentation$0();
      t2.writeCharCode$1(125);
    },
    _writeLineFeed$0: function() {
      if (this._style !== C.OutputStyle_compressed)
        this._buffer.write$1(0, this._lineFeed.text);
    },
    _writeIndentation$0: function() {
      var _this = this;
      if (_this._style === C.OutputStyle_compressed)
        return;
      _this._writeTimes$2(_this._indentCharacter, _this._indentation * _this._indentWidth);
    },
    _writeTimes$2: function(char, times) {
      var t1, i;
      for (t1 = this._buffer, i = 0; i < times; ++i)
        t1.writeCharCode$1(char);
    },
    _writeBetween$1$3: function(iterable, text, callback) {
      var t1, t2, first, value;
      for (t1 = J.get$iterator$ax(iterable), t2 = this._buffer, first = true; t1.moveNext$0();) {
        value = t1.get$current(t1);
        if (first)
          first = false;
        else
          t2.write$1(0, text);
        callback.call$1(value);
      }
    },
    _writeBetween$3: function(iterable, text, callback) {
      return this._writeBetween$1$3(iterable, text, callback, null);
    },
    _isInvisible$1: function(node) {
      if (this._inspect)
        return false;
      if (this._style === C.OutputStyle_compressed && !!J.getInterceptor$(node).$isCssComment && J._codeUnitAt$1$s(node.text, 2) !== 33)
        return true;
      if (!!J.getInterceptor$(node).$isCssParentNode) {
        if (!!node.$isCssAtRule)
          return false;
        if (!!node.$isCssStyleRule && node.selector.value.get$isInvisible())
          return true;
        return J.every$1$ax(node.get$children(), this.get$_isInvisible());
      } else
        return false;
    }
  };
  N._SerializeVisitor_visitCssComment_closure.prototype = {
    call$0: function() {
      var t2, t3, minimumIndentation,
        t1 = this.$this;
      if (t1._style === C.OutputStyle_compressed && J._codeUnitAt$1$s(this.node.text, 2) !== 33)
        return;
      t2 = this.node;
      t3 = t2.text;
      minimumIndentation = t1._minimumIndentation$1(t3);
      if (minimumIndentation == null) {
        t1._writeIndentation$0();
        t1._buffer.write$1(0, t3);
        return;
      }
      t2 = t2.span;
      if (t2 != null) {
        t2 = Y.FileLocation$_(t2.file, t2._start);
        minimumIndentation = Math.min(minimumIndentation, t2.file.getColumn$1(t2.offset));
      }
      t1._writeIndentation$0();
      t1._writeWithIndent$2(t3, minimumIndentation);
    }
  };
  N._SerializeVisitor_visitCssAtRule_closure.prototype = {
    call$0: function() {
      var t3,
        t1 = this.$this,
        t2 = t1._buffer;
      t2.writeCharCode$1(64);
      t3 = this.node;
      t1._write$1(t3.name);
      t3 = t3.value;
      if (t3 != null) {
        t2.writeCharCode$1(32);
        t1._write$1(t3);
      }
    }
  };
  N._SerializeVisitor_visitCssMediaRule_closure.prototype = {
    call$0: function() {
      var t3, t4,
        t1 = this.$this,
        t2 = t1._buffer;
      t2.write$1(0, "@media");
      t3 = t1._style === C.OutputStyle_compressed;
      if (t3) {
        t4 = C.JSArray_methods.get$first(this.node.queries);
        t4 = !(t4.modifier == null && t4.type == null);
      } else
        t4 = true;
      if (t4)
        t2.writeCharCode$1(32);
      t2 = t3 ? "," : ", ";
      t1._writeBetween$3(this.node.queries, t2, t1.get$_visitMediaQuery());
    }
  };
  N._SerializeVisitor_visitCssImport_closure.prototype = {
    call$0: function() {
      var t3, t4, t5, t6,
        t1 = this.$this,
        t2 = t1._buffer;
      t2.write$1(0, "@import");
      t3 = t1._style === C.OutputStyle_compressed;
      t4 = !t3;
      if (t4)
        t2.writeCharCode$1(32);
      t5 = this.node;
      t2.forSpan$2(t5.url.get$span(), new N._SerializeVisitor_visitCssImport__closure(t1, t5));
      t6 = t5.supports;
      if (t6 != null) {
        if (t4)
          t2.writeCharCode$1(32);
        t1._write$1(t6);
      }
      t5 = t5.media;
      if (t5 != null) {
        if (t4)
          t2.writeCharCode$1(32);
        t2 = t3 ? "," : ", ";
        t1._writeBetween$3(t5, t2, t1.get$_visitMediaQuery());
      }
    }
  };
  N._SerializeVisitor_visitCssImport__closure.prototype = {
    call$0: function() {
      return this.$this._writeImportUrl$1(this.node.url.get$value());
    }
  };
  N._SerializeVisitor_visitCssKeyframeBlock_closure.prototype = {
    call$0: function() {
      var t1 = this.$this,
        t2 = t1._style === C.OutputStyle_compressed ? "," : ", ",
        t3 = t1._buffer;
      return t1._writeBetween$3(this.node.selector.value, t2, t3.get$write(t3));
    }
  };
  N._SerializeVisitor_visitCssStyleRule_closure.prototype = {
    call$0: function() {
      var t1 = this.node.selector.value;
      t1.toString;
      return this.$this.visitSelectorList$1(t1);
    }
  };
  N._SerializeVisitor_visitCssSupportsRule_closure.prototype = {
    call$0: function() {
      var t1 = this.$this,
        t2 = t1._buffer;
      t2.write$1(0, "@supports");
      if (!(t1._style === C.OutputStyle_compressed && J.codeUnitAt$1$s(this.node.condition.value, 0) === 40))
        t2.writeCharCode$1(32);
      t1._write$1(this.node.condition);
    }
  };
  N._SerializeVisitor_visitCssDeclaration_closure.prototype = {
    call$0: function() {
      var t1 = this.$this,
        t2 = this.node;
      if (t1._style === C.OutputStyle_compressed)
        t1._writeFoldedValue$1(t2);
      else
        t1._writeReindentedValue$1(t2);
    }
  };
  N._SerializeVisitor_visitCssDeclaration_closure0.prototype = {
    call$0: function() {
      return this.node.value.value.accept$1(this.$this);
    }
  };
  N._SerializeVisitor_visitList_closure.prototype = {
    call$1: function(element) {
      return !element.get$isBlank();
    }
  };
  N._SerializeVisitor_visitList_closure0.prototype = {
    call$1: function(element) {
      var t1 = this.$this,
        needsParens = t1._elementNeedsParens$2(this.value.separator, element);
      if (needsParens)
        t1._buffer.writeCharCode$1(40);
      element.accept$1(t1);
      if (needsParens)
        t1._buffer.writeCharCode$1(41);
    }
  };
  N._SerializeVisitor_visitList_closure1.prototype = {
    call$1: function(element) {
      element.accept$1(this.$this);
    }
  };
  N._SerializeVisitor_visitMap_closure.prototype = {
    call$1: function(key) {
      var t1 = this.$this;
      t1._writeMapElement$1(key);
      t1._buffer.write$1(0, ": ");
      t1._writeMapElement$1(this.map.contents.$index(0, key));
    }
  };
  N._SerializeVisitor_visitSelectorList_closure.prototype = {
    call$1: function(complex) {
      return !complex.get$isInvisible();
    }
  };
  N._SerializeVisitor__write_closure.prototype = {
    call$0: function() {
      return this.$this._buffer.write$1(0, this.value.get$value());
    }
  };
  N._SerializeVisitor__visitChildren_closure.prototype = {
    call$0: function() {
      var t1, t2, t3, t4, t5, t6, i, child, t7;
      for (t1 = this.children._collection$_source, t2 = J.getInterceptor$asx(t1), t3 = this._box_0, t4 = this.$this, t5 = t4._buffer, t6 = t4._lineFeed.text, i = 0; i < t2.get$length(t1); ++i) {
        child = t2.elementAt$1(t1, i);
        if (t4._isInvisible$1(child))
          continue;
        t7 = t3.previous;
        if (t7 != null) {
          if (!!t7.$isCssParentNode ? t7.get$isChildless() : !t7.$isCssComment)
            t5.writeCharCode$1(59);
          t7 = t4._style !== C.OutputStyle_compressed;
          if (t7)
            t5.write$1(0, t6);
          if (t3.previous.get$isGroupEnd())
            if (t7)
              t5.write$1(0, t6);
        }
        t3.previous = child;
        child.accept$1(t4);
      }
    }
  };
  N.OutputStyle.prototype = {
    toString$0: function(_) {
      return this._serialize$_name;
    }
  };
  N.LineFeed.prototype = {
    toString$0: function(_) {
      return this.name;
    }
  };
  N.SerializeResult.prototype = {};
  N.withWarnCallback_closure.prototype = {
    call$0: function() {
      return this.callback.call$0();
    },
    "call*": "call$0",
    $requiredArgCount: 0
  };
  L.Entry.prototype = {
    compareTo$1: function(_, other) {
      var t1, t2, t3,
        res = this.target.compareTo$1(0, other.target);
      if (res !== 0)
        return res;
      t1 = this.source;
      t2 = J.toString$0$(t1.file.url);
      t3 = other.source;
      res = C.JSString_methods.compareTo$1(t2, J.toString$0$(t3.file.url));
      if (res !== 0)
        return res;
      return t1.compareTo$1(0, t3);
    },
    $isComparable: 1,
    $asComparable: function() {
      return [L.Entry];
    },
    get$source: function() {
      return this.source;
    },
    get$target: function() {
      return this.target;
    },
    get$identifierName: function() {
      return this.identifierName;
    }
  };
  T.Mapping.prototype = {};
  T.SingleMapping.prototype = {
    toJson$1$includeSourceContents: function(includeSourceContents) {
      var t1, t2, line, column, srcLine, srcColumn, srcUrlId, srcNameId, first, _i, entry, nextLine, i, t3, t4, _i0, segment, column0, t5, newUrlId, srcLine0, srcColumn0, srcNameId0, result, _this = this,
        buff = new P.StringBuffer("");
      for (t1 = _this.lines, t2 = t1.length, line = 0, column = 0, srcLine = 0, srcColumn = 0, srcUrlId = 0, srcNameId = 0, first = true, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
        entry = t1[_i];
        nextLine = entry.line;
        if (nextLine > line) {
          for (i = line; i < nextLine; ++i)
            buff._contents += ";";
          line = nextLine;
          column = 0;
          first = true;
        }
        for (t3 = entry.entries, t4 = t3.length, _i0 = 0; _i0 < t3.length; t3.length === t4 || (0, H.throwConcurrentModificationError)(t3), ++_i0, column = column0, first = false) {
          segment = t3[_i0];
          if (!first)
            buff._contents += ",";
          column0 = segment.column;
          t5 = L.encodeVlq(column0 - column);
          t5 = P.StringBuffer__writeAll(buff._contents, t5, "");
          buff._contents = t5;
          newUrlId = segment.sourceUrlId;
          if (newUrlId == null)
            continue;
          t5 = P.StringBuffer__writeAll(t5, L.encodeVlq(newUrlId - srcUrlId), "");
          buff._contents = t5;
          srcLine0 = segment.sourceLine;
          t5 = P.StringBuffer__writeAll(t5, L.encodeVlq(srcLine0 - srcLine), "");
          buff._contents = t5;
          srcColumn0 = segment.sourceColumn;
          t5 = P.StringBuffer__writeAll(t5, L.encodeVlq(srcColumn0 - srcColumn), "");
          buff._contents = t5;
          srcNameId0 = segment.sourceNameId;
          if (srcNameId0 == null) {
            srcUrlId = newUrlId;
            srcColumn = srcColumn0;
            srcLine = srcLine0;
            continue;
          }
          buff._contents = P.StringBuffer__writeAll(t5, L.encodeVlq(srcNameId0 - srcNameId), "");
          srcNameId = srcNameId0;
          srcUrlId = newUrlId;
          srcColumn = srcColumn0;
          srcLine = srcLine0;
        }
      }
      t1 = _this.sourceRoot;
      if (t1 == null)
        t1 = "";
      t2 = buff._contents;
      t3 = P.String;
      result = P.LinkedHashMap_LinkedHashMap$_literal(["version", 3, "sourceRoot", t1, "sources", _this.urls, "names", _this.names, "mappings", t2.charCodeAt(0) == 0 ? t2 : t2], t3, P.Object);
      t1 = _this.targetUrl;
      if (t1 != null)
        result.$indexSet(0, "file", t1);
      if (includeSourceContents) {
        t1 = _this.files;
        result.$indexSet(0, "sourcesContent", new H.MappedListIterable(t1, new T.SingleMapping_toJson_closure(), [H.getTypeArgumentByIndex(t1, 0), t3]).toList$0(0));
      }
      _this.extensions.forEach$1(0, new T.SingleMapping_toJson_closure0(result));
      return result;
    },
    toJson$0: function() {
      return this.toJson$1$includeSourceContents(false);
    },
    toString$0: function(_) {
      var _this = this,
        t1 = H.getRuntimeType(_this).toString$0(0);
      t1 + " : [";
      t1 = t1 + " : [targetUrl: " + H.S(_this.targetUrl) + ", sourceRoot: " + H.S(_this.sourceRoot) + ", urls: " + H.S(_this.urls) + ", names: " + H.S(_this.names) + ", lines: " + H.S(_this.lines) + "]";
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    }
  };
  T.SingleMapping_SingleMapping$fromEntries_closure.prototype = {
    call$0: function() {
      var t1 = this.urls;
      return t1.get$length(t1);
    }
  };
  T.SingleMapping_SingleMapping$fromEntries_closure0.prototype = {
    call$0: function() {
      return H.interceptedTypeCast(this.sourceEntry.get$source(), "$isFileLocation").file;
    }
  };
  T.SingleMapping_SingleMapping$fromEntries_closure1.prototype = {
    call$1: function(i) {
      return this.files.$index(0, i);
    },
    $signature: 54
  };
  T.SingleMapping_toJson_closure.prototype = {
    call$1: function(file) {
      return file == null ? null : P.String_String$fromCharCodes(C.NativeUint32List_methods.sublist$2(file._decodedChars, 0, null), 0, null);
    }
  };
  T.SingleMapping_toJson_closure0.prototype = {
    call$2: function($name, value) {
      this.result.$indexSet(0, $name, value);
      return value;
    }
  };
  T.TargetLineEntry.prototype = {
    toString$0: function(_) {
      return H.getRuntimeType(this).toString$0(0) + ": " + this.line + " " + H.S(this.entries);
    }
  };
  T.TargetEntry.prototype = {
    toString$0: function(_) {
      var _this = this;
      return H.getRuntimeType(_this).toString$0(0) + ": (" + H.S(_this.column) + ", " + H.S(_this.sourceUrlId) + ", " + H.S(_this.sourceLine) + ", " + H.S(_this.sourceColumn) + ", " + H.S(_this.sourceNameId) + ")";
    }
  };
  Y.SourceFile.prototype = {
    get$length: function(_) {
      return this._decodedChars.length;
    },
    get$lines: function() {
      return this._lineStarts.length;
    },
    SourceFile$decoded$2$url: function(decodedChars, url) {
      var t1, t2, t3, i, c, j;
      for (t1 = this._decodedChars, t2 = t1.length, t3 = this._lineStarts, i = 0; i < t2; ++i) {
        c = t1[i];
        if (c === 13) {
          j = i + 1;
          if (j >= t2 || t1[j] !== 10)
            c = 10;
        }
        if (c === 10)
          t3.push(i + 1);
      }
    },
    span$2: function(start, end) {
      return Y._FileSpan$(this, start, end == null ? this._decodedChars.length : end);
    },
    getLine$1: function(offset) {
      var t1, _this = this;
      if (offset < 0)
        throw H.wrapException(P.RangeError$("Offset may not be negative, was " + H.S(offset) + "."));
      else if (offset > _this._decodedChars.length)
        throw H.wrapException(P.RangeError$("Offset " + H.S(offset) + " must not be greater than the number of characters in the file, " + _this.get$length(_this) + "."));
      t1 = _this._lineStarts;
      if (offset < C.JSArray_methods.get$first(t1))
        return -1;
      if (offset >= C.JSArray_methods.get$last(t1))
        return t1.length - 1;
      if (_this._isNearCachedLine$1(offset))
        return _this._cachedLine;
      return _this._cachedLine = _this._binarySearch$1(offset) - 1;
    },
    _isNearCachedLine$1: function(offset) {
      var t2, t3,
        t1 = this._cachedLine;
      if (t1 == null)
        return false;
      t2 = this._lineStarts;
      if (offset < t2[t1])
        return false;
      t3 = t2.length;
      if (t1 >= t3 - 1 || offset < t2[t1 + 1])
        return true;
      if (t1 >= t3 - 2 || offset < t2[t1 + 2]) {
        this._cachedLine = t1 + 1;
        return true;
      }
      return false;
    },
    _binarySearch$1: function(offset) {
      var min, half,
        t1 = this._lineStarts,
        max = t1.length - 1;
      for (min = 0; min < max;) {
        half = min + C.JSInt_methods._tdivFast$1(max - min, 2);
        if (t1[half] > offset)
          max = half;
        else
          min = half + 1;
      }
      return max;
    },
    getColumn$1: function(offset) {
      var line, lineStart, _this = this;
      if (offset < 0)
        throw H.wrapException(P.RangeError$("Offset may not be negative, was " + H.S(offset) + "."));
      else if (offset > _this._decodedChars.length)
        throw H.wrapException(P.RangeError$("Offset " + H.S(offset) + " must be not be greater than the number of characters in the file, " + _this.get$length(_this) + "."));
      line = _this.getLine$1(offset);
      lineStart = _this._lineStarts[line];
      if (lineStart > offset)
        throw H.wrapException(P.RangeError$("Line " + H.S(line) + " comes after offset " + H.S(offset) + "."));
      return offset - lineStart;
    },
    getOffset$1: function(line) {
      var t1, t2, result, t3;
      if (line < 0)
        throw H.wrapException(P.RangeError$("Line may not be negative, was " + H.S(line) + "."));
      else {
        t1 = this._lineStarts;
        t2 = t1.length;
        if (line >= t2)
          throw H.wrapException(P.RangeError$("Line " + H.S(line) + " must be less than the number of lines in the file, " + this.get$lines() + "."));
      }
      result = t1[line];
      if (result <= this._decodedChars.length) {
        t3 = line + 1;
        t1 = t3 < t2 && result >= t1[t3];
      } else
        t1 = true;
      if (t1)
        throw H.wrapException(P.RangeError$("Line " + H.S(line) + " doesn't have 0 columns."));
      return result;
    }
  };
  Y.FileLocation.prototype = {
    get$sourceUrl: function() {
      return this.file.url;
    },
    get$line: function() {
      return this.file.getLine$1(this.offset);
    },
    get$column: function() {
      return this.file.getColumn$1(this.offset);
    },
    pointSpan$0: function() {
      var t1 = this.offset;
      return Y._FileSpan$(this.file, t1, t1);
    },
    get$offset: function() {
      return this.offset;
    }
  };
  Y.FileSpan.prototype = {$isComparable: 1,
    $asComparable: function() {
      return [V.SourceSpan];
    },
    $isSourceSpan: 1,
    $isSourceSpanWithContext: 1
  };
  Y._FileSpan.prototype = {
    get$sourceUrl: function() {
      return this.file.url;
    },
    get$length: function(_) {
      return this._end - this._start;
    },
    get$start: function(_) {
      return Y.FileLocation$_(this.file, this._start);
    },
    get$end: function(_) {
      return Y.FileLocation$_(this.file, this._end);
    },
    get$text: function() {
      return P.String_String$fromCharCodes(C.NativeUint32List_methods.sublist$2(this.file._decodedChars, this._start, this._end), 0, null);
    },
    get$context: function(_) {
      var _this = this,
        t1 = _this.file,
        endOffset = _this._end,
        endLine = t1.getLine$1(endOffset);
      if (t1.getColumn$1(endOffset) === 0 && endLine !== 0) {
        if (endOffset - _this._start === 0)
          return endLine === t1._lineStarts.length - 1 ? "" : P.String_String$fromCharCodes(C.NativeUint32List_methods.sublist$2(t1._decodedChars, t1.getOffset$1(endLine), t1.getOffset$1(endLine + 1)), 0, null);
      } else
        endOffset = endLine === t1._lineStarts.length - 1 ? t1._decodedChars.length : t1.getOffset$1(endLine + 1);
      return P.String_String$fromCharCodes(C.NativeUint32List_methods.sublist$2(t1._decodedChars, t1.getOffset$1(t1.getLine$1(_this._start)), endOffset), 0, null);
    },
    compareTo$1: function(_, other) {
      var result;
      if (!(other instanceof Y._FileSpan))
        return this.super$SourceSpanMixin$compareTo(0, other);
      result = J.compareTo$1$ns(this._start, other._start);
      return result === 0 ? J.compareTo$1$ns(this._end, other._end) : result;
    },
    $eq: function(_, other) {
      var _this = this;
      if (other == null)
        return false;
      if (!J.getInterceptor$(other).$isFileSpan)
        return _this.super$SourceSpanMixin$$eq(0, other);
      return _this._start == other._start && _this._end == other._end && J.$eq$(_this.file.url, other.file.url);
    },
    get$hashCode: function(_) {
      return Y.SourceSpanMixin.prototype.get$hashCode.call(this, this);
    },
    expand$1: function(_, other) {
      var start, _this = this,
        t1 = _this.file;
      if (!J.$eq$(t1.url, other.file.url))
        throw H.wrapException(P.ArgumentError$('Source URLs "' + H.S(_this.get$sourceUrl()) + '" and  "' + H.S(other.get$sourceUrl()) + "\" don't match."));
      start = Math.min(H.checkNum(_this._start), H.checkNum(other._start));
      return Y._FileSpan$(t1, start, Math.max(H.checkNum(_this._end), H.checkNum(other._end)));
    },
    $isFileSpan: 1,
    $isSourceSpanWithContext: 1
  };
  U.Highlighter.prototype = {
    highlight$0: function() {
      var t1, t2, lineStart, context, lines, t3, t4, lineNumber, _i, line, lastLineIndex, _this = this;
      _this._writeSidebar$1$end($._glyphs.get$downEnd());
      t1 = _this._highlighter$_buffer;
      t1._contents += "\n";
      t2 = _this._highlighter$_span;
      lineStart = B.findLineStart(t2.get$context(t2), t2.get$text(), t2.get$start(t2).get$column());
      context = t2.get$context(t2);
      if (lineStart > 0) {
        lines = C.JSString_methods.substring$2(context, 0, lineStart - 1).split("\n");
        t3 = t2.get$start(t2).get$line();
        t4 = lines.length;
        lineNumber = t3 - t4;
        for (t3 = _this._multiline, _i = 0; _i < t4; ++_i) {
          line = lines[_i];
          _this._writeSidebar$1$line(lineNumber);
          t1._contents += C.JSString_methods.$mul(" ", t3 ? 3 : 1);
          _this._writeText$1(line);
          t1._contents += "\n";
          ++lineNumber;
        }
        context = C.JSString_methods.substring$1(context, lineStart);
      }
      lines = H.setRuntimeTypeInfo(context.split("\n"), [P.String]);
      lastLineIndex = t2.get$end(t2).get$line() - t2.get$start(t2).get$line();
      if (J.get$length$asx(C.JSArray_methods.get$last(lines)) === 0 && lines.length > lastLineIndex + 1)
        lines.pop();
      _this._writeFirstLine$1(C.JSArray_methods.get$first(lines));
      if (_this._multiline) {
        _this._writeIntermediateLines$1(H.SubListIterable$(lines, 1, null, H.getTypeArgumentByIndex(lines, 0)).take$1(0, lastLineIndex - 1));
        _this._writeLastLine$1(lines[lastLineIndex]);
      }
      _this._writeTrailingLines$1(H.SubListIterable$(lines, lastLineIndex + 1, null, H.getTypeArgumentByIndex(lines, 0)));
      _this._writeSidebar$1$end($._glyphs.get$upEnd());
      t1 = t1._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    _writeFirstLine$1: function(line) {
      var t3, t4, startColumn, endColumn, textBefore, textInside, tabsBefore, tabsInside, _this = this, t1 = {},
        t2 = _this._highlighter$_span;
      _this._writeSidebar$1$line(t2.get$start(t2).get$line());
      t3 = t2.get$start(t2).get$column();
      t4 = line.length;
      startColumn = t1.startColumn = Math.min(H.checkNum(t3), t4);
      endColumn = t1.endColumn = Math.min(startColumn + t2.get$end(t2).get$offset() - t2.get$start(t2).get$offset(), t4);
      textBefore = J.substring$2$s(line, 0, startColumn);
      t2 = _this._multiline;
      if (t2 && _this._isOnlyWhitespace$1(textBefore)) {
        t1 = _this._highlighter$_buffer;
        t1._contents += " ";
        _this._colorize$1(new U.Highlighter__writeFirstLine_closure(_this, line));
        t1._contents += "\n";
        return;
      }
      t3 = _this._highlighter$_buffer;
      t3._contents += C.JSString_methods.$mul(" ", t2 ? 3 : 1);
      _this._writeText$1(textBefore);
      textInside = C.JSString_methods.substring$2(line, startColumn, endColumn);
      _this._colorize$1(new U.Highlighter__writeFirstLine_closure0(_this, textInside));
      _this._writeText$1(C.JSString_methods.substring$1(line, endColumn));
      t3._contents += "\n";
      tabsBefore = _this._countTabs$1(textBefore);
      tabsInside = _this._countTabs$1(textInside);
      startColumn += tabsBefore * 3;
      t1.startColumn = startColumn;
      t1.endColumn = endColumn + (tabsBefore + tabsInside) * 3;
      _this._writeSidebar$0();
      if (t2) {
        t3._contents += " ";
        _this._colorize$1(new U.Highlighter__writeFirstLine_closure1(t1, _this));
      } else {
        t3._contents += C.JSString_methods.$mul(" ", startColumn + 1);
        _this._colorize$1(new U.Highlighter__writeFirstLine_closure2(t1, _this));
      }
      t3._contents += "\n";
    },
    _writeIntermediateLines$1: function(lines) {
      var t2, t3, _this = this,
        t1 = _this._highlighter$_span,
        lineNumber = t1.get$start(t1).get$line() + 1;
      for (t1 = new H.ListIterator(lines, lines.get$length(lines)), t2 = _this._highlighter$_buffer; t1.moveNext$0();) {
        t3 = t1.__internal$_current;
        _this._writeSidebar$1$line(lineNumber);
        t2._contents += " ";
        _this._colorize$1(new U.Highlighter__writeIntermediateLines_closure(_this, t3));
        t2._contents += "\n";
        ++lineNumber;
      }
    },
    _writeLastLine$1: function(line) {
      var t3, endColumn, textInside, _this = this, t1 = {},
        t2 = _this._highlighter$_span;
      _this._writeSidebar$1$line(t2.get$end(t2).get$line());
      t2 = t2.get$end(t2).get$column();
      t3 = line.length;
      endColumn = t1.endColumn = Math.min(H.checkNum(t2), t3);
      if (_this._multiline && endColumn === t3) {
        t1 = _this._highlighter$_buffer;
        t1._contents += " ";
        _this._colorize$1(new U.Highlighter__writeLastLine_closure(_this, line));
        t1._contents += "\n";
        return;
      }
      t2 = _this._highlighter$_buffer;
      t2._contents += " ";
      textInside = J.substring$2$s(line, 0, endColumn);
      _this._colorize$1(new U.Highlighter__writeLastLine_closure0(_this, textInside));
      _this._writeText$1(C.JSString_methods.substring$1(line, endColumn));
      t2._contents += "\n";
      t1.endColumn = endColumn + _this._countTabs$1(textInside) * 3;
      _this._writeSidebar$0();
      t2._contents += " ";
      _this._colorize$1(new U.Highlighter__writeLastLine_closure1(t1, _this));
      t2._contents += "\n";
    },
    _writeTrailingLines$1: function(lines) {
      var t2, t3, t4, _this = this,
        t1 = _this._highlighter$_span,
        lineNumber = t1.get$end(t1).get$line() + 1;
      for (t1 = new H.ListIterator(lines, lines.get$length(lines)), t2 = _this._highlighter$_buffer, t3 = _this._multiline; t1.moveNext$0();) {
        t4 = t1.__internal$_current;
        _this._writeSidebar$1$line(lineNumber);
        t2._contents += C.JSString_methods.$mul(" ", t3 ? 3 : 1);
        _this._writeText$1(t4);
        t2._contents += "\n";
        ++lineNumber;
      }
    },
    _writeText$1: function(text) {
      var t1, t2, t3;
      for (text.toString, t1 = new H.CodeUnits(text), t1 = new H.ListIterator(t1, t1.get$length(t1)), t2 = this._highlighter$_buffer; t1.moveNext$0();) {
        t3 = t1.__internal$_current;
        if (t3 === 9)
          t2._contents += C.JSString_methods.$mul(" ", 4);
        else
          t2._contents += H.Primitives_stringFromCharCode(t3);
      }
    },
    _writeSidebar$2$end$line: function(end, line) {
      this._colorize$2$color(new U.Highlighter__writeSidebar_closure(this, line, end), "\x1b[34m");
    },
    _writeSidebar$1$end: function(end) {
      return this._writeSidebar$2$end$line(end, null);
    },
    _writeSidebar$1$line: function(line) {
      return this._writeSidebar$2$end$line(null, line);
    },
    _writeSidebar$0: function() {
      return this._writeSidebar$2$end$line(null, null);
    },
    _countTabs$1: function(text) {
      var t1, count;
      for (t1 = new H.CodeUnits(text), t1 = new H.ListIterator(t1, t1.get$length(t1)), count = 0; t1.moveNext$0();)
        if (t1.__internal$_current === 9)
          ++count;
      return count;
    },
    _isOnlyWhitespace$1: function(text) {
      var t1, t2;
      for (t1 = new H.CodeUnits(text), t1 = new H.ListIterator(t1, t1.get$length(t1)); t1.moveNext$0();) {
        t2 = t1.__internal$_current;
        if (t2 !== 32 && t2 !== 9)
          return false;
      }
      return true;
    },
    _colorize$2$color: function(callback, color) {
      var t1 = this._color,
        t2 = t1 != null;
      if (t2) {
        t1 = color == null ? t1 : color;
        this._highlighter$_buffer._contents += t1;
      }
      callback.call$0();
      if (t2)
        this._highlighter$_buffer._contents += "\x1b[0m";
    },
    _colorize$1: function(callback) {
      return this._colorize$2$color(callback, null);
    }
  };
  U.Highlighter__writeFirstLine_closure.prototype = {
    call$0: function() {
      var t1 = this.$this,
        t2 = t1._highlighter$_buffer,
        t3 = t2._contents += $._glyphs.glyphOrAscii$2("\u250c", "/");
      t2._contents = t3 + " ";
      t1._writeText$1(this.line);
    }
  };
  U.Highlighter__writeFirstLine_closure0.prototype = {
    call$0: function() {
      return this.$this._writeText$1(this.textInside);
    }
  };
  U.Highlighter__writeFirstLine_closure1.prototype = {
    call$0: function() {
      var t2,
        t1 = this.$this._highlighter$_buffer;
      t1._contents += $._glyphs.get$topLeftCorner();
      t2 = t1._contents += C.JSString_methods.$mul($._glyphs.get$horizontalLine(), this._box_0.startColumn + 1);
      t1._contents = t2 + "^";
    }
  };
  U.Highlighter__writeFirstLine_closure2.prototype = {
    call$0: function() {
      var t1 = this._box_0;
      this.$this._highlighter$_buffer._contents += C.JSString_methods.$mul("^", Math.max(t1.endColumn - t1.startColumn, 1));
      return;
    }
  };
  U.Highlighter__writeIntermediateLines_closure.prototype = {
    call$0: function() {
      var t1 = this.$this,
        t2 = t1._highlighter$_buffer,
        t3 = t2._contents += $._glyphs.get$verticalLine();
      t2._contents = t3 + " ";
      t1._writeText$1(this.line);
    }
  };
  U.Highlighter__writeLastLine_closure.prototype = {
    call$0: function() {
      var t1 = this.$this,
        t2 = t1._highlighter$_buffer,
        t3 = t2._contents += $._glyphs.glyphOrAscii$2("\u2514", "\\");
      t2._contents = t3 + " ";
      t1._writeText$1(this.line);
    }
  };
  U.Highlighter__writeLastLine_closure0.prototype = {
    call$0: function() {
      var t1 = this.$this,
        t2 = t1._highlighter$_buffer,
        t3 = t2._contents += $._glyphs.get$verticalLine();
      t2._contents = t3 + " ";
      t1._writeText$1(this.textInside);
    }
  };
  U.Highlighter__writeLastLine_closure1.prototype = {
    call$0: function() {
      var t2,
        t1 = this.$this._highlighter$_buffer;
      t1._contents += $._glyphs.get$bottomLeftCorner();
      t2 = t1._contents += C.JSString_methods.$mul($._glyphs.get$horizontalLine(), this._box_0.endColumn);
      t1._contents = t2 + "^";
    }
  };
  U.Highlighter__writeSidebar_closure.prototype = {
    call$0: function() {
      var t1 = this.line,
        t2 = this.$this,
        t3 = t2._highlighter$_buffer;
      t2 = t2._paddingBeforeSidebar;
      if (t1 != null)
        t3._contents += C.JSString_methods.padRight$1(C.JSInt_methods.toString$0(t1 + 1), t2);
      else
        t3._contents += C.JSString_methods.$mul(" ", t2);
      t1 = this.end;
      t3._contents += t1 == null ? $._glyphs.get$verticalLine() : t1;
    }
  };
  V.SourceLocation.prototype = {
    distance$1: function(other) {
      var t1 = this.sourceUrl;
      if (!J.$eq$(t1, other.get$sourceUrl()))
        throw H.wrapException(P.ArgumentError$('Source URLs "' + H.S(t1) + '" and "' + H.S(other.get$sourceUrl()) + "\" don't match."));
      return Math.abs(this.offset - other.get$offset());
    },
    compareTo$1: function(_, other) {
      var t1 = this.sourceUrl;
      if (!J.$eq$(t1, other.get$sourceUrl()))
        throw H.wrapException(P.ArgumentError$('Source URLs "' + H.S(t1) + '" and "' + H.S(other.get$sourceUrl()) + "\" don't match."));
      return this.offset - other.get$offset();
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return !!J.getInterceptor$(other).$isSourceLocation && J.$eq$(this.sourceUrl, other.get$sourceUrl()) && this.offset == other.get$offset();
    },
    get$hashCode: function(_) {
      return J.get$hashCode$(this.sourceUrl) + this.offset;
    },
    toString$0: function(_) {
      var _this = this,
        t1 = "<" + H.getRuntimeType(_this).toString$0(0) + ": " + H.S(_this.offset) + " ",
        source = _this.sourceUrl;
      return t1 + (H.S(source == null ? "unknown source" : source) + ":" + (_this.line + 1) + ":" + (_this.column + 1)) + ">";
    },
    $isComparable: 1,
    $asComparable: function() {
      return [V.SourceLocation];
    },
    get$sourceUrl: function() {
      return this.sourceUrl;
    },
    get$offset: function() {
      return this.offset;
    },
    get$line: function() {
      return this.line;
    },
    get$column: function() {
      return this.column;
    }
  };
  D.SourceLocationMixin.prototype = {
    distance$1: function(other) {
      if (!J.$eq$(this.file.url, other.get$sourceUrl()))
        throw H.wrapException(P.ArgumentError$('Source URLs "' + H.S(this.get$sourceUrl()) + '" and "' + H.S(other.get$sourceUrl()) + "\" don't match."));
      return Math.abs(this.offset - other.get$offset());
    },
    compareTo$1: function(_, other) {
      if (!J.$eq$(this.file.url, other.get$sourceUrl()))
        throw H.wrapException(P.ArgumentError$('Source URLs "' + H.S(this.get$sourceUrl()) + '" and "' + H.S(other.get$sourceUrl()) + "\" don't match."));
      return this.offset - other.get$offset();
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return !!J.getInterceptor$(other).$isSourceLocation && J.$eq$(this.file.url, other.get$sourceUrl()) && this.offset == other.get$offset();
    },
    get$hashCode: function(_) {
      return J.get$hashCode$(this.file.url) + this.offset;
    },
    toString$0: function(_) {
      var t1 = this.offset,
        t2 = "<" + H.getRuntimeType(this).toString$0(0) + ": " + H.S(t1) + " ",
        t3 = this.file,
        source = t3.url;
      return t2 + (H.S(source == null ? "unknown source" : source) + ":" + (t3.getLine$1(t1) + 1) + ":" + (t3.getColumn$1(t1) + 1)) + ">";
    },
    $isComparable: 1,
    $asComparable: function() {
      return [V.SourceLocation];
    },
    $isSourceLocation: 1
  };
  V.SourceSpan.prototype = {$isComparable: 1,
    $asComparable: function() {
      return [V.SourceSpan];
    }
  };
  V.SourceSpanBase.prototype = {
    SourceSpanBase$3: function(start, end, text) {
      var t3,
        t1 = this.end,
        t2 = this.start;
      if (!J.$eq$(t1.get$sourceUrl(), t2.get$sourceUrl()))
        throw H.wrapException(P.ArgumentError$('Source URLs "' + H.S(t2.get$sourceUrl()) + '" and  "' + H.S(t1.get$sourceUrl()) + "\" don't match."));
      else if (t1.get$offset() < t2.get$offset())
        throw H.wrapException(P.ArgumentError$("End " + t1.toString$0(0) + " must come after start " + t2.toString$0(0) + "."));
      else {
        t3 = this.text;
        if (t3.length !== t2.distance$1(t1))
          throw H.wrapException(P.ArgumentError$('Text "' + t3 + '" must be ' + t2.distance$1(t1) + " characters long."));
      }
    },
    get$start: function(receiver) {
      return this.start;
    },
    get$end: function(receiver) {
      return this.end;
    },
    get$text: function() {
      return this.text;
    }
  };
  G.SourceSpanException.prototype = {
    get$message: function(_) {
      return this._span_exception$_message;
    },
    get$span: function() {
      return this._span;
    },
    toString$1$color: function(_, color) {
      var _this = this;
      if (_this.get$span() == null)
        return _this._span_exception$_message;
      return "Error on " + _this.get$span().message$2$color(0, _this._span_exception$_message, color);
    },
    toString$0: function($receiver) {
      return this.toString$1$color($receiver, null);
    },
    $isException: 1
  };
  G.SourceSpanFormatException.prototype = {
    get$source: function() {
      return this._span_exception$_source;
    },
    $isFormatException: 1
  };
  Y.SourceSpanMixin.prototype = {
    get$sourceUrl: function() {
      return this.get$start(this).get$sourceUrl();
    },
    get$length: function(_) {
      var _this = this;
      return _this.get$end(_this).get$offset() - _this.get$start(_this).get$offset();
    },
    compareTo$1: function(_, other) {
      var _this = this,
        result = _this.get$start(_this).compareTo$1(0, other.get$start(other));
      return result === 0 ? _this.get$end(_this).compareTo$1(0, other.get$end(other)) : result;
    },
    message$2$color: function(_, message, color) {
      var t2, highlight, _this = this,
        t1 = "line " + (_this.get$start(_this).get$line() + 1) + ", column " + (_this.get$start(_this).get$column() + 1);
      if (_this.get$sourceUrl() != null) {
        t2 = _this.get$sourceUrl();
        t2 = t1 + (" of " + H.S($.$get$context().prettyUri$1(t2)));
        t1 = t2;
      }
      t1 += ": " + H.S(message);
      highlight = _this.highlight$1$color(color);
      if (highlight.length !== 0)
        t1 = t1 + "\n" + highlight;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    message$1: function($receiver, message) {
      return this.message$2$color($receiver, message, null);
    },
    highlight$1$color: function(color) {
      var t2, t3, t4, newSpan, _this = this,
        t1 = !!_this.$isSourceSpanWithContext;
      if (!t1 && _this.get$length(_this) === 0)
        return "";
      if (J.$eq$(color, true))
        color = "\x1b[31m";
      if (J.$eq$(color, false))
        color = null;
      if (t1 && B.findLineStart(_this.get$context(_this), _this.get$text(), _this.get$start(_this).get$column()) != null)
        t1 = _this;
      else {
        t1 = V.SourceLocation$(_this.get$start(_this).get$offset(), 0, 0, _this.get$sourceUrl());
        t2 = _this.get$end(_this).get$offset();
        t3 = _this.get$sourceUrl();
        t4 = B.countCodeUnits(_this.get$text(), 10);
        t3 = X.SourceSpanWithContext$(t1, V.SourceLocation$(t2, U.Highlighter__lastLineLength(_this.get$text()), t4, t3), _this.get$text(), _this.get$text());
        t1 = t3;
      }
      newSpan = U.Highlighter__normalizeEndOfLine(U.Highlighter__normalizeTrailingNewline(U.Highlighter__normalizeNewlines(t1)));
      return new U.Highlighter(newSpan, color, newSpan.get$start(newSpan).get$line() != newSpan.get$end(newSpan).get$line(), J.toString$0$(newSpan.get$end(newSpan).get$line()).length + 1, new P.StringBuffer("")).highlight$0();
    },
    $eq: function(_, other) {
      var _this = this;
      if (other == null)
        return false;
      return !!J.getInterceptor$(other).$isSourceSpan && _this.get$start(_this).$eq(0, other.get$start(other)) && _this.get$end(_this).$eq(0, other.get$end(other));
    },
    get$hashCode: function(_) {
      var t2, _this = this,
        t1 = _this.get$start(_this);
      t1 = t1.get$hashCode(t1);
      t2 = _this.get$end(_this);
      return t1 + 31 * t2.get$hashCode(t2);
    },
    toString$0: function(_) {
      var _this = this;
      return "<" + H.getRuntimeType(_this).toString$0(0) + ": from " + _this.get$start(_this).toString$0(0) + " to " + _this.get$end(_this).toString$0(0) + ' "' + _this.get$text() + '">';
    },
    $isComparable: 1,
    $asComparable: function() {
      return [V.SourceSpan];
    },
    $isSourceSpan: 1
  };
  X.SourceSpanWithContext.prototype = {
    get$context: function(_) {
      return this._context;
    }
  };
  U.Chain.prototype = {
    toTrace$0: function() {
      var t1 = this.traces,
        t2 = A.Frame;
      return new Y.Trace(P.List_List$unmodifiable(new H.ExpandIterable(t1, new U.Chain_toTrace_closure(), [H.getTypeArgumentByIndex(t1, 0), t2]), t2), new P._StringStackTrace(null));
    },
    toString$0: function(_) {
      var t1 = this.traces,
        t2 = P.int,
        t3 = H.getTypeArgumentByIndex(t1, 0);
      return new H.MappedListIterable(t1, new U.Chain_toString_closure(new H.MappedListIterable(t1, new U.Chain_toString_closure0(), [t3, t2]).fold$2(0, 0, H.instantiate1(P.math__max$closure(), t2))), [t3, P.String]).join$1(0, "===== asynchronous gap ===========================\n");
    },
    $isStackTrace: 1
  };
  U.Chain_Chain$parse_closure.prototype = {
    call$1: function(trace) {
      return new Y.Trace(P.List_List$unmodifiable(Y.Trace__parseVM(trace), A.Frame), new P._StringStackTrace(trace));
    }
  };
  U.Chain_Chain$parse_closure0.prototype = {
    call$1: function(trace) {
      return Y.Trace$parseFriendly(trace);
    }
  };
  U.Chain_toTrace_closure.prototype = {
    call$1: function(trace) {
      return trace.get$frames();
    }
  };
  U.Chain_toString_closure0.prototype = {
    call$1: function(trace) {
      var t1 = trace.get$frames(),
        t2 = P.int;
      return new H.MappedListIterable(t1, new U.Chain_toString__closure0(), [H.getTypeArgumentByIndex(t1, 0), t2]).fold$2(0, 0, H.instantiate1(P.math__max$closure(), t2));
    }
  };
  U.Chain_toString__closure0.prototype = {
    call$1: function(frame) {
      return frame.get$location().length;
    }
  };
  U.Chain_toString_closure.prototype = {
    call$1: function(trace) {
      var t1 = trace.get$frames();
      return new H.MappedListIterable(t1, new U.Chain_toString__closure(this.longest), [H.getTypeArgumentByIndex(t1, 0), P.String]).join$0(0);
    }
  };
  U.Chain_toString__closure.prototype = {
    call$1: function(frame) {
      return J.padRight$1$s(frame.get$location(), this.longest) + "  " + H.S(frame.get$member()) + "\n";
    }
  };
  A.Frame.prototype = {
    get$isCore: function() {
      return this.uri.get$scheme() === "dart";
    },
    get$library: function() {
      var t1 = this.uri;
      if (t1.get$scheme() === "data")
        return "data:...";
      return $.$get$context().prettyUri$1(t1);
    },
    get$$package: function() {
      var t1 = this.uri;
      if (t1.get$scheme() !== "package")
        return;
      return C.JSArray_methods.get$first(t1.get$path(t1).split("/"));
    },
    get$location: function() {
      var t2, _this = this,
        t1 = _this.line;
      if (t1 == null)
        return _this.get$library();
      t2 = _this.column;
      if (t2 == null)
        return H.S(_this.get$library()) + " " + H.S(t1);
      return H.S(_this.get$library()) + " " + H.S(t1) + ":" + H.S(t2);
    },
    toString$0: function(_) {
      return H.S(this.get$location()) + " in " + H.S(this.member);
    },
    get$uri: function() {
      return this.uri;
    },
    get$line: function() {
      return this.line;
    },
    get$column: function() {
      return this.column;
    },
    get$member: function() {
      return this.member;
    }
  };
  A.Frame_Frame$parseVM_closure.prototype = {
    call$0: function() {
      var match, t2, t3, member, uri, lineAndColumn, line, _null = null,
        t1 = this.frame;
      if (t1 === "...")
        return new A.Frame(P._Uri__Uri(_null, _null, _null, _null), _null, _null, "...");
      match = $.$get$_vmFrame().firstMatch$1(t1);
      if (match == null)
        return new N.UnparsedFrame(P._Uri__Uri(_null, "unparsed", _null, _null), t1);
      t1 = match._match;
      t2 = t1[1];
      t3 = $.$get$_asyncBody();
      t2.toString;
      t2 = H.stringReplaceAllUnchecked(t2, t3, "<async>");
      member = H.stringReplaceAllUnchecked(t2, "<anonymous closure>", "<fn>");
      uri = P.Uri_parse(t1[2]);
      lineAndColumn = t1[3].split(":");
      t1 = lineAndColumn.length;
      line = t1 > 1 ? P.int_parse(lineAndColumn[1], _null, _null) : _null;
      return new A.Frame(uri, line, t1 > 2 ? P.int_parse(lineAndColumn[2], _null, _null) : _null, member);
    }
  };
  A.Frame_Frame$parseV8_closure.prototype = {
    call$0: function() {
      var t2, t3, _s4_ = "<fn>",
        t1 = this.frame,
        match = $.$get$_v8Frame().firstMatch$1(t1);
      if (match == null)
        return new N.UnparsedFrame(P._Uri__Uri(null, "unparsed", null, null), t1);
      t1 = new A.Frame_Frame$parseV8_closure_parseLocation(t1);
      t2 = match._match;
      t3 = t2[2];
      if (t3 != null) {
        t2 = t2[1];
        t2.toString;
        t2 = H.stringReplaceAllUnchecked(t2, "<anonymous>", _s4_);
        t2 = H.stringReplaceAllUnchecked(t2, "Anonymous function", _s4_);
        return t1.call$2(t3, H.stringReplaceAllUnchecked(t2, "(anonymous function)", _s4_));
      } else
        return t1.call$2(t2[3], _s4_);
    }
  };
  A.Frame_Frame$parseV8_closure_parseLocation.prototype = {
    call$2: function($location, member) {
      var urlMatch, _null = null,
        t1 = $.$get$_v8EvalLocation(),
        evalMatch = t1.firstMatch$1($location);
      for (; evalMatch != null;) {
        $location = evalMatch._match[1];
        evalMatch = t1.firstMatch$1($location);
      }
      if ($location === "native")
        return new A.Frame(P.Uri_parse("native"), _null, _null, member);
      urlMatch = $.$get$_v8UrlLocation().firstMatch$1($location);
      if (urlMatch == null)
        return new N.UnparsedFrame(P._Uri__Uri(_null, "unparsed", _null, _null), this.frame);
      t1 = urlMatch._match;
      return new A.Frame(A.Frame__uriOrPathToUri(t1[1]), P.int_parse(t1[2], _null, _null), P.int_parse(t1[3], _null, _null), member);
    },
    $signature: 56
  };
  A.Frame_Frame$parseFirefox_closure.prototype = {
    call$0: function() {
      var uri, t2, t3, member, line, _null = null,
        t1 = this.frame,
        match = $.$get$_firefoxSafariFrame().firstMatch$1(t1);
      if (match == null)
        return new N.UnparsedFrame(P._Uri__Uri(_null, "unparsed", _null, _null), t1);
      t1 = match._match;
      uri = A.Frame__uriOrPathToUri(t1[3]);
      t2 = t1[1];
      if (t2 != null) {
        t3 = C.JSString_methods.allMatches$1("/", t1[2]);
        member = J.$add$ansx(t2, C.JSArray_methods.join$0(P.List_List$filled(t3.get$length(t3), ".<fn>", P.String)));
        if (member === "")
          member = "<fn>";
        member = C.JSString_methods.replaceFirst$2(member, $.$get$_initialDot(), "");
      } else
        member = "<fn>";
      t2 = t1[4];
      line = t2 === "" ? _null : P.int_parse(t2, _null, _null);
      t1 = t1[5];
      return new A.Frame(uri, line, t1 == null || t1 === "" ? _null : P.int_parse(t1, _null, _null), member);
    }
  };
  A.Frame_Frame$parseFriendly_closure.prototype = {
    call$0: function() {
      var t2, uri, line, column, _null = null,
        t1 = this.frame,
        match = $.$get$_friendlyFrame().firstMatch$1(t1);
      if (match == null)
        throw H.wrapException(P.FormatException$("Couldn't parse package:stack_trace stack trace line '" + H.S(t1) + "'.", _null, _null));
      t1 = match._match;
      t2 = t1[1];
      uri = t2 === "data:..." ? P.Uri_Uri$dataFromString("", _null, _null) : P.Uri_parse(t2);
      if (uri.get$scheme() === "") {
        t2 = $.$get$context();
        uri = t2.toUri$1(D.absolute(t2.style.pathFromUri$1(M._parseUri(uri))));
      }
      t2 = t1[2];
      line = t2 == null ? _null : P.int_parse(t2, _null, _null);
      t2 = t1[3];
      column = t2 == null ? _null : P.int_parse(t2, _null, _null);
      return new A.Frame(uri, line, column, t1[4]);
    }
  };
  T.LazyTrace.prototype = {
    get$_lazy_trace$_trace: function() {
      var t1 = this._lazy_trace$_inner;
      return t1 == null ? this._lazy_trace$_inner = this._thunk.call$0() : t1;
    },
    get$frames: function() {
      return this.get$_lazy_trace$_trace().get$frames();
    },
    get$terse: function() {
      return new T.LazyTrace(new T.LazyTrace_terse_closure(this));
    },
    toString$0: function(_) {
      return J.toString$0$(this.get$_lazy_trace$_trace());
    },
    $isStackTrace: 1,
    $isTrace: 1
  };
  T.LazyTrace_terse_closure.prototype = {
    call$0: function() {
      return this.$this.get$_lazy_trace$_trace().get$terse();
    }
  };
  Y.Trace.prototype = {
    get$terse: function() {
      return this.foldFrames$2$terse(new Y.Trace_terse_closure(), true);
    },
    foldFrames$2$terse: function(predicate, terse) {
      var t1, newFrames, t2, t3, _box_0 = {};
      _box_0.predicate = predicate;
      _box_0.predicate = new Y.Trace_foldFrames_closure(predicate);
      t1 = A.Frame;
      newFrames = H.setRuntimeTypeInfo([], [t1]);
      for (t2 = this.frames, t2 = new H.ReversedListIterable(t2, [H.getTypeArgumentByIndex(t2, 0)]), t2 = new H.ListIterator(t2, t2.get$length(t2)); t2.moveNext$0();) {
        t3 = t2.__internal$_current;
        if (t3 instanceof N.UnparsedFrame || !_box_0.predicate.call$1(t3))
          newFrames.push(t3);
        else if (newFrames.length === 0 || !_box_0.predicate.call$1(C.JSArray_methods.get$last(newFrames)))
          newFrames.push(new A.Frame(t3.get$uri(), t3.get$line(), t3.get$column(), t3.get$member()));
      }
      newFrames = new H.MappedListIterable(newFrames, new Y.Trace_foldFrames_closure0(_box_0), [H.getTypeArgumentByIndex(newFrames, 0), t1]).toList$0(0);
      if (newFrames.length > 1 && _box_0.predicate.call$1(C.JSArray_methods.get$first(newFrames)))
        C.JSArray_methods.removeAt$1(newFrames, 0);
      return new Y.Trace(P.List_List$unmodifiable(new H.ReversedListIterable(newFrames, [H.getTypeArgumentByIndex(newFrames, 0)]), t1), new P._StringStackTrace(this.original._core$_stackTrace));
    },
    toString$0: function(_) {
      var t1 = this.frames,
        t2 = P.int,
        t3 = H.getTypeArgumentByIndex(t1, 0);
      return new H.MappedListIterable(t1, new Y.Trace_toString_closure(new H.MappedListIterable(t1, new Y.Trace_toString_closure0(), [t3, t2]).fold$2(0, 0, H.instantiate1(P.math__max$closure(), t2))), [t3, P.String]).join$0(0);
    },
    $isStackTrace: 1,
    get$frames: function() {
      return this.frames;
    }
  };
  Y.Trace_Trace$from_closure.prototype = {
    call$0: function() {
      return Y.Trace_Trace$parse(this.trace.toString$0(0));
    }
  };
  Y.Trace__parseVM_closure.prototype = {
    call$1: function(line) {
      return A.Frame_Frame$parseVM(line);
    }
  };
  Y.Trace$parseV8_closure.prototype = {
    call$1: function(line) {
      return !J.startsWith$1$s(line, $.$get$_v8TraceLine());
    }
  };
  Y.Trace$parseV8_closure0.prototype = {
    call$1: function(line) {
      return A.Frame_Frame$parseV8(line);
    }
  };
  Y.Trace$parseJSCore_closure.prototype = {
    call$1: function(line) {
      return line !== "\tat ";
    }
  };
  Y.Trace$parseJSCore_closure0.prototype = {
    call$1: function(line) {
      return A.Frame_Frame$parseV8(line);
    }
  };
  Y.Trace$parseFirefox_closure.prototype = {
    call$1: function(line) {
      return line.length !== 0 && line !== "[native code]";
    }
  };
  Y.Trace$parseFirefox_closure0.prototype = {
    call$1: function(line) {
      return A.Frame_Frame$parseFirefox(line);
    }
  };
  Y.Trace$parseFriendly_closure.prototype = {
    call$1: function(line) {
      return !J.startsWith$1$s(line, "=====");
    }
  };
  Y.Trace$parseFriendly_closure0.prototype = {
    call$1: function(line) {
      return A.Frame_Frame$parseFriendly(line);
    }
  };
  Y.Trace_terse_closure.prototype = {
    call$1: function(_) {
      return false;
    }
  };
  Y.Trace_foldFrames_closure.prototype = {
    call$1: function(frame) {
      if (this.oldPredicate.call$1(frame))
        return true;
      if (frame.get$isCore())
        return true;
      if (frame.get$$package() === "stack_trace")
        return true;
      if (!J.contains$1$asx(frame.get$member(), "<async>"))
        return false;
      return frame.get$line() == null;
    }
  };
  Y.Trace_foldFrames_closure0.prototype = {
    call$1: function(frame) {
      var t1, t2;
      if (frame instanceof N.UnparsedFrame || !this._box_0.predicate.call$1(frame))
        return frame;
      t1 = frame.get$library();
      t2 = $.$get$_terseRegExp();
      t1.toString;
      return new A.Frame(P.Uri_parse(H.stringReplaceAllUnchecked(t1, t2, "")), null, null, frame.get$member());
    }
  };
  Y.Trace_toString_closure0.prototype = {
    call$1: function(frame) {
      return frame.get$location().length;
    }
  };
  Y.Trace_toString_closure.prototype = {
    call$1: function(frame) {
      if (frame instanceof N.UnparsedFrame)
        return frame.toString$0(0) + "\n";
      return J.padRight$1$s(frame.get$location(), this.longest) + "  " + H.S(frame.get$member()) + "\n";
    }
  };
  N.UnparsedFrame.prototype = {
    toString$0: function(_) {
      return this.member;
    },
    $isFrame: 1,
    get$uri: function() {
      return this.uri;
    },
    get$line: function() {
      return null;
    },
    get$column: function() {
      return null;
    },
    get$isCore: function() {
      return false;
    },
    get$library: function() {
      return "unparsed";
    },
    get$$package: function() {
      return null;
    },
    get$location: function() {
      return "unparsed";
    },
    get$member: function() {
      return this.member;
    }
  };
  T._debounceAggregate_closure.prototype = {
    call$2: function(value, sink) {
      var t1 = this._box_0,
        t2 = t1.timer;
      if (t2 != null)
        t2.cancel$0();
      t1.timer = P.Timer_Timer(this.duration, new T._debounceAggregate__closure(t1, sink));
      t1.soFar = this.collect.call$2(value, t1.soFar);
    },
    "call*": "call$2",
    $requiredArgCount: 2
  };
  T._debounceAggregate__closure.prototype = {
    call$0: function() {
      var t1 = this.sink,
        t2 = this._box_0;
      t1.add$1(0, t2.soFar);
      if (t2.shouldClose)
        t1.close$0(0);
      t2.timer = t2.soFar = null;
    },
    "call*": "call$0",
    $requiredArgCount: 0
  };
  T._debounceAggregate_closure0.prototype = {
    call$1: function(sink) {
      var t1 = this._box_0;
      if (t1.soFar != null)
        t1.shouldClose = true;
      else
        sink.close$0(0);
    }
  };
  L._StreamTransformer.prototype = {
    bind$1: function(values) {
      var controller, _null = null, t1 = {},
        t2 = H.getTypeArgumentByIndex(this, 1);
      if (values.get$isBroadcast())
        controller = new P._SyncBroadcastStreamController(_null, _null, [t2]);
      else
        controller = P.StreamController_StreamController(_null, _null, _null, _null, true, t2);
      t1.subscription = null;
      controller.set$onListen(new L._StreamTransformer_bind_closure(t1, this, values, controller));
      return controller.get$stream();
    }
  };
  L._StreamTransformer_bind_closure.prototype = {
    call$0: function() {
      var t2, t3, t4, t5, _this = this, t1 = {};
      t1.valuesDone = false;
      t2 = _this.values;
      t3 = _this.$this;
      t4 = _this.controller;
      t5 = _this._box_1;
      t5.subscription = t2.listen$3$onDone$onError(new L._StreamTransformer_bind__closure(t3, t4), new L._StreamTransformer_bind__closure0(t1, t3, t4), new L._StreamTransformer_bind__closure1(t3, t4));
      if (!t2.get$isBroadcast()) {
        t2 = t5.subscription;
        t4.set$onPause(t2.get$pause(t2));
        t4.set$onResume(t5.subscription.get$resume());
      }
      t4.set$onCancel(new L._StreamTransformer_bind__closure2(t5, t1));
    }
  };
  L._StreamTransformer_bind__closure.prototype = {
    call$1: function(value) {
      return this.$this._from_handlers$_handleData.call$2(value, this.controller);
    },
    $signature: function() {
      return {func: 1, ret: -1, args: [H.getTypeArgumentByIndex(this.$this, 0)]};
    }
  };
  L._StreamTransformer_bind__closure1.prototype = {
    call$2: function(error, stackTrace) {
      this.$this._from_handlers$_handleError.call$3(error, stackTrace, this.controller);
    },
    "call*": "call$2",
    $requiredArgCount: 2,
    $signature: 18
  };
  L._StreamTransformer_bind__closure0.prototype = {
    call$0: function() {
      this._box_0.valuesDone = true;
      this.$this._from_handlers$_handleDone.call$1(this.controller);
    },
    "call*": "call$0",
    $requiredArgCount: 0
  };
  L._StreamTransformer_bind__closure2.prototype = {
    call$0: function() {
      var t1 = this._box_1,
        toCancel = t1.subscription;
      t1.subscription = null;
      if (!this._box_0.valuesDone)
        return toCancel.cancel$0();
      return;
    },
    "call*": "call$0",
    $requiredArgCount: 0
  };
  E.StringScannerException.prototype = {
    get$source: function() {
      return G.SourceSpanFormatException.prototype.get$source.call(this);
    }
  };
  Z.LineScanner.prototype = {
    get$_betweenCRLF: function() {
      return this.peekChar$1(-1) === 13 && this.peekChar$0() === 10;
    },
    scanChar$1: function(character) {
      if (!this.super$StringScanner$scanChar(character))
        return false;
      this._adjustLineAndColumn$1(character);
      return true;
    },
    _adjustLineAndColumn$1: function(character) {
      var t1, _this = this;
      if (character !== 10)
        t1 = character === 13 && _this.peekChar$0() !== 10;
      else
        t1 = true;
      if (t1) {
        ++_this._line_scanner$_line;
        _this._line_scanner$_column = 0;
      } else
        ++_this._line_scanner$_column;
    },
    scan$1: function(pattern) {
      var newlines, t1, t2, _this = this;
      if (!_this.super$StringScanner$scan(pattern))
        return false;
      newlines = _this._newlinesIn$1(_this.get$lastMatch().group$1(0));
      t1 = _this._line_scanner$_line;
      t2 = newlines.length;
      _this._line_scanner$_line = t1 + t2;
      if (t2 === 0)
        _this._line_scanner$_column = _this._line_scanner$_column + _this.get$lastMatch().group$1(0).length;
      else
        _this._line_scanner$_column = _this.get$lastMatch().group$1(0).length - J.get$end$x(C.JSArray_methods.get$last(newlines));
      return true;
    },
    _newlinesIn$1: function(text) {
      var t1 = $.$get$_newlineRegExp().allMatches$1(0, text),
        newlines = P.List_List$from(t1, true, H.getRuntimeTypeArgument(t1, "Iterable", 0));
      if (this.get$_betweenCRLF())
        C.JSArray_methods.removeLast$0(newlines);
      return newlines;
    }
  };
  S.SpanScanner.prototype = {
    set$state: function(state) {
      if (!(state instanceof S._SpanScannerState) || state._scanner !== this)
        throw H.wrapException(P.ArgumentError$("The given LineScannerState was not returned by this LineScanner."));
      this.set$position(state.position);
    },
    spanFrom$2: function(startState, endState) {
      var endPosition = endState == null ? this._string_scanner$_position : endState.position;
      return this._sourceFile.span$2(startState.position, endPosition);
    },
    spanFrom$1: function(startState) {
      return this.spanFrom$2(startState, null);
    },
    matches$1: function(pattern) {
      var t1, t2, _this = this;
      if (!_this.super$StringScanner$matches(pattern))
        return false;
      t1 = _this._string_scanner$_position;
      t2 = _this.get$lastMatch();
      _this._sourceFile.span$2(t1, t2.start + t2.pattern.length);
      return true;
    },
    error$3$length$position: function(message, $length, position) {
      var t2, match, _this = this,
        t1 = _this.string;
      B.validateErrorArgs(t1, null, position, $length);
      t2 = position == null && $length == null;
      match = t2 ? _this.get$lastMatch() : null;
      if (position == null)
        position = match == null ? _this._string_scanner$_position : match.start;
      if ($length == null)
        if (match == null)
          $length = 0;
        else {
          t2 = match.start;
          $length = t2 + match.pattern.length - t2;
        }
      throw H.wrapException(E.StringScannerException$(message, _this._sourceFile.span$2(position, position + $length), t1));
    },
    error$1: function(message) {
      return this.error$3$length$position(message, null, null);
    },
    error$2$position: function(message, position) {
      return this.error$3$length$position(message, null, position);
    },
    error$2$length: function(message, $length) {
      return this.error$3$length$position(message, $length, null);
    }
  };
  S._SpanScannerState.prototype = {};
  X.StringScanner.prototype = {
    set$position: function(position) {
      if (position < 0 || position > this.string.length)
        throw H.wrapException(P.ArgumentError$("Invalid position " + position));
      this._string_scanner$_position = position;
      this._lastMatch = null;
    },
    get$lastMatch: function() {
      var _this = this;
      if (_this._string_scanner$_position !== _this._lastMatchPosition)
        _this._lastMatch = null;
      return _this._lastMatch;
    },
    readChar$0: function() {
      var _this = this,
        t1 = _this._string_scanner$_position,
        t2 = _this.string;
      if (t1 === t2.length)
        _this.error$3$length$position("expected more input.", 0, t1);
      return J.codeUnitAt$1$s(t2, _this._string_scanner$_position++);
    },
    peekChar$1: function(offset) {
      var index;
      if (offset == null)
        offset = 0;
      index = this._string_scanner$_position + offset;
      if (index < 0 || index >= this.string.length)
        return;
      return J.codeUnitAt$1$s(this.string, index);
    },
    peekChar$0: function() {
      return this.peekChar$1(null);
    },
    scanChar$1: function(character) {
      var t1 = this._string_scanner$_position,
        t2 = this.string;
      if (t1 === t2.length)
        return false;
      if (J.codeUnitAt$1$s(t2, t1) !== character)
        return false;
      this._string_scanner$_position = t1 + 1;
      return true;
    },
    expectChar$2$name: function(character, $name) {
      if (this.scanChar$1(character))
        return;
      if ($name == null)
        if (character === 92)
          $name = '"\\"';
        else
          $name = character === 34 ? '"\\""' : '"' + H.Primitives_stringFromCharCode(character) + '"';
      this.error$3$length$position("expected " + $name + ".", 0, this._string_scanner$_position);
    },
    expectChar$1: function(character) {
      return this.expectChar$2$name(character, null);
    },
    scan$1: function(pattern) {
      var t1, _this = this,
        success = _this.matches$1(pattern);
      if (success) {
        t1 = _this._lastMatch;
        _this._lastMatchPosition = _this._string_scanner$_position = t1.start + t1.pattern.length;
      }
      return success;
    },
    expect$1: function(pattern) {
      var t1, $name;
      if (this.scan$1(pattern))
        return;
      t1 = H.stringReplaceAllUnchecked(pattern, "\\", "\\\\");
      $name = '"' + H.stringReplaceAllUnchecked(t1, '"', '\\"') + '"';
      this.error$3$length$position("expected " + $name + ".", 0, this._string_scanner$_position);
    },
    expectDone$0: function() {
      var t1 = this._string_scanner$_position;
      if (t1 === this.string.length)
        return;
      this.error$3$length$position("expected no more input.", 0, t1);
    },
    matches$1: function(pattern) {
      var _this = this,
        t1 = C.JSString_methods.matchAsPrefix$2(pattern, _this.string, _this._string_scanner$_position);
      _this._lastMatch = t1;
      _this._lastMatchPosition = _this._string_scanner$_position;
      return t1 != null;
    },
    substring$1: function(_, start) {
      var end = this._string_scanner$_position;
      return J.substring$2$s(this.string, start, end);
    },
    error$3$length$position: function(message, $length, position) {
      var t2, t3, t4, sourceFile,
        t1 = this.string;
      B.validateErrorArgs(t1, null, position, $length);
      t2 = this.sourceUrl;
      t1.toString;
      t3 = new H.CodeUnits(t1);
      t4 = H.setRuntimeTypeInfo([0], [P.int]);
      sourceFile = new Y.SourceFile(t2, t4, new Uint32Array(H._ensureNativeList(t3.toList$0(t3))));
      sourceFile.SourceFile$decoded$2$url(t3, t2);
      throw H.wrapException(E.StringScannerException$(message, sourceFile.span$2(position, position + $length), t1));
    }
  };
  A.AsciiGlyphSet.prototype = {
    glyphOrAscii$2: function(glyph, alternative) {
      return alternative;
    },
    get$horizontalLine: function() {
      return "-";
    },
    get$verticalLine: function() {
      return "|";
    },
    get$topLeftCorner: function() {
      return ",";
    },
    get$bottomLeftCorner: function() {
      return "'";
    },
    get$upEnd: function() {
      return "'";
    },
    get$downEnd: function() {
      return ",";
    }
  };
  K.UnicodeGlyphSet.prototype = {
    glyphOrAscii$2: function(glyph, alternative) {
      return glyph;
    },
    get$horizontalLine: function() {
      return "\u2500";
    },
    get$verticalLine: function() {
      return "\u2502";
    },
    get$topLeftCorner: function() {
      return "\u250c";
    },
    get$bottomLeftCorner: function() {
      return "\u2514";
    },
    get$upEnd: function() {
      return "\u2575";
    },
    get$downEnd: function() {
      return "\u2577";
    }
  };
  S.Tuple2.prototype = {
    toString$0: function(_) {
      return "[" + H.S(this.item1) + ", " + H.S(this.item2) + "]";
    },
    $eq: function(_, o) {
      if (o == null)
        return false;
      return o instanceof S.Tuple2 && J.$eq$(o.item1, this.item1) && J.$eq$(o.item2, this.item2);
    },
    get$hashCode: function(_) {
      var t1 = J.get$hashCode$(this.item1),
        t2 = J.get$hashCode$(this.item2);
      return X._finish(X._combine(X._combine(0, C.JSInt_methods.get$hashCode(t1)), C.JSInt_methods.get$hashCode(t2)));
    }
  };
  S.Tuple3.prototype = {
    toString$0: function(_) {
      return "[" + H.S(this.item1) + ", " + this.item2.toString$0(0) + ", " + H.S(this.item3) + "]";
    },
    $eq: function(_, o) {
      if (o == null)
        return false;
      return o instanceof S.Tuple3 && o.item1 == this.item1 && o.item2.$eq(0, this.item2) && J.$eq$(o.item3, this.item3);
    },
    get$hashCode: function(_) {
      var t3,
        t1 = J.get$hashCode$(this.item1),
        t2 = this.item2;
      t2 = t2.get$hashCode(t2);
      t3 = J.get$hashCode$(this.item3);
      return X._finish(X._combine(X._combine(X._combine(0, C.JSInt_methods.get$hashCode(t1)), C.JSInt_methods.get$hashCode(t2)), C.JSInt_methods.get$hashCode(t3)));
    }
  };
  E.WatchEvent.prototype = {
    toString$0: function(_) {
      return H.S(this.type) + " " + H.S(this.path);
    },
    get$path: function(receiver) {
      return this.path;
    }
  };
  E.ChangeType.prototype = {
    toString$0: function(_) {
      return this._watch_event$_name;
    }
  };
  (function aliases() {
    var _ = J.Interceptor.prototype;
    _.super$Interceptor$noSuchMethod = _.noSuchMethod$1;
    _ = J.JavaScriptObject.prototype;
    _.super$JavaScriptObject$toString = _.toString$0;
    _ = H.JsLinkedHashMap.prototype;
    _.super$JsLinkedHashMap$internalContainsKey = _.internalContainsKey$1;
    _.super$JsLinkedHashMap$internalGet = _.internalGet$1;
    _.super$JsLinkedHashMap$internalSet = _.internalSet$2;
    _.super$JsLinkedHashMap$internalRemove = _.internalRemove$1;
    _ = P._BroadcastStreamController.prototype;
    _.super$_BroadcastStreamController$_addEventError = _._addEventError$0;
    _ = P._BufferingStreamSubscription.prototype;
    _.super$_BufferingStreamSubscription$_add = _._async$_add$1;
    _.super$_BufferingStreamSubscription$_addError = _._addError$2;
    _ = P.ListMixin.prototype;
    _.super$ListMixin$setRange = _.setRange$4;
    _ = P.Iterable.prototype;
    _.super$Iterable$where = _.where$1;
    _.super$Iterable$skipWhile = _.skipWhile$1;
    _ = B.ModifiableCssParentNode.prototype;
    _.super$ModifiableCssParentNode$addChild = _.addChild$1;
    _ = M.SimpleSelector.prototype;
    _.super$SimpleSelector$addSuffix = _.addSuffix$1;
    _.super$SimpleSelector$unify = _.unify$1;
    _ = G.Parser.prototype;
    _.super$Parser$silentComment = _.silentComment$0;
    _ = V.StylesheetParser.prototype;
    _.super$StylesheetParser$importArgument = _.importArgument$0;
    _ = F.Value.prototype;
    _.super$Value$assertMap = _.assertMap$1;
    _.super$Value$plus = _.plus$1;
    _.super$Value$minus = _.minus$1;
    _.super$Value$dividedBy = _.dividedBy$1;
    _ = Y.SourceSpanMixin.prototype;
    _.super$SourceSpanMixin$compareTo = _.compareTo$1;
    _.super$SourceSpanMixin$$eq = _.$eq;
    _ = X.StringScanner.prototype;
    _.super$StringScanner$readChar = _.readChar$0;
    _.super$StringScanner$scanChar = _.scanChar$1;
    _.super$StringScanner$scan = _.scan$1;
    _.super$StringScanner$matches = _.matches$1;
  })();
  (function installTearOffs() {
    var _static_2 = hunkHelpers._static_2,
      _instance_1_i = hunkHelpers._instance_1i,
      _instance_1_u = hunkHelpers._instance_1u,
      _static_1 = hunkHelpers._static_1,
      _static_0 = hunkHelpers._static_0,
      _static = hunkHelpers.installStaticTearOff,
      _instance_0_u = hunkHelpers._instance_0u,
      _instance = hunkHelpers.installInstanceTearOff,
      _instance_0_i = hunkHelpers._instance_0i,
      _instance_2_u = hunkHelpers._instance_2u;
    _static_2(J, "_interceptors_JSArray__compareAny$closure", "JSArray__compareAny", 86);
    _instance_1_i(J.JSArray.prototype, "get$contains", "contains$1", 7);
    _instance_1_i(H._CastIterableBase.prototype, "get$contains", "contains$1", 7);
    _instance_1_u(H.JsLinkedHashMap.prototype, "get$containsKey", "containsKey$1", 7);
    _static_1(P, "async__AsyncRun__scheduleImmediateJsOverride$closure", "_AsyncRun__scheduleImmediateJsOverride", 23);
    _static_1(P, "async__AsyncRun__scheduleImmediateWithSetImmediate$closure", "_AsyncRun__scheduleImmediateWithSetImmediate", 23);
    _static_1(P, "async__AsyncRun__scheduleImmediateWithTimer$closure", "_AsyncRun__scheduleImmediateWithTimer", 23);
    _static_0(P, "async___startMicrotaskLoop$closure", "_startMicrotaskLoop", 1);
    _static_1(P, "async___nullDataHandler$closure", "_nullDataHandler", 8);
    _static(P, "async___nullErrorHandler$closure", 1, function() {
      return [null];
    }, ["call$2", "call$1"], ["_nullErrorHandler", function(error) {
      return P._nullErrorHandler(error, null);
    }], 14, 0);
    _static_0(P, "async___nullDoneHandler$closure", "_nullDoneHandler", 1);
    _static(P, "async___rootHandleUncaughtError$closure", 5, null, ["call$5"], ["_rootHandleUncaughtError"], 59, 0);
    _static(P, "async___rootRun$closure", 4, null, ["call$1$4", "call$4"], ["_rootRun", function($self, $parent, zone, f) {
      return P._rootRun($self, $parent, zone, f, null);
    }], 60, 1);
    _static(P, "async___rootRunUnary$closure", 5, null, ["call$2$5", "call$5"], ["_rootRunUnary", function($self, $parent, zone, f, arg) {
      return P._rootRunUnary($self, $parent, zone, f, arg, null, null);
    }], 61, 1);
    _static(P, "async___rootRunBinary$closure", 6, null, ["call$3$6", "call$6"], ["_rootRunBinary", function($self, $parent, zone, f, arg1, arg2) {
      return P._rootRunBinary($self, $parent, zone, f, arg1, arg2, null, null, null);
    }], 62, 1);
    _static(P, "async___rootRegisterCallback$closure", 4, null, ["call$1$4", "call$4"], ["_rootRegisterCallback", function($self, $parent, zone, f) {
      return P._rootRegisterCallback($self, $parent, zone, f, null);
    }], 63, 0);
    _static(P, "async___rootRegisterUnaryCallback$closure", 4, null, ["call$2$4", "call$4"], ["_rootRegisterUnaryCallback", function($self, $parent, zone, f) {
      return P._rootRegisterUnaryCallback($self, $parent, zone, f, null, null);
    }], 64, 0);
    _static(P, "async___rootRegisterBinaryCallback$closure", 4, null, ["call$3$4", "call$4"], ["_rootRegisterBinaryCallback", function($self, $parent, zone, f) {
      return P._rootRegisterBinaryCallback($self, $parent, zone, f, null, null, null);
    }], 85, 0);
    _static(P, "async___rootErrorCallback$closure", 5, null, ["call$5"], ["_rootErrorCallback"], 66, 0);
    _static(P, "async___rootScheduleMicrotask$closure", 4, null, ["call$4"], ["_rootScheduleMicrotask"], 67, 0);
    _static(P, "async___rootCreateTimer$closure", 5, null, ["call$5"], ["_rootCreateTimer"], 68, 0);
    _static(P, "async___rootCreatePeriodicTimer$closure", 5, null, ["call$5"], ["_rootCreatePeriodicTimer"], 69, 0);
    _static(P, "async___rootPrint$closure", 4, null, ["call$4"], ["_rootPrint"], 70, 0);
    _static_1(P, "async___printToZone$closure", "_printToZone", 71);
    _static(P, "async___rootFork$closure", 5, null, ["call$5"], ["_rootFork"], 72, 0);
    var _;
    _instance_0_u(_ = P._BroadcastSubscription.prototype, "get$_async$_onPause", "_async$_onPause$0", 1);
    _instance_0_u(_, "get$_async$_onResume", "_async$_onResume$0", 1);
    _instance(P._Completer.prototype, "get$completeError", 0, 1, function() {
      return [null];
    }, ["call$2", "call$1"], ["completeError$2", "completeError$1"], 14, 0);
    _instance(P._AsyncCompleter.prototype, "get$complete", 0, 0, function() {
      return [null];
    }, ["call$1", "call$0"], ["complete$1", "complete$0"], 32, 0);
    _instance(P._SyncCompleter.prototype, "get$complete", 0, 0, function() {
      return [null];
    }, ["call$1", "call$0"], ["complete$1", "complete$0"], 32, 0);
    _instance(P._Future.prototype, "get$_completeError", 0, 1, function() {
      return [null];
    }, ["call$2", "call$1"], ["_completeError$2", "_completeError$1"], 14, 0);
    _instance_1_i(_ = P._StreamController.prototype, "get$add", "add$1", 8);
    _instance(_, "get$addError", 0, 1, function() {
      return [null];
    }, ["call$2", "call$1"], ["addError$2", "addError$1"], 14, 0);
    _instance_0_i(_, "get$close", "close$0", 36);
    _instance_1_u(_, "get$_async$_add", "_async$_add$1", 8);
    _instance_2_u(_, "get$_addError", "_addError$2", 50);
    _instance_0_u(_, "get$_close", "_close$0", 1);
    _instance_0_u(_ = P._ControllerSubscription.prototype, "get$_async$_onPause", "_async$_onPause$0", 1);
    _instance_0_u(_, "get$_async$_onResume", "_async$_onResume$0", 1);
    _instance(_ = P._BufferingStreamSubscription.prototype, "get$pause", 1, 0, null, ["call$1", "call$0"], ["pause$1", "pause$0"], 26, 0);
    _instance_0_u(_, "get$resume", "resume$0", 1);
    _instance_0_u(_, "get$_async$_onPause", "_async$_onPause$0", 1);
    _instance_0_u(_, "get$_async$_onResume", "_async$_onResume$0", 1);
    _instance(_ = P._DoneStreamSubscription.prototype, "get$pause", 1, 0, null, ["call$1", "call$0"], ["pause$1", "pause$0"], 26, 0);
    _instance_0_u(_, "get$resume", "resume$0", 1);
    _instance_0_u(_, "get$_sendDone", "_sendDone$0", 1);
    _instance_1_u(_ = P._StreamIterator.prototype, "get$_onData", "_onData$1", 8);
    _instance(_, "get$_onError", 0, 1, function() {
      return [null];
    }, ["call$2", "call$1"], ["_onError$2", "_onError$1"], 14, 0);
    _instance_0_u(_, "get$_onDone", "_onDone$0", 1);
    _instance_0_u(_ = P._ForwardingStreamSubscription.prototype, "get$_async$_onPause", "_async$_onPause$0", 1);
    _instance_0_u(_, "get$_async$_onResume", "_async$_onResume$0", 1);
    _instance_1_u(_, "get$_handleData", "_handleData$1", 8);
    _instance_2_u(_, "get$_handleError", "_handleError$2", 41);
    _instance_0_u(_, "get$_handleDone", "_handleDone$0", 1);
    _static_2(P, "collection___defaultEquals$closure", "_defaultEquals", 73);
    _static_1(P, "collection___defaultHashCode$closure", "_defaultHashCode", 74);
    _static_1(P, "collection_MapBase__id$closure", "MapBase__id", 10);
    _instance_1_u(P._LinkedCustomHashMap.prototype, "get$containsKey", "containsKey$1", 7);
    _instance(_ = P._LinkedHashSet.prototype, "get$_newSimilarSet", 0, 0, null, ["call$1$0", "call$0"], ["_newSimilarSet$1$0", "_newSimilarSet$0"], 28, 0);
    _instance_1_i(_, "get$contains", "contains$1", 7);
    _instance(P._LinkedIdentityHashSet.prototype, "get$_newSimilarSet", 0, 0, null, ["call$1$0", "call$0"], ["_newSimilarSet$1$0", "_newSimilarSet$0"], 28, 0);
    _static_1(P, "convert___defaultToEncodable$closure", "_defaultToEncodable", 10);
    _static_1(P, "core__identityHashCode$closure", "identityHashCode", 75);
    _static_2(P, "core__identical$closure", "identical", 76);
    _static_1(P, "core_Uri_decodeComponent$closure", "Uri_decodeComponent", 27);
    _instance_1_i(P.Iterable.prototype, "get$contains", "contains$1", 7);
    _static(P, "math__max$closure", 2, null, ["call$1$2", "call$2"], ["max", function(a, b) {
      return P.max(a, b, P.num);
    }], 78, 1);
    _instance_1_u(_ = Y.StreamCompleter.prototype, "get$setSourceStream", "setSourceStream$1", 8);
    _instance(_, "get$setError", 0, 1, function() {
      return [null];
    }, ["call$2", "call$1"], ["setError$2", "setError$1"], 37, 0);
    _instance_0_u(_ = L.StreamGroup.prototype, "get$_onListen", "_onListen$0", 1);
    _instance_0_u(_, "get$_onPause", "_onPause$0", 1);
    _instance_0_u(_, "get$_onResume", "_onResume$0", 1);
    _instance_0_u(_, "get$_onCancel", "_onCancel$0", 36);
    _instance_1_i(O.EmptyUnmodifiableSet.prototype, "get$contains", "contains$1", 7);
    _instance_1_i(M._DelegatingIterableBase.prototype, "get$contains", "contains$1", 7);
    _instance_1_i(M.MapKeySet.prototype, "get$contains", "contains$1", 7);
    _instance_1_u(B.ModifiableCssNode.prototype, "get$_node0$_isInvisible", "_node0$_isInvisible$1", 34);
    _instance_1_u(D.SelectorList.prototype, "get$_complexContainsParentSelector", "_complexContainsParentSelector$1", 58);
    _static_1(Y, "functions___isUnique$closure", "_isUnique", 79);
    _static_1(K, "color___opacify$closure", "_opacify", 5);
    _static_1(K, "color___transparentize$closure", "_transparentize", 5);
    _static_2(B, "node___render$closure", "_render", 80);
    _static_1(B, "node___renderSync$closure", "_renderSync", 81);
    _instance_0_u(_ = G.Parser.prototype, "get$whitespace", "whitespace$0", 1);
    _instance_0_u(_, "get$loudComment", "loudComment$0", 1);
    _instance_0_u(_, "get$string", "string$0", 43);
    _instance_0_u(U.SassParser.prototype, "get$whitespace", "whitespace$0", 1);
    _instance(_ = V.StylesheetParser.prototype, "get$_statement", 0, 0, null, ["call$1$root", "call$0"], ["_statement$1$root", "_statement$0"], 44, 0);
    _instance_0_u(_, "get$_declarationChild", "_declarationChild$0", 25);
    _instance_0_u(_, "get$_declarationAtRule", "_declarationAtRule$0", 25);
    _instance_0_u(_, "get$_functionAtRule", "_functionAtRule$0", 25);
    _instance_0_u(_, "get$_number", "_number$0", 46);
    _instance_1_i(N.NoSourceMapBuffer.prototype, "get$write", "write$1", 8);
    _instance_1_i(D.SourceMapBuffer.prototype, "get$write", "write$1", 8);
    _static_1(B, "utils__isPublic$closure", "isPublic", 82);
    _instance_1_u(_ = N._SerializeVisitor.prototype, "get$_visitMediaQuery", "_visitMediaQuery$1", 53);
    _instance_1_u(_, "get$_isInvisible", "_isInvisible$1", 34);
    _instance(Y.SourceSpanMixin.prototype, "get$message", 1, 1, function() {
      return {color: null};
    }, ["call$2$color", "call$1"], ["message$2$color", "message$1"], 55, 0);
    _static(T, "debounce___collectToList$closure", 2, null, ["call$1$2", "call$2"], ["_collectToList", function(element, soFar) {
      return T._collectToList(element, soFar, null);
    }], 83, 0);
    _static(L, "from_handlers__StreamTransformer__defaultHandleError$closure", 3, null, ["call$1$3", "call$3"], ["_StreamTransformer__defaultHandleError", function(error, stackTrace, sink) {
      return L._StreamTransformer__defaultHandleError(error, stackTrace, sink, null);
    }], 84, 0);
    _static_1(D, "path__dirname$closure", "dirname", 27);
    _static_1(F, "value0__wrapValue$closure", "wrapValue", 65);
    _static_1(T, "character__isWhitespace$closure", "isWhitespace", 13);
    _static_1(T, "character__isNewline$closure", "isNewline", 13);
    _static_1(T, "character__isHex$closure", "isHex", 13);
    _static_2(T, "number__fuzzyEquals$closure", "fuzzyEquals", 16);
    _static_2(T, "number__fuzzyLessThan$closure", "fuzzyLessThan", 16);
    _static_2(T, "number__fuzzyLessThanOrEquals$closure", "fuzzyLessThanOrEquals", 16);
    _static_2(T, "number__fuzzyGreaterThan$closure", "fuzzyGreaterThan", 16);
    _static_2(T, "number__fuzzyGreaterThanOrEquals$closure", "fuzzyGreaterThanOrEquals", 16);
    _static_1(T, "number__fuzzyRound$closure", "fuzzyRound", 24);
  })();
  (function inheritance() {
    var _mixin = hunkHelpers.mixin,
      _inherit = hunkHelpers.inherit,
      _inheritMany = hunkHelpers.inheritMany;
    _inherit(P.Object, null);
    _inheritMany(P.Object, [H.JS_CONST, J.Interceptor, J.ArrayIterator, P.Iterable, H.CastIterator, P._ListBase_Object_ListMixin, H.ListIterator, P.Iterator, H.ExpandIterator, H.EmptyIterator, H.FollowedByIterator, H.WhereTypeIterator, H.FixedLengthListMixin, H.UnmodifiableListMixin, H.Symbol0, P.MapView, H.ConstantMap, H.Closure, H.JSInvocationMirror, H.TypeErrorDecoder, P.Error, H.ExceptionAndStackTrace, H._StackTrace, H.TypeImpl, P.MapMixin, H.LinkedHashMapCell, H.LinkedHashMapKeyIterator, H.JSSyntaxRegExp, H._MatchImplementation, H._AllMatchesIterator, H.StringMatch, H._StringAllMatchesIterator, P._TimerImpl, P._AsyncAwaitCompleter, P._AsyncStarStreamController, P._IterationMarker, P._SyncStarIterator, P.Stream, P._BufferingStreamSubscription, P._BroadcastStreamController, P.Future, P._Completer, P._FutureListener, P._Future, P._AsyncCallbackEntry, P.StreamSubscription, P.EventSink, P.StreamTransformerBase, P._StreamController, P._SyncStreamControllerDispatch, P._AsyncStreamControllerDispatch, P._AddStreamState, P._DelayedEvent, P._DelayedDone, P._PendingEvents, P._DoneStreamSubscription, P._StreamIterator, P.Timer, P.AsyncError, P._ZoneFunction, P.ZoneSpecification, P._ZoneSpecification, P.ZoneDelegate, P.Zone, P._ZoneDelegate, P._Zone, P._HashMapKeyIterator, P._SetBase, P._LinkedHashSetCell, P._LinkedHashSetIterator, P.ListMixin, P._MapBaseValueIterator, P._UnmodifiableMapMixin, P.Queue, P._ListQueueIterator, P.Codec, P._Base64Encoder, P.ChunkedConversionSink, P._JsonStringifier, P.StringConversionSinkMixin, P._Utf8Encoder, P._Utf8Decoder, P.bool, P.DateTime, P.num, P.Duration, P.OutOfMemoryError, P.StackOverflowError, P._Exception, P.FormatException, P.Function, P.List, P.Map, P.MapEntry, P.Null, P.Match, P.RegExpMatch, P.StackTrace, P._StringStackTrace, P.String, P.RuneIterator, P.StringBuffer, P.StringSink, P.Symbol, P.Uri, P._Uri, P.UriData, P._SimpleUri, P._JSRandom, P.Uint8List, N.ArgParser, V.ArgResults, G.Option, G.OptionType, G.Parser0, G.Usage, V.ErrorResult, E.Result, F.ValueResult, Y.StreamCompleter, L.StreamGroup, L._StreamGroupState, G.StreamQueue, G._EventRequest, G._NextRequest, Q.Repl, B.ReplAdapter, U.DefaultEquality, U.ListEquality, U._MapEntry, U.MapEquality, Q._QueueList_Object_ListMixin, M._DelegatingIterableBase, L.UnmodifiableSetMixin, M.Context, M._PathDirection, M._PathRelation, O.Style, X.ParsedPath, X.PathException, F.CssMediaQuery, F._SingletonCssMediaQueryMergeResult, F.MediaQuerySuccessfulMergeResult, B.AstNode, F.ModifiableCssValue, F.CssValue, Z.Argument, B.ArgumentDeclaration, X.ArgumentInvocation, V.AtRootQuery, T.Expression, V.BinaryOperationExpression, V.BinaryOperator, Z.BooleanExpression, K.ColorExpression, F.FunctionExpression, L.IfExpression, D.ListExpression, A.MapExpression, O.NullExpression, T.NumberExpression, T.ParenthesizedExpression, T.SelectorExpression, D.StringExpression, X.UnaryOperationExpression, X.UnaryOperator, F.ValueExpression, S.VariableExpression, F.Import, B.DynamicImport, Q.StaticImport, X.Interpolation, O.Statement, M.ParentStatement, Q.ContentRule, Q.DebugRule, D.ErrorRule, X.ExtendRule, L.ForwardRule, V.IfRule, V.IfClause, B.ImportRule, A.IncludeRule, L.LoudComment, B.ReturnRule, B.SilentComment, T.UseRule, Z.VariableDeclaration, Y.WarnRule, L.SupportsDeclaration, X.SupportsInterpolation, M.SupportsNegation, U.SupportsOperation, T.Selector, N.AttributeOperator, S.ComplexSelectorComponent, S.Combinator, D.QualifiedName, X.CompileResult, Q.AsyncEnvironment, Q._EnvironmentModule0, O.AsyncImportCache, B.AsyncCallable, S.AsyncBuiltInCallable, Q.BuiltInCallable, L.PlainCssCallable, E.UserDefinedCallable, O.Environment, O._EnvironmentModule, G.SourceSpanException, E.SassScriptException, B.ExecutableOptions, B.UsageException, A._Watcher, T.EmptyExtender, F.Extender, S.Extension, L.ExtendMode, R.ImportCache, B.AsyncImporter, F.NodeImporter, E.ImporterResult, Z.InterpolationBuffer, B.FileSystemException, B.Stderr, F._QuietLogger, S.StderrLogger, T.TrackingLogger, G.Module, Q.BuiltInModule, R.ForwardedModuleView, G.Parser, M.StylesheetGraph, M.StylesheetNode, M.Syntax, G.FixedLengthListBuilder, U.MultiDirWatcher, N.NoSourceMapBuffer, D.SourceMapBuffer, F.Value, D.ListSeparator, E._EvaluateVisitor0, E._ImportedCssVisitor0, E.EvaluateResult, E._ArgumentResults0, V._CloneCssVisitor, R._EvaluateVisitor, R._ImportedCssVisitor, R._ArgumentResults, D.RecursiveStatementVisitor, N._SerializeVisitor, N.OutputStyle, N.LineFeed, N.SerializeResult, L.Entry, T.Mapping, T.TargetLineEntry, T.TargetEntry, Y.SourceFile, D.SourceLocationMixin, Y.FileSpan, Y.SourceSpanMixin, U.Highlighter, V.SourceLocation, V.SourceSpan, U.Chain, A.Frame, T.LazyTrace, Y.Trace, N.UnparsedFrame, X.StringScanner, S._SpanScannerState, A.AsciiGlyphSet, K.UnicodeGlyphSet, S.Tuple2, S.Tuple3, E.WatchEvent, E.ChangeType]);
    _inheritMany(J.Interceptor, [J.JSBool, J.JSNull, J.JavaScriptObject, J.JSArray, J.JSNumber, J.JSString, H.NativeTypedData]);
    _inheritMany(J.JavaScriptObject, [J.PlainJavaScriptObject, J.UnknownJavaScriptObject, J.JavaScriptFunction, B.Stdin, B.Stdout, B.ReadlineModule, B.ReadlineOptions, B.ReadlineInterface, B._FS, B._Stat, B._Date, B._Stderr, B._Stdin, B._SystemError, B._Process, Y.Chokidar, Y.ChokidarOptions, Y.ChokidarWatcher, V.JSError, D.Exports, E.FiberClass, E.Fiber, F.JSFunction, F.NodeImporterResult, Z.RenderContext, L.RenderContextOptions, R.RenderOptions, U.RenderResult, U.RenderResultStats, G.Types, K._NodeSassColor, D._NodeSassList, A._NodeSassMap, T._NodeSassNumber, D._NodeSassString]);
    _inherit(J.JSUnmodifiableArray, J.JSArray);
    _inheritMany(J.JSNumber, [J.JSInt, J.JSDouble]);
    _inheritMany(P.Iterable, [H._CastIterableBase, H.EfficientLengthIterable, H.MappedIterable, H.WhereIterable, H.ExpandIterable, H.TakeIterable, H.SkipIterable, H.SkipWhileIterable, H.FollowedByIterable, H.WhereTypeIterable, H._ConstantMapKeyIterable, P.IterableBase, H._StringAllMatchesIterable, P.Runes]);
    _inheritMany(H._CastIterableBase, [H.CastIterable, H.__CastListBase__CastIterableBase_ListMixin, H.CastSet, H.CastQueue]);
    _inherit(H._EfficientLengthCastIterable, H.CastIterable);
    _inherit(H._CastListBase, H.__CastListBase__CastIterableBase_ListMixin);
    _inherit(H.CastList, H._CastListBase);
    _inherit(P.ListBase, P._ListBase_Object_ListMixin);
    _inherit(H.UnmodifiableListBase, P.ListBase);
    _inheritMany(H.UnmodifiableListBase, [H.CodeUnits, P.UnmodifiableListView]);
    _inheritMany(H.EfficientLengthIterable, [H.ListIterable, H.EmptyIterable, H.LinkedHashMapKeyIterable, P._HashMapKeyIterable, P._MapBaseValueIterable, P.Set]);
    _inheritMany(H.ListIterable, [H.SubListIterable, H.MappedListIterable, H.ReversedListIterable, P.ListQueue, P._GeneratorIterable]);
    _inherit(H.EfficientLengthMappedIterable, H.MappedIterable);
    _inheritMany(P.Iterator, [H.MappedIterator, H.WhereIterator, H.TakeIterator, H.SkipIterator, H.SkipWhileIterator]);
    _inherit(H.EfficientLengthTakeIterable, H.TakeIterable);
    _inherit(H.EfficientLengthSkipIterable, H.SkipIterable);
    _inherit(H.EfficientLengthFollowedByIterable, H.FollowedByIterable);
    _inheritMany(P.MapView, [P._UnmodifiableMapView_MapView__UnmodifiableMapMixin, K.PathMap]);
    _inherit(P.UnmodifiableMapView, P._UnmodifiableMapView_MapView__UnmodifiableMapMixin);
    _inherit(H.ConstantMapView, P.UnmodifiableMapView);
    _inherit(H.ConstantStringMap, H.ConstantMap);
    _inheritMany(H.Closure, [H.ConstantStringMap_values_closure, H.Instantiation, H.Primitives_functionNoSuchMethod_closure, H.unwrapException_saveStackTrace, H.TearOffClosure, H.JsLinkedHashMap_values_closure, H.JsLinkedHashMap_addAll_closure, H.initHooks_closure, H.initHooks_closure0, H.initHooks_closure1, P._AsyncRun__initializeScheduleImmediate_internalCallback, P._AsyncRun__initializeScheduleImmediate_closure, P._AsyncRun__scheduleImmediateJsOverride_internalCallback, P._AsyncRun__scheduleImmediateWithSetImmediate_internalCallback, P._TimerImpl_internalCallback, P._TimerImpl$periodic_closure, P._AsyncAwaitCompleter_complete_closure, P._AsyncAwaitCompleter_completeError_closure, P._awaitOnObject_closure, P._awaitOnObject_closure0, P._wrapJsFunctionForAsync_closure, P._asyncStarHelper_closure, P._asyncStarHelper_closure0, P._AsyncStarStreamController__resumeBody, P._AsyncStarStreamController__resumeBody_closure, P._AsyncStarStreamController_closure0, P._AsyncStarStreamController_closure1, P._AsyncStarStreamController_closure, P._AsyncStarStreamController__closure, P._SyncBroadcastStreamController__sendData_closure, P._SyncBroadcastStreamController__sendError_closure, P._SyncBroadcastStreamController__sendDone_closure, P.Future_wait_handleError, P.Future_wait_closure, P._Future__addListener_closure, P._Future__prependListeners_closure, P._Future__chainForeignFuture_closure, P._Future__chainForeignFuture_closure0, P._Future__chainForeignFuture_closure1, P._Future__asyncComplete_closure, P._Future__chainFuture_closure, P._Future__asyncCompleteError_closure, P._Future__propagateToListeners_handleWhenCompleteCallback, P._Future__propagateToListeners_handleWhenCompleteCallback_closure, P._Future__propagateToListeners_handleValueCallback, P._Future__propagateToListeners_handleError, P.Stream_Stream$fromFuture_closure, P.Stream_Stream$fromFuture_closure0, P.Stream_length_closure, P.Stream_length_closure0, P._StreamController__subscribe_closure, P._StreamController__recordCancel_complete, P._AddStreamState_cancel_closure, P._BufferingStreamSubscription__sendError_sendError, P._BufferingStreamSubscription__sendDone_sendDone, P._PendingEvents_schedule_closure, P._CustomZone_bindCallback_closure, P._CustomZone_bindUnaryCallback_closure, P._CustomZone_bindCallbackGuarded_closure, P._rootHandleUncaughtError_closure, P._RootZone_bindCallback_closure, P._RootZone_bindCallbackGuarded_closure, P._HashMap_values_closure, P._HashMap_addAll_closure, P._LinkedCustomHashMap_closure, P.HashMap_HashMap$from_closure, P.LinkedHashMap_LinkedHashMap$from_closure, P.MapBase_mapToString_closure, P.MapMixin_entries_closure, P._JsonStringifier_writeMap_closure, P.NoSuchMethodError_toString_closure, P.Duration_toString_sixDigits, P.Duration_toString_twoDigits, P.Uri__parseIPv4Address_error, P.Uri_parseIPv6Address_error, P.Uri_parseIPv6Address_parseHex, P._Uri__Uri$notSimple_closure, P._Uri__checkNonWindowsPathReservedCharacters_closure, P._Uri__makePath_closure, P._createTables_closure, P._createTables_build, P._createTables_setChars, P._createTables_setRange, N.ArgParser_findByAbbreviation_closure, N.ArgParser_findByAbbreviation_closure0, G.Parser_parse_closure, G.Parser_setOption_closure, G.Usage_generate_closure, G.Usage_buildAllowedList_closure, L.StreamGroup_add_closure, L.StreamGroup_add_closure0, L.StreamGroup__onListen_closure, L.StreamGroup__onCancel_closure, L.StreamGroup__onCancel_closure0, L.StreamGroup__listenToStream_closure, G.StreamQueue__ensureListening_closure, G.StreamQueue__ensureListening_closure1, G.StreamQueue__ensureListening_closure0, Q.closure130, B.ReplAdapter_runAsync_closure, Y.mapMap_closure, Y.mapMap_closure0, Y.mapMap_closure1, B.defaultCompare_closure, M.Context_join_closure, M.Context_joinAll_closure, M.Context_split_closure, M._validateArgList_closure, X.ParsedPath_normalize_closure, X.ParsedPath__splitExtension_closure, X.ParsedPath__splitExtension_closure0, K.PathMap__create_closure, K.PathMap__create_closure0, K.PathMap__create_closure1, L.WindowsStyle_absolutePathToUri_closure, B.ArgumentDeclaration_verify_closure, B.ArgumentDeclaration_verify_closure0, D.ListExpression_toString_closure, A.MapExpression_toString_closure, X.Interpolation_toString_closure, V.EachRule_toString_closure, L.ForwardRule__memberList_closure, V.IfRule_toString_closure, V.IfClause$__closure, M.ParentStatement_closure, S.ComplexSelector_isInvisible_closure, X.CompoundSelector_isInvisible_closure, N.IDSelector_unify_closure, D.SelectorList_isInvisible_closure, D.SelectorList_asSassList_closure, D.SelectorList_asSassList__closure, D.SelectorList_unify_closure, D.SelectorList_unify__closure, D.SelectorList_unify___closure, D.SelectorList_resolveParentSelectors_closure, D.SelectorList_resolveParentSelectors__closure, D.SelectorList_resolveParentSelectors__closure0, D.SelectorList__complexContainsParentSelector_closure, D.SelectorList__complexContainsParentSelector__closure, D.SelectorList__resolveParentSelectorsCompound_closure, D.SelectorList__resolveParentSelectorsCompound_closure0, D.SelectorList__resolveParentSelectorsCompound_closure1, X._compileStylesheet_closure0, Q.AsyncEnvironment__getVariableFromGlobalModule_closure, Q.AsyncEnvironment_setVariable_closure, Q.AsyncEnvironment_setVariable_closure0, Q.AsyncEnvironment_setVariable_closure1, Q.AsyncEnvironment__getFunctionFromGlobalModule_closure, Q.AsyncEnvironment__getMixinFromGlobalModule_closure, Q._EnvironmentModule__EnvironmentModule_closure5, Q._EnvironmentModule__EnvironmentModule_closure6, Q._EnvironmentModule__EnvironmentModule_closure7, Q._EnvironmentModule__EnvironmentModule_closure8, Q._EnvironmentModule__EnvironmentModule_closure9, Q._EnvironmentModule__EnvironmentModule_closure10, O.AsyncImportCache_canonicalize_closure, O.AsyncImportCache_importCanonical_closure, O.AsyncImportCache_humanize_closure, O.AsyncImportCache_humanize_closure0, O.AsyncImportCache_humanize_closure1, S.AsyncBuiltInCallable_callbackFor_closure, S.AsyncBuiltInCallable_callbackFor_closure0, Q.BuiltInCallable_callbackFor_closure, Q.BuiltInCallable_callbackFor_closure0, X.closure34, X.closure35, U._compileStylesheet_closure, O.Environment__getVariableFromGlobalModule_closure, O.Environment_setVariable_closure, O.Environment_setVariable_closure0, O.Environment_setVariable_closure1, O.Environment__getFunctionFromGlobalModule_closure, O.Environment__getMixinFromGlobalModule_closure, O._EnvironmentModule__EnvironmentModule_closure, O._EnvironmentModule__EnvironmentModule_closure0, O._EnvironmentModule__EnvironmentModule_closure1, O._EnvironmentModule__EnvironmentModule_closure2, O._EnvironmentModule__EnvironmentModule_closure3, O._EnvironmentModule__EnvironmentModule_closure4, F.main_printError, F.main_closure0, D._writeSourceMap_closure, B.ExecutableOptions_closure, B.ExecutableOptions_emitErrorCss_closure, A.watch_closure, A._Watcher__debounceEvents_closure, A._Watcher__debounceEvents__closure, F.Extender__extendOrReplace_closure, F.Extender_extensionsWhereTarget_closure, F.Extender__registerSelector_closure, F.Extender_addExtension_closure, F.Extender_addExtension_closure0, F.Extender_addExtension_closure1, F.Extender__extendExistingExtensions_closure, F.Extender__extendExistingExtensions_closure0, F.Extender_addExtensions_closure, F.Extender_addExtensions__closure, F.Extender_addExtensions___closure, F.Extender_addExtensions___closure0, F.Extender__extendList_closure, F.Extender__extendComplex_closure, F.Extender__extendComplex_closure0, F.Extender__extendComplex__closure, F.Extender__extendComplex__closure0, F.Extender__extendComplex___closure, F.Extender__extendCompound_closure, F.Extender__extendCompound_closure0, F.Extender__extendCompound__closure, F.Extender__extendCompound__closure0, F.Extender__extendCompound_closure1, F.Extender__extendCompound_closure2, F.Extender__extendSimple_withoutPseudo, F.Extender__extendSimple_closure, F.Extender__extendPseudo_closure, F.Extender__extendPseudo_closure0, F.Extender__extendPseudo_closure1, F.Extender__extendPseudo_closure2, F.Extender__extendPseudo_closure3, F.Extender__trim_closure, F.Extender__trim_closure0, F.Extender_clone_closure, Y.unifyComplex_closure, Y._weaveParents_closure, Y._weaveParents_closure0, Y._weaveParents_closure1, Y._weaveParents__closure1, Y._weaveParents_closure2, Y._weaveParents_closure3, Y._weaveParents__closure0, Y._weaveParents_closure4, Y._weaveParents_closure5, Y._weaveParents__closure, Y._mustUnify_closure, Y._mustUnify__closure, Y.paths_closure, Y.paths__closure, Y.paths___closure, Y._hasRoot_closure, Y.listIsSuperslector_closure, Y.listIsSuperslector__closure, Y._simpleIsSuperselectorOfCompound_closure, Y._simpleIsSuperselectorOfCompound__closure, Y._selectorPseudoIsSuperselector_closure, Y._selectorPseudoIsSuperselector_closure0, Y._selectorPseudoIsSuperselector_closure1, Y._selectorPseudoIsSuperselector_closure2, Y._selectorPseudoIsSuperselector__closure, Y._selectorPseudoIsSuperselector___closure, Y._selectorPseudoIsSuperselector___closure0, Y._selectorPseudoIsSuperselector_closure3, Y._selectorPseudoIsSuperselector_closure4, Y._selectorPseudosNamed_closure, Y.closure37, K.closure81, K.closure82, K.closure83, K.closure84, K.closure85, K.closure86, K.closure87, K.closure88, K.closure89, K.closure90, K.closure91, K.closure92, K.closure93, K.closure94, K.closure95, K.closure96, K.closure97, K.closure98, K.closure99, K.closure100, K.closure101, K.closure102, K.closure103, K.closure104, K.closure105, K._closure17, K.closure106, K.closure120, K.closure121, K.closure122, K.closure123, K._closure18, K.closure124, K.closure119, K.closure118, K.closure117, K.closure116, K.closure115, K.closure114, K.closure113, K.closure112, K.closure111, K.closure109, K.closure_getInRange0, K._closure16, K.closure108, K.closure_getScale, K.closure_scaleValue, K._closure15, K.closure107, K.closure_getInRange, K._closure14, K.closure110, K.closure_hexString, K._functionString_closure, K._removedColorFunction_closure, K._parseChannels_closure, D.closure80, D.closure79, D.closure78, D.closure77, D.closure76, D.closure75, D._closure11, D._closure12, D._closure13, D.closure74, D.closure72, D.closure73, A.closure71, A.closure70, A.closure68, A.closure69, A.closure67, A.closure66, A.closure65, K.closure57, K.closure64, K.closure63, K.closure62, K.closure61, K.closure60, K.closure59, K.closure58, K.closure56, K.closure55, K._numberFunction_closure, Q.closure125, Q.closure126, Q.closure127, Q.closure128, Q._closure19, T.closure51, T._closure8, T._closure9, T.closure50, T._closure6, T._closure7, T.__closure, T.closure49, T.closure48, T.closure47, T.closure54, T.closure53, T._closure10, T.closure52, D.closure46, D.closure45, D.closure41, D.closure40, D.closure39, D.closure38, D.closure44, D.closure43, D.closure42, R.ImportCache_canonicalize_closure, R.ImportCache_importCanonical_closure, R.ImportCache_humanize_closure, R.ImportCache_humanize_closure0, R.ImportCache_humanize_closure1, B.resolveImportPath_closure, B.resolveImportPath_closure0, B._tryPathAsDirectory_closure, B._exactlyOne_closure, F.realCasePath_closure, B._readFile_closure, B.writeFile_closure, B.deleteFile_closure, B.readStdin_closure, B.readStdin_closure0, B.readStdin_closure1, B.readStdin_closure2, B.ensureDir_closure, B.listDir_closure, B.listDir__closure, B.listDir__closure0, B.listDir_closure_list, B.listDir__list_closure, B.modificationTime_closure, B.watchDir_closure, B.watchDir_closure0, B.watchDir_closure1, B.watchDir_closure2, B.watchDir_closure3, B.watchDir__closure, B.main_closure, B._render_closure, B._render_closure0, B._render_closure1, B._parseFunctions_closure, B._parseFunctions__closure, B._parseFunctions___closure0, B._parseFunctions____closure, B._parseFunctions__closure0, B._parseFunctions__closure1, B._parseFunctions___closure, B._parseImporter_closure, B._parseImporter__closure, B._parseImporter___closure, B._parseImporter____closure, B.forwardToString_closure, B.createClass_closure, Z.closure36, Z._closure4, Z._closure5, K.closure24, K.closure25, K.closure26, K.closure27, K.closure28, K.closure29, K.closure30, K.closure31, K.closure32, K.closure33, D.closure17, D._closure3, D.closure18, D.closure19, D.closure20, D.closure21, D.closure22, D.closure23, A.closure10, A._closure1, A._closure2, A.closure11, A.closure12, A.closure13, A.closure14, A.closure15, A.closure16, O.closure9, O._closure, O._closure0, T.closure3, T.closure4, T.closure5, T.closure6, T.closure7, T.closure8, T._parseNumber_closure, T._parseNumber_closure0, D.closure, D.closure0, D.closure1, D.closure2, V.AtRootQueryParser_parse_closure, Q.closure129, E.KeyframeSelectorParser_parse_closure, F.MediaQueryParser_parse_closure, G.Parser__parseIdentifier_closure, U.SassParser_children_closure, T.SelectorParser_parse_closure, T.SelectorParser_parseCompoundSelector_closure, V.StylesheetParser_parse_closure, V.StylesheetParser_parse__closure, V.StylesheetParser_parse__closure0, V.StylesheetParser_parseArgumentDeclaration_closure, V.StylesheetParser_parseExpression_closure, V.StylesheetParser_parseVariableDeclaration_closure, V.StylesheetParser_parseSignature_closure, V.StylesheetParser__statement_closure, V.StylesheetParser_variableDeclaration_closure, V.StylesheetParser__styleRule_closure, V.StylesheetParser__declarationOrStyleRule_closure, V.StylesheetParser__declarationOrBuffer_closure, V.StylesheetParser__declarationOrBuffer_closure0, V.StylesheetParser__declaration_closure, V.StylesheetParser__declaration_closure0, V.StylesheetParser__atRootRule_closure, V.StylesheetParser__atRootRule_closure0, V.StylesheetParser__eachRule_closure, V.StylesheetParser__functionRule_closure, V.StylesheetParser__forRule_closure, V.StylesheetParser__forRule_closure0, V.StylesheetParser__memberList_closure, V.StylesheetParser__includeRule_closure, V.StylesheetParser_mediaRule_closure, V.StylesheetParser__mixinRule_closure, V.StylesheetParser_mozDocumentRule_closure, V.StylesheetParser_supportsRule_closure, V.StylesheetParser__whileRule_closure, V.StylesheetParser_unknownAtRule_closure, V.StylesheetParser_expression_resetState, V.StylesheetParser_expression_resolveOneOperation, V.StylesheetParser_expression_resolveOperations, V.StylesheetParser_expression_addSingleExpression, V.StylesheetParser_expression_addOperator, V.StylesheetParser_expression_resolveSpaceExpressions, V.StylesheetParser__expressionUntilComma_closure, V.StylesheetParser__unicodeRange_closure, V.StylesheetParser__unicodeRange_closure0, V.StylesheetParser__expressionUntilComparison_closure, M.StylesheetGraph_modifiedSince_transitiveModificationTime, M.StylesheetGraph_modifiedSince_transitiveModificationTime_closure, M.StylesheetGraph__add_closure, M.StylesheetGraph_addCanonical_closure, M.StylesheetGraph_addCanonical_closure0, M.StylesheetGraph__upstreamNodes_closure, M.StylesheetGraph_reload_closure, M.StylesheetGraph__nodeFor_closure, M.StylesheetGraph__nodeFor_closure0, F._PrefixedKeys_iterator_closure, D.SourceMapBuffer_sourceFiles_closure, D.SourceMapBuffer__addEntry_closure, D.SourceMapBuffer_buildSourceMap_closure, B.indent_closure, B.flattenVertically_closure, B.flattenVertically_closure0, B.longestCommonSubsequence_closure, B.longestCommonSubsequence_closure0, B.longestCommonSubsequence_closure1, B.longestCommonSubsequence_backtrack, B.mapAddAll2_closure, B.mapMapAsync_closure, B.copyMapOfMap_closure, B.copyMapOfList_closure, D.SassList_isBlank_closure, A.SassMap_asList_closure, T.SassNumber_valueInUnits_closure, T.SassNumber_valueInUnits_closure0, T.SassNumber_valueInUnits_closure1, T.SassNumber_valueInUnits_closure2, T.SassNumber_modulo_closure, T.SassNumber_plus_closure, T.SassNumber_minus_closure, T.SassNumber__multiplyUnits_closure, T.SassNumber__multiplyUnits_closure0, T.SassNumber__multiplyUnits_closure1, T.SassNumber__multiplyUnits_closure2, T.SassNumber__areAnyConvertible_closure, T.SassNumber__canonicalMultiplier_closure, E._EvaluateVisitor_closure8, E._EvaluateVisitor_closure9, E._EvaluateVisitor_closure10, E._EvaluateVisitor_closure11, E._EvaluateVisitor_closure12, E._EvaluateVisitor_closure13, E._EvaluateVisitor_closure14, E._EvaluateVisitor_closure15, E._EvaluateVisitor__closure4, E._EvaluateVisitor_closure16, E._EvaluateVisitor__closure2, E._EvaluateVisitor__closure3, E._EvaluateVisitor_run_closure0, E._EvaluateVisitor__withWarnCallback_closure0, E._EvaluateVisitor__loadModule_closure0, E._EvaluateVisitor__loadModule__closure0, E._EvaluateVisitor__execute_closure0, E._EvaluateVisitor__execute__closure0, E._EvaluateVisitor__combineCss_closure2, E._EvaluateVisitor__combineCss_closure3, E._EvaluateVisitor__combineCss_closure4, E._EvaluateVisitor__extendModules_closure1, E._EvaluateVisitor__extendModules_closure2, E._EvaluateVisitor__topologicalModules_visitModule0, E._EvaluateVisitor_visitAtRootRule_closure2, E._EvaluateVisitor_visitAtRootRule_closure3, E._EvaluateVisitor_visitAtRootRule_closure4, E._EvaluateVisitor__scopeForAtRoot_closure5, E._EvaluateVisitor__scopeForAtRoot_closure6, E._EvaluateVisitor__scopeForAtRoot_closure7, E._EvaluateVisitor__scopeForAtRoot__closure0, E._EvaluateVisitor__scopeForAtRoot_closure8, E._EvaluateVisitor__scopeForAtRoot_closure9, E._EvaluateVisitor__scopeForAtRoot_closure10, E._EvaluateVisitor_visitContentRule_closure0, E._EvaluateVisitor_visitDeclaration_closure0, E._EvaluateVisitor_visitEachRule_closure2, E._EvaluateVisitor_visitEachRule_closure3, E._EvaluateVisitor_visitEachRule_closure4, E._EvaluateVisitor_visitEachRule__closure0, E._EvaluateVisitor_visitEachRule___closure0, E._EvaluateVisitor_visitExtendRule_closure0, E._EvaluateVisitor_visitAtRule_closure1, E._EvaluateVisitor_visitAtRule__closure0, E._EvaluateVisitor_visitAtRule_closure2, E._EvaluateVisitor_visitForRule_closure4, E._EvaluateVisitor_visitForRule_closure5, E._EvaluateVisitor_visitForRule_closure6, E._EvaluateVisitor_visitForRule_closure7, E._EvaluateVisitor_visitForRule_closure8, E._EvaluateVisitor_visitForRule__closure0, E._EvaluateVisitor_visitForwardRule_closure0, E._EvaluateVisitor_visitIfRule_closure0, E._EvaluateVisitor_visitIfRule__closure0, E._EvaluateVisitor__visitDynamicImport_closure0, E._EvaluateVisitor__visitDynamicImport__closure1, E._EvaluateVisitor__visitDynamicImport__closure2, E._EvaluateVisitor_visitIncludeRule_closure1, E._EvaluateVisitor_visitIncludeRule_closure2, E._EvaluateVisitor_visitIncludeRule__closure0, E._EvaluateVisitor_visitIncludeRule___closure0, E._EvaluateVisitor_visitMediaRule_closure1, E._EvaluateVisitor_visitMediaRule__closure0, E._EvaluateVisitor_visitMediaRule___closure0, E._EvaluateVisitor_visitMediaRule_closure2, E._EvaluateVisitor__visitMediaQueries_closure0, E._EvaluateVisitor_visitStyleRule_closure6, E._EvaluateVisitor_visitStyleRule_closure7, E._EvaluateVisitor_visitStyleRule_closure8, E._EvaluateVisitor_visitStyleRule_closure9, E._EvaluateVisitor_visitStyleRule_closure10, E._EvaluateVisitor_visitStyleRule_closure11, E._EvaluateVisitor_visitStyleRule__closure0, E._EvaluateVisitor_visitStyleRule_closure12, E._EvaluateVisitor_visitSupportsRule_closure1, E._EvaluateVisitor_visitSupportsRule__closure0, E._EvaluateVisitor_visitSupportsRule_closure2, E._EvaluateVisitor_visitVariableDeclaration_closure1, E._EvaluateVisitor_visitVariableDeclaration_closure2, E._EvaluateVisitor_visitUseRule_closure0, E._EvaluateVisitor_visitWarnRule_closure0, E._EvaluateVisitor_visitWhileRule_closure0, E._EvaluateVisitor_visitWhileRule__closure0, E._EvaluateVisitor_visitBinaryOperationExpression_closure0, E._EvaluateVisitor_visitVariableExpression_closure0, E._EvaluateVisitor_visitListExpression_closure0, E._EvaluateVisitor_visitFunctionExpression_closure0, E._EvaluateVisitor__runUserDefinedCallable_closure0, E._EvaluateVisitor__runUserDefinedCallable__closure0, E._EvaluateVisitor__runUserDefinedCallable___closure0, E._EvaluateVisitor__runUserDefinedCallable____closure0, E._EvaluateVisitor__runFunctionCallable_closure0, E._EvaluateVisitor__runBuiltInCallable_closure1, E._EvaluateVisitor__runBuiltInCallable_closure2, E._EvaluateVisitor__evaluateArguments_closure6, E._EvaluateVisitor__evaluateArguments_closure7, E._EvaluateVisitor__evaluateArguments_closure8, E._EvaluateVisitor__evaluateArguments_closure9, E._EvaluateVisitor__evaluateArguments_closure10, E._EvaluateVisitor__evaluateArguments_closure11, E._EvaluateVisitor__evaluateArguments_closure12, E._EvaluateVisitor__evaluateMacroArguments_closure3, E._EvaluateVisitor__evaluateMacroArguments_closure4, E._EvaluateVisitor__evaluateMacroArguments_closure5, E._EvaluateVisitor__evaluateMacroArguments_closure6, E._EvaluateVisitor__addRestMap_closure1, E._EvaluateVisitor__addRestMap_closure2, E._EvaluateVisitor__verifyArguments_closure0, E._EvaluateVisitor_visitStringExpression_closure0, E._EvaluateVisitor_visitCssAtRule_closure1, E._EvaluateVisitor_visitCssAtRule_closure2, E._EvaluateVisitor_visitCssKeyframeBlock_closure1, E._EvaluateVisitor_visitCssKeyframeBlock_closure2, E._EvaluateVisitor_visitCssMediaRule_closure1, E._EvaluateVisitor_visitCssMediaRule__closure0, E._EvaluateVisitor_visitCssMediaRule___closure0, E._EvaluateVisitor_visitCssMediaRule_closure2, E._EvaluateVisitor_visitCssStyleRule_closure1, E._EvaluateVisitor_visitCssStyleRule__closure0, E._EvaluateVisitor_visitCssStyleRule_closure2, E._EvaluateVisitor_visitCssSupportsRule_closure1, E._EvaluateVisitor_visitCssSupportsRule__closure0, E._EvaluateVisitor_visitCssSupportsRule_closure2, E._EvaluateVisitor__performInterpolation_closure0, E._EvaluateVisitor__serialize_closure0, E._EvaluateVisitor__stackTrace_closure0, E._ImportedCssVisitor_visitCssAtRule_closure0, E._ImportedCssVisitor_visitCssMediaRule_closure0, E._ImportedCssVisitor_visitCssStyleRule_closure0, E._ImportedCssVisitor_visitCssSupportsRule_closure0, R._EvaluateVisitor_closure, R._EvaluateVisitor_closure0, R._EvaluateVisitor_closure1, R._EvaluateVisitor_closure2, R._EvaluateVisitor_closure3, R._EvaluateVisitor_closure4, R._EvaluateVisitor_closure5, R._EvaluateVisitor_closure6, R._EvaluateVisitor__closure1, R._EvaluateVisitor_closure7, R._EvaluateVisitor__closure, R._EvaluateVisitor__closure0, R._EvaluateVisitor_run_closure, R._EvaluateVisitor_runExpression_closure, R._EvaluateVisitor__withWarnCallback_closure, R._EvaluateVisitor__loadModule_closure, R._EvaluateVisitor__loadModule__closure, R._EvaluateVisitor__execute_closure, R._EvaluateVisitor__execute__closure, R._EvaluateVisitor__combineCss_closure, R._EvaluateVisitor__combineCss_closure0, R._EvaluateVisitor__combineCss_closure1, R._EvaluateVisitor__extendModules_closure, R._EvaluateVisitor__extendModules_closure0, R._EvaluateVisitor__topologicalModules_visitModule, R._EvaluateVisitor_visitAtRootRule_closure, R._EvaluateVisitor_visitAtRootRule_closure0, R._EvaluateVisitor_visitAtRootRule_closure1, R._EvaluateVisitor__scopeForAtRoot_closure, R._EvaluateVisitor__scopeForAtRoot_closure0, R._EvaluateVisitor__scopeForAtRoot_closure1, R._EvaluateVisitor__scopeForAtRoot__closure, R._EvaluateVisitor__scopeForAtRoot_closure2, R._EvaluateVisitor__scopeForAtRoot_closure3, R._EvaluateVisitor__scopeForAtRoot_closure4, R._EvaluateVisitor_visitContentRule_closure, R._EvaluateVisitor_visitDeclaration_closure, R._EvaluateVisitor_visitEachRule_closure, R._EvaluateVisitor_visitEachRule_closure0, R._EvaluateVisitor_visitEachRule_closure1, R._EvaluateVisitor_visitEachRule__closure, R._EvaluateVisitor_visitEachRule___closure, R._EvaluateVisitor_visitExtendRule_closure, R._EvaluateVisitor_visitAtRule_closure, R._EvaluateVisitor_visitAtRule__closure, R._EvaluateVisitor_visitAtRule_closure0, R._EvaluateVisitor_visitForRule_closure, R._EvaluateVisitor_visitForRule_closure0, R._EvaluateVisitor_visitForRule_closure1, R._EvaluateVisitor_visitForRule_closure2, R._EvaluateVisitor_visitForRule_closure3, R._EvaluateVisitor_visitForRule__closure, R._EvaluateVisitor_visitForwardRule_closure, R._EvaluateVisitor_visitIfRule_closure, R._EvaluateVisitor_visitIfRule__closure, R._EvaluateVisitor__visitDynamicImport_closure, R._EvaluateVisitor__visitDynamicImport__closure, R._EvaluateVisitor__visitDynamicImport__closure0, R._EvaluateVisitor_visitIncludeRule_closure, R._EvaluateVisitor_visitIncludeRule_closure0, R._EvaluateVisitor_visitIncludeRule__closure, R._EvaluateVisitor_visitIncludeRule___closure, R._EvaluateVisitor_visitMediaRule_closure, R._EvaluateVisitor_visitMediaRule__closure, R._EvaluateVisitor_visitMediaRule___closure, R._EvaluateVisitor_visitMediaRule_closure0, R._EvaluateVisitor__visitMediaQueries_closure, R._EvaluateVisitor_visitStyleRule_closure, R._EvaluateVisitor_visitStyleRule_closure0, R._EvaluateVisitor_visitStyleRule_closure1, R._EvaluateVisitor_visitStyleRule_closure2, R._EvaluateVisitor_visitStyleRule_closure3, R._EvaluateVisitor_visitStyleRule_closure4, R._EvaluateVisitor_visitStyleRule__closure, R._EvaluateVisitor_visitStyleRule_closure5, R._EvaluateVisitor_visitSupportsRule_closure, R._EvaluateVisitor_visitSupportsRule__closure, R._EvaluateVisitor_visitSupportsRule_closure0, R._EvaluateVisitor_visitVariableDeclaration_closure, R._EvaluateVisitor_visitVariableDeclaration_closure0, R._EvaluateVisitor_visitUseRule_closure, R._EvaluateVisitor_visitWarnRule_closure, R._EvaluateVisitor_visitWhileRule_closure, R._EvaluateVisitor_visitWhileRule__closure, R._EvaluateVisitor_visitBinaryOperationExpression_closure, R._EvaluateVisitor_visitVariableExpression_closure, R._EvaluateVisitor_visitListExpression_closure, R._EvaluateVisitor_visitFunctionExpression_closure, R._EvaluateVisitor__runUserDefinedCallable_closure, R._EvaluateVisitor__runUserDefinedCallable__closure, R._EvaluateVisitor__runUserDefinedCallable___closure, R._EvaluateVisitor__runUserDefinedCallable____closure, R._EvaluateVisitor__runFunctionCallable_closure, R._EvaluateVisitor__runBuiltInCallable_closure, R._EvaluateVisitor__runBuiltInCallable_closure0, R._EvaluateVisitor__evaluateArguments_closure, R._EvaluateVisitor__evaluateArguments_closure0, R._EvaluateVisitor__evaluateArguments_closure1, R._EvaluateVisitor__evaluateArguments_closure2, R._EvaluateVisitor__evaluateArguments_closure3, R._EvaluateVisitor__evaluateArguments_closure4, R._EvaluateVisitor__evaluateArguments_closure5, R._EvaluateVisitor__evaluateMacroArguments_closure, R._EvaluateVisitor__evaluateMacroArguments_closure0, R._EvaluateVisitor__evaluateMacroArguments_closure1, R._EvaluateVisitor__evaluateMacroArguments_closure2, R._EvaluateVisitor__addRestMap_closure, R._EvaluateVisitor__addRestMap_closure0, R._EvaluateVisitor__verifyArguments_closure, R._EvaluateVisitor_visitStringExpression_closure, R._EvaluateVisitor_visitCssAtRule_closure, R._EvaluateVisitor_visitCssAtRule_closure0, R._EvaluateVisitor_visitCssKeyframeBlock_closure, R._EvaluateVisitor_visitCssKeyframeBlock_closure0, R._EvaluateVisitor_visitCssMediaRule_closure, R._EvaluateVisitor_visitCssMediaRule__closure, R._EvaluateVisitor_visitCssMediaRule___closure, R._EvaluateVisitor_visitCssMediaRule_closure0, R._EvaluateVisitor_visitCssStyleRule_closure, R._EvaluateVisitor_visitCssStyleRule__closure, R._EvaluateVisitor_visitCssStyleRule_closure0, R._EvaluateVisitor_visitCssSupportsRule_closure, R._EvaluateVisitor_visitCssSupportsRule__closure, R._EvaluateVisitor_visitCssSupportsRule_closure0, R._EvaluateVisitor__performInterpolation_closure, R._EvaluateVisitor__serialize_closure, R._EvaluateVisitor__stackTrace_closure, R._ImportedCssVisitor_visitCssAtRule_closure, R._ImportedCssVisitor_visitCssMediaRule_closure, R._ImportedCssVisitor_visitCssStyleRule_closure, R._ImportedCssVisitor_visitCssSupportsRule_closure, N.serialize_closure, N._SerializeVisitor_visitCssComment_closure, N._SerializeVisitor_visitCssAtRule_closure, N._SerializeVisitor_visitCssMediaRule_closure, N._SerializeVisitor_visitCssImport_closure, N._SerializeVisitor_visitCssImport__closure, N._SerializeVisitor_visitCssKeyframeBlock_closure, N._SerializeVisitor_visitCssStyleRule_closure, N._SerializeVisitor_visitCssSupportsRule_closure, N._SerializeVisitor_visitCssDeclaration_closure, N._SerializeVisitor_visitCssDeclaration_closure0, N._SerializeVisitor_visitList_closure, N._SerializeVisitor_visitList_closure0, N._SerializeVisitor_visitList_closure1, N._SerializeVisitor_visitMap_closure, N._SerializeVisitor_visitSelectorList_closure, N._SerializeVisitor__write_closure, N._SerializeVisitor__visitChildren_closure, N.withWarnCallback_closure, T.SingleMapping_SingleMapping$fromEntries_closure, T.SingleMapping_SingleMapping$fromEntries_closure0, T.SingleMapping_SingleMapping$fromEntries_closure1, T.SingleMapping_toJson_closure, T.SingleMapping_toJson_closure0, U.Highlighter__writeFirstLine_closure, U.Highlighter__writeFirstLine_closure0, U.Highlighter__writeFirstLine_closure1, U.Highlighter__writeFirstLine_closure2, U.Highlighter__writeIntermediateLines_closure, U.Highlighter__writeLastLine_closure, U.Highlighter__writeLastLine_closure0, U.Highlighter__writeLastLine_closure1, U.Highlighter__writeSidebar_closure, U.Chain_Chain$parse_closure, U.Chain_Chain$parse_closure0, U.Chain_toTrace_closure, U.Chain_toString_closure0, U.Chain_toString__closure0, U.Chain_toString_closure, U.Chain_toString__closure, A.Frame_Frame$parseVM_closure, A.Frame_Frame$parseV8_closure, A.Frame_Frame$parseV8_closure_parseLocation, A.Frame_Frame$parseFirefox_closure, A.Frame_Frame$parseFriendly_closure, T.LazyTrace_terse_closure, Y.Trace_Trace$from_closure, Y.Trace__parseVM_closure, Y.Trace$parseV8_closure, Y.Trace$parseV8_closure0, Y.Trace$parseJSCore_closure, Y.Trace$parseJSCore_closure0, Y.Trace$parseFirefox_closure, Y.Trace$parseFirefox_closure0, Y.Trace$parseFriendly_closure, Y.Trace$parseFriendly_closure0, Y.Trace_terse_closure, Y.Trace_foldFrames_closure, Y.Trace_foldFrames_closure0, Y.Trace_toString_closure0, Y.Trace_toString_closure, T._debounceAggregate_closure, T._debounceAggregate__closure, T._debounceAggregate_closure0, L._StreamTransformer_bind_closure, L._StreamTransformer_bind__closure, L._StreamTransformer_bind__closure1, L._StreamTransformer_bind__closure0, L._StreamTransformer_bind__closure2]);
    _inherit(H.ConstantProtoMap, H.ConstantStringMap);
    _inherit(H.Instantiation1, H.Instantiation);
    _inheritMany(P.Error, [H.NullError, H.JsNoSuchMethodError, H.UnknownJsTypeError, H.CastErrorImplementation, H.RuntimeError, P.JsonUnsupportedObjectError, P.NullThrownError, P.ArgumentError, P.NoSuchMethodError, P.UnsupportedError, P.UnimplementedError, P.StateError, P.ConcurrentModificationError, P.CyclicInitializationError]);
    _inheritMany(H.TearOffClosure, [H.StaticClosure, H.BoundClosure]);
    _inherit(P.MapBase, P.MapMixin);
    _inheritMany(P.MapBase, [H.JsLinkedHashMap, P._HashMap, P.UnmodifiableMapBase, Z.MergedMapView]);
    _inheritMany(P.IterableBase, [H._AllMatchesIterable, P._SyncStarIterable, O.EmptyUnmodifiableSet, F._PrefixedKeys]);
    _inherit(H.NativeTypedArray, H.NativeTypedData);
    _inheritMany(H.NativeTypedArray, [H._NativeTypedArrayOfDouble_NativeTypedArray_ListMixin, H._NativeTypedArrayOfInt_NativeTypedArray_ListMixin]);
    _inherit(H._NativeTypedArrayOfDouble_NativeTypedArray_ListMixin_FixedLengthListMixin, H._NativeTypedArrayOfDouble_NativeTypedArray_ListMixin);
    _inherit(H.NativeTypedArrayOfDouble, H._NativeTypedArrayOfDouble_NativeTypedArray_ListMixin_FixedLengthListMixin);
    _inherit(H._NativeTypedArrayOfInt_NativeTypedArray_ListMixin_FixedLengthListMixin, H._NativeTypedArrayOfInt_NativeTypedArray_ListMixin);
    _inherit(H.NativeTypedArrayOfInt, H._NativeTypedArrayOfInt_NativeTypedArray_ListMixin_FixedLengthListMixin);
    _inheritMany(H.NativeTypedArrayOfDouble, [H.NativeFloat32List, H.NativeFloat64List]);
    _inheritMany(H.NativeTypedArrayOfInt, [H.NativeInt16List, H.NativeInt32List, H.NativeInt8List, H.NativeUint16List, H.NativeUint32List, H.NativeUint8ClampedList, H.NativeUint8List]);
    _inheritMany(P.Stream, [P._StreamImpl, P._ForwardingStream, Y._CompleterStream]);
    _inherit(P._ControllerStream, P._StreamImpl);
    _inherit(P._BroadcastStream, P._ControllerStream);
    _inheritMany(P._BufferingStreamSubscription, [P._ControllerSubscription, P._ForwardingStreamSubscription]);
    _inherit(P._BroadcastSubscription, P._ControllerSubscription);
    _inherit(P._SyncBroadcastStreamController, P._BroadcastStreamController);
    _inheritMany(P._Completer, [P._AsyncCompleter, P._SyncCompleter]);
    _inheritMany(P._StreamController, [P._AsyncStreamController, P._SyncStreamController]);
    _inherit(P._StreamControllerAddStreamState, P._AddStreamState);
    _inheritMany(P._DelayedEvent, [P._DelayedData, P._DelayedError]);
    _inherit(P._StreamImplEvents, P._PendingEvents);
    _inherit(P._ExpandStream, P._ForwardingStream);
    _inheritMany(P._Zone, [P._CustomZone, P._RootZone]);
    _inheritMany(H.JsLinkedHashMap, [P._LinkedIdentityHashMap, P._LinkedCustomHashMap]);
    _inherit(P._LinkedHashSet, P._SetBase);
    _inherit(P._LinkedIdentityHashSet, P._LinkedHashSet);
    _inheritMany(P.Codec, [P.Encoding, P.Base64Codec, P.JsonCodec]);
    _inheritMany(P.Encoding, [P.AsciiCodec, P.Utf8Codec]);
    _inheritMany(P.StreamTransformerBase, [P.Converter, L._StreamTransformer]);
    _inheritMany(P.Converter, [P._UnicodeSubsetEncoder, P.Base64Encoder, P.JsonEncoder, P.Utf8Encoder, P.Utf8Decoder]);
    _inherit(P.AsciiEncoder, P._UnicodeSubsetEncoder);
    _inherit(P._BufferCachingBase64Encoder, P._Base64Encoder);
    _inherit(P.ByteConversionSink, P.ChunkedConversionSink);
    _inheritMany(P.ByteConversionSink, [P.ByteConversionSinkBase, P._Utf8StringSinkAdapter, P._Utf8ConversionSink]);
    _inherit(P._Base64EncoderSink, P.ByteConversionSinkBase);
    _inheritMany(P._Base64EncoderSink, [P._AsciiBase64EncoderSink, P._Utf8Base64EncoderSink]);
    _inherit(P.JsonCyclicError, P.JsonUnsupportedObjectError);
    _inherit(P._JsonStringStringifier, P._JsonStringifier);
    _inherit(P.StringConversionSinkBase, P.StringConversionSinkMixin);
    _inheritMany(P.StringConversionSinkBase, [P._StringSinkConversionSink, P._StringAdapterSink]);
    _inherit(P._StringCallbackSink, P._StringSinkConversionSink);
    _inheritMany(P.num, [P.double, P.int]);
    _inheritMany(P.ArgumentError, [P.RangeError, P.IndexError]);
    _inherit(P._DataUri, P._Uri);
    _inherit(Z.ArgParserException, P.FormatException);
    _inherit(Q.QueueList, Q._QueueList_Object_ListMixin);
    _inherit(Q._CastQueueList, Q.QueueList);
    _inheritMany(M._DelegatingIterableBase, [M.DelegatingIterable, M._MapKeySet__DelegatingIterableBase_UnmodifiableSetMixin]);
    _inherit(M.DelegatingSet, M.DelegatingIterable);
    _inherit(L._UnmodifiableSetView_DelegatingSet_UnmodifiableSetMixin, M.DelegatingSet);
    _inherit(L.UnmodifiableSetView, L._UnmodifiableSetView_DelegatingSet_UnmodifiableSetMixin);
    _inherit(M.MapKeySet, M._MapKeySet__DelegatingIterableBase_UnmodifiableSetMixin);
    _inherit(B.InternalStyle, O.Style);
    _inheritMany(B.InternalStyle, [E.PosixStyle, F.UrlStyle, L.WindowsStyle]);
    _inheritMany(B.AstNode, [B.CssNode, B.SassNode]);
    _inheritMany(B.CssNode, [B.ModifiableCssNode, B.CssParentNode]);
    _inheritMany(B.ModifiableCssNode, [B.ModifiableCssParentNode, R.ModifiableCssComment, L.ModifiableCssDeclaration, F.ModifiableCssImport]);
    _inheritMany(B.ModifiableCssParentNode, [U.ModifiableCssAtRule, U.ModifiableCssKeyframeBlock, G.ModifiableCssMediaRule, X.ModifiableCssStyleRule, V.ModifiableCssStylesheet, B.ModifiableCssSupportsRule]);
    _inheritMany(B.CssParentNode, [X.CssStyleRule, V.CssStylesheet]);
    _inheritMany(M.ParentStatement, [V.AtRootRule, U.AtRule, M.CallableDeclaration, L.Declaration, V.EachRule, B.ForRule, G.MediaRule, X.StyleRule, V.Stylesheet, B.SupportsRule, G.WhileRule]);
    _inheritMany(M.CallableDeclaration, [Y.ContentBlock, M.FunctionRule, T.MixinRule]);
    _inherit(N.SupportsCondition, B.SassNode);
    _inheritMany(T.Selector, [M.SimpleSelector, S.ComplexSelector, X.CompoundSelector, D.SelectorList]);
    _inheritMany(M.SimpleSelector, [N.AttributeSelector, X.ClassSelector, N.IDSelector, M.ParentSelector, N.PlaceholderSelector, D.PseudoSelector, F.TypeSelector, N.UniversalSelector]);
    _inherit(D.Callable, B.AsyncCallable);
    _inheritMany(G.SourceSpanException, [E.SassException, G.SourceSpanFormatException]);
    _inheritMany(E.SassException, [E.SassRuntimeException, E.SassFormatException]);
    _inherit(A.MergedExtension, S.Extension);
    _inherit(M.Importer, B.AsyncImporter);
    _inherit(F.FilesystemImporter, M.Importer);
    _inheritMany(G.Parser, [V.AtRootQueryParser, V.StylesheetParser, E.KeyframeSelectorParser, F.MediaQueryParser, T.SelectorParser]);
    _inheritMany(V.StylesheetParser, [L.ScssParser, U.SassParser]);
    _inherit(Q.CssParser, L.ScssParser);
    _inheritMany(P.UnmodifiableMapBase, [K.LimitedMapView, F.PrefixedMapView, U.PublicMemberMapView]);
    _inheritMany(F.Value, [D.SassList, Z.SassBoolean, K.SassColor, F.SassFunction, A.SassMap, O.SassNull, T.SassNumber, D.SassString]);
    _inherit(D.SassArgumentList, D.SassList);
    _inherit(L._FindImportsVisitor, D.RecursiveStatementVisitor);
    _inherit(T.SingleMapping, T.Mapping);
    _inherit(Y.FileLocation, D.SourceLocationMixin);
    _inheritMany(Y.SourceSpanMixin, [Y._FileSpan, V.SourceSpanBase]);
    _inherit(X.SourceSpanWithContext, V.SourceSpanBase);
    _inherit(E.StringScannerException, G.SourceSpanFormatException);
    _inheritMany(X.StringScanner, [Z.LineScanner, S.SpanScanner]);
    _mixin(H.UnmodifiableListBase, H.UnmodifiableListMixin);
    _mixin(H.__CastListBase__CastIterableBase_ListMixin, P.ListMixin);
    _mixin(H._NativeTypedArrayOfDouble_NativeTypedArray_ListMixin, P.ListMixin);
    _mixin(H._NativeTypedArrayOfDouble_NativeTypedArray_ListMixin_FixedLengthListMixin, H.FixedLengthListMixin);
    _mixin(H._NativeTypedArrayOfInt_NativeTypedArray_ListMixin, P.ListMixin);
    _mixin(H._NativeTypedArrayOfInt_NativeTypedArray_ListMixin_FixedLengthListMixin, H.FixedLengthListMixin);
    _mixin(P._AsyncStreamController, P._AsyncStreamControllerDispatch);
    _mixin(P._SyncStreamController, P._SyncStreamControllerDispatch);
    _mixin(P.UnmodifiableMapBase, P._UnmodifiableMapMixin);
    _mixin(P._ListBase_Object_ListMixin, P.ListMixin);
    _mixin(P._UnmodifiableMapView_MapView__UnmodifiableMapMixin, P._UnmodifiableMapMixin);
    _mixin(Q._QueueList_Object_ListMixin, P.ListMixin);
    _mixin(L._UnmodifiableSetView_DelegatingSet_UnmodifiableSetMixin, L.UnmodifiableSetMixin);
    _mixin(M._MapKeySet__DelegatingIterableBase_UnmodifiableSetMixin, L.UnmodifiableSetMixin);
  })();
  (function constants() {
    var makeConstList = hunkHelpers.makeConstList;
    C.Interceptor_methods = J.Interceptor.prototype;
    C.JSArray_methods = J.JSArray.prototype;
    C.JSBool_methods = J.JSBool.prototype;
    C.JSDouble_methods = J.JSDouble.prototype;
    C.JSInt_methods = J.JSInt.prototype;
    C.JSNumber_methods = J.JSNumber.prototype;
    C.JSString_methods = J.JSString.prototype;
    C.JavaScriptFunction_methods = J.JavaScriptFunction.prototype;
    C.NativeUint32List_methods = H.NativeUint32List.prototype;
    C.NativeUint8List_methods = H.NativeUint8List.prototype;
    C.PlainJavaScriptObject_methods = J.PlainJavaScriptObject.prototype;
    C.UnknownJavaScriptObject_methods = J.UnknownJavaScriptObject.prototype;
    C.AsciiEncoder_127 = new P.AsciiEncoder(127);
    C.C_EmptyUnmodifiableSet0 = new O.EmptyUnmodifiableSet([P.String]);
    C.AtRootQuery_UsS = new V.AtRootQuery(false, C.C_EmptyUnmodifiableSet0, false, true);
    C.AttributeOperator_4L5 = new N.AttributeOperator("^=");
    C.AttributeOperator_AuK = new N.AttributeOperator("|=");
    C.AttributeOperator_fz1 = new N.AttributeOperator("~=");
    C.AttributeOperator_gqZ = new N.AttributeOperator("*=");
    C.AttributeOperator_mOX = new N.AttributeOperator("$=");
    C.AttributeOperator_sEs = new N.AttributeOperator("=");
    C.BinaryOperator_1da = new V.BinaryOperator("greater than or equals", ">=", 4);
    C.BinaryOperator_2ad = new V.BinaryOperator("modulo", "%", 6);
    C.BinaryOperator_33h = new V.BinaryOperator("less than or equals", "<=", 4);
    C.BinaryOperator_8qt = new V.BinaryOperator("less than", "<", 4);
    C.BinaryOperator_AcR = new V.BinaryOperator("greater than", ">", 4);
    C.BinaryOperator_AcR0 = new V.BinaryOperator("plus", "+", 5);
    C.BinaryOperator_O1M = new V.BinaryOperator("times", "*", 6);
    C.BinaryOperator_RTB = new V.BinaryOperator("divided by", "/", 6);
    C.BinaryOperator_YlX = new V.BinaryOperator("equals", "==", 3);
    C.BinaryOperator_and_and_2 = new V.BinaryOperator("and", "and", 2);
    C.BinaryOperator_i5H = new V.BinaryOperator("not equals", "!=", 3);
    C.BinaryOperator_iyO = new V.BinaryOperator("minus", "-", 5);
    C.BinaryOperator_kjl = new V.BinaryOperator("single equals", "=", 0);
    C.BinaryOperator_or_or_1 = new V.BinaryOperator("or", "or", 1);
    C.C_AsciiCodec = new P.AsciiCodec();
    C.C_AsciiGlyphSet = new A.AsciiGlyphSet();
    C.C_Base64Encoder = new P.Base64Encoder();
    C.C_Base64Codec = new P.Base64Codec();
    C.C_DefaultEquality = new U.DefaultEquality();
    C.C_EmptyExtender = new T.EmptyExtender();
    C.C_EmptyIterator = new H.EmptyIterator();
    C.C_EmptyUnmodifiableSet = new O.EmptyUnmodifiableSet([M.SimpleSelector]);
    C.C_JS_CONST = function getTagFallback(o) {
  var s = Object.prototype.toString.call(o);
  return s.substring(8, s.length - 1);
};
    C.C_JS_CONST0 = function() {
  var toStringFunction = Object.prototype.toString;
  function getTag(o) {
    var s = toStringFunction.call(o);
    return s.substring(8, s.length - 1);
  }
  function getUnknownTag(object, tag) {
    if (/^HTML[A-Z].*Element$/.test(tag)) {
      var name = toStringFunction.call(object);
      if (name == "[object Object]") return null;
      return "HTMLElement";
    }
  }
  function getUnknownTagGenericBrowser(object, tag) {
    if (self.HTMLElement && object instanceof HTMLElement) return "HTMLElement";
    return getUnknownTag(object, tag);
  }
  function prototypeForTag(tag) {
    if (typeof window == "undefined") return null;
    if (typeof window[tag] == "undefined") return null;
    var constructor = window[tag];
    if (typeof constructor != "function") return null;
    return constructor.prototype;
  }
  function discriminator(tag) { return null; }
  var isBrowser = typeof navigator == "object";
  return {
    getTag: getTag,
    getUnknownTag: isBrowser ? getUnknownTagGenericBrowser : getUnknownTag,
    prototypeForTag: prototypeForTag,
    discriminator: discriminator };
};
    C.C_JS_CONST6 = function(getTagFallback) {
  return function(hooks) {
    if (typeof navigator != "object") return hooks;
    var ua = navigator.userAgent;
    if (ua.indexOf("DumpRenderTree") >= 0) return hooks;
    if (ua.indexOf("Chrome") >= 0) {
      function confirm(p) {
        return typeof window == "object" && window[p] && window[p].name == p;
      }
      if (confirm("Window") && confirm("HTMLElement")) return hooks;
    }
    hooks.getTag = getTagFallback;
  };
};
    C.C_JS_CONST1 = function(hooks) {
  if (typeof dartExperimentalFixupGetTag != "function") return hooks;
  hooks.getTag = dartExperimentalFixupGetTag(hooks.getTag);
};
    C.C_JS_CONST2 = function(hooks) {
  var getTag = hooks.getTag;
  var prototypeForTag = hooks.prototypeForTag;
  function getTagFixed(o) {
    var tag = getTag(o);
    if (tag == "Document") {
      if (!!o.xmlVersion) return "!Document";
      return "!HTMLDocument";
    }
    return tag;
  }
  function prototypeForTagFixed(tag) {
    if (tag == "Document") return null;
    return prototypeForTag(tag);
  }
  hooks.getTag = getTagFixed;
  hooks.prototypeForTag = prototypeForTagFixed;
};
    C.C_JS_CONST5 = function(hooks) {
  var userAgent = typeof navigator == "object" ? navigator.userAgent : "";
  if (userAgent.indexOf("Firefox") == -1) return hooks;
  var getTag = hooks.getTag;
  var quickMap = {
    "BeforeUnloadEvent": "Event",
    "DataTransfer": "Clipboard",
    "GeoGeolocation": "Geolocation",
    "Location": "!Location",
    "WorkerMessageEvent": "MessageEvent",
    "XMLDocument": "!Document"};
  function getTagFirefox(o) {
    var tag = getTag(o);
    return quickMap[tag] || tag;
  }
  hooks.getTag = getTagFirefox;
};
    C.C_JS_CONST4 = function(hooks) {
  var userAgent = typeof navigator == "object" ? navigator.userAgent : "";
  if (userAgent.indexOf("Trident/") == -1) return hooks;
  var getTag = hooks.getTag;
  var quickMap = {
    "BeforeUnloadEvent": "Event",
    "DataTransfer": "Clipboard",
    "HTMLDDElement": "HTMLElement",
    "HTMLDTElement": "HTMLElement",
    "HTMLPhraseElement": "HTMLElement",
    "Position": "Geoposition"
  };
  function getTagIE(o) {
    var tag = getTag(o);
    var newTag = quickMap[tag];
    if (newTag) return newTag;
    if (tag == "Object") {
      if (window.DataView && (o instanceof window.DataView)) return "DataView";
    }
    return tag;
  }
  function prototypeForTagIE(tag) {
    var constructor = window[tag];
    if (constructor == null) return null;
    return constructor.prototype;
  }
  hooks.getTag = getTagIE;
  hooks.prototypeForTag = prototypeForTagIE;
};
    C.C_JS_CONST3 = function(hooks) { return hooks; }
;
    C.C_JsonCodec = new P.JsonCodec();
    C.C_ListEquality = new U.ListEquality();
    C.C_MapEquality = new U.MapEquality();
    C.C_OutOfMemoryError = new P.OutOfMemoryError();
    C.C_SassNull = new O.SassNull();
    C.C_UnicodeGlyphSet = new K.UnicodeGlyphSet();
    C.C_Utf8Codec = new P.Utf8Codec();
    C.C_Utf8Encoder = new P.Utf8Encoder();
    C.C__DelayedDone = new P._DelayedDone();
    C.C__JSRandom = new P._JSRandom();
    C.C__RootZone = new P._RootZone();
    C.ChangeType_add = new E.ChangeType("add");
    C.ChangeType_modify = new E.ChangeType("modify");
    C.ChangeType_remove = new E.ChangeType("remove");
    C.Combinator_CzM = new S.Combinator("~");
    C.Combinator_sgq = new S.Combinator(">");
    C.Combinator_uzg = new S.Combinator("+");
    C.Duration_0 = new P.Duration(0);
    C.ExtendMode_allTargets = new L.ExtendMode("allTargets");
    C.ExtendMode_normal = new L.ExtendMode("normal");
    C.ExtendMode_replace = new L.ExtendMode("replace");
    C.JsonEncoder_null = new P.JsonEncoder(null);
    C.LineFeed_D6m = new N.LineFeed("lf", "\n");
    C.LineFeed_Mss = new N.LineFeed("crlf", "\r\n");
    C.LineFeed_a1Y = new N.LineFeed("lfcr", "\n\r");
    C.LineFeed_kMT = new N.LineFeed("cr", "\r");
    C.ListSeparator_comma = new D.ListSeparator("comma");
    C.ListSeparator_space = new D.ListSeparator("space");
    C.ListSeparator_undecided = new D.ListSeparator("undecided");
    C.List_127_2047_65535_1114111 = H.setRuntimeTypeInfo(makeConstList([127, 2047, 65535, 1114111]), [P.int]);
    C.List_2Vk = H.setRuntimeTypeInfo(makeConstList([0, 0, 32776, 33792, 1, 10240, 0, 0]), [P.int]);
    C.List_CVk = H.setRuntimeTypeInfo(makeConstList([0, 0, 65490, 45055, 65535, 34815, 65534, 18431]), [P.int]);
    C.List_JYB = H.setRuntimeTypeInfo(makeConstList([0, 0, 26624, 1023, 65534, 2047, 65534, 2047]), [P.int]);
    C.List_empty9 = H.setRuntimeTypeInfo(makeConstList([]), [Z.Argument]);
    C.List_empty11 = H.setRuntimeTypeInfo(makeConstList([]), [B.AsyncCallable]);
    C.List_empty13 = H.setRuntimeTypeInfo(makeConstList([]), [B.AsyncImporter]);
    C.List_empty7 = H.setRuntimeTypeInfo(makeConstList([]), [S.ComplexSelector]);
    C.List_empty3 = H.setRuntimeTypeInfo(makeConstList([]), [B.CssNode]);
    C.List_empty8 = H.setRuntimeTypeInfo(makeConstList([]), [T.Expression]);
    C.List_empty5 = H.setRuntimeTypeInfo(makeConstList([]), [S.Extension]);
    C.List_empty10 = H.setRuntimeTypeInfo(makeConstList([]), [M.Importer]);
    C.List_empty12 = H.setRuntimeTypeInfo(makeConstList([]), [[G.Module, B.AsyncCallable]]);
    C.List_empty2 = H.setRuntimeTypeInfo(makeConstList([]), [[G.Module, D.Callable]]);
    C.List_empty6 = H.setRuntimeTypeInfo(makeConstList([]), [[G.Module, P.Null]]);
    C.List_empty14 = H.setRuntimeTypeInfo(makeConstList([]), [P.Null]);
    C.List_empty0 = H.setRuntimeTypeInfo(makeConstList([]), [P.String]);
    C.List_empty1 = H.setRuntimeTypeInfo(makeConstList([]), [F.Value]);
    C.List_empty4 = H.setRuntimeTypeInfo(makeConstList([]), [P.int]);
    C.List_empty = makeConstList([]);
    C.List_gRj = H.setRuntimeTypeInfo(makeConstList([0, 0, 32722, 12287, 65534, 34815, 65534, 18431]), [P.int]);
    C.List_nxB = H.setRuntimeTypeInfo(makeConstList([0, 0, 24576, 1023, 65534, 34815, 65534, 18431]), [P.int]);
    C.List_qFt = H.setRuntimeTypeInfo(makeConstList([0, 0, 27858, 1023, 65534, 51199, 65535, 32767]), [P.int]);
    C.List_qNA = H.setRuntimeTypeInfo(makeConstList([0, 0, 32754, 11263, 65534, 34815, 65534, 18431]), [P.int]);
    C.List_qg40 = H.setRuntimeTypeInfo(makeConstList([0, 0, 32722, 12287, 65535, 34815, 65534, 18431]), [P.int]);
    C.List_qg4 = H.setRuntimeTypeInfo(makeConstList([0, 0, 65490, 12287, 65535, 34815, 65534, 18431]), [P.int]);
    C.Map_empty3 = new H.ConstantStringMap(0, {}, C.List_empty0, [P.String, B.AstNode]);
    C.Map_empty5 = new H.ConstantStringMap(0, {}, C.List_empty0, [P.String, T.Expression]);
    C.Map_empty6 = new H.ConstantStringMap(0, {}, C.List_empty0, [P.String, [G.Module, B.AsyncCallable]]);
    C.Map_empty1 = new H.ConstantStringMap(0, {}, C.List_empty0, [P.String, [G.Module, D.Callable]]);
    C.Map_empty2 = new H.ConstantStringMap(0, {}, C.List_empty0, [P.String, P.Null]);
    C.Map_empty0 = new H.ConstantStringMap(0, {}, C.List_empty0, [P.String, Y.SourceFile]);
    C.Map_empty7 = new H.ConstantStringMap(0, {}, C.List_empty0, [P.String, P.String]);
    C.Map_empty4 = new H.ConstantStringMap(0, {}, C.List_empty0, [P.String, F.Value]);
    C.List_empty15 = H.setRuntimeTypeInfo(makeConstList([]), [P.Symbol]);
    C.Map_empty = new H.ConstantStringMap(0, {}, C.List_empty15, [P.Symbol, null]);
    C.OptionType_YwU = new G.OptionType("OptionType.single");
    C.OptionType_nMZ = new G.OptionType("OptionType.flag");
    C.OptionType_qyr = new G.OptionType("OptionType.multiple");
    C.OutputStyle_compressed = new N.OutputStyle("compressed");
    C.OutputStyle_expanded = new N.OutputStyle("expanded");
    C.SassBoolean_false = new Z.SassBoolean(false);
    C.SassBoolean_true = new Z.SassBoolean(true);
    C.SassList_lmy = new D.SassList(C.List_empty1, C.ListSeparator_comma, false);
    C.Map_empty8 = new H.ConstantStringMap(0, {}, C.List_empty1, [F.Value, F.Value]);
    C.SassMap_Map_empty = new A.SassMap(C.Map_empty8);
    C.StderrLogger_false = new S.StderrLogger(false);
    C.Symbol__warn = new H.Symbol0("_warn");
    C.Symbol_call = new H.Symbol0("call");
    C.Syntax_CSS = new M.Syntax("CSS");
    C.Syntax_SCSS = new M.Syntax("SCSS");
    C.Syntax_Sass = new M.Syntax("Sass");
    C.List_empty16 = H.setRuntimeTypeInfo(makeConstList([]), [X.CssStyleRule]);
    C.Map_empty9 = new H.ConstantStringMap(0, {}, C.List_empty16, [X.CssStyleRule, X.ModifiableCssStyleRule]);
    C.Tuple2_EmptyExtender_Map_empty = new S.Tuple2(C.C_EmptyExtender, C.Map_empty9, [F.Extender, [P.Map, X.CssStyleRule, X.ModifiableCssStyleRule]]);
    C.UnaryOperator_U4G = new X.UnaryOperator("minus", "-");
    C.UnaryOperator_j2w = new X.UnaryOperator("plus", "+");
    C.UnaryOperator_not_not = new X.UnaryOperator("not", "not");
    C.UnaryOperator_zDx = new X.UnaryOperator("divide", "/");
    C._IterationMarker_null_2 = new P._IterationMarker(null, 2);
    C._PathDirection_8Gl = new M._PathDirection("at root");
    C._PathDirection_988 = new M._PathDirection("below root");
    C._PathDirection_FIw = new M._PathDirection("reaches root");
    C._PathDirection_ZGD = new M._PathDirection("above root");
    C._PathRelation_different = new M._PathRelation("different");
    C._PathRelation_equal = new M._PathRelation("equal");
    C._PathRelation_inconclusive = new M._PathRelation("inconclusive");
    C._PathRelation_within = new M._PathRelation("within");
    C._SingletonCssMediaQueryMergeResult_empty = new F._SingletonCssMediaQueryMergeResult("empty");
    C._SingletonCssMediaQueryMergeResult_unrepresentable = new F._SingletonCssMediaQueryMergeResult("unrepresentable");
    C._StreamGroupState_canceled = new L._StreamGroupState("canceled");
    C._StreamGroupState_dormant = new L._StreamGroupState("dormant");
    C._StreamGroupState_listening = new L._StreamGroupState("listening");
    C._StreamGroupState_paused = new L._StreamGroupState("paused");
    C._ZoneFunction_3bB = new P._ZoneFunction(C.C__RootZone, P.async___rootCreatePeriodicTimer$closure());
    C._ZoneFunction_7G2 = new P._ZoneFunction(C.C__RootZone, P.async___rootRegisterBinaryCallback$closure());
    C._ZoneFunction_Eeh = new P._ZoneFunction(C.C__RootZone, P.async___rootRegisterUnaryCallback$closure());
    C._ZoneFunction_NMc = new P._ZoneFunction(C.C__RootZone, P.async___rootHandleUncaughtError$closure());
    C._ZoneFunction__RootZone__rootCreateTimer = new P._ZoneFunction(C.C__RootZone, P.async___rootCreateTimer$closure());
    C._ZoneFunction__RootZone__rootErrorCallback = new P._ZoneFunction(C.C__RootZone, P.async___rootErrorCallback$closure());
    C._ZoneFunction__RootZone__rootFork = new P._ZoneFunction(C.C__RootZone, P.async___rootFork$closure());
    C._ZoneFunction__RootZone__rootPrint = new P._ZoneFunction(C.C__RootZone, P.async___rootPrint$closure());
    C._ZoneFunction__RootZone__rootRegisterCallback = new P._ZoneFunction(C.C__RootZone, P.async___rootRegisterCallback$closure());
    C._ZoneFunction__RootZone__rootRun = new P._ZoneFunction(C.C__RootZone, P.async___rootRun$closure());
    C._ZoneFunction__RootZone__rootRunBinary = new P._ZoneFunction(C.C__RootZone, P.async___rootRunBinary$closure());
    C._ZoneFunction__RootZone__rootRunUnary = new P._ZoneFunction(C.C__RootZone, P.async___rootRunUnary$closure());
    C._ZoneFunction__RootZone__rootScheduleMicrotask = new P._ZoneFunction(C.C__RootZone, P.async___rootScheduleMicrotask$closure());
    C._ZoneSpecification_ALf = new P._ZoneSpecification(null, null, null, null, null, null, null, null, null, null, null, null, null);
  })();
  var init = {mangledGlobalNames: {int: "int", double: "double", num: "num", String: "String", bool: "bool", Null: "Null", List: "List"}, mangledNames: {}, getTypeFromName: getGlobalFromName, metadata: [], types: [{func: 1, ret: F.Value, args: [[P.List, F.Value]]}, {func: 1, ret: -1}, {func: 1, ret: D.SassString, args: [[P.List, F.Value]]}, {func: 1, ret: Z.SassBoolean, args: [[P.List, F.Value]]}, {func: 1, ret: T.SassNumber, args: [[P.List, F.Value]]}, {func: 1, ret: K.SassColor, args: [[P.List, F.Value]]}, {func: 1, ret: D.SassList, args: [[P.List, F.Value]]}, {func: 1, ret: P.bool, args: [P.Object]}, {func: 1, ret: -1, args: [P.Object]}, {func: 1, ret: A.SassMap, args: [[P.List, F.Value]]}, {func: 1, args: [,]}, {func: 1, ret: P.Null, opt: [,]}, {func: 1, ret: P.Null, args: [,,]}, {func: 1, ret: P.bool, args: [P.int]}, {func: 1, ret: -1, args: [P.Object], opt: [P.StackTrace]}, {func: 1, ret: P.String, args: [,,]}, {func: 1, ret: P.bool, args: [P.num, P.num]}, {func: 1, ret: P.Null, args: [,]}, {func: 1, ret: P.Null, args: [, P.StackTrace]}, {func: 1, ret: P.bool, args: [,]}, {func: 1, ret: P.String, args: [P.int]}, {func: 1, ret: P.String, args: [P.Object]}, {func: 1, ret: B.AstNode, args: [,,]}, {func: 1, ret: -1, args: [{func: 1, ret: -1}]}, {func: 1, ret: P.int, args: [P.num]}, {func: 1, ret: O.Statement}, {func: 1, ret: -1, opt: [[P.Future,,]]}, {func: 1, ret: P.String, args: [P.String]}, {func: 1, bounds: [P.Object], ret: [P.Set, 0]}, {func: 1, ret: -1, args: [,]}, {func: 1, ret: O.SassNull, args: [P.int]}, {func: 1, ret: P.String, args: [,]}, {func: 1, ret: -1, opt: [P.Object]}, {func: 1, ret: F.SassFunction, args: [[P.List, F.Value]]}, {func: 1, ret: P.bool, args: [B.CssNode]}, {func: 1, ret: [P.Future, P.String], args: [,]}, {func: 1, ret: [P.Future,,]}, {func: 1, ret: -1, args: [,], opt: [P.StackTrace]}, {func: 1, ret: [P.Iterable, P.String], args: [P.Object]}, {func: 1, ret: P.Null, args: [P.Object, P.Object]}, {func: 1, ret: -1, opt: [,]}, {func: 1, ret: -1, args: [, P.StackTrace]}, {func: 1, ret: T.SassNumber, args: [P.int]}, {func: 1, ret: P.String}, {func: 1, ret: O.Statement, named: {root: P.bool}}, {func: 1, ret: [P._Future,,], args: [,]}, {func: 1, ret: T.NumberExpression}, {func: 1, ret: S.Extension, args: [,]}, {func: 1, ret: P.Null, args: [[P.List, F.Value]]}, {func: 1, ret: [P.List, P.int], args: [P.int]}, {func: 1, ret: -1, args: [P.Object, P.StackTrace]}, {func: 1, ret: P.Null, args: [,], opt: [P.StackTrace]}, {func: 1, ret: P.Uint8List, args: [P.int]}, {func: 1, ret: -1, args: [F.CssMediaQuery]}, {func: 1, ret: Y.SourceFile, args: [P.int]}, {func: 1, ret: P.String, args: [P.String], named: {color: null}}, {func: 1, ret: A.Frame, args: [,,]}, {func: 1, ret: P.Uint8List, args: [,,]}, {func: 1, ret: P.bool, args: [S.ComplexSelector]}, {func: 1, ret: -1, args: [P.Zone, P.ZoneDelegate, P.Zone,, P.StackTrace]}, {func: 1, bounds: [P.Object], ret: 0, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, ret: 0}]}, {func: 1, bounds: [P.Object, P.Object], ret: 0, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, ret: 0, args: [1]}, 1]}, {func: 1, bounds: [P.Object, P.Object, P.Object], ret: 0, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, ret: 0, args: [1, 2]}, 1, 2]}, {func: 1, bounds: [P.Object], ret: {func: 1, ret: 0}, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, ret: 0}]}, {func: 1, bounds: [P.Object, P.Object], ret: {func: 1, ret: 0, args: [1]}, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, ret: 0, args: [1]}]}, {func: 1, ret: P.Object, args: [F.Value]}, {func: 1, ret: P.AsyncError, args: [P.Zone, P.ZoneDelegate, P.Zone, P.Object, P.StackTrace]}, {func: 1, ret: -1, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, ret: -1}]}, {func: 1, ret: P.Timer, args: [P.Zone, P.ZoneDelegate, P.Zone, P.Duration, {func: 1, ret: -1}]}, {func: 1, ret: P.Timer, args: [P.Zone, P.ZoneDelegate, P.Zone, P.Duration, {func: 1, ret: -1, args: [P.Timer]}]}, {func: 1, ret: -1, args: [P.Zone, P.ZoneDelegate, P.Zone, P.String]}, {func: 1, ret: -1, args: [P.String]}, {func: 1, ret: P.Zone, args: [P.Zone, P.ZoneDelegate, P.Zone, P.ZoneSpecification, [P.Map,,,]]}, {func: 1, ret: P.bool, args: [,,]}, {func: 1, ret: P.int, args: [,]}, {func: 1, ret: P.int, args: [P.Object]}, {func: 1, ret: P.bool, args: [P.Object, P.Object]}, {func: 1, ret: P.num, args: [P.num]}, {func: 1, bounds: [P.num], ret: 0, args: [0, 0]}, {func: 1, ret: P.bool, args: [M.SimpleSelector]}, {func: 1, ret: -1, args: [R.RenderOptions, {func: 1, ret: -1, args: [V.JSError, U.RenderResult]}]}, {func: 1, ret: U.RenderResult, args: [R.RenderOptions]}, {func: 1, ret: P.bool, args: [P.String]}, {func: 1, bounds: [P.Object], ret: [P.List, 0], args: [0, [P.List, 0]]}, {func: 1, bounds: [P.Object], ret: -1, args: [P.Object, P.StackTrace, [P.EventSink, 0]]}, {func: 1, bounds: [P.Object, P.Object, P.Object], ret: {func: 1, ret: 0, args: [1, 2]}, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, ret: 0, args: [1, 2]}]}, {func: 1, ret: P.int, args: [,,]}], interceptorsByTag: null, leafTags: null};
  (function staticFields() {
    $.printToZone = null;
    $.Closure_functionCounter = 0;
    $.BoundClosure_selfFieldNameCache = null;
    $.BoundClosure_receiverFieldNameCache = null;
    $.getTagFunction = null;
    $.alternateTagFunction = null;
    $.prototypeForTagFunction = null;
    $.dispatchRecordsForInstanceTags = null;
    $.interceptorsForUncacheableTags = null;
    $.initNativeDispatchFlag = null;
    $._nextCallback = null;
    $._lastCallback = null;
    $._lastPriorityCallback = null;
    $._isInCallbackLoop = false;
    $.Zone__current = C.C__RootZone;
    $._RootZone__rootDelegate = null;
    $._toStringVisiting = [];
    $._currentUriBase = null;
    $._current = null;
    $._subselectorPseudos = P.LinkedHashSet_LinkedHashSet$_literal(["matches", "any", "nth-child", "nth-last-child"], P.String);
    $._features = P.LinkedHashSet_LinkedHashSet$_literal(["global-variable-shadowing", "extend-selector-pseudoclass", "units-level-3", "at-error", "custom-property"], P.String);
    $._inUseRule = false;
    $._selectorPseudoClasses = P.LinkedHashSet_LinkedHashSet$_literal(["not", "matches", "current", "any", "has", "host", "host-context"], P.String);
    $._selectorPseudoElements = P.LinkedHashSet_LinkedHashSet$_literal(["slotted"], P.String);
    $._glyphs = C.C_UnicodeGlyphSet;
  })();
  (function lazyInitializers() {
    var _lazy = hunkHelpers.lazy;
    _lazy($, "DART_CLOSURE_PROPERTY_NAME", "$get$DART_CLOSURE_PROPERTY_NAME", function() {
      return H.getIsolateAffinityTag("_$dart_dartClosure");
    });
    _lazy($, "JS_INTEROP_INTERCEPTOR_TAG", "$get$JS_INTEROP_INTERCEPTOR_TAG", function() {
      return H.getIsolateAffinityTag("_$dart_js");
    });
    _lazy($, "TypeErrorDecoder_noSuchMethodPattern", "$get$TypeErrorDecoder_noSuchMethodPattern", function() {
      return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokeCallErrorOn({
        toString: function() {
          return "$receiver$";
        }
      }));
    });
    _lazy($, "TypeErrorDecoder_notClosurePattern", "$get$TypeErrorDecoder_notClosurePattern", function() {
      return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokeCallErrorOn({$method$: null,
        toString: function() {
          return "$receiver$";
        }
      }));
    });
    _lazy($, "TypeErrorDecoder_nullCallPattern", "$get$TypeErrorDecoder_nullCallPattern", function() {
      return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokeCallErrorOn(null));
    });
    _lazy($, "TypeErrorDecoder_nullLiteralCallPattern", "$get$TypeErrorDecoder_nullLiteralCallPattern", function() {
      return H.TypeErrorDecoder_extractPattern(function() {
        var $argumentsExpr$ = '$arguments$';
        try {
          null.$method$($argumentsExpr$);
        } catch (e) {
          return e.message;
        }
      }());
    });
    _lazy($, "TypeErrorDecoder_undefinedCallPattern", "$get$TypeErrorDecoder_undefinedCallPattern", function() {
      return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokeCallErrorOn(void 0));
    });
    _lazy($, "TypeErrorDecoder_undefinedLiteralCallPattern", "$get$TypeErrorDecoder_undefinedLiteralCallPattern", function() {
      return H.TypeErrorDecoder_extractPattern(function() {
        var $argumentsExpr$ = '$arguments$';
        try {
          (void 0).$method$($argumentsExpr$);
        } catch (e) {
          return e.message;
        }
      }());
    });
    _lazy($, "TypeErrorDecoder_nullPropertyPattern", "$get$TypeErrorDecoder_nullPropertyPattern", function() {
      return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokePropertyErrorOn(null));
    });
    _lazy($, "TypeErrorDecoder_nullLiteralPropertyPattern", "$get$TypeErrorDecoder_nullLiteralPropertyPattern", function() {
      return H.TypeErrorDecoder_extractPattern(function() {
        try {
          null.$method$;
        } catch (e) {
          return e.message;
        }
      }());
    });
    _lazy($, "TypeErrorDecoder_undefinedPropertyPattern", "$get$TypeErrorDecoder_undefinedPropertyPattern", function() {
      return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokePropertyErrorOn(void 0));
    });
    _lazy($, "TypeErrorDecoder_undefinedLiteralPropertyPattern", "$get$TypeErrorDecoder_undefinedLiteralPropertyPattern", function() {
      return H.TypeErrorDecoder_extractPattern(function() {
        try {
          (void 0).$method$;
        } catch (e) {
          return e.message;
        }
      }());
    });
    _lazy($, "_AsyncRun__scheduleImmediateClosure", "$get$_AsyncRun__scheduleImmediateClosure", function() {
      return P._AsyncRun__initializeScheduleImmediate();
    });
    _lazy($, "Future__nullFuture", "$get$Future__nullFuture", function() {
      return P._Future$zoneValue(null, C.C__RootZone, P.Null);
    });
    _lazy($, "Future__falseFuture", "$get$Future__falseFuture", function() {
      return P._Future$zoneValue(false, C.C__RootZone, P.bool);
    });
    _lazy($, "_RootZone__rootMap", "$get$_RootZone__rootMap", function() {
      return P.HashMap_HashMap(null, null);
    });
    _lazy($, "Utf8Decoder__decoder", "$get$Utf8Decoder__decoder", function() {
      return P.Utf8Decoder__makeDecoder();
    });
    _lazy($, "_Base64Decoder__inverseAlphabet", "$get$_Base64Decoder__inverseAlphabet", function() {
      return H.NativeInt8List__create1(H._ensureNativeList(H.setRuntimeTypeInfo([-2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -1, -2, -2, -2, -2, -2, 62, -2, 62, -2, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -2, -2, -2, -1, -2, -2, -2, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -2, -2, -2, -2, 63, -2, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -2, -2, -2, -2, -2], [P.int])));
    });
    _lazy($, "_Uri__isWindowsCached", "$get$_Uri__isWindowsCached", function() {
      return typeof process != "undefined" && Object.prototype.toString.call(process) == "[object process]" && process.platform == "win32";
    });
    _lazy($, "_Uri__needsNoEncoding", "$get$_Uri__needsNoEncoding", function() {
      return P.RegExp_RegExp("^[\\-\\.0-9A-Z_a-z~]*$", false);
    });
    _lazy($, "_hasErrorStackProperty", "$get$_hasErrorStackProperty", function() {
      return new Error().stack != void 0;
    });
    _lazy($, "_scannerTables", "$get$_scannerTables", function() {
      return P._createTables();
    });
    _lazy($, "Option__invalidChars", "$get$Option__invalidChars", function() {
      return P.RegExp_RegExp("[ \\t\\r\\n\"'\\\\/]", false);
    });
    _lazy($, "_soloOpt", "$get$_soloOpt", function() {
      return P.RegExp_RegExp("^-([a-zA-Z0-9])$", false);
    });
    _lazy($, "_abbrOpt", "$get$_abbrOpt", function() {
      return P.RegExp_RegExp("^-([a-zA-Z0-9]+)(.*)$", false);
    });
    _lazy($, "_longOpt", "$get$_longOpt", function() {
      return P.RegExp_RegExp("^--([a-zA-Z\\-_0-9]+)(=(.*))?$", false);
    });
    _lazy($, "alwaysValid", "$get$alwaysValid", function() {
      return new Q.closure130();
    });
    _lazy($, "readline", "$get$readline", function() {
      return self.readline;
    });
    _lazy($, "windows", "$get$windows", function() {
      return M.Context_Context($.$get$Style_windows());
    });
    _lazy($, "url", "$get$url", function() {
      return M.Context_Context($.$get$Style_url());
    });
    _lazy($, "context", "$get$context", function() {
      return new M.Context($.$get$Style_platform(), null);
    });
    _lazy($, "Style_posix", "$get$Style_posix", function() {
      return new E.PosixStyle(P.RegExp_RegExp("/", false), P.RegExp_RegExp("[^/]$", false), P.RegExp_RegExp("^/", false));
    });
    _lazy($, "Style_windows", "$get$Style_windows", function() {
      return new L.WindowsStyle(P.RegExp_RegExp("[/\\\\]", false), P.RegExp_RegExp("[^/\\\\]$", false), P.RegExp_RegExp("^(\\\\\\\\[^\\\\]+\\\\[^\\\\/]+|[a-zA-Z]:[/\\\\])", false), P.RegExp_RegExp("^[/\\\\](?![/\\\\])", false));
    });
    _lazy($, "Style_url", "$get$Style_url", function() {
      return new F.UrlStyle(P.RegExp_RegExp("/", false), P.RegExp_RegExp("(^[a-zA-Z][-+.a-zA-Z\\d]*://|[^/])$", false), P.RegExp_RegExp("[a-zA-Z][-+.a-zA-Z\\d]*://[^/]*", false), P.RegExp_RegExp("^/", false));
    });
    _lazy($, "Style_platform", "$get$Style_platform", function() {
      return O.Style__getPlatformStyle();
    });
    _lazy($, "IfExpression_declaration", "$get$IfExpression_declaration", function() {
      return B.ArgumentDeclaration_ArgumentDeclaration$parse("$condition, $if-true, $if-false");
    });
    _lazy($, "colorsByName", "$get$colorsByName", function() {
      var _null = null;
      return P.LinkedHashMap_LinkedHashMap$_literal(["yellowgreen", K.SassColor$rgb(154, 205, 50, _null, _null), "yellow", K.SassColor$rgb(255, 255, 0, _null, _null), "whitesmoke", K.SassColor$rgb(245, 245, 245, _null, _null), "white", K.SassColor$rgb(255, 255, 255, _null, _null), "wheat", K.SassColor$rgb(245, 222, 179, _null, _null), "violet", K.SassColor$rgb(238, 130, 238, _null, _null), "turquoise", K.SassColor$rgb(64, 224, 208, _null, _null), "transparent", K.SassColor$rgb(0, 0, 0, 0, _null), "tomato", K.SassColor$rgb(255, 99, 71, _null, _null), "thistle", K.SassColor$rgb(216, 191, 216, _null, _null), "teal", K.SassColor$rgb(0, 128, 128, _null, _null), "tan", K.SassColor$rgb(210, 180, 140, _null, _null), "steelblue", K.SassColor$rgb(70, 130, 180, _null, _null), "springgreen", K.SassColor$rgb(0, 255, 127, _null, _null), "snow", K.SassColor$rgb(255, 250, 250, _null, _null), "slategrey", K.SassColor$rgb(112, 128, 144, _null, _null), "slategray", K.SassColor$rgb(112, 128, 144, _null, _null), "slateblue", K.SassColor$rgb(106, 90, 205, _null, _null), "skyblue", K.SassColor$rgb(135, 206, 235, _null, _null), "silver", K.SassColor$rgb(192, 192, 192, _null, _null), "sienna", K.SassColor$rgb(160, 82, 45, _null, _null), "seashell", K.SassColor$rgb(255, 245, 238, _null, _null), "seagreen", K.SassColor$rgb(46, 139, 87, _null, _null), "sandybrown", K.SassColor$rgb(244, 164, 96, _null, _null), "salmon", K.SassColor$rgb(250, 128, 114, _null, _null), "saddlebrown", K.SassColor$rgb(139, 69, 19, _null, _null), "royalblue", K.SassColor$rgb(65, 105, 225, _null, _null), "rosybrown", K.SassColor$rgb(188, 143, 143, _null, _null), "red", K.SassColor$rgb(255, 0, 0, _null, _null), "rebeccapurple", K.SassColor$rgb(102, 51, 153, _null, _null), "purple", K.SassColor$rgb(128, 0, 128, _null, _null), "powderblue", K.SassColor$rgb(176, 224, 230, _null, _null), "plum", K.SassColor$rgb(221, 160, 221, _null, _null), "pink", K.SassColor$rgb(255, 192, 203, _null, _null), "peru", K.SassColor$rgb(205, 133, 63, _null, _null), "peachpuff", K.SassColor$rgb(255, 218, 185, _null, _null), "papayawhip", K.SassColor$rgb(255, 239, 213, _null, _null), "palevioletred", K.SassColor$rgb(219, 112, 147, _null, _null), "paleturquoise", K.SassColor$rgb(175, 238, 238, _null, _null), "palegreen", K.SassColor$rgb(152, 251, 152, _null, _null), "palegoldenrod", K.SassColor$rgb(238, 232, 170, _null, _null), "orchid", K.SassColor$rgb(218, 112, 214, _null, _null), "orangered", K.SassColor$rgb(255, 69, 0, _null, _null), "orange", K.SassColor$rgb(255, 165, 0, _null, _null), "olivedrab", K.SassColor$rgb(107, 142, 35, _null, _null), "olive", K.SassColor$rgb(128, 128, 0, _null, _null), "oldlace", K.SassColor$rgb(253, 245, 230, _null, _null), "navy", K.SassColor$rgb(0, 0, 128, _null, _null), "navajowhite", K.SassColor$rgb(255, 222, 173, _null, _null), "moccasin", K.SassColor$rgb(255, 228, 181, _null, _null), "mistyrose", K.SassColor$rgb(255, 228, 225, _null, _null), "mintcream", K.SassColor$rgb(245, 255, 250, _null, _null), "midnightblue", K.SassColor$rgb(25, 25, 112, _null, _null), "mediumvioletred", K.SassColor$rgb(199, 21, 133, _null, _null), "mediumturquoise", K.SassColor$rgb(72, 209, 204, _null, _null), "mediumspringgreen", K.SassColor$rgb(0, 250, 154, _null, _null), "mediumslateblue", K.SassColor$rgb(123, 104, 238, _null, _null), "mediumseagreen", K.SassColor$rgb(60, 179, 113, _null, _null), "mediumpurple", K.SassColor$rgb(147, 112, 219, _null, _null), "mediumorchid", K.SassColor$rgb(186, 85, 211, _null, _null), "mediumblue", K.SassColor$rgb(0, 0, 205, _null, _null), "mediumaquamarine", K.SassColor$rgb(102, 205, 170, _null, _null), "maroon", K.SassColor$rgb(128, 0, 0, _null, _null), "magenta", K.SassColor$rgb(255, 0, 255, _null, _null), "linen", K.SassColor$rgb(250, 240, 230, _null, _null), "limegreen", K.SassColor$rgb(50, 205, 50, _null, _null), "lime", K.SassColor$rgb(0, 255, 0, _null, _null), "lightyellow", K.SassColor$rgb(255, 255, 224, _null, _null), "lightsteelblue", K.SassColor$rgb(176, 196, 222, _null, _null), "lightslategrey", K.SassColor$rgb(119, 136, 153, _null, _null), "lightslategray", K.SassColor$rgb(119, 136, 153, _null, _null), "lightskyblue", K.SassColor$rgb(135, 206, 250, _null, _null), "lightseagreen", K.SassColor$rgb(32, 178, 170, _null, _null), "lightsalmon", K.SassColor$rgb(255, 160, 122, _null, _null), "lightpink", K.SassColor$rgb(255, 182, 193, _null, _null), "lightgrey", K.SassColor$rgb(211, 211, 211, _null, _null), "lightgreen", K.SassColor$rgb(144, 238, 144, _null, _null), "lightgray", K.SassColor$rgb(211, 211, 211, _null, _null), "lightgoldenrodyellow", K.SassColor$rgb(250, 250, 210, _null, _null), "lightcyan", K.SassColor$rgb(224, 255, 255, _null, _null), "lightcoral", K.SassColor$rgb(240, 128, 128, _null, _null), "lightblue", K.SassColor$rgb(173, 216, 230, _null, _null), "lemonchiffon", K.SassColor$rgb(255, 250, 205, _null, _null), "lawngreen", K.SassColor$rgb(124, 252, 0, _null, _null), "lavenderblush", K.SassColor$rgb(255, 240, 245, _null, _null), "lavender", K.SassColor$rgb(230, 230, 250, _null, _null), "khaki", K.SassColor$rgb(240, 230, 140, _null, _null), "ivory", K.SassColor$rgb(255, 255, 240, _null, _null), "indigo", K.SassColor$rgb(75, 0, 130, _null, _null), "indianred", K.SassColor$rgb(205, 92, 92, _null, _null), "hotpink", K.SassColor$rgb(255, 105, 180, _null, _null), "honeydew", K.SassColor$rgb(240, 255, 240, _null, _null), "grey", K.SassColor$rgb(128, 128, 128, _null, _null), "greenyellow", K.SassColor$rgb(173, 255, 47, _null, _null), "green", K.SassColor$rgb(0, 128, 0, _null, _null), "gray", K.SassColor$rgb(128, 128, 128, _null, _null), "goldenrod", K.SassColor$rgb(218, 165, 32, _null, _null), "gold", K.SassColor$rgb(255, 215, 0, _null, _null), "ghostwhite", K.SassColor$rgb(248, 248, 255, _null, _null), "gainsboro", K.SassColor$rgb(220, 220, 220, _null, _null), "fuchsia", K.SassColor$rgb(255, 0, 255, _null, _null), "forestgreen", K.SassColor$rgb(34, 139, 34, _null, _null), "floralwhite", K.SassColor$rgb(255, 250, 240, _null, _null), "firebrick", K.SassColor$rgb(178, 34, 34, _null, _null), "dodgerblue", K.SassColor$rgb(30, 144, 255, _null, _null), "dimgrey", K.SassColor$rgb(105, 105, 105, _null, _null), "dimgray", K.SassColor$rgb(105, 105, 105, _null, _null), "deepskyblue", K.SassColor$rgb(0, 191, 255, _null, _null), "deeppink", K.SassColor$rgb(255, 20, 147, _null, _null), "darkviolet", K.SassColor$rgb(148, 0, 211, _null, _null), "darkturquoise", K.SassColor$rgb(0, 206, 209, _null, _null), "darkslategrey", K.SassColor$rgb(47, 79, 79, _null, _null), "darkslategray", K.SassColor$rgb(47, 79, 79, _null, _null), "darkslateblue", K.SassColor$rgb(72, 61, 139, _null, _null), "darkseagreen", K.SassColor$rgb(143, 188, 143, _null, _null), "darksalmon", K.SassColor$rgb(233, 150, 122, _null, _null), "darkred", K.SassColor$rgb(139, 0, 0, _null, _null), "darkorchid", K.SassColor$rgb(153, 50, 204, _null, _null), "darkorange", K.SassColor$rgb(255, 140, 0, _null, _null), "darkolivegreen", K.SassColor$rgb(85, 107, 47, _null, _null), "darkmagenta", K.SassColor$rgb(139, 0, 139, _null, _null), "darkkhaki", K.SassColor$rgb(189, 183, 107, _null, _null), "darkgrey", K.SassColor$rgb(169, 169, 169, _null, _null), "darkgreen", K.SassColor$rgb(0, 100, 0, _null, _null), "darkgray", K.SassColor$rgb(169, 169, 169, _null, _null), "darkgoldenrod", K.SassColor$rgb(184, 134, 11, _null, _null), "darkcyan", K.SassColor$rgb(0, 139, 139, _null, _null), "darkblue", K.SassColor$rgb(0, 0, 139, _null, _null), "cyan", K.SassColor$rgb(0, 255, 255, _null, _null), "crimson", K.SassColor$rgb(220, 20, 60, _null, _null), "cornsilk", K.SassColor$rgb(255, 248, 220, _null, _null), "cornflowerblue", K.SassColor$rgb(100, 149, 237, _null, _null), "coral", K.SassColor$rgb(255, 127, 80, _null, _null), "chocolate", K.SassColor$rgb(210, 105, 30, _null, _null), "chartreuse", K.SassColor$rgb(127, 255, 0, _null, _null), "cadetblue", K.SassColor$rgb(95, 158, 160, _null, _null), "burlywood", K.SassColor$rgb(222, 184, 135, _null, _null), "brown", K.SassColor$rgb(165, 42, 42, _null, _null), "blueviolet", K.SassColor$rgb(138, 43, 226, _null, _null), "blue", K.SassColor$rgb(0, 0, 255, _null, _null), "blanchedalmond", K.SassColor$rgb(255, 235, 205, _null, _null), "black", K.SassColor$rgb(0, 0, 0, _null, _null), "bisque", K.SassColor$rgb(255, 228, 196, _null, _null), "beige", K.SassColor$rgb(245, 245, 220, _null, _null), "azure", K.SassColor$rgb(240, 255, 255, _null, _null), "aquamarine", K.SassColor$rgb(127, 255, 212, _null, _null), "aqua", K.SassColor$rgb(0, 255, 255, _null, _null), "antiquewhite", K.SassColor$rgb(250, 235, 215, _null, _null), "aliceblue", K.SassColor$rgb(240, 248, 255, _null, _null)], P.String, K.SassColor);
    });
    _lazy($, "namesByColor", "$get$namesByColor", function() {
      var t1 = P.String,
        t2 = K.SassColor;
      return Y.mapMap($.$get$colorsByName(), new X.closure34(), new X.closure35(), t1, t2, t2, t1);
    });
    _lazy($, "ExecutableOptions__separatorBar", "$get$ExecutableOptions__separatorBar", function() {
      return B.isWindows() ? "=" : "\u2501";
    });
    _lazy($, "ExecutableOptions__parser", "$get$ExecutableOptions__parser", function() {
      return new B.ExecutableOptions_closure().call$0();
    });
    _lazy($, "globalFunctions", "$get$globalFunctions", function() {
      var t3,
        t1 = Q.BuiltInCallable,
        t2 = H.setRuntimeTypeInfo([], [t1]);
      for (t3 = $.$get$global0(), t3 = t3.get$iterator(t3); t3.moveNext$0();)
        t2.push(t3.__internal$_current);
      for (t3 = $.$get$global1(), t3 = t3.get$iterator(t3); t3.moveNext$0();)
        t2.push(t3.__internal$_current);
      for (t3 = $.$get$global2(), t3 = t3.get$iterator(t3); t3.moveNext$0();)
        t2.push(t3.__internal$_current);
      for (t3 = $.$get$global3(), t3 = t3.get$iterator(t3); t3.moveNext$0();)
        t2.push(t3.__internal$_current);
      for (t3 = $.$get$global4(), t3 = t3.get$iterator(t3); t3.moveNext$0();)
        t2.push(t3.__internal$_current);
      for (t3 = $.$get$global5(), t3 = t3.get$iterator(t3); t3.moveNext$0();)
        t2.push(t3.__internal$_current);
      for (t3 = $.$get$global(), t3 = t3.get$iterator(t3); t3.moveNext$0();)
        t2.push(t3.__internal$_current);
      t2.push(Q.BuiltInCallable$("if", "$condition, $if-true, $if-false", new Y.closure37()));
      return P.UnmodifiableListView$(t2, t1);
    });
    _lazy($, "coreModules", "$get$coreModules", function() {
      var t1 = [Q.BuiltInModule, Q.BuiltInCallable];
      return P.UnmodifiableListView$(H.setRuntimeTypeInfo([$.$get$module(), $.$get$module0(), $.$get$module1(), $.$get$module2(), $.$get$module3(), $.$get$module4()], [t1]), t1);
    });
    _lazy($, "_microsoftFilterStart", "$get$_microsoftFilterStart", function() {
      return P.RegExp_RegExp("^[a-zA-Z]+\\s*=", false);
    });
    _lazy($, "global", "$get$global0", function() {
      var _s27_ = "$red, $green, $blue, $alpha",
        _s19_ = "$red, $green, $blue",
        _s37_ = "$hue, $saturation, $lightness, $alpha",
        _s29_ = "$hue, $saturation, $lightness",
        _s17_ = "$hue, $saturation",
        _s15_ = "$color, $amount",
        t1 = P.String,
        t2 = {func: 1, ret: F.Value, args: [[P.List, F.Value]]},
        t3 = Q.BuiltInCallable;
      return P.UnmodifiableListView$(H.setRuntimeTypeInfo([$.$get$_red(), $.$get$_green(), $.$get$_blue(), $.$get$_mix(), Q.BuiltInCallable$overloaded("rgb", P.LinkedHashMap_LinkedHashMap$_literal([_s27_, new K.closure81(), _s19_, new K.closure82(), "$color, $alpha", new K.closure83(), "$channels", new K.closure84()], t1, t2)), Q.BuiltInCallable$overloaded("rgba", P.LinkedHashMap_LinkedHashMap$_literal([_s27_, new K.closure85(), _s19_, new K.closure86(), "$color, $alpha", new K.closure87(), "$channels", new K.closure88()], t1, t2)), Q.BuiltInCallable$("invert", "$color, $weight: 100%", new K.closure89()), $.$get$_hue(), $.$get$_saturation(), $.$get$_lightness(), $.$get$_adjustHue(), $.$get$_complement(), Q.BuiltInCallable$overloaded("hsl", P.LinkedHashMap_LinkedHashMap$_literal([_s37_, new K.closure90(), _s29_, new K.closure91(), _s17_, new K.closure92(), "$channels", new K.closure93()], t1, t2)), Q.BuiltInCallable$overloaded("hsla", P.LinkedHashMap_LinkedHashMap$_literal([_s37_, new K.closure94(), _s29_, new K.closure95(), _s17_, new K.closure96(), "$channels", new K.closure97()], t1, t2)), Q.BuiltInCallable$("grayscale", "$color", new K.closure98()), Q.BuiltInCallable$("lighten", _s15_, new K.closure99()), Q.BuiltInCallable$("darken", _s15_, new K.closure100()), Q.BuiltInCallable$overloaded("saturate", P.LinkedHashMap_LinkedHashMap$_literal(["$amount", new K.closure101(), "$color, $amount", new K.closure102()], t1, t2)), Q.BuiltInCallable$("desaturate", _s15_, new K.closure103()), Q.BuiltInCallable$("opacify", _s15_, K.color___opacify$closure()), Q.BuiltInCallable$("fade-in", _s15_, K.color___opacify$closure()), Q.BuiltInCallable$("transparentize", _s15_, K.color___transparentize$closure()), Q.BuiltInCallable$("fade-out", _s15_, K.color___transparentize$closure()), Q.BuiltInCallable$overloaded("alpha", P.LinkedHashMap_LinkedHashMap$_literal(["$color", new K.closure104(), "$args...", new K.closure105()], t1, t2)), Q.BuiltInCallable$("opacity", "$color", new K.closure106()), $.$get$_ieHexStr(), $.$get$_adjust().withName$1("adjust-color"), $.$get$_scale().withName$1("scale-color"), $.$get$_change().withName$1("change-color")], [t3]), t3);
    });
    _lazy($, "module", "$get$module", function() {
      var _s9_ = "lightness",
        _s10_ = "saturation",
        _s5_ = "alpha",
        t1 = Q.BuiltInCallable;
      return Q.BuiltInModule$("color", H.setRuntimeTypeInfo([$.$get$_red(), $.$get$_green(), $.$get$_blue(), $.$get$_mix(), Q.BuiltInCallable$("invert", "$color, $weight: 100%", new K.closure120()), $.$get$_hue(), $.$get$_saturation(), $.$get$_lightness(), $.$get$_adjustHue(), $.$get$_complement(), K._removedColorFunction("lighten", _s9_, false), K._removedColorFunction("darken", _s9_, true), K._removedColorFunction("saturate", _s10_, false), K._removedColorFunction("desaturate", _s10_, true), Q.BuiltInCallable$("grayscale", "$color", new K.closure121()), K._removedColorFunction("opacify", _s5_, false), K._removedColorFunction("fade-in", _s5_, false), K._removedColorFunction("transparentize", _s5_, true), K._removedColorFunction("fade-out", _s5_, true), Q.BuiltInCallable$overloaded(_s5_, P.LinkedHashMap_LinkedHashMap$_literal(["$color", new K.closure122(), "$args...", new K.closure123()], P.String, {func: 1, ret: F.Value, args: [[P.List, F.Value]]})), Q.BuiltInCallable$("opacity", "$color", new K.closure124()), $.$get$_adjust(), $.$get$_scale(), $.$get$_change(), $.$get$_ieHexStr()], [t1]), t1);
    });
    _lazy($, "_red", "$get$_red", function() {
      return Q.BuiltInCallable$("red", "$color", new K.closure119());
    });
    _lazy($, "_green", "$get$_green", function() {
      return Q.BuiltInCallable$("green", "$color", new K.closure118());
    });
    _lazy($, "_blue", "$get$_blue", function() {
      return Q.BuiltInCallable$("blue", "$color", new K.closure117());
    });
    _lazy($, "_mix", "$get$_mix", function() {
      return Q.BuiltInCallable$("mix", "$color1, $color2, $weight: 50%", new K.closure116());
    });
    _lazy($, "_hue", "$get$_hue", function() {
      return Q.BuiltInCallable$("hue", "$color", new K.closure115());
    });
    _lazy($, "_saturation", "$get$_saturation", function() {
      return Q.BuiltInCallable$("saturation", "$color", new K.closure114());
    });
    _lazy($, "_lightness", "$get$_lightness", function() {
      return Q.BuiltInCallable$("lightness", "$color", new K.closure113());
    });
    _lazy($, "_adjustHue", "$get$_adjustHue", function() {
      return Q.BuiltInCallable$("adjust-hue", "$color, $degrees", new K.closure112());
    });
    _lazy($, "_complement", "$get$_complement", function() {
      return Q.BuiltInCallable$("complement", "$color", new K.closure111());
    });
    _lazy($, "_adjust", "$get$_adjust", function() {
      return Q.BuiltInCallable$("adjust", "$color, $kwargs...", new K.closure109());
    });
    _lazy($, "_scale", "$get$_scale", function() {
      return Q.BuiltInCallable$("scale", "$color, $kwargs...", new K.closure108());
    });
    _lazy($, "_change", "$get$_change", function() {
      return Q.BuiltInCallable$("change", "$color, $kwargs...", new K.closure107());
    });
    _lazy($, "_ieHexStr", "$get$_ieHexStr", function() {
      return Q.BuiltInCallable$("ie-hex-str", "$color", new K.closure110());
    });
    _lazy($, "global0", "$get$global1", function() {
      var t1 = Q.BuiltInCallable;
      return P.UnmodifiableListView$(H.setRuntimeTypeInfo([$.$get$_length0(), $.$get$_nth(), $.$get$_setNth(), $.$get$_join(), $.$get$_append0(), $.$get$_zip(), $.$get$_index0(), $.$get$_isBracketed(), $.$get$_separator().withName$1("list-separator")], [t1]), t1);
    });
    _lazy($, "module0", "$get$module0", function() {
      var t1 = Q.BuiltInCallable;
      return Q.BuiltInModule$("list", H.setRuntimeTypeInfo([$.$get$_length0(), $.$get$_nth(), $.$get$_setNth(), $.$get$_join(), $.$get$_append0(), $.$get$_zip(), $.$get$_index0(), $.$get$_isBracketed(), $.$get$_separator()], [t1]), t1);
    });
    _lazy($, "_length", "$get$_length0", function() {
      return Q.BuiltInCallable$("length", "$list", new D.closure80());
    });
    _lazy($, "_nth", "$get$_nth", function() {
      return Q.BuiltInCallable$("nth", "$list, $n", new D.closure79());
    });
    _lazy($, "_setNth", "$get$_setNth", function() {
      return Q.BuiltInCallable$("set-nth", "$list, $n, $value", new D.closure78());
    });
    _lazy($, "_join", "$get$_join", function() {
      return Q.BuiltInCallable$("join", "$list1, $list2, $separator: auto, $bracketed: auto", new D.closure77());
    });
    _lazy($, "_append", "$get$_append0", function() {
      return Q.BuiltInCallable$("append", "$list, $val, $separator: auto", new D.closure76());
    });
    _lazy($, "_zip", "$get$_zip", function() {
      return Q.BuiltInCallable$("zip", "$lists...", new D.closure75());
    });
    _lazy($, "_index", "$get$_index0", function() {
      return Q.BuiltInCallable$("index", "$list, $value", new D.closure74());
    });
    _lazy($, "_separator", "$get$_separator", function() {
      return Q.BuiltInCallable$("separator", "$list", new D.closure72());
    });
    _lazy($, "_isBracketed", "$get$_isBracketed", function() {
      return Q.BuiltInCallable$("is-bracketed", "$list", new D.closure73());
    });
    _lazy($, "global1", "$get$global2", function() {
      var t1 = Q.BuiltInCallable;
      return P.UnmodifiableListView$(H.setRuntimeTypeInfo([$.$get$_get().withName$1("map-get"), $.$get$_merge().withName$1("map-merge"), $.$get$_remove().withName$1("map-remove"), $.$get$_keys().withName$1("map-keys"), $.$get$_values().withName$1("map-values"), $.$get$_hasKey().withName$1("map-has-key")], [t1]), t1);
    });
    _lazy($, "module1", "$get$module1", function() {
      var t1 = Q.BuiltInCallable;
      return Q.BuiltInModule$("map", H.setRuntimeTypeInfo([$.$get$_get(), $.$get$_merge(), $.$get$_remove(), $.$get$_keys(), $.$get$_values(), $.$get$_hasKey()], [t1]), t1);
    });
    _lazy($, "_get", "$get$_get", function() {
      return Q.BuiltInCallable$("get", "$map, $key", new A.closure71());
    });
    _lazy($, "_merge", "$get$_merge", function() {
      return Q.BuiltInCallable$("merge", "$map1, $map2", new A.closure70());
    });
    _lazy($, "_remove", "$get$_remove", function() {
      return Q.BuiltInCallable$overloaded("remove", P.LinkedHashMap_LinkedHashMap$_literal(["$map", new A.closure68(), "$map, $key, $keys...", new A.closure69()], P.String, {func: 1, ret: F.Value, args: [[P.List, F.Value]]}));
    });
    _lazy($, "_keys", "$get$_keys", function() {
      return Q.BuiltInCallable$("keys", "$map", new A.closure67());
    });
    _lazy($, "_values", "$get$_values", function() {
      return Q.BuiltInCallable$("values", "$map", new A.closure66());
    });
    _lazy($, "_hasKey", "$get$_hasKey", function() {
      return Q.BuiltInCallable$("has-key", "$map, $key", new A.closure65());
    });
    _lazy($, "_random", "$get$_random0", function() {
      return P.Random_Random();
    });
    _lazy($, "global2", "$get$global3", function() {
      var t1 = Q.BuiltInCallable;
      return P.UnmodifiableListView$(H.setRuntimeTypeInfo([$.$get$_round(), $.$get$_ceil(), $.$get$_floor(), $.$get$_abs(), $.$get$_max(), $.$get$_min(), $.$get$_randomFunction(), $.$get$_unit(), $.$get$_percentage(), $.$get$_isUnitless().withName$1("unitless"), $.$get$_compatible().withName$1("comparable")], [t1]), t1);
    });
    _lazy($, "module2", "$get$module2", function() {
      var t1 = Q.BuiltInCallable;
      return Q.BuiltInModule$("math", H.setRuntimeTypeInfo([$.$get$_round(), $.$get$_ceil(), $.$get$_floor(), $.$get$_abs(), $.$get$_max(), $.$get$_min(), $.$get$_randomFunction(), $.$get$_unit(), $.$get$_isUnitless(), $.$get$_percentage(), $.$get$_compatible()], [t1]), t1);
    });
    _lazy($, "_percentage", "$get$_percentage", function() {
      return Q.BuiltInCallable$("percentage", "$number", new K.closure57());
    });
    _lazy($, "_round", "$get$_round", function() {
      return K._numberFunction("round", T.number__fuzzyRound$closure());
    });
    _lazy($, "_ceil", "$get$_ceil", function() {
      return K._numberFunction("ceil", new K.closure64());
    });
    _lazy($, "_floor", "$get$_floor", function() {
      return K._numberFunction("floor", new K.closure63());
    });
    _lazy($, "_abs", "$get$_abs", function() {
      return K._numberFunction("abs", new K.closure62());
    });
    _lazy($, "_max", "$get$_max", function() {
      return Q.BuiltInCallable$("max", "$numbers...", new K.closure61());
    });
    _lazy($, "_min", "$get$_min", function() {
      return Q.BuiltInCallable$("min", "$numbers...", new K.closure60());
    });
    _lazy($, "_randomFunction", "$get$_randomFunction", function() {
      return Q.BuiltInCallable$("random", "$limit: null", new K.closure59());
    });
    _lazy($, "_unit", "$get$_unit", function() {
      return Q.BuiltInCallable$("unit", "$number", new K.closure58());
    });
    _lazy($, "_isUnitless", "$get$_isUnitless", function() {
      return Q.BuiltInCallable$("is-unitless", "$number", new K.closure56());
    });
    _lazy($, "_compatible", "$get$_compatible", function() {
      return Q.BuiltInCallable$("compatible", "$number1, $number2", new K.closure55());
    });
    _lazy($, "global3", "$get$global", function() {
      var t1 = Q.BuiltInCallable;
      return P.UnmodifiableListView$(H.setRuntimeTypeInfo([Q.BuiltInCallable$("feature-exists", "$feature", new Q.closure125()), Q.BuiltInCallable$("inspect", "$value", new Q.closure126()), Q.BuiltInCallable$("type-of", "$value", new Q.closure127()), Q.BuiltInCallable$("keywords", "$args", new Q.closure128())], [t1]), t1);
    });
    _lazy($, "global4", "$get$global4", function() {
      var t1 = Q.BuiltInCallable;
      return P.UnmodifiableListView$(H.setRuntimeTypeInfo([$.$get$_isSuperselector(), $.$get$_simpleSelectors(), $.$get$_parse().withName$1("selector-parse"), $.$get$_nest().withName$1("selector-nest"), $.$get$_append().withName$1("selector-append"), $.$get$_extend().withName$1("selector-extend"), $.$get$_replace().withName$1("selector-replace"), $.$get$_unify().withName$1("selector-unify")], [t1]), t1);
    });
    _lazy($, "module3", "$get$module3", function() {
      var t1 = Q.BuiltInCallable;
      return Q.BuiltInModule$("selector", H.setRuntimeTypeInfo([$.$get$_isSuperselector(), $.$get$_simpleSelectors(), $.$get$_parse(), $.$get$_nest(), $.$get$_append(), $.$get$_extend(), $.$get$_replace(), $.$get$_unify()], [t1]), t1);
    });
    _lazy($, "_nest", "$get$_nest", function() {
      return Q.BuiltInCallable$("nest", "$selectors...", new T.closure51());
    });
    _lazy($, "_append0", "$get$_append", function() {
      return Q.BuiltInCallable$("append", "$selectors...", new T.closure50());
    });
    _lazy($, "_extend", "$get$_extend", function() {
      return Q.BuiltInCallable$("extend", "$selector, $extendee, $extender", new T.closure49());
    });
    _lazy($, "_replace", "$get$_replace", function() {
      return Q.BuiltInCallable$("replace", "$selector, $original, $replacement", new T.closure48());
    });
    _lazy($, "_unify", "$get$_unify", function() {
      return Q.BuiltInCallable$("unify", "$selector1, $selector2", new T.closure47());
    });
    _lazy($, "_isSuperselector", "$get$_isSuperselector", function() {
      return Q.BuiltInCallable$("is-superselector", "$super, $sub", new T.closure54());
    });
    _lazy($, "_simpleSelectors", "$get$_simpleSelectors", function() {
      return Q.BuiltInCallable$("simple-selectors", "$selector", new T.closure53());
    });
    _lazy($, "_parse", "$get$_parse", function() {
      return Q.BuiltInCallable$("parse", "$selector", new T.closure52());
    });
    _lazy($, "_random0", "$get$_random", function() {
      return P.Random_Random();
    });
    _lazy($, "_previousUniqueId", "$get$_previousUniqueId", function() {
      return $.$get$_random().nextInt$1(H.intTypeCast(P.pow(36, 6)));
    });
    _lazy($, "global5", "$get$global5", function() {
      var t1 = Q.BuiltInCallable;
      return P.UnmodifiableListView$(H.setRuntimeTypeInfo([$.$get$_unquote(), $.$get$_quote(), $.$get$_toUpperCase(), $.$get$_toLowerCase(), $.$get$_uniqueId(), $.$get$_length().withName$1("str-length"), $.$get$_insert().withName$1("str-insert"), $.$get$_index().withName$1("str-index"), $.$get$_slice().withName$1("str-slice")], [t1]), t1);
    });
    _lazy($, "module4", "$get$module4", function() {
      var t1 = Q.BuiltInCallable;
      return Q.BuiltInModule$("string", H.setRuntimeTypeInfo([$.$get$_unquote(), $.$get$_quote(), $.$get$_toUpperCase(), $.$get$_toLowerCase(), $.$get$_length(), $.$get$_insert(), $.$get$_index(), $.$get$_slice(), $.$get$_uniqueId()], [t1]), t1);
    });
    _lazy($, "_unquote", "$get$_unquote", function() {
      return Q.BuiltInCallable$("unquote", "$string", new D.closure46());
    });
    _lazy($, "_quote", "$get$_quote", function() {
      return Q.BuiltInCallable$("quote", "$string", new D.closure45());
    });
    _lazy($, "_length0", "$get$_length", function() {
      return Q.BuiltInCallable$("length", "$string", new D.closure41());
    });
    _lazy($, "_insert", "$get$_insert", function() {
      return Q.BuiltInCallable$("insert", "$string, $insert, $index", new D.closure40());
    });
    _lazy($, "_index0", "$get$_index", function() {
      return Q.BuiltInCallable$("index", "$string, $substring", new D.closure39());
    });
    _lazy($, "_slice", "$get$_slice", function() {
      return Q.BuiltInCallable$("slice", "$string, $start-at, $end-at: -1", new D.closure38());
    });
    _lazy($, "_toUpperCase", "$get$_toUpperCase", function() {
      return Q.BuiltInCallable$("to-upper-case", "$string", new D.closure44());
    });
    _lazy($, "_toLowerCase", "$get$_toLowerCase", function() {
      return Q.BuiltInCallable$("to-lower-case", "$string", new D.closure43());
    });
    _lazy($, "_uniqueId", "$get$_uniqueId", function() {
      return Q.BuiltInCallable$("unique-id", "", new D.closure42());
    });
    _lazy($, "stderr", "$get$stderr", function() {
      return new B.Stderr(self.process.stderr);
    });
    _lazy($, "Logger_quiet", "$get$Logger_quiet", function() {
      return new F._QuietLogger();
    });
    _lazy($, "_jsThrow", "$get$_jsThrow", function() {
      return new self.Function("error", "throw error;");
    });
    _lazy($, "_isUndefined", "$get$_isUndefined", function() {
      return new self.Function("value", "return value === undefined;");
    });
    _lazy($, "booleanConstructor", "$get$booleanConstructor", function() {
      return new Z.closure36().call$0();
    });
    _lazy($, "colorConstructor", "$get$colorConstructor", function() {
      return B.createClass(new K.closure24(), P.LinkedHashMap_LinkedHashMap$_literal(["getR", new K.closure25(), "getG", new K.closure26(), "getB", new K.closure27(), "getA", new K.closure28(), "setR", new K.closure29(), "setG", new K.closure30(), "setB", new K.closure31(), "setA", new K.closure32(), "toString", new K.closure33()], P.String, P.Function));
    });
    _lazy($, "listConstructor", "$get$listConstructor", function() {
      return B.createClass(new D.closure17(), P.LinkedHashMap_LinkedHashMap$_literal(["getValue", new D.closure18(), "setValue", new D.closure19(), "getSeparator", new D.closure20(), "setSeparator", new D.closure21(), "getLength", new D.closure22(), "toString", new D.closure23()], P.String, P.Function));
    });
    _lazy($, "mapConstructor", "$get$mapConstructor", function() {
      return B.createClass(new A.closure10(), P.LinkedHashMap_LinkedHashMap$_literal(["getKey", new A.closure11(), "getValue", new A.closure12(), "getLength", new A.closure13(), "setKey", new A.closure14(), "setValue", new A.closure15(), "toString", new A.closure16()], P.String, P.Function));
    });
    _lazy($, "nullConstructor", "$get$nullConstructor", function() {
      return new O.closure9().call$0();
    });
    _lazy($, "numberConstructor", "$get$numberConstructor", function() {
      return B.createClass(new T.closure3(), P.LinkedHashMap_LinkedHashMap$_literal(["getValue", new T.closure4(), "setValue", new T.closure5(), "getUnit", new T.closure6(), "setUnit", new T.closure7(), "toString", new T.closure8()], P.String, P.Function));
    });
    _lazy($, "stringConstructor", "$get$stringConstructor", function() {
      return B.createClass(new D.closure(), P.LinkedHashMap_LinkedHashMap$_literal(["getValue", new D.closure0(), "setValue", new D.closure1(), "toString", new D.closure2()], P.String, P.Function));
    });
    _lazy($, "_disallowedFunctionNames", "$get$_disallowedFunctionNames", function() {
      var t1 = $.$get$globalFunctions();
      t1 = t1.map$1$1(t1, new Q.closure129(), P.String).toSet$0(0);
      t1.add$1(0, "if");
      t1.remove$1(0, "rgb");
      t1.remove$1(0, "rgba");
      t1.remove$1(0, "hsl");
      t1.remove$1(0, "hsla");
      t1.remove$1(0, "grayscale");
      t1.remove$1(0, "invert");
      t1.remove$1(0, "alpha");
      t1.remove$1(0, "opacity");
      return t1;
    });
    _lazy($, "epsilon", "$get$epsilon", function() {
      return P.pow(10, -11);
    });
    _lazy($, "_inverseEpsilon", "$get$_inverseEpsilon", function() {
      return 1 / $.$get$epsilon();
    });
    _lazy($, "_noSourceUrl", "$get$_noSourceUrl", function() {
      return P.Uri_parse("-");
    });
    _lazy($, "_conversions", "$get$_conversions", function() {
      var t1 = P.String,
        t2 = P.num;
      return P.LinkedHashMap_LinkedHashMap$_literal(["in", P.LinkedHashMap_LinkedHashMap$_literal(["in", 1, "cm", 0.39370078740157477, "pc", 0.16666666666666666, "mm", 0.03937007874015748, "q", 0.00984251968503937, "pt", 0.013888888888888888, "px", 0.010416666666666666], t1, t2), "cm", P.LinkedHashMap_LinkedHashMap$_literal(["in", 2.54, "cm", 1, "pc", 0.42333333333333334, "mm", 0.1, "q", 0.025, "pt", 0.035277777777777776, "px", 0.026458333333333334], t1, t2), "pc", P.LinkedHashMap_LinkedHashMap$_literal(["in", 6, "cm", 2.3622047244094486, "pc", 1, "mm", 0.2362204724409449, "q", 0.05905511811023623, "pt", 0.08333333333333333, "px", 0.0625], t1, t2), "mm", P.LinkedHashMap_LinkedHashMap$_literal(["in", 25.4, "cm", 10, "pc", 4.233333333333333, "mm", 1, "q", 0.25, "pt", 0.35277777777777775, "px", 0.26458333333333334], t1, t2), "q", P.LinkedHashMap_LinkedHashMap$_literal(["in", 101.6, "cm", 40, "pc", 16.933333333333334, "mm", 4, "q", 1, "pt", 1.411111111111111, "px", 1.0583333333333333], t1, t2), "pt", P.LinkedHashMap_LinkedHashMap$_literal(["in", 72, "cm", 28.346456692913385, "pc", 12, "mm", 2.834645669291339, "q", 0.7086614173228347, "pt", 1, "px", 0.75], t1, t2), "px", P.LinkedHashMap_LinkedHashMap$_literal(["in", 96, "cm", 37.79527559055118, "pc", 16, "mm", 3.7795275590551185, "q", 0.9448818897637796, "pt", 1.3333333333333333, "px", 1], t1, t2), "deg", P.LinkedHashMap_LinkedHashMap$_literal(["deg", 1, "grad", 0.9, "rad", 57.29577951308232, "turn", 360], t1, t2), "grad", P.LinkedHashMap_LinkedHashMap$_literal(["deg", 1.1111111111111112, "grad", 1, "rad", 63.66197723675813, "turn", 400], t1, t2), "rad", P.LinkedHashMap_LinkedHashMap$_literal(["deg", 0.017453292519943295, "grad", 0.015707963267948967, "rad", 1, "turn", 6.283185307179586], t1, t2), "turn", P.LinkedHashMap_LinkedHashMap$_literal(["deg", 0.002777777777777778, "grad", 0.0025, "rad", 0.15915494309189535, "turn", 1], t1, t2), "s", P.LinkedHashMap_LinkedHashMap$_literal(["s", 1, "ms", 0.001], t1, t2), "ms", P.LinkedHashMap_LinkedHashMap$_literal(["s", 1000, "ms", 1], t1, t2), "Hz", P.LinkedHashMap_LinkedHashMap$_literal(["Hz", 1, "kHz", 1000], t1, t2), "kHz", P.LinkedHashMap_LinkedHashMap$_literal(["Hz", 0.001, "kHz", 1], t1, t2), "dpi", P.LinkedHashMap_LinkedHashMap$_literal(["dpi", 1, "dpcm", 2.54, "dppx", 96], t1, t2), "dpcm", P.LinkedHashMap_LinkedHashMap$_literal(["dpi", 0.39370078740157477, "dpcm", 1, "dppx", 37.79527559055118], t1, t2), "dppx", P.LinkedHashMap_LinkedHashMap$_literal(["dpi", 0.010416666666666666, "dpcm", 0.026458333333333334, "dppx", 1], t1, t2)], t1, [P.Map, P.String, P.num]);
    });
    _lazy($, "_emptyQuoted", "$get$_emptyQuoted", function() {
      return D.SassString$("", true);
    });
    _lazy($, "_emptyUnquoted", "$get$_emptyUnquoted", function() {
      return D.SassString$("", false);
    });
    _lazy($, "MAX_INT32", "$get$MAX_INT32", function() {
      return P.pow(2, 31) - 1;
    });
    _lazy($, "MIN_INT32", "$get$MIN_INT32", function() {
      return -P.pow(2, 31);
    });
    _lazy($, "_vmFrame", "$get$_vmFrame", function() {
      return P.RegExp_RegExp("^#\\d+\\s+(\\S.*) \\((.+?)((?::\\d+){0,2})\\)$", false);
    });
    _lazy($, "_v8Frame", "$get$_v8Frame", function() {
      return P.RegExp_RegExp("^\\s*at (?:(\\S.*?)(?: \\[as [^\\]]+\\])? \\((.*)\\)|(.*))$", false);
    });
    _lazy($, "_v8UrlLocation", "$get$_v8UrlLocation", function() {
      return P.RegExp_RegExp("^(.*):(\\d+):(\\d+)|native$", false);
    });
    _lazy($, "_v8EvalLocation", "$get$_v8EvalLocation", function() {
      return P.RegExp_RegExp("^eval at (?:\\S.*?) \\((.*)\\)(?:, .*?:\\d+:\\d+)?$", false);
    });
    _lazy($, "_firefoxSafariFrame", "$get$_firefoxSafariFrame", function() {
      return P.RegExp_RegExp("^(?:([^@(/]*)(?:\\(.*\\))?((?:/[^/]*)*)(?:\\(.*\\))?@)?(.*?):(\\d*)(?::(\\d*))?$", false);
    });
    _lazy($, "_friendlyFrame", "$get$_friendlyFrame", function() {
      return P.RegExp_RegExp("^(\\S+)(?: (\\d+)(?::(\\d+))?)?\\s+([^\\d].*)$", false);
    });
    _lazy($, "_asyncBody", "$get$_asyncBody", function() {
      return P.RegExp_RegExp("<(<anonymous closure>|[^>]+)_async_body>", false);
    });
    _lazy($, "_initialDot", "$get$_initialDot", function() {
      return P.RegExp_RegExp("^\\.", false);
    });
    _lazy($, "Frame__uriRegExp", "$get$Frame__uriRegExp", function() {
      return P.RegExp_RegExp("^[a-zA-Z][-+.a-zA-Z\\d]*://", false);
    });
    _lazy($, "Frame__windowsRegExp", "$get$Frame__windowsRegExp", function() {
      return P.RegExp_RegExp("^([a-zA-Z]:[\\\\/]|\\\\\\\\)", false);
    });
    _lazy($, "_terseRegExp", "$get$_terseRegExp", function() {
      return P.RegExp_RegExp("(-patch)?([/\\\\].*)?$", false);
    });
    _lazy($, "_v8Trace", "$get$_v8Trace", function() {
      return P.RegExp_RegExp("\\n    ?at ", false);
    });
    _lazy($, "_v8TraceLine", "$get$_v8TraceLine", function() {
      return P.RegExp_RegExp("    ?at ", false);
    });
    _lazy($, "_firefoxSafariTrace", "$get$_firefoxSafariTrace", function() {
      return P.RegExp_RegExp("^(([.0-9A-Za-z_$/<]|\\(.*\\))*@)?[^\\s]*:\\d*$", true);
    });
    _lazy($, "_friendlyTrace", "$get$_friendlyTrace", function() {
      return P.RegExp_RegExp("^[^\\s<][^\\s]*( \\d+(:\\d+)?)?[ \\t]+[^\\s]+$", true);
    });
    _lazy($, "_newlineRegExp", "$get$_newlineRegExp", function() {
      return P.RegExp_RegExp("\\r\\n?|\\n", false);
    });
  })();
  (function nativeSupport() {
    !function() {
      var intern = function(s) {
        var o = {};
        o[s] = 1;
        return Object.keys(hunkHelpers.convertToFastObject(o))[0];
      };
      init.getIsolateTag = function(name) {
        return intern("___dart_" + name + init.isolateTag);
      };
      var tableProperty = "___dart_isolate_tags_";
      var usedProperties = Object[tableProperty] || (Object[tableProperty] = Object.create(null));
      var rootProperty = "_ZxYxX";
      for (var i = 0;; i++) {
        var property = intern(rootProperty + "_" + i + "_");
        if (!(property in usedProperties)) {
          usedProperties[property] = 1;
          init.isolateTag = property;
          break;
        }
      }
      init.dispatchPropertyName = init.getIsolateTag("dispatch_record");
    }();
    hunkHelpers.setOrUpdateInterceptorsByTag({ArrayBuffer: J.Interceptor, DataView: H.NativeTypedData, ArrayBufferView: H.NativeTypedData, Float32Array: H.NativeFloat32List, Float64Array: H.NativeFloat64List, Int16Array: H.NativeInt16List, Int32Array: H.NativeInt32List, Int8Array: H.NativeInt8List, Uint16Array: H.NativeUint16List, Uint32Array: H.NativeUint32List, Uint8ClampedArray: H.NativeUint8ClampedList, CanvasPixelArray: H.NativeUint8ClampedList, Uint8Array: H.NativeUint8List});
    hunkHelpers.setOrUpdateLeafTags({ArrayBuffer: true, DataView: true, ArrayBufferView: false, Float32Array: true, Float64Array: true, Int16Array: true, Int32Array: true, Int8Array: true, Uint16Array: true, Uint32Array: true, Uint8ClampedArray: true, CanvasPixelArray: true, Uint8Array: false});
    H.NativeTypedArray.$nativeSuperclassTag = "ArrayBufferView";
    H._NativeTypedArrayOfDouble_NativeTypedArray_ListMixin.$nativeSuperclassTag = "ArrayBufferView";
    H._NativeTypedArrayOfDouble_NativeTypedArray_ListMixin_FixedLengthListMixin.$nativeSuperclassTag = "ArrayBufferView";
    H.NativeTypedArrayOfDouble.$nativeSuperclassTag = "ArrayBufferView";
    H._NativeTypedArrayOfInt_NativeTypedArray_ListMixin.$nativeSuperclassTag = "ArrayBufferView";
    H._NativeTypedArrayOfInt_NativeTypedArray_ListMixin_FixedLengthListMixin.$nativeSuperclassTag = "ArrayBufferView";
    H.NativeTypedArrayOfInt.$nativeSuperclassTag = "ArrayBufferView";
  })();
  Function.prototype.call$1 = function(a) {
    return this(a);
  };
  Function.prototype.call$2 = function(a, b) {
    return this(a, b);
  };
  Function.prototype.call$0 = function() {
    return this();
  };
  Function.prototype.call$3 = function(a, b, c) {
    return this(a, b, c);
  };
  Function.prototype.call$4 = function(a, b, c, d) {
    return this(a, b, c, d);
  };
  Function.prototype.call$1$1 = function(a) {
    return this(a);
  };
  Function.prototype.call$5 = function(a, b, c, d, e) {
    return this(a, b, c, d, e);
  };
  Function.prototype.call$1$3 = function(a, b, c) {
    return this(a, b, c);
  };
  Function.prototype.call$2$2 = function(a, b) {
    return this(a, b);
  };
  Function.prototype.call$6 = function(a, b, c, d, e, f) {
    return this(a, b, c, d, e, f);
  };
  Function.prototype.call$1$0 = function() {
    return this();
  };
  convertAllToFastObject(holders);
  convertToFastObject($);
  (function(callback) {
    if (typeof document === "undefined") {
      callback(null);
      return;
    }
    if (typeof document.currentScript != 'undefined') {
      callback(document.currentScript);
      return;
    }
    var scripts = document.scripts;
    function onLoad(event) {
      for (var i = 0; i < scripts.length; ++i)
        scripts[i].removeEventListener("load", onLoad, false);
      callback(event.target);
    }
    for (var i = 0; i < scripts.length; ++i)
      scripts[i].addEventListener("load", onLoad, false);
  })(function(currentScript) {
    init.currentScript = currentScript;
    if (typeof dartMainRunner === "function")
      dartMainRunner(B.main0, []);
    else
      B.main0([]);
  });
})();

/* WEBPACK VAR INJECTION */}.call(this, "/", "/index.js"))

/***/ }),

/***/ "./node_modules/send/index.js":
/*!************************************!*\
  !*** ./node_modules/send/index.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * send
 * Copyright(c) 2012 TJ Holowaychuk
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var createError = __webpack_require__(/*! http-errors */ "./node_modules/http-errors/index.js")
var debug = __webpack_require__(/*! debug */ "./node_modules/send/node_modules/debug/src/index.js")('send')
var deprecate = __webpack_require__(/*! depd */ "./node_modules/depd/index.js")('send')
var destroy = __webpack_require__(/*! destroy */ "./node_modules/destroy/index.js")
var encodeUrl = __webpack_require__(/*! encodeurl */ "./node_modules/encodeurl/index.js")
var escapeHtml = __webpack_require__(/*! escape-html */ "./node_modules/escape-html/index.js")
var etag = __webpack_require__(/*! etag */ "./node_modules/etag/index.js")
var fresh = __webpack_require__(/*! fresh */ "./node_modules/fresh/index.js")
var fs = __webpack_require__(/*! fs */ "fs")
var mime = __webpack_require__(/*! mime */ "./node_modules/mime/mime.js")
var ms = __webpack_require__(/*! ms */ "./node_modules/send/node_modules/ms/index.js")
var onFinished = __webpack_require__(/*! on-finished */ "./node_modules/on-finished/index.js")
var parseRange = __webpack_require__(/*! range-parser */ "./node_modules/range-parser/index.js")
var path = __webpack_require__(/*! path */ "path")
var statuses = __webpack_require__(/*! statuses */ "./node_modules/statuses/index.js")
var Stream = __webpack_require__(/*! stream */ "stream")
var util = __webpack_require__(/*! util */ "util")

/**
 * Path function references.
 * @private
 */

var extname = path.extname
var join = path.join
var normalize = path.normalize
var resolve = path.resolve
var sep = path.sep

/**
 * Regular expression for identifying a bytes Range header.
 * @private
 */

var BYTES_RANGE_REGEXP = /^ *bytes=/

/**
 * Maximum value allowed for the max age.
 * @private
 */

var MAX_MAXAGE = 60 * 60 * 24 * 365 * 1000 // 1 year

/**
 * Regular expression to match a path with a directory up component.
 * @private
 */

var UP_PATH_REGEXP = /(?:^|[\\/])\.\.(?:[\\/]|$)/

/**
 * Module exports.
 * @public
 */

module.exports = send
module.exports.mime = mime

/**
 * Return a `SendStream` for `req` and `path`.
 *
 * @param {object} req
 * @param {string} path
 * @param {object} [options]
 * @return {SendStream}
 * @public
 */

function send (req, path, options) {
  return new SendStream(req, path, options)
}

/**
 * Initialize a `SendStream` with the given `path`.
 *
 * @param {Request} req
 * @param {String} path
 * @param {object} [options]
 * @private
 */

function SendStream (req, path, options) {
  Stream.call(this)

  var opts = options || {}

  this.options = opts
  this.path = path
  this.req = req

  this._acceptRanges = opts.acceptRanges !== undefined
    ? Boolean(opts.acceptRanges)
    : true

  this._cacheControl = opts.cacheControl !== undefined
    ? Boolean(opts.cacheControl)
    : true

  this._etag = opts.etag !== undefined
    ? Boolean(opts.etag)
    : true

  this._dotfiles = opts.dotfiles !== undefined
    ? opts.dotfiles
    : 'ignore'

  if (this._dotfiles !== 'ignore' && this._dotfiles !== 'allow' && this._dotfiles !== 'deny') {
    throw new TypeError('dotfiles option must be "allow", "deny", or "ignore"')
  }

  this._hidden = Boolean(opts.hidden)

  if (opts.hidden !== undefined) {
    deprecate('hidden: use dotfiles: \'' + (this._hidden ? 'allow' : 'ignore') + '\' instead')
  }

  // legacy support
  if (opts.dotfiles === undefined) {
    this._dotfiles = undefined
  }

  this._extensions = opts.extensions !== undefined
    ? normalizeList(opts.extensions, 'extensions option')
    : []

  this._immutable = opts.immutable !== undefined
    ? Boolean(opts.immutable)
    : false

  this._index = opts.index !== undefined
    ? normalizeList(opts.index, 'index option')
    : ['index.html']

  this._lastModified = opts.lastModified !== undefined
    ? Boolean(opts.lastModified)
    : true

  this._maxage = opts.maxAge || opts.maxage
  this._maxage = typeof this._maxage === 'string'
    ? ms(this._maxage)
    : Number(this._maxage)
  this._maxage = !isNaN(this._maxage)
    ? Math.min(Math.max(0, this._maxage), MAX_MAXAGE)
    : 0

  this._root = opts.root
    ? resolve(opts.root)
    : null

  if (!this._root && opts.from) {
    this.from(opts.from)
  }
}

/**
 * Inherits from `Stream`.
 */

util.inherits(SendStream, Stream)

/**
 * Enable or disable etag generation.
 *
 * @param {Boolean} val
 * @return {SendStream}
 * @api public
 */

SendStream.prototype.etag = deprecate.function(function etag (val) {
  this._etag = Boolean(val)
  debug('etag %s', this._etag)
  return this
}, 'send.etag: pass etag as option')

/**
 * Enable or disable "hidden" (dot) files.
 *
 * @param {Boolean} path
 * @return {SendStream}
 * @api public
 */

SendStream.prototype.hidden = deprecate.function(function hidden (val) {
  this._hidden = Boolean(val)
  this._dotfiles = undefined
  debug('hidden %s', this._hidden)
  return this
}, 'send.hidden: use dotfiles option')

/**
 * Set index `paths`, set to a falsy
 * value to disable index support.
 *
 * @param {String|Boolean|Array} paths
 * @return {SendStream}
 * @api public
 */

SendStream.prototype.index = deprecate.function(function index (paths) {
  var index = !paths ? [] : normalizeList(paths, 'paths argument')
  debug('index %o', paths)
  this._index = index
  return this
}, 'send.index: pass index as option')

/**
 * Set root `path`.
 *
 * @param {String} path
 * @return {SendStream}
 * @api public
 */

SendStream.prototype.root = function root (path) {
  this._root = resolve(String(path))
  debug('root %s', this._root)
  return this
}

SendStream.prototype.from = deprecate.function(SendStream.prototype.root,
  'send.from: pass root as option')

SendStream.prototype.root = deprecate.function(SendStream.prototype.root,
  'send.root: pass root as option')

/**
 * Set max-age to `maxAge`.
 *
 * @param {Number} maxAge
 * @return {SendStream}
 * @api public
 */

SendStream.prototype.maxage = deprecate.function(function maxage (maxAge) {
  this._maxage = typeof maxAge === 'string'
    ? ms(maxAge)
    : Number(maxAge)
  this._maxage = !isNaN(this._maxage)
    ? Math.min(Math.max(0, this._maxage), MAX_MAXAGE)
    : 0
  debug('max-age %d', this._maxage)
  return this
}, 'send.maxage: pass maxAge as option')

/**
 * Emit error with `status`.
 *
 * @param {number} status
 * @param {Error} [err]
 * @private
 */

SendStream.prototype.error = function error (status, err) {
  // emit if listeners instead of responding
  if (hasListeners(this, 'error')) {
    return this.emit('error', createError(status, err, {
      expose: false
    }))
  }

  var res = this.res
  var msg = statuses[status] || String(status)
  var doc = createHtmlDocument('Error', escapeHtml(msg))

  // clear existing headers
  clearHeaders(res)

  // add error headers
  if (err && err.headers) {
    setHeaders(res, err.headers)
  }

  // send basic response
  res.statusCode = status
  res.setHeader('Content-Type', 'text/html; charset=UTF-8')
  res.setHeader('Content-Length', Buffer.byteLength(doc))
  res.setHeader('Content-Security-Policy', "default-src 'none'")
  res.setHeader('X-Content-Type-Options', 'nosniff')
  res.end(doc)
}

/**
 * Check if the pathname ends with "/".
 *
 * @return {boolean}
 * @private
 */

SendStream.prototype.hasTrailingSlash = function hasTrailingSlash () {
  return this.path[this.path.length - 1] === '/'
}

/**
 * Check if this is a conditional GET request.
 *
 * @return {Boolean}
 * @api private
 */

SendStream.prototype.isConditionalGET = function isConditionalGET () {
  return this.req.headers['if-match'] ||
    this.req.headers['if-unmodified-since'] ||
    this.req.headers['if-none-match'] ||
    this.req.headers['if-modified-since']
}

/**
 * Check if the request preconditions failed.
 *
 * @return {boolean}
 * @private
 */

SendStream.prototype.isPreconditionFailure = function isPreconditionFailure () {
  var req = this.req
  var res = this.res

  // if-match
  var match = req.headers['if-match']
  if (match) {
    var etag = res.getHeader('ETag')
    return !etag || (match !== '*' && parseTokenList(match).every(function (match) {
      return match !== etag && match !== 'W/' + etag && 'W/' + match !== etag
    }))
  }

  // if-unmodified-since
  var unmodifiedSince = parseHttpDate(req.headers['if-unmodified-since'])
  if (!isNaN(unmodifiedSince)) {
    var lastModified = parseHttpDate(res.getHeader('Last-Modified'))
    return isNaN(lastModified) || lastModified > unmodifiedSince
  }

  return false
}

/**
 * Strip content-* header fields.
 *
 * @private
 */

SendStream.prototype.removeContentHeaderFields = function removeContentHeaderFields () {
  var res = this.res
  var headers = getHeaderNames(res)

  for (var i = 0; i < headers.length; i++) {
    var header = headers[i]
    if (header.substr(0, 8) === 'content-' && header !== 'content-location') {
      res.removeHeader(header)
    }
  }
}

/**
 * Respond with 304 not modified.
 *
 * @api private
 */

SendStream.prototype.notModified = function notModified () {
  var res = this.res
  debug('not modified')
  this.removeContentHeaderFields()
  res.statusCode = 304
  res.end()
}

/**
 * Raise error that headers already sent.
 *
 * @api private
 */

SendStream.prototype.headersAlreadySent = function headersAlreadySent () {
  var err = new Error('Can\'t set headers after they are sent.')
  debug('headers already sent')
  this.error(500, err)
}

/**
 * Check if the request is cacheable, aka
 * responded with 2xx or 304 (see RFC 2616 section 14.2{5,6}).
 *
 * @return {Boolean}
 * @api private
 */

SendStream.prototype.isCachable = function isCachable () {
  var statusCode = this.res.statusCode
  return (statusCode >= 200 && statusCode < 300) ||
    statusCode === 304
}

/**
 * Handle stat() error.
 *
 * @param {Error} error
 * @private
 */

SendStream.prototype.onStatError = function onStatError (error) {
  switch (error.code) {
    case 'ENAMETOOLONG':
    case 'ENOENT':
    case 'ENOTDIR':
      this.error(404, error)
      break
    default:
      this.error(500, error)
      break
  }
}

/**
 * Check if the cache is fresh.
 *
 * @return {Boolean}
 * @api private
 */

SendStream.prototype.isFresh = function isFresh () {
  return fresh(this.req.headers, {
    'etag': this.res.getHeader('ETag'),
    'last-modified': this.res.getHeader('Last-Modified')
  })
}

/**
 * Check if the range is fresh.
 *
 * @return {Boolean}
 * @api private
 */

SendStream.prototype.isRangeFresh = function isRangeFresh () {
  var ifRange = this.req.headers['if-range']

  if (!ifRange) {
    return true
  }

  // if-range as etag
  if (ifRange.indexOf('"') !== -1) {
    var etag = this.res.getHeader('ETag')
    return Boolean(etag && ifRange.indexOf(etag) !== -1)
  }

  // if-range as modified date
  var lastModified = this.res.getHeader('Last-Modified')
  return parseHttpDate(lastModified) <= parseHttpDate(ifRange)
}

/**
 * Redirect to path.
 *
 * @param {string} path
 * @private
 */

SendStream.prototype.redirect = function redirect (path) {
  var res = this.res

  if (hasListeners(this, 'directory')) {
    this.emit('directory', res, path)
    return
  }

  if (this.hasTrailingSlash()) {
    this.error(403)
    return
  }

  var loc = encodeUrl(collapseLeadingSlashes(this.path + '/'))
  var doc = createHtmlDocument('Redirecting', 'Redirecting to <a href="' + escapeHtml(loc) + '">' +
    escapeHtml(loc) + '</a>')

  // redirect
  res.statusCode = 301
  res.setHeader('Content-Type', 'text/html; charset=UTF-8')
  res.setHeader('Content-Length', Buffer.byteLength(doc))
  res.setHeader('Content-Security-Policy', "default-src 'none'")
  res.setHeader('X-Content-Type-Options', 'nosniff')
  res.setHeader('Location', loc)
  res.end(doc)
}

/**
 * Pipe to `res.
 *
 * @param {Stream} res
 * @return {Stream} res
 * @api public
 */

SendStream.prototype.pipe = function pipe (res) {
  // root path
  var root = this._root

  // references
  this.res = res

  // decode the path
  var path = decode(this.path)
  if (path === -1) {
    this.error(400)
    return res
  }

  // null byte(s)
  if (~path.indexOf('\0')) {
    this.error(400)
    return res
  }

  var parts
  if (root !== null) {
    // normalize
    if (path) {
      path = normalize('.' + sep + path)
    }

    // malicious path
    if (UP_PATH_REGEXP.test(path)) {
      debug('malicious path "%s"', path)
      this.error(403)
      return res
    }

    // explode path parts
    parts = path.split(sep)

    // join / normalize from optional root dir
    path = normalize(join(root, path))
  } else {
    // ".." is malicious without "root"
    if (UP_PATH_REGEXP.test(path)) {
      debug('malicious path "%s"', path)
      this.error(403)
      return res
    }

    // explode path parts
    parts = normalize(path).split(sep)

    // resolve the path
    path = resolve(path)
  }

  // dotfile handling
  if (containsDotFile(parts)) {
    var access = this._dotfiles

    // legacy support
    if (access === undefined) {
      access = parts[parts.length - 1][0] === '.'
        ? (this._hidden ? 'allow' : 'ignore')
        : 'allow'
    }

    debug('%s dotfile "%s"', access, path)
    switch (access) {
      case 'allow':
        break
      case 'deny':
        this.error(403)
        return res
      case 'ignore':
      default:
        this.error(404)
        return res
    }
  }

  // index file support
  if (this._index.length && this.hasTrailingSlash()) {
    this.sendIndex(path)
    return res
  }

  this.sendFile(path)
  return res
}

/**
 * Transfer `path`.
 *
 * @param {String} path
 * @api public
 */

SendStream.prototype.send = function send (path, stat) {
  var len = stat.size
  var options = this.options
  var opts = {}
  var res = this.res
  var req = this.req
  var ranges = req.headers.range
  var offset = options.start || 0

  if (headersSent(res)) {
    // impossible to send now
    this.headersAlreadySent()
    return
  }

  debug('pipe "%s"', path)

  // set header fields
  this.setHeader(path, stat)

  // set content-type
  this.type(path)

  // conditional GET support
  if (this.isConditionalGET()) {
    if (this.isPreconditionFailure()) {
      this.error(412)
      return
    }

    if (this.isCachable() && this.isFresh()) {
      this.notModified()
      return
    }
  }

  // adjust len to start/end options
  len = Math.max(0, len - offset)
  if (options.end !== undefined) {
    var bytes = options.end - offset + 1
    if (len > bytes) len = bytes
  }

  // Range support
  if (this._acceptRanges && BYTES_RANGE_REGEXP.test(ranges)) {
    // parse
    ranges = parseRange(len, ranges, {
      combine: true
    })

    // If-Range support
    if (!this.isRangeFresh()) {
      debug('range stale')
      ranges = -2
    }

    // unsatisfiable
    if (ranges === -1) {
      debug('range unsatisfiable')

      // Content-Range
      res.setHeader('Content-Range', contentRange('bytes', len))

      // 416 Requested Range Not Satisfiable
      return this.error(416, {
        headers: { 'Content-Range': res.getHeader('Content-Range') }
      })
    }

    // valid (syntactically invalid/multiple ranges are treated as a regular response)
    if (ranges !== -2 && ranges.length === 1) {
      debug('range %j', ranges)

      // Content-Range
      res.statusCode = 206
      res.setHeader('Content-Range', contentRange('bytes', len, ranges[0]))

      // adjust for requested range
      offset += ranges[0].start
      len = ranges[0].end - ranges[0].start + 1
    }
  }

  // clone options
  for (var prop in options) {
    opts[prop] = options[prop]
  }

  // set read options
  opts.start = offset
  opts.end = Math.max(offset, offset + len - 1)

  // content-length
  res.setHeader('Content-Length', len)

  // HEAD support
  if (req.method === 'HEAD') {
    res.end()
    return
  }

  this.stream(path, opts)
}

/**
 * Transfer file for `path`.
 *
 * @param {String} path
 * @api private
 */
SendStream.prototype.sendFile = function sendFile (path) {
  var i = 0
  var self = this

  debug('stat "%s"', path)
  fs.stat(path, function onstat (err, stat) {
    if (err && err.code === 'ENOENT' && !extname(path) && path[path.length - 1] !== sep) {
      // not found, check extensions
      return next(err)
    }
    if (err) return self.onStatError(err)
    if (stat.isDirectory()) return self.redirect(path)
    self.emit('file', path, stat)
    self.send(path, stat)
  })

  function next (err) {
    if (self._extensions.length <= i) {
      return err
        ? self.onStatError(err)
        : self.error(404)
    }

    var p = path + '.' + self._extensions[i++]

    debug('stat "%s"', p)
    fs.stat(p, function (err, stat) {
      if (err) return next(err)
      if (stat.isDirectory()) return next()
      self.emit('file', p, stat)
      self.send(p, stat)
    })
  }
}

/**
 * Transfer index for `path`.
 *
 * @param {String} path
 * @api private
 */
SendStream.prototype.sendIndex = function sendIndex (path) {
  var i = -1
  var self = this

  function next (err) {
    if (++i >= self._index.length) {
      if (err) return self.onStatError(err)
      return self.error(404)
    }

    var p = join(path, self._index[i])

    debug('stat "%s"', p)
    fs.stat(p, function (err, stat) {
      if (err) return next(err)
      if (stat.isDirectory()) return next()
      self.emit('file', p, stat)
      self.send(p, stat)
    })
  }

  next()
}

/**
 * Stream `path` to the response.
 *
 * @param {String} path
 * @param {Object} options
 * @api private
 */

SendStream.prototype.stream = function stream (path, options) {
  // TODO: this is all lame, refactor meeee
  var finished = false
  var self = this
  var res = this.res

  // pipe
  var stream = fs.createReadStream(path, options)
  this.emit('stream', stream)
  stream.pipe(res)

  // response finished, done with the fd
  onFinished(res, function onfinished () {
    finished = true
    destroy(stream)
  })

  // error handling code-smell
  stream.on('error', function onerror (err) {
    // request already finished
    if (finished) return

    // clean up stream
    finished = true
    destroy(stream)

    // error
    self.onStatError(err)
  })

  // end
  stream.on('end', function onend () {
    self.emit('end')
  })
}

/**
 * Set content-type based on `path`
 * if it hasn't been explicitly set.
 *
 * @param {String} path
 * @api private
 */

SendStream.prototype.type = function type (path) {
  var res = this.res

  if (res.getHeader('Content-Type')) return

  var type = mime.lookup(path)

  if (!type) {
    debug('no content-type')
    return
  }

  var charset = mime.charsets.lookup(type)

  debug('content-type %s', type)
  res.setHeader('Content-Type', type + (charset ? '; charset=' + charset : ''))
}

/**
 * Set response header fields, most
 * fields may be pre-defined.
 *
 * @param {String} path
 * @param {Object} stat
 * @api private
 */

SendStream.prototype.setHeader = function setHeader (path, stat) {
  var res = this.res

  this.emit('headers', res, path, stat)

  if (this._acceptRanges && !res.getHeader('Accept-Ranges')) {
    debug('accept ranges')
    res.setHeader('Accept-Ranges', 'bytes')
  }

  if (this._cacheControl && !res.getHeader('Cache-Control')) {
    var cacheControl = 'public, max-age=' + Math.floor(this._maxage / 1000)

    if (this._immutable) {
      cacheControl += ', immutable'
    }

    debug('cache-control %s', cacheControl)
    res.setHeader('Cache-Control', cacheControl)
  }

  if (this._lastModified && !res.getHeader('Last-Modified')) {
    var modified = stat.mtime.toUTCString()
    debug('modified %s', modified)
    res.setHeader('Last-Modified', modified)
  }

  if (this._etag && !res.getHeader('ETag')) {
    var val = etag(stat)
    debug('etag %s', val)
    res.setHeader('ETag', val)
  }
}

/**
 * Clear all headers from a response.
 *
 * @param {object} res
 * @private
 */

function clearHeaders (res) {
  var headers = getHeaderNames(res)

  for (var i = 0; i < headers.length; i++) {
    res.removeHeader(headers[i])
  }
}

/**
 * Collapse all leading slashes into a single slash
 *
 * @param {string} str
 * @private
 */
function collapseLeadingSlashes (str) {
  for (var i = 0; i < str.length; i++) {
    if (str[i] !== '/') {
      break
    }
  }

  return i > 1
    ? '/' + str.substr(i)
    : str
}

/**
 * Determine if path parts contain a dotfile.
 *
 * @api private
 */

function containsDotFile (parts) {
  for (var i = 0; i < parts.length; i++) {
    var part = parts[i]
    if (part.length > 1 && part[0] === '.') {
      return true
    }
  }

  return false
}

/**
 * Create a Content-Range header.
 *
 * @param {string} type
 * @param {number} size
 * @param {array} [range]
 */

function contentRange (type, size, range) {
  return type + ' ' + (range ? range.start + '-' + range.end : '*') + '/' + size
}

/**
 * Create a minimal HTML document.
 *
 * @param {string} title
 * @param {string} body
 * @private
 */

function createHtmlDocument (title, body) {
  return '<!DOCTYPE html>\n' +
    '<html lang="en">\n' +
    '<head>\n' +
    '<meta charset="utf-8">\n' +
    '<title>' + title + '</title>\n' +
    '</head>\n' +
    '<body>\n' +
    '<pre>' + body + '</pre>\n' +
    '</body>\n' +
    '</html>\n'
}

/**
 * decodeURIComponent.
 *
 * Allows V8 to only deoptimize this fn instead of all
 * of send().
 *
 * @param {String} path
 * @api private
 */

function decode (path) {
  try {
    return decodeURIComponent(path)
  } catch (err) {
    return -1
  }
}

/**
 * Get the header names on a respnse.
 *
 * @param {object} res
 * @returns {array[string]}
 * @private
 */

function getHeaderNames (res) {
  return typeof res.getHeaderNames !== 'function'
    ? Object.keys(res._headers || {})
    : res.getHeaderNames()
}

/**
 * Determine if emitter has listeners of a given type.
 *
 * The way to do this check is done three different ways in Node.js >= 0.8
 * so this consolidates them into a minimal set using instance methods.
 *
 * @param {EventEmitter} emitter
 * @param {string} type
 * @returns {boolean}
 * @private
 */

function hasListeners (emitter, type) {
  var count = typeof emitter.listenerCount !== 'function'
    ? emitter.listeners(type).length
    : emitter.listenerCount(type)

  return count > 0
}

/**
 * Determine if the response headers have been sent.
 *
 * @param {object} res
 * @returns {boolean}
 * @private
 */

function headersSent (res) {
  return typeof res.headersSent !== 'boolean'
    ? Boolean(res._header)
    : res.headersSent
}

/**
 * Normalize the index option into an array.
 *
 * @param {boolean|string|array} val
 * @param {string} name
 * @private
 */

function normalizeList (val, name) {
  var list = [].concat(val || [])

  for (var i = 0; i < list.length; i++) {
    if (typeof list[i] !== 'string') {
      throw new TypeError(name + ' must be array of strings or false')
    }
  }

  return list
}

/**
 * Parse an HTTP Date into a number.
 *
 * @param {string} date
 * @private
 */

function parseHttpDate (date) {
  var timestamp = date && Date.parse(date)

  return typeof timestamp === 'number'
    ? timestamp
    : NaN
}

/**
 * Parse a HTTP token list.
 *
 * @param {string} str
 * @private
 */

function parseTokenList (str) {
  var end = 0
  var list = []
  var start = 0

  // gather tokens
  for (var i = 0, len = str.length; i < len; i++) {
    switch (str.charCodeAt(i)) {
      case 0x20: /*   */
        if (start === end) {
          start = end = i + 1
        }
        break
      case 0x2c: /* , */
        list.push(str.substring(start, end))
        start = end = i + 1
        break
      default:
        end = i + 1
        break
    }
  }

  // final token
  list.push(str.substring(start, end))

  return list
}

/**
 * Set an object of headers on a response.
 *
 * @param {object} res
 * @param {object} headers
 * @private
 */

function setHeaders (res, headers) {
  var keys = Object.keys(headers)

  for (var i = 0; i < keys.length; i++) {
    var key = keys[i]
    res.setHeader(key, headers[key])
  }
}


/***/ }),

/***/ "./node_modules/send/node_modules/debug/node_modules/ms/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/send/node_modules/debug/node_modules/ms/index.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') ||
    plural(ms, h, 'hour') ||
    plural(ms, m, 'minute') ||
    plural(ms, s, 'second') ||
    ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return;
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }
  return Math.ceil(ms / n) + ' ' + name + 's';
}


/***/ }),

/***/ "./node_modules/send/node_modules/debug/src/browser.js":
/*!*************************************************************!*\
  !*** ./node_modules/send/node_modules/debug/src/browser.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __webpack_require__(/*! ./debug */ "./node_modules/send/node_modules/debug/src/debug.js");
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}


/***/ }),

/***/ "./node_modules/send/node_modules/debug/src/debug.js":
/*!***********************************************************!*\
  !*** ./node_modules/send/node_modules/debug/src/debug.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = __webpack_require__(/*! ms */ "./node_modules/send/node_modules/debug/node_modules/ms/index.js");

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  return debug;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}


/***/ }),

/***/ "./node_modules/send/node_modules/debug/src/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/send/node_modules/debug/src/index.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Detect Electron renderer process, which is node, but we should
 * treat as a browser.
 */

if (typeof process !== 'undefined' && process.type === 'renderer') {
  module.exports = __webpack_require__(/*! ./browser.js */ "./node_modules/send/node_modules/debug/src/browser.js");
} else {
  module.exports = __webpack_require__(/*! ./node.js */ "./node_modules/send/node_modules/debug/src/node.js");
}


/***/ }),

/***/ "./node_modules/send/node_modules/debug/src/node.js":
/*!**********************************************************!*\
  !*** ./node_modules/send/node_modules/debug/src/node.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Module dependencies.
 */

var tty = __webpack_require__(/*! tty */ "tty");
var util = __webpack_require__(/*! util */ "util");

/**
 * This is the Node.js implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __webpack_require__(/*! ./debug */ "./node_modules/send/node_modules/debug/src/debug.js");
exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(function (key) {
  return /^debug_/i.test(key);
}).reduce(function (obj, key) {
  // camel-case
  var prop = key
    .substring(6)
    .toLowerCase()
    .replace(/_([a-z])/g, function (_, k) { return k.toUpperCase() });

  // coerce string value into JS value
  var val = process.env[key];
  if (/^(yes|on|true|enabled)$/i.test(val)) val = true;
  else if (/^(no|off|false|disabled)$/i.test(val)) val = false;
  else if (val === 'null') val = null;
  else val = Number(val);

  obj[prop] = val;
  return obj;
}, {});

/**
 * The file descriptor to write the `debug()` calls to.
 * Set the `DEBUG_FD` env variable to override with another value. i.e.:
 *
 *   $ DEBUG_FD=3 node script.js 3>debug.log
 */

var fd = parseInt(process.env.DEBUG_FD, 10) || 2;

if (1 !== fd && 2 !== fd) {
  util.deprecate(function(){}, 'except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)')()
}

var stream = 1 === fd ? process.stdout :
             2 === fd ? process.stderr :
             createWritableStdioStream(fd);

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
  return 'colors' in exports.inspectOpts
    ? Boolean(exports.inspectOpts.colors)
    : tty.isatty(fd);
}

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

exports.formatters.o = function(v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts)
    .split('\n').map(function(str) {
      return str.trim()
    }).join(' ');
};

/**
 * Map %o to `util.inspect()`, allowing multiple lines if needed.
 */

exports.formatters.O = function(v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts);
};

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var name = this.namespace;
  var useColors = this.useColors;

  if (useColors) {
    var c = this.color;
    var prefix = '  \u001b[3' + c + ';1m' + name + ' ' + '\u001b[0m';

    args[0] = prefix + args[0].split('\n').join('\n' + prefix);
    args.push('\u001b[3' + c + 'm+' + exports.humanize(this.diff) + '\u001b[0m');
  } else {
    args[0] = new Date().toUTCString()
      + ' ' + name + ' ' + args[0];
  }
}

/**
 * Invokes `util.format()` with the specified arguments and writes to `stream`.
 */

function log() {
  return stream.write(util.format.apply(util, arguments) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  if (null == namespaces) {
    // If you set a process.env field to null or undefined, it gets cast to the
    // string 'null' or 'undefined'. Just delete instead.
    delete process.env.DEBUG;
  } else {
    process.env.DEBUG = namespaces;
  }
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  return process.env.DEBUG;
}

/**
 * Copied from `node/src/node.js`.
 *
 * XXX: It's lame that node doesn't expose this API out-of-the-box. It also
 * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.
 */

function createWritableStdioStream (fd) {
  var stream;
  var tty_wrap = process.binding('tty_wrap');

  // Note stream._type is used for test-module-load-list.js

  switch (tty_wrap.guessHandleType(fd)) {
    case 'TTY':
      stream = new tty.WriteStream(fd);
      stream._type = 'tty';

      // Hack to have stream not keep the event loop alive.
      // See https://github.com/joyent/node/issues/1726
      if (stream._handle && stream._handle.unref) {
        stream._handle.unref();
      }
      break;

    case 'FILE':
      var fs = __webpack_require__(/*! fs */ "fs");
      stream = new fs.SyncWriteStream(fd, { autoClose: false });
      stream._type = 'fs';
      break;

    case 'PIPE':
    case 'TCP':
      var net = __webpack_require__(/*! net */ "net");
      stream = new net.Socket({
        fd: fd,
        readable: false,
        writable: true
      });

      // FIXME Should probably have an option in net.Socket to create a
      // stream from an existing fd which is writable only. But for now
      // we'll just add this hack and set the `readable` member to false.
      // Test: ./node test/fixtures/echo.js < /etc/passwd
      stream.readable = false;
      stream.read = null;
      stream._type = 'pipe';

      // FIXME Hack to have stream not keep the event loop alive.
      // See https://github.com/joyent/node/issues/1726
      if (stream._handle && stream._handle.unref) {
        stream._handle.unref();
      }
      break;

    default:
      // Probably an error on in uv_guess_handle()
      throw new Error('Implement me. Unknown stream file type!');
  }

  // For supporting legacy API we put the FD here.
  stream.fd = fd;

  stream._isStdio = true;

  return stream;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init (debug) {
  debug.inspectOpts = {};

  var keys = Object.keys(exports.inspectOpts);
  for (var i = 0; i < keys.length; i++) {
    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
  }
}

/**
 * Enable namespaces listed in `process.env.DEBUG` initially.
 */

exports.enable(load());


/***/ }),

/***/ "./node_modules/send/node_modules/ms/index.js":
/*!****************************************************!*\
  !*** ./node_modules/send/node_modules/ms/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\-?\d?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}


/***/ }),

/***/ "./node_modules/serve-static/index.js":
/*!********************************************!*\
  !*** ./node_modules/serve-static/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * serve-static
 * Copyright(c) 2010 Sencha Inc.
 * Copyright(c) 2011 TJ Holowaychuk
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var encodeUrl = __webpack_require__(/*! encodeurl */ "./node_modules/encodeurl/index.js")
var escapeHtml = __webpack_require__(/*! escape-html */ "./node_modules/escape-html/index.js")
var parseUrl = __webpack_require__(/*! parseurl */ "./node_modules/parseurl/index.js")
var resolve = __webpack_require__(/*! path */ "path").resolve
var send = __webpack_require__(/*! send */ "./node_modules/send/index.js")
var url = __webpack_require__(/*! url */ "url")

/**
 * Module exports.
 * @public
 */

module.exports = serveStatic
module.exports.mime = send.mime

/**
 * @param {string} root
 * @param {object} [options]
 * @return {function}
 * @public
 */

function serveStatic (root, options) {
  if (!root) {
    throw new TypeError('root path required')
  }

  if (typeof root !== 'string') {
    throw new TypeError('root path must be a string')
  }

  // copy options object
  var opts = Object.create(options || null)

  // fall-though
  var fallthrough = opts.fallthrough !== false

  // default redirect
  var redirect = opts.redirect !== false

  // headers listener
  var setHeaders = opts.setHeaders

  if (setHeaders && typeof setHeaders !== 'function') {
    throw new TypeError('option setHeaders must be function')
  }

  // setup options for send
  opts.maxage = opts.maxage || opts.maxAge || 0
  opts.root = resolve(root)

  // construct directory listener
  var onDirectory = redirect
    ? createRedirectDirectoryListener()
    : createNotFoundDirectoryListener()

  return function serveStatic (req, res, next) {
    if (req.method !== 'GET' && req.method !== 'HEAD') {
      if (fallthrough) {
        return next()
      }

      // method not allowed
      res.statusCode = 405
      res.setHeader('Allow', 'GET, HEAD')
      res.setHeader('Content-Length', '0')
      res.end()
      return
    }

    var forwardError = !fallthrough
    var originalUrl = parseUrl.original(req)
    var path = parseUrl(req).pathname

    // make sure redirect occurs at mount
    if (path === '/' && originalUrl.pathname.substr(-1) !== '/') {
      path = ''
    }

    // create send stream
    var stream = send(req, path, opts)

    // add directory handler
    stream.on('directory', onDirectory)

    // add headers listener
    if (setHeaders) {
      stream.on('headers', setHeaders)
    }

    // add file listener for fallthrough
    if (fallthrough) {
      stream.on('file', function onFile () {
        // once file is determined, always forward error
        forwardError = true
      })
    }

    // forward errors
    stream.on('error', function error (err) {
      if (forwardError || !(err.statusCode < 500)) {
        next(err)
        return
      }

      next()
    })

    // pipe
    stream.pipe(res)
  }
}

/**
 * Collapse all leading slashes into a single slash
 * @private
 */
function collapseLeadingSlashes (str) {
  for (var i = 0; i < str.length; i++) {
    if (str.charCodeAt(i) !== 0x2f /* / */) {
      break
    }
  }

  return i > 1
    ? '/' + str.substr(i)
    : str
}

/**
 * Create a minimal HTML document.
 *
 * @param {string} title
 * @param {string} body
 * @private
 */

function createHtmlDocument (title, body) {
  return '<!DOCTYPE html>\n' +
    '<html lang="en">\n' +
    '<head>\n' +
    '<meta charset="utf-8">\n' +
    '<title>' + title + '</title>\n' +
    '</head>\n' +
    '<body>\n' +
    '<pre>' + body + '</pre>\n' +
    '</body>\n' +
    '</html>\n'
}

/**
 * Create a directory listener that just 404s.
 * @private
 */

function createNotFoundDirectoryListener () {
  return function notFound () {
    this.error(404)
  }
}

/**
 * Create a directory listener that performs a redirect.
 * @private
 */

function createRedirectDirectoryListener () {
  return function redirect (res) {
    if (this.hasTrailingSlash()) {
      this.error(404)
      return
    }

    // get original URL
    var originalUrl = parseUrl.original(this.req)

    // append trailing slash
    originalUrl.path = null
    originalUrl.pathname = collapseLeadingSlashes(originalUrl.pathname + '/')

    // reformat the URL
    var loc = encodeUrl(url.format(originalUrl))
    var doc = createHtmlDocument('Redirecting', 'Redirecting to <a href="' + escapeHtml(loc) + '">' +
      escapeHtml(loc) + '</a>')

    // send redirect response
    res.statusCode = 301
    res.setHeader('Content-Type', 'text/html; charset=UTF-8')
    res.setHeader('Content-Length', Buffer.byteLength(doc))
    res.setHeader('Content-Security-Policy', "default-src 'none'")
    res.setHeader('X-Content-Type-Options', 'nosniff')
    res.setHeader('Location', loc)
    res.end(doc)
  }
}


/***/ }),

/***/ "./node_modules/setprototypeof/index.js":
/*!**********************************************!*\
  !*** ./node_modules/setprototypeof/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* eslint no-proto: 0 */
module.exports = Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? setProtoOf : mixinProperties)

function setProtoOf (obj, proto) {
  obj.__proto__ = proto
  return obj
}

function mixinProperties (obj, proto) {
  for (var prop in proto) {
    if (!obj.hasOwnProperty(prop)) {
      obj[prop] = proto[prop]
    }
  }
  return obj
}


/***/ }),

/***/ "./node_modules/statuses/codes.json":
/*!******************************************!*\
  !*** ./node_modules/statuses/codes.json ***!
  \******************************************/
/*! exports provided: 100, 101, 102, 103, 200, 201, 202, 203, 204, 205, 206, 207, 208, 226, 300, 301, 302, 303, 304, 305, 306, 307, 308, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 421, 422, 423, 424, 425, 426, 428, 429, 431, 451, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"100\":\"Continue\",\"101\":\"Switching Protocols\",\"102\":\"Processing\",\"103\":\"Early Hints\",\"200\":\"OK\",\"201\":\"Created\",\"202\":\"Accepted\",\"203\":\"Non-Authoritative Information\",\"204\":\"No Content\",\"205\":\"Reset Content\",\"206\":\"Partial Content\",\"207\":\"Multi-Status\",\"208\":\"Already Reported\",\"226\":\"IM Used\",\"300\":\"Multiple Choices\",\"301\":\"Moved Permanently\",\"302\":\"Found\",\"303\":\"See Other\",\"304\":\"Not Modified\",\"305\":\"Use Proxy\",\"306\":\"(Unused)\",\"307\":\"Temporary Redirect\",\"308\":\"Permanent Redirect\",\"400\":\"Bad Request\",\"401\":\"Unauthorized\",\"402\":\"Payment Required\",\"403\":\"Forbidden\",\"404\":\"Not Found\",\"405\":\"Method Not Allowed\",\"406\":\"Not Acceptable\",\"407\":\"Proxy Authentication Required\",\"408\":\"Request Timeout\",\"409\":\"Conflict\",\"410\":\"Gone\",\"411\":\"Length Required\",\"412\":\"Precondition Failed\",\"413\":\"Payload Too Large\",\"414\":\"URI Too Long\",\"415\":\"Unsupported Media Type\",\"416\":\"Range Not Satisfiable\",\"417\":\"Expectation Failed\",\"418\":\"I'm a teapot\",\"421\":\"Misdirected Request\",\"422\":\"Unprocessable Entity\",\"423\":\"Locked\",\"424\":\"Failed Dependency\",\"425\":\"Unordered Collection\",\"426\":\"Upgrade Required\",\"428\":\"Precondition Required\",\"429\":\"Too Many Requests\",\"431\":\"Request Header Fields Too Large\",\"451\":\"Unavailable For Legal Reasons\",\"500\":\"Internal Server Error\",\"501\":\"Not Implemented\",\"502\":\"Bad Gateway\",\"503\":\"Service Unavailable\",\"504\":\"Gateway Timeout\",\"505\":\"HTTP Version Not Supported\",\"506\":\"Variant Also Negotiates\",\"507\":\"Insufficient Storage\",\"508\":\"Loop Detected\",\"509\":\"Bandwidth Limit Exceeded\",\"510\":\"Not Extended\",\"511\":\"Network Authentication Required\"}");

/***/ }),

/***/ "./node_modules/statuses/index.js":
/*!****************************************!*\
  !*** ./node_modules/statuses/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * statuses
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var codes = __webpack_require__(/*! ./codes.json */ "./node_modules/statuses/codes.json")

/**
 * Module exports.
 * @public
 */

module.exports = status

// status code to message map
status.STATUS_CODES = codes

// array of status codes
status.codes = populateStatusesMap(status, codes)

// status codes for redirects
status.redirect = {
  300: true,
  301: true,
  302: true,
  303: true,
  305: true,
  307: true,
  308: true
}

// status codes for empty bodies
status.empty = {
  204: true,
  205: true,
  304: true
}

// status codes for when you should retry the request
status.retry = {
  502: true,
  503: true,
  504: true
}

/**
 * Populate the statuses map for given codes.
 * @private
 */

function populateStatusesMap (statuses, codes) {
  var arr = []

  Object.keys(codes).forEach(function forEachCode (code) {
    var message = codes[code]
    var status = Number(code)

    // Populate properties
    statuses[status] = message
    statuses[message] = status
    statuses[message.toLowerCase()] = status

    // Add to array
    arr.push(status)
  })

  return arr
}

/**
 * Get the status code.
 *
 * Given a number, this will throw if it is not a known status
 * code, otherwise the code will be returned. Given a string,
 * the string will be parsed for a number and return the code
 * if valid, otherwise will lookup the code assuming this is
 * the status message.
 *
 * @param {string|number} code
 * @returns {number}
 * @public
 */

function status (code) {
  if (typeof code === 'number') {
    if (!status[code]) throw new Error('invalid status code: ' + code)
    return code
  }

  if (typeof code !== 'string') {
    throw new TypeError('code must be a number or string')
  }

  // '403'
  var n = parseInt(code, 10)
  if (!isNaN(n)) {
    if (!status[n]) throw new Error('invalid status code: ' + n)
    return n
  }

  n = status[code.toLowerCase()]
  if (!n) throw new Error('invalid status message: "' + code + '"')
  return n
}


/***/ }),

/***/ "./node_modules/to-regex-range/index.js":
/*!**********************************************!*\
  !*** ./node_modules/to-regex-range/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * to-regex-range <https://github.com/micromatch/to-regex-range>
 *
 * Copyright (c) 2015-present, Jon Schlinkert.
 * Released under the MIT License.
 */



const isNumber = __webpack_require__(/*! is-number */ "./node_modules/is-number/index.js");

const toRegexRange = (min, max, options) => {
  if (isNumber(min) === false) {
    throw new TypeError('toRegexRange: expected the first argument to be a number');
  }

  if (max === void 0 || min === max) {
    return String(min);
  }

  if (isNumber(max) === false) {
    throw new TypeError('toRegexRange: expected the second argument to be a number.');
  }

  let opts = { relaxZeros: true, ...options };
  if (typeof opts.strictZeros === 'boolean') {
    opts.relaxZeros = opts.strictZeros === false;
  }

  let relax = String(opts.relaxZeros);
  let shorthand = String(opts.shorthand);
  let capture = String(opts.capture);
  let wrap = String(opts.wrap);
  let cacheKey = min + ':' + max + '=' + relax + shorthand + capture + wrap;

  if (toRegexRange.cache.hasOwnProperty(cacheKey)) {
    return toRegexRange.cache[cacheKey].result;
  }

  let a = Math.min(min, max);
  let b = Math.max(min, max);

  if (Math.abs(a - b) === 1) {
    let result = min + '|' + max;
    if (opts.capture) {
      return `(${result})`;
    }
    if (opts.wrap === false) {
      return result;
    }
    return `(?:${result})`;
  }

  let isPadded = hasPadding(min) || hasPadding(max);
  let state = { min, max, a, b };
  let positives = [];
  let negatives = [];

  if (isPadded) {
    state.isPadded = isPadded;
    state.maxLen = String(state.max).length;
  }

  if (a < 0) {
    let newMin = b < 0 ? Math.abs(b) : 1;
    negatives = splitToPatterns(newMin, Math.abs(a), state, opts);
    a = state.a = 0;
  }

  if (b >= 0) {
    positives = splitToPatterns(a, b, state, opts);
  }

  state.negatives = negatives;
  state.positives = positives;
  state.result = collatePatterns(negatives, positives, opts);

  if (opts.capture === true) {
    state.result = `(${state.result})`;
  } else if (opts.wrap !== false && (positives.length + negatives.length) > 1) {
    state.result = `(?:${state.result})`;
  }

  toRegexRange.cache[cacheKey] = state;
  return state.result;
};

function collatePatterns(neg, pos, options) {
  let onlyNegative = filterPatterns(neg, pos, '-', false, options) || [];
  let onlyPositive = filterPatterns(pos, neg, '', false, options) || [];
  let intersected = filterPatterns(neg, pos, '-?', true, options) || [];
  let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
  return subpatterns.join('|');
}

function splitToRanges(min, max) {
  let nines = 1;
  let zeros = 1;

  let stop = countNines(min, nines);
  let stops = new Set([max]);

  while (min <= stop && stop <= max) {
    stops.add(stop);
    nines += 1;
    stop = countNines(min, nines);
  }

  stop = countZeros(max + 1, zeros) - 1;

  while (min < stop && stop <= max) {
    stops.add(stop);
    zeros += 1;
    stop = countZeros(max + 1, zeros) - 1;
  }

  stops = [...stops];
  stops.sort(compare);
  return stops;
}

/**
 * Convert a range to a regex pattern
 * @param {Number} `start`
 * @param {Number} `stop`
 * @return {String}
 */

function rangeToPattern(start, stop, options) {
  if (start === stop) {
    return { pattern: start, count: [], digits: 0 };
  }

  let zipped = zip(start, stop);
  let digits = zipped.length;
  let pattern = '';
  let count = 0;

  for (let i = 0; i < digits; i++) {
    let [startDigit, stopDigit] = zipped[i];

    if (startDigit === stopDigit) {
      pattern += startDigit;

    } else if (startDigit !== '0' || stopDigit !== '9') {
      pattern += toCharacterClass(startDigit, stopDigit, options);

    } else {
      count++;
    }
  }

  if (count) {
    pattern += options.shorthand === true ? '\\d' : '[0-9]';
  }

  return { pattern, count: [count], digits };
}

function splitToPatterns(min, max, tok, options) {
  let ranges = splitToRanges(min, max);
  let tokens = [];
  let start = min;
  let prev;

  for (let i = 0; i < ranges.length; i++) {
    let max = ranges[i];
    let obj = rangeToPattern(String(start), String(max), options);
    let zeros = '';

    if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
      if (prev.count.length > 1) {
        prev.count.pop();
      }

      prev.count.push(obj.count[0]);
      prev.string = prev.pattern + toQuantifier(prev.count);
      start = max + 1;
      continue;
    }

    if (tok.isPadded) {
      zeros = padZeros(max, tok, options);
    }

    obj.string = zeros + obj.pattern + toQuantifier(obj.count);
    tokens.push(obj);
    start = max + 1;
    prev = obj;
  }

  return tokens;
}

function filterPatterns(arr, comparison, prefix, intersection, options) {
  let result = [];

  for (let ele of arr) {
    let { string } = ele;

    // only push if _both_ are negative...
    if (!intersection && !contains(comparison, 'string', string)) {
      result.push(prefix + string);
    }

    // or _both_ are positive
    if (intersection && contains(comparison, 'string', string)) {
      result.push(prefix + string);
    }
  }
  return result;
}

/**
 * Zip strings
 */

function zip(a, b) {
  let arr = [];
  for (let i = 0; i < a.length; i++) arr.push([a[i], b[i]]);
  return arr;
}

function compare(a, b) {
  return a > b ? 1 : b > a ? -1 : 0;
}

function contains(arr, key, val) {
  return arr.some(ele => ele[key] === val);
}

function countNines(min, len) {
  return Number(String(min).slice(0, -len) + '9'.repeat(len));
}

function countZeros(integer, zeros) {
  return integer - (integer % Math.pow(10, zeros));
}

function toQuantifier(digits) {
  let [start = 0, stop = ''] = digits;
  if (stop || start > 1) {
    return `{${start + (stop ? ',' + stop : '')}}`;
  }
  return '';
}

function toCharacterClass(a, b, options) {
  return `[${a}${(b - a === 1) ? '' : '-'}${b}]`;
}

function hasPadding(str) {
  return /^-?(0+)\d/.test(str);
}

function padZeros(value, tok, options) {
  if (!tok.isPadded) {
    return value;
  }

  let diff = Math.abs(tok.maxLen - String(value).length);
  let relax = options.relaxZeros !== false;

  switch (diff) {
    case 0:
      return '';
    case 1:
      return relax ? '0?' : '0';
    case 2:
      return relax ? '0{0,2}' : '00';
    default: {
      return relax ? `0{0,${diff}}` : `0{${diff}}`;
    }
  }
}

/**
 * Cache
 */

toRegexRange.cache = {};
toRegexRange.clearCache = () => (toRegexRange.cache = {});

/**
 * Expose `toRegexRange`
 */

module.exports = toRegexRange;


/***/ }),

/***/ "./node_modules/toidentifier/index.js":
/*!********************************************!*\
  !*** ./node_modules/toidentifier/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*!
 * toidentifier
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module exports.
 * @public
 */

module.exports = toIdentifier

/**
 * Trasform the given string into a JavaScript identifier
 *
 * @param {string} str
 * @returns {string}
 * @public
 */

function toIdentifier (str) {
  return str
    .split(' ')
    .map(function (token) {
      return token.slice(0, 1).toUpperCase() + token.slice(1)
    })
    .join('')
    .replace(/[^ _0-9a-z]/gi, '')
}


/***/ }),

/***/ "./node_modules/type-is/index.js":
/*!***************************************!*\
  !*** ./node_modules/type-is/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * type-is
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var typer = __webpack_require__(/*! media-typer */ "./node_modules/media-typer/index.js")
var mime = __webpack_require__(/*! mime-types */ "./node_modules/mime-types/index.js")

/**
 * Module exports.
 * @public
 */

module.exports = typeofrequest
module.exports.is = typeis
module.exports.hasBody = hasbody
module.exports.normalize = normalize
module.exports.match = mimeMatch

/**
 * Compare a `value` content-type with `types`.
 * Each `type` can be an extension like `html`,
 * a special shortcut like `multipart` or `urlencoded`,
 * or a mime type.
 *
 * If no types match, `false` is returned.
 * Otherwise, the first `type` that matches is returned.
 *
 * @param {String} value
 * @param {Array} types
 * @public
 */

function typeis (value, types_) {
  var i
  var types = types_

  // remove parameters and normalize
  var val = tryNormalizeType(value)

  // no type or invalid
  if (!val) {
    return false
  }

  // support flattened arguments
  if (types && !Array.isArray(types)) {
    types = new Array(arguments.length - 1)
    for (i = 0; i < types.length; i++) {
      types[i] = arguments[i + 1]
    }
  }

  // no types, return the content type
  if (!types || !types.length) {
    return val
  }

  var type
  for (i = 0; i < types.length; i++) {
    if (mimeMatch(normalize(type = types[i]), val)) {
      return type[0] === '+' || type.indexOf('*') !== -1
        ? val
        : type
    }
  }

  // no matches
  return false
}

/**
 * Check if a request has a request body.
 * A request with a body __must__ either have `transfer-encoding`
 * or `content-length` headers set.
 * http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.3
 *
 * @param {Object} request
 * @return {Boolean}
 * @public
 */

function hasbody (req) {
  return req.headers['transfer-encoding'] !== undefined ||
    !isNaN(req.headers['content-length'])
}

/**
 * Check if the incoming request contains the "Content-Type"
 * header field, and it contains any of the give mime `type`s.
 * If there is no request body, `null` is returned.
 * If there is no content type, `false` is returned.
 * Otherwise, it returns the first `type` that matches.
 *
 * Examples:
 *
 *     // With Content-Type: text/html; charset=utf-8
 *     this.is('html'); // => 'html'
 *     this.is('text/html'); // => 'text/html'
 *     this.is('text/*', 'application/json'); // => 'text/html'
 *
 *     // When Content-Type is application/json
 *     this.is('json', 'urlencoded'); // => 'json'
 *     this.is('application/json'); // => 'application/json'
 *     this.is('html', 'application/*'); // => 'application/json'
 *
 *     this.is('html'); // => false
 *
 * @param {String|Array} types...
 * @return {String|false|null}
 * @public
 */

function typeofrequest (req, types_) {
  var types = types_

  // no body
  if (!hasbody(req)) {
    return null
  }

  // support flattened arguments
  if (arguments.length > 2) {
    types = new Array(arguments.length - 1)
    for (var i = 0; i < types.length; i++) {
      types[i] = arguments[i + 1]
    }
  }

  // request content type
  var value = req.headers['content-type']

  return typeis(value, types)
}

/**
 * Normalize a mime type.
 * If it's a shorthand, expand it to a valid mime type.
 *
 * In general, you probably want:
 *
 *   var type = is(req, ['urlencoded', 'json', 'multipart']);
 *
 * Then use the appropriate body parsers.
 * These three are the most common request body types
 * and are thus ensured to work.
 *
 * @param {String} type
 * @private
 */

function normalize (type) {
  if (typeof type !== 'string') {
    // invalid type
    return false
  }

  switch (type) {
    case 'urlencoded':
      return 'application/x-www-form-urlencoded'
    case 'multipart':
      return 'multipart/*'
  }

  if (type[0] === '+') {
    // "+json" -> "*/*+json" expando
    return '*/*' + type
  }

  return type.indexOf('/') === -1
    ? mime.lookup(type)
    : type
}

/**
 * Check if `expected` mime type
 * matches `actual` mime type with
 * wildcard and +suffix support.
 *
 * @param {String} expected
 * @param {String} actual
 * @return {Boolean}
 * @private
 */

function mimeMatch (expected, actual) {
  // invalid type
  if (expected === false) {
    return false
  }

  // split types
  var actualParts = actual.split('/')
  var expectedParts = expected.split('/')

  // invalid format
  if (actualParts.length !== 2 || expectedParts.length !== 2) {
    return false
  }

  // validate type
  if (expectedParts[0] !== '*' && expectedParts[0] !== actualParts[0]) {
    return false
  }

  // validate suffix wildcard
  if (expectedParts[1].substr(0, 2) === '*+') {
    return expectedParts[1].length <= actualParts[1].length + 1 &&
      expectedParts[1].substr(1) === actualParts[1].substr(1 - expectedParts[1].length)
  }

  // validate subtype
  if (expectedParts[1] !== '*' && expectedParts[1] !== actualParts[1]) {
    return false
  }

  return true
}

/**
 * Normalize a type and remove parameters.
 *
 * @param {string} value
 * @return {string}
 * @private
 */

function normalizeType (value) {
  // parse the type
  var type = typer.parse(value)

  // remove the parameters
  type.parameters = undefined

  // reformat it
  return typer.format(type)
}

/**
 * Try to normalize a type and remove parameters.
 *
 * @param {string} value
 * @return {string}
 * @private
 */

function tryNormalizeType (value) {
  if (!value) {
    return null
  }

  try {
    return normalizeType(value)
  } catch (err) {
    return null
  }
}


/***/ }),

/***/ "./node_modules/unpipe/index.js":
/*!**************************************!*\
  !*** ./node_modules/unpipe/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * unpipe
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = unpipe

/**
 * Determine if there are Node.js pipe-like data listeners.
 * @private
 */

function hasPipeDataListeners(stream) {
  var listeners = stream.listeners('data')

  for (var i = 0; i < listeners.length; i++) {
    if (listeners[i].name === 'ondata') {
      return true
    }
  }

  return false
}

/**
 * Unpipe a stream from all destinations.
 *
 * @param {object} stream
 * @public
 */

function unpipe(stream) {
  if (!stream) {
    throw new TypeError('argument stream is required')
  }

  if (typeof stream.unpipe === 'function') {
    // new-style
    stream.unpipe()
    return
  }

  // Node.js 0.8 hack
  if (!hasPipeDataListeners(stream)) {
    return
  }

  var listener
  var listeners = stream.listeners('close')

  for (var i = 0; i < listeners.length; i++) {
    listener = listeners[i]

    if (listener.name !== 'cleanup' && listener.name !== 'onclose') {
      continue
    }

    // invoke the listener
    listener.call(stream)
  }
}


/***/ }),

/***/ "./node_modules/utils-merge/index.js":
/*!*******************************************!*\
  !*** ./node_modules/utils-merge/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Merge object b with object a.
 *
 *     var a = { foo: 'bar' }
 *       , b = { bar: 'baz' };
 *
 *     merge(a, b);
 *     // => { foo: 'bar', bar: 'baz' }
 *
 * @param {Object} a
 * @param {Object} b
 * @return {Object}
 * @api public
 */

exports = module.exports = function(a, b){
  if (a && b) {
    for (var key in b) {
      a[key] = b[key];
    }
  }
  return a;
};


/***/ }),

/***/ "./node_modules/vary/index.js":
/*!************************************!*\
  !*** ./node_modules/vary/index.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * vary
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 */

module.exports = vary
module.exports.append = append

/**
 * RegExp to match field-name in RFC 7230 sec 3.2
 *
 * field-name    = token
 * token         = 1*tchar
 * tchar         = "!" / "#" / "$" / "%" / "&" / "'" / "*"
 *               / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
 *               / DIGIT / ALPHA
 *               ; any VCHAR, except delimiters
 */

var FIELD_NAME_REGEXP = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/

/**
 * Append a field to a vary header.
 *
 * @param {String} header
 * @param {String|Array} field
 * @return {String}
 * @public
 */

function append (header, field) {
  if (typeof header !== 'string') {
    throw new TypeError('header argument is required')
  }

  if (!field) {
    throw new TypeError('field argument is required')
  }

  // get fields array
  var fields = !Array.isArray(field)
    ? parse(String(field))
    : field

  // assert on invalid field names
  for (var j = 0; j < fields.length; j++) {
    if (!FIELD_NAME_REGEXP.test(fields[j])) {
      throw new TypeError('field argument contains an invalid header name')
    }
  }

  // existing, unspecified vary
  if (header === '*') {
    return header
  }

  // enumerate current values
  var val = header
  var vals = parse(header.toLowerCase())

  // unspecified vary
  if (fields.indexOf('*') !== -1 || vals.indexOf('*') !== -1) {
    return '*'
  }

  for (var i = 0; i < fields.length; i++) {
    var fld = fields[i].toLowerCase()

    // append value (case-preserving)
    if (vals.indexOf(fld) === -1) {
      vals.push(fld)
      val = val
        ? val + ', ' + fields[i]
        : fields[i]
    }
  }

  return val
}

/**
 * Parse a vary header into an array.
 *
 * @param {String} header
 * @return {Array}
 * @private
 */

function parse (header) {
  var end = 0
  var list = []
  var start = 0

  // gather tokens
  for (var i = 0, len = header.length; i < len; i++) {
    switch (header.charCodeAt(i)) {
      case 0x20: /*   */
        if (start === end) {
          start = end = i + 1
        }
        break
      case 0x2c: /* , */
        list.push(header.substring(start, end))
        start = end = i + 1
        break
      default:
        end = i + 1
        break
    }
  }

  // final token
  list.push(header.substring(start, end))

  return list
}

/**
 * Mark that a request is varied on a header field.
 *
 * @param {Object} res
 * @param {String|Array} field
 * @public
 */

function vary (res, field) {
  if (!res || !res.getHeader || !res.setHeader) {
    // quack quack
    throw new TypeError('res argument is required')
  }

  // get existing header
  var val = res.getHeader('Vary') || ''
  var header = Array.isArray(val)
    ? val.join(', ')
    : String(val)

  // set new header
  if ((val = append(header, field))) {
    res.setHeader('Vary', val)
  }
}


/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./node_modules/ws/index.js":
/*!**********************************!*\
  !*** ./node_modules/ws/index.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const WebSocket = __webpack_require__(/*! ./lib/websocket */ "./node_modules/ws/lib/websocket.js");

WebSocket.createWebSocketStream = __webpack_require__(/*! ./lib/stream */ "./node_modules/ws/lib/stream.js");
WebSocket.Server = __webpack_require__(/*! ./lib/websocket-server */ "./node_modules/ws/lib/websocket-server.js");
WebSocket.Receiver = __webpack_require__(/*! ./lib/receiver */ "./node_modules/ws/lib/receiver.js");
WebSocket.Sender = __webpack_require__(/*! ./lib/sender */ "./node_modules/ws/lib/sender.js");

module.exports = WebSocket;


/***/ }),

/***/ "./node_modules/ws/lib/buffer-util.js":
/*!********************************************!*\
  !*** ./node_modules/ws/lib/buffer-util.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const { EMPTY_BUFFER } = __webpack_require__(/*! ./constants */ "./node_modules/ws/lib/constants.js");

/**
 * Merges an array of buffers into a new buffer.
 *
 * @param {Buffer[]} list The array of buffers to concat
 * @param {Number} totalLength The total length of buffers in the list
 * @return {Buffer} The resulting buffer
 * @public
 */
function concat(list, totalLength) {
  if (list.length === 0) return EMPTY_BUFFER;
  if (list.length === 1) return list[0];

  const target = Buffer.allocUnsafe(totalLength);
  let offset = 0;

  for (let i = 0; i < list.length; i++) {
    const buf = list[i];
    buf.copy(target, offset);
    offset += buf.length;
  }

  return target;
}

/**
 * Masks a buffer using the given mask.
 *
 * @param {Buffer} source The buffer to mask
 * @param {Buffer} mask The mask to use
 * @param {Buffer} output The buffer where to store the result
 * @param {Number} offset The offset at which to start writing
 * @param {Number} length The number of bytes to mask.
 * @public
 */
function _mask(source, mask, output, offset, length) {
  for (let i = 0; i < length; i++) {
    output[offset + i] = source[i] ^ mask[i & 3];
  }
}

/**
 * Unmasks a buffer using the given mask.
 *
 * @param {Buffer} buffer The buffer to unmask
 * @param {Buffer} mask The mask to use
 * @public
 */
function _unmask(buffer, mask) {
  // Required until https://github.com/nodejs/node/issues/9006 is resolved.
  const length = buffer.length;
  for (let i = 0; i < length; i++) {
    buffer[i] ^= mask[i & 3];
  }
}

/**
 * Converts a buffer to an `ArrayBuffer`.
 *
 * @param {Buffer} buf The buffer to convert
 * @return {ArrayBuffer} Converted buffer
 * @public
 */
function toArrayBuffer(buf) {
  if (buf.byteLength === buf.buffer.byteLength) {
    return buf.buffer;
  }

  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
}

/**
 * Converts `data` to a `Buffer`.
 *
 * @param {*} data The data to convert
 * @return {Buffer} The buffer
 * @throws {TypeError}
 * @public
 */
function toBuffer(data) {
  toBuffer.readOnly = true;

  if (Buffer.isBuffer(data)) return data;

  let buf;

  if (data instanceof ArrayBuffer) {
    buf = Buffer.from(data);
  } else if (ArrayBuffer.isView(data)) {
    buf = viewToBuffer(data);
  } else {
    buf = Buffer.from(data);
    toBuffer.readOnly = false;
  }

  return buf;
}

/**
 * Converts an `ArrayBuffer` view into a buffer.
 *
 * @param {(DataView|TypedArray)} view The view to convert
 * @return {Buffer} Converted view
 * @private
 */
function viewToBuffer(view) {
  const buf = Buffer.from(view.buffer);

  if (view.byteLength !== view.buffer.byteLength) {
    return buf.slice(view.byteOffset, view.byteOffset + view.byteLength);
  }

  return buf;
}

try {
  const bufferUtil = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module 'bufferutil'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
  const bu = bufferUtil.BufferUtil || bufferUtil;

  module.exports = {
    concat,
    mask(source, mask, output, offset, length) {
      if (length < 48) _mask(source, mask, output, offset, length);
      else bu.mask(source, mask, output, offset, length);
    },
    toArrayBuffer,
    toBuffer,
    unmask(buffer, mask) {
      if (buffer.length < 32) _unmask(buffer, mask);
      else bu.unmask(buffer, mask);
    }
  };
} catch (e) /* istanbul ignore next */ {
  module.exports = {
    concat,
    mask: _mask,
    toArrayBuffer,
    toBuffer,
    unmask: _unmask
  };
}


/***/ }),

/***/ "./node_modules/ws/lib/constants.js":
/*!******************************************!*\
  !*** ./node_modules/ws/lib/constants.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  BINARY_TYPES: ['nodebuffer', 'arraybuffer', 'fragments'],
  GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',
  kStatusCode: Symbol('status-code'),
  kWebSocket: Symbol('websocket'),
  EMPTY_BUFFER: Buffer.alloc(0),
  NOOP: () => {}
};


/***/ }),

/***/ "./node_modules/ws/lib/event-target.js":
/*!*********************************************!*\
  !*** ./node_modules/ws/lib/event-target.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Class representing an event.
 *
 * @private
 */
class Event {
  /**
   * Create a new `Event`.
   *
   * @param {String} type The name of the event
   * @param {Object} target A reference to the target to which the event was dispatched
   */
  constructor(type, target) {
    this.target = target;
    this.type = type;
  }
}

/**
 * Class representing a message event.
 *
 * @extends Event
 * @private
 */
class MessageEvent extends Event {
  /**
   * Create a new `MessageEvent`.
   *
   * @param {(String|Buffer|ArrayBuffer|Buffer[])} data The received data
   * @param {WebSocket} target A reference to the target to which the event was dispatched
   */
  constructor(data, target) {
    super('message', target);

    this.data = data;
  }
}

/**
 * Class representing a close event.
 *
 * @extends Event
 * @private
 */
class CloseEvent extends Event {
  /**
   * Create a new `CloseEvent`.
   *
   * @param {Number} code The status code explaining why the connection is being closed
   * @param {String} reason A human-readable string explaining why the connection is closing
   * @param {WebSocket} target A reference to the target to which the event was dispatched
   */
  constructor(code, reason, target) {
    super('close', target);

    this.wasClean = target._closeFrameReceived && target._closeFrameSent;
    this.reason = reason;
    this.code = code;
  }
}

/**
 * Class representing an open event.
 *
 * @extends Event
 * @private
 */
class OpenEvent extends Event {
  /**
   * Create a new `OpenEvent`.
   *
   * @param {WebSocket} target A reference to the target to which the event was dispatched
   */
  constructor(target) {
    super('open', target);
  }
}

/**
 * Class representing an error event.
 *
 * @extends Event
 * @private
 */
class ErrorEvent extends Event {
  /**
   * Create a new `ErrorEvent`.
   *
   * @param {Object} error The error that generated this event
   * @param {WebSocket} target A reference to the target to which the event was dispatched
   */
  constructor(error, target) {
    super('error', target);

    this.message = error.message;
    this.error = error;
  }
}

/**
 * This provides methods for emulating the `EventTarget` interface. It's not
 * meant to be used directly.
 *
 * @mixin
 */
const EventTarget = {
  /**
   * Register an event listener.
   *
   * @param {String} method A string representing the event type to listen for
   * @param {Function} listener The listener to add
   * @public
   */
  addEventListener(method, listener) {
    if (typeof listener !== 'function') return;

    function onMessage(data) {
      listener.call(this, new MessageEvent(data, this));
    }

    function onClose(code, message) {
      listener.call(this, new CloseEvent(code, message, this));
    }

    function onError(error) {
      listener.call(this, new ErrorEvent(error, this));
    }

    function onOpen() {
      listener.call(this, new OpenEvent(this));
    }

    if (method === 'message') {
      onMessage._listener = listener;
      this.on(method, onMessage);
    } else if (method === 'close') {
      onClose._listener = listener;
      this.on(method, onClose);
    } else if (method === 'error') {
      onError._listener = listener;
      this.on(method, onError);
    } else if (method === 'open') {
      onOpen._listener = listener;
      this.on(method, onOpen);
    } else {
      this.on(method, listener);
    }
  },

  /**
   * Remove an event listener.
   *
   * @param {String} method A string representing the event type to remove
   * @param {Function} listener The listener to remove
   * @public
   */
  removeEventListener(method, listener) {
    const listeners = this.listeners(method);

    for (let i = 0; i < listeners.length; i++) {
      if (listeners[i] === listener || listeners[i]._listener === listener) {
        this.removeListener(method, listeners[i]);
      }
    }
  }
};

module.exports = EventTarget;


/***/ }),

/***/ "./node_modules/ws/lib/extension.js":
/*!******************************************!*\
  !*** ./node_modules/ws/lib/extension.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


//
// Allowed token characters:
//
// '!', '#', '$', '%', '&', ''', '*', '+', '-',
// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'
//
// tokenChars[32] === 0 // ' '
// tokenChars[33] === 1 // '!'
// tokenChars[34] === 0 // '"'
// ...
//
// prettier-ignore
const tokenChars = [
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31
  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32 - 47
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63
  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, // 80 - 95
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127
];

/**
 * Adds an offer to the map of extension offers or a parameter to the map of
 * parameters.
 *
 * @param {Object} dest The map of extension offers or parameters
 * @param {String} name The extension or parameter name
 * @param {(Object|Boolean|String)} elem The extension parameters or the
 *     parameter value
 * @private
 */
function push(dest, name, elem) {
  if (dest[name] === undefined) dest[name] = [elem];
  else dest[name].push(elem);
}

/**
 * Parses the `Sec-WebSocket-Extensions` header into an object.
 *
 * @param {String} header The field value of the header
 * @return {Object} The parsed object
 * @public
 */
function parse(header) {
  const offers = Object.create(null);

  if (header === undefined || header === '') return offers;

  let params = Object.create(null);
  let mustUnescape = false;
  let isEscaping = false;
  let inQuotes = false;
  let extensionName;
  let paramName;
  let start = -1;
  let end = -1;
  let i = 0;

  for (; i < header.length; i++) {
    const code = header.charCodeAt(i);

    if (extensionName === undefined) {
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (code === 0x20 /* ' ' */ || code === 0x09 /* '\t' */) {
        if (end === -1 && start !== -1) end = i;
      } else if (code === 0x3b /* ';' */ || code === 0x2c /* ',' */) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        const name = header.slice(start, end);
        if (code === 0x2c) {
          push(offers, name, params);
          params = Object.create(null);
        } else {
          extensionName = name;
        }

        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    } else if (paramName === undefined) {
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (code === 0x20 || code === 0x09) {
        if (end === -1 && start !== -1) end = i;
      } else if (code === 0x3b || code === 0x2c) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        push(params, header.slice(start, end), true);
        if (code === 0x2c) {
          push(offers, extensionName, params);
          params = Object.create(null);
          extensionName = undefined;
        }

        start = end = -1;
      } else if (code === 0x3d /* '=' */ && start !== -1 && end === -1) {
        paramName = header.slice(start, i);
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    } else {
      //
      // The value of a quoted-string after unescaping must conform to the
      // token ABNF, so only token characters are valid.
      // Ref: https://tools.ietf.org/html/rfc6455#section-9.1
      //
      if (isEscaping) {
        if (tokenChars[code] !== 1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
        if (start === -1) start = i;
        else if (!mustUnescape) mustUnescape = true;
        isEscaping = false;
      } else if (inQuotes) {
        if (tokenChars[code] === 1) {
          if (start === -1) start = i;
        } else if (code === 0x22 /* '"' */ && start !== -1) {
          inQuotes = false;
          end = i;
        } else if (code === 0x5c /* '\' */) {
          isEscaping = true;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {
        inQuotes = true;
      } else if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (start !== -1 && (code === 0x20 || code === 0x09)) {
        if (end === -1) end = i;
      } else if (code === 0x3b || code === 0x2c) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        let value = header.slice(start, end);
        if (mustUnescape) {
          value = value.replace(/\\/g, '');
          mustUnescape = false;
        }
        push(params, paramName, value);
        if (code === 0x2c) {
          push(offers, extensionName, params);
          params = Object.create(null);
          extensionName = undefined;
        }

        paramName = undefined;
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    }
  }

  if (start === -1 || inQuotes) {
    throw new SyntaxError('Unexpected end of input');
  }

  if (end === -1) end = i;
  const token = header.slice(start, end);
  if (extensionName === undefined) {
    push(offers, token, params);
  } else {
    if (paramName === undefined) {
      push(params, token, true);
    } else if (mustUnescape) {
      push(params, paramName, token.replace(/\\/g, ''));
    } else {
      push(params, paramName, token);
    }
    push(offers, extensionName, params);
  }

  return offers;
}

/**
 * Builds the `Sec-WebSocket-Extensions` header field value.
 *
 * @param {Object} extensions The map of extensions and parameters to format
 * @return {String} A string representing the given object
 * @public
 */
function format(extensions) {
  return Object.keys(extensions)
    .map((extension) => {
      let configurations = extensions[extension];
      if (!Array.isArray(configurations)) configurations = [configurations];
      return configurations
        .map((params) => {
          return [extension]
            .concat(
              Object.keys(params).map((k) => {
                let values = params[k];
                if (!Array.isArray(values)) values = [values];
                return values
                  .map((v) => (v === true ? k : `${k}=${v}`))
                  .join('; ');
              })
            )
            .join('; ');
        })
        .join(', ');
    })
    .join(', ');
}

module.exports = { format, parse };


/***/ }),

/***/ "./node_modules/ws/lib/permessage-deflate.js":
/*!***************************************************!*\
  !*** ./node_modules/ws/lib/permessage-deflate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Limiter = __webpack_require__(/*! async-limiter */ "./node_modules/async-limiter/index.js");
const zlib = __webpack_require__(/*! zlib */ "zlib");

const bufferUtil = __webpack_require__(/*! ./buffer-util */ "./node_modules/ws/lib/buffer-util.js");
const { kStatusCode, NOOP } = __webpack_require__(/*! ./constants */ "./node_modules/ws/lib/constants.js");

const TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);
const EMPTY_BLOCK = Buffer.from([0x00]);

const kPerMessageDeflate = Symbol('permessage-deflate');
const kTotalLength = Symbol('total-length');
const kCallback = Symbol('callback');
const kBuffers = Symbol('buffers');
const kError = Symbol('error');

//
// We limit zlib concurrency, which prevents severe memory fragmentation
// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913
// and https://github.com/websockets/ws/issues/1202
//
// Intentionally global; it's the global thread pool that's an issue.
//
let zlibLimiter;

/**
 * permessage-deflate implementation.
 */
class PerMessageDeflate {
  /**
   * Creates a PerMessageDeflate instance.
   *
   * @param {Object} options Configuration options
   * @param {Boolean} options.serverNoContextTakeover Request/accept disabling
   *     of server context takeover
   * @param {Boolean} options.clientNoContextTakeover Advertise/acknowledge
   *     disabling of client context takeover
   * @param {(Boolean|Number)} options.serverMaxWindowBits Request/confirm the
   *     use of a custom server window size
   * @param {(Boolean|Number)} options.clientMaxWindowBits Advertise support
   *     for, or request, a custom client window size
   * @param {Object} options.zlibDeflateOptions Options to pass to zlib on deflate
   * @param {Object} options.zlibInflateOptions Options to pass to zlib on inflate
   * @param {Number} options.threshold Size (in bytes) below which messages
   *     should not be compressed
   * @param {Number} options.concurrencyLimit The number of concurrent calls to
   *     zlib
   * @param {Boolean} isServer Create the instance in either server or client
   *     mode
   * @param {Number} maxPayload The maximum allowed message length
   */
  constructor(options, isServer, maxPayload) {
    this._maxPayload = maxPayload | 0;
    this._options = options || {};
    this._threshold =
      this._options.threshold !== undefined ? this._options.threshold : 1024;
    this._isServer = !!isServer;
    this._deflate = null;
    this._inflate = null;

    this.params = null;

    if (!zlibLimiter) {
      const concurrency =
        this._options.concurrencyLimit !== undefined
          ? this._options.concurrencyLimit
          : 10;
      zlibLimiter = new Limiter({ concurrency });
    }
  }

  /**
   * @type {String}
   */
  static get extensionName() {
    return 'permessage-deflate';
  }

  /**
   * Create an extension negotiation offer.
   *
   * @return {Object} Extension parameters
   * @public
   */
  offer() {
    const params = {};

    if (this._options.serverNoContextTakeover) {
      params.server_no_context_takeover = true;
    }
    if (this._options.clientNoContextTakeover) {
      params.client_no_context_takeover = true;
    }
    if (this._options.serverMaxWindowBits) {
      params.server_max_window_bits = this._options.serverMaxWindowBits;
    }
    if (this._options.clientMaxWindowBits) {
      params.client_max_window_bits = this._options.clientMaxWindowBits;
    } else if (this._options.clientMaxWindowBits == null) {
      params.client_max_window_bits = true;
    }

    return params;
  }

  /**
   * Accept an extension negotiation offer/response.
   *
   * @param {Array} configurations The extension negotiation offers/reponse
   * @return {Object} Accepted configuration
   * @public
   */
  accept(configurations) {
    configurations = this.normalizeParams(configurations);

    this.params = this._isServer
      ? this.acceptAsServer(configurations)
      : this.acceptAsClient(configurations);

    return this.params;
  }

  /**
   * Releases all resources used by the extension.
   *
   * @public
   */
  cleanup() {
    if (this._inflate) {
      this._inflate.close();
      this._inflate = null;
    }

    if (this._deflate) {
      this._deflate.close();
      this._deflate = null;
    }
  }

  /**
   *  Accept an extension negotiation offer.
   *
   * @param {Array} offers The extension negotiation offers
   * @return {Object} Accepted configuration
   * @private
   */
  acceptAsServer(offers) {
    const opts = this._options;
    const accepted = offers.find((params) => {
      if (
        (opts.serverNoContextTakeover === false &&
          params.server_no_context_takeover) ||
        (params.server_max_window_bits &&
          (opts.serverMaxWindowBits === false ||
            (typeof opts.serverMaxWindowBits === 'number' &&
              opts.serverMaxWindowBits > params.server_max_window_bits))) ||
        (typeof opts.clientMaxWindowBits === 'number' &&
          !params.client_max_window_bits)
      ) {
        return false;
      }

      return true;
    });

    if (!accepted) {
      throw new Error('None of the extension offers can be accepted');
    }

    if (opts.serverNoContextTakeover) {
      accepted.server_no_context_takeover = true;
    }
    if (opts.clientNoContextTakeover) {
      accepted.client_no_context_takeover = true;
    }
    if (typeof opts.serverMaxWindowBits === 'number') {
      accepted.server_max_window_bits = opts.serverMaxWindowBits;
    }
    if (typeof opts.clientMaxWindowBits === 'number') {
      accepted.client_max_window_bits = opts.clientMaxWindowBits;
    } else if (
      accepted.client_max_window_bits === true ||
      opts.clientMaxWindowBits === false
    ) {
      delete accepted.client_max_window_bits;
    }

    return accepted;
  }

  /**
   * Accept the extension negotiation response.
   *
   * @param {Array} response The extension negotiation response
   * @return {Object} Accepted configuration
   * @private
   */
  acceptAsClient(response) {
    const params = response[0];

    if (
      this._options.clientNoContextTakeover === false &&
      params.client_no_context_takeover
    ) {
      throw new Error('Unexpected parameter "client_no_context_takeover"');
    }

    if (!params.client_max_window_bits) {
      if (typeof this._options.clientMaxWindowBits === 'number') {
        params.client_max_window_bits = this._options.clientMaxWindowBits;
      }
    } else if (
      this._options.clientMaxWindowBits === false ||
      (typeof this._options.clientMaxWindowBits === 'number' &&
        params.client_max_window_bits > this._options.clientMaxWindowBits)
    ) {
      throw new Error(
        'Unexpected or invalid parameter "client_max_window_bits"'
      );
    }

    return params;
  }

  /**
   * Normalize parameters.
   *
   * @param {Array} configurations The extension negotiation offers/reponse
   * @return {Array} The offers/response with normalized parameters
   * @private
   */
  normalizeParams(configurations) {
    configurations.forEach((params) => {
      Object.keys(params).forEach((key) => {
        let value = params[key];

        if (value.length > 1) {
          throw new Error(`Parameter "${key}" must have only a single value`);
        }

        value = value[0];

        if (key === 'client_max_window_bits') {
          if (value !== true) {
            const num = +value;
            if (!Number.isInteger(num) || num < 8 || num > 15) {
              throw new TypeError(
                `Invalid value for parameter "${key}": ${value}`
              );
            }
            value = num;
          } else if (!this._isServer) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
        } else if (key === 'server_max_window_bits') {
          const num = +value;
          if (!Number.isInteger(num) || num < 8 || num > 15) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
          value = num;
        } else if (
          key === 'client_no_context_takeover' ||
          key === 'server_no_context_takeover'
        ) {
          if (value !== true) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
        } else {
          throw new Error(`Unknown parameter "${key}"`);
        }

        params[key] = value;
      });
    });

    return configurations;
  }

  /**
   * Decompress data. Concurrency limited by async-limiter.
   *
   * @param {Buffer} data Compressed data
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @public
   */
  decompress(data, fin, callback) {
    zlibLimiter.push((done) => {
      this._decompress(data, fin, (err, result) => {
        done();
        callback(err, result);
      });
    });
  }

  /**
   * Compress data. Concurrency limited by async-limiter.
   *
   * @param {Buffer} data Data to compress
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @public
   */
  compress(data, fin, callback) {
    zlibLimiter.push((done) => {
      this._compress(data, fin, (err, result) => {
        done();
        callback(err, result);
      });
    });
  }

  /**
   * Decompress data.
   *
   * @param {Buffer} data Compressed data
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @private
   */
  _decompress(data, fin, callback) {
    const endpoint = this._isServer ? 'client' : 'server';

    if (!this._inflate) {
      const key = `${endpoint}_max_window_bits`;
      const windowBits =
        typeof this.params[key] !== 'number'
          ? zlib.Z_DEFAULT_WINDOWBITS
          : this.params[key];

      this._inflate = zlib.createInflateRaw({
        ...this._options.zlibInflateOptions,
        windowBits
      });
      this._inflate[kPerMessageDeflate] = this;
      this._inflate[kTotalLength] = 0;
      this._inflate[kBuffers] = [];
      this._inflate.on('error', inflateOnError);
      this._inflate.on('data', inflateOnData);
    }

    this._inflate[kCallback] = callback;

    this._inflate.write(data);
    if (fin) this._inflate.write(TRAILER);

    this._inflate.flush(() => {
      const err = this._inflate[kError];

      if (err) {
        this._inflate.close();
        this._inflate = null;
        callback(err);
        return;
      }

      const data = bufferUtil.concat(
        this._inflate[kBuffers],
        this._inflate[kTotalLength]
      );

      if (fin && this.params[`${endpoint}_no_context_takeover`]) {
        this._inflate.close();
        this._inflate = null;
      } else {
        this._inflate[kTotalLength] = 0;
        this._inflate[kBuffers] = [];
      }

      callback(null, data);
    });
  }

  /**
   * Compress data.
   *
   * @param {Buffer} data Data to compress
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @private
   */
  _compress(data, fin, callback) {
    if (!data || data.length === 0) {
      process.nextTick(callback, null, EMPTY_BLOCK);
      return;
    }

    const endpoint = this._isServer ? 'server' : 'client';

    if (!this._deflate) {
      const key = `${endpoint}_max_window_bits`;
      const windowBits =
        typeof this.params[key] !== 'number'
          ? zlib.Z_DEFAULT_WINDOWBITS
          : this.params[key];

      this._deflate = zlib.createDeflateRaw({
        ...this._options.zlibDeflateOptions,
        windowBits
      });

      this._deflate[kTotalLength] = 0;
      this._deflate[kBuffers] = [];

      //
      // An `'error'` event is emitted, only on Node.js < 10.0.0, if the
      // `zlib.DeflateRaw` instance is closed while data is being processed.
      // This can happen if `PerMessageDeflate#cleanup()` is called at the wrong
      // time due to an abnormal WebSocket closure.
      //
      this._deflate.on('error', NOOP);
      this._deflate.on('data', deflateOnData);
    }

    this._deflate.write(data);
    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
      if (!this._deflate) {
        //
        // This `if` statement is only needed for Node.js < 10.0.0 because as of
        // commit https://github.com/nodejs/node/commit/5e3f5164, the flush
        // callback is no longer called if the deflate stream is closed while
        // data is being processed.
        //
        return;
      }

      let data = bufferUtil.concat(
        this._deflate[kBuffers],
        this._deflate[kTotalLength]
      );

      if (fin) data = data.slice(0, data.length - 4);

      if (fin && this.params[`${endpoint}_no_context_takeover`]) {
        this._deflate.close();
        this._deflate = null;
      } else {
        this._deflate[kTotalLength] = 0;
        this._deflate[kBuffers] = [];
      }

      callback(null, data);
    });
  }
}

module.exports = PerMessageDeflate;

/**
 * The listener of the `zlib.DeflateRaw` stream `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function deflateOnData(chunk) {
  this[kBuffers].push(chunk);
  this[kTotalLength] += chunk.length;
}

/**
 * The listener of the `zlib.InflateRaw` stream `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function inflateOnData(chunk) {
  this[kTotalLength] += chunk.length;

  if (
    this[kPerMessageDeflate]._maxPayload < 1 ||
    this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload
  ) {
    this[kBuffers].push(chunk);
    return;
  }

  this[kError] = new RangeError('Max payload size exceeded');
  this[kError][kStatusCode] = 1009;
  this.removeListener('data', inflateOnData);
  this.reset();
}

/**
 * The listener of the `zlib.InflateRaw` stream `'error'` event.
 *
 * @param {Error} err The emitted error
 * @private
 */
function inflateOnError(err) {
  //
  // There is no need to call `Zlib#close()` as the handle is automatically
  // closed when an error is emitted.
  //
  this[kPerMessageDeflate]._inflate = null;
  err[kStatusCode] = 1007;
  this[kCallback](err);
}


/***/ }),

/***/ "./node_modules/ws/lib/receiver.js":
/*!*****************************************!*\
  !*** ./node_modules/ws/lib/receiver.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const { Writable } = __webpack_require__(/*! stream */ "stream");

const PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ "./node_modules/ws/lib/permessage-deflate.js");
const {
  BINARY_TYPES,
  EMPTY_BUFFER,
  kStatusCode,
  kWebSocket
} = __webpack_require__(/*! ./constants */ "./node_modules/ws/lib/constants.js");
const { concat, toArrayBuffer, unmask } = __webpack_require__(/*! ./buffer-util */ "./node_modules/ws/lib/buffer-util.js");
const { isValidStatusCode, isValidUTF8 } = __webpack_require__(/*! ./validation */ "./node_modules/ws/lib/validation.js");

const GET_INFO = 0;
const GET_PAYLOAD_LENGTH_16 = 1;
const GET_PAYLOAD_LENGTH_64 = 2;
const GET_MASK = 3;
const GET_DATA = 4;
const INFLATING = 5;

/**
 * HyBi Receiver implementation.
 *
 * @extends stream.Writable
 */
class Receiver extends Writable {
  /**
   * Creates a Receiver instance.
   *
   * @param {String} binaryType The type for binary data
   * @param {Object} extensions An object containing the negotiated extensions
   * @param {Number} maxPayload The maximum allowed message length
   */
  constructor(binaryType, extensions, maxPayload) {
    super();

    this._binaryType = binaryType || BINARY_TYPES[0];
    this[kWebSocket] = undefined;
    this._extensions = extensions || {};
    this._maxPayload = maxPayload | 0;

    this._bufferedBytes = 0;
    this._buffers = [];

    this._compressed = false;
    this._payloadLength = 0;
    this._mask = undefined;
    this._fragmented = 0;
    this._masked = false;
    this._fin = false;
    this._opcode = 0;

    this._totalPayloadLength = 0;
    this._messageLength = 0;
    this._fragments = [];

    this._state = GET_INFO;
    this._loop = false;
  }

  /**
   * Implements `Writable.prototype._write()`.
   *
   * @param {Buffer} chunk The chunk of data to write
   * @param {String} encoding The character encoding of `chunk`
   * @param {Function} cb Callback
   */
  _write(chunk, encoding, cb) {
    if (this._opcode === 0x08 && this._state == GET_INFO) return cb();

    this._bufferedBytes += chunk.length;
    this._buffers.push(chunk);
    this.startLoop(cb);
  }

  /**
   * Consumes `n` bytes from the buffered data.
   *
   * @param {Number} n The number of bytes to consume
   * @return {Buffer} The consumed bytes
   * @private
   */
  consume(n) {
    this._bufferedBytes -= n;

    if (n === this._buffers[0].length) return this._buffers.shift();

    if (n < this._buffers[0].length) {
      const buf = this._buffers[0];
      this._buffers[0] = buf.slice(n);
      return buf.slice(0, n);
    }

    const dst = Buffer.allocUnsafe(n);

    do {
      const buf = this._buffers[0];

      if (n >= buf.length) {
        this._buffers.shift().copy(dst, dst.length - n);
      } else {
        buf.copy(dst, dst.length - n, 0, n);
        this._buffers[0] = buf.slice(n);
      }

      n -= buf.length;
    } while (n > 0);

    return dst;
  }

  /**
   * Starts the parsing loop.
   *
   * @param {Function} cb Callback
   * @private
   */
  startLoop(cb) {
    let err;
    this._loop = true;

    do {
      switch (this._state) {
        case GET_INFO:
          err = this.getInfo();
          break;
        case GET_PAYLOAD_LENGTH_16:
          err = this.getPayloadLength16();
          break;
        case GET_PAYLOAD_LENGTH_64:
          err = this.getPayloadLength64();
          break;
        case GET_MASK:
          this.getMask();
          break;
        case GET_DATA:
          err = this.getData(cb);
          break;
        default:
          // `INFLATING`
          this._loop = false;
          return;
      }
    } while (this._loop);

    cb(err);
  }

  /**
   * Reads the first two bytes of a frame.
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  getInfo() {
    if (this._bufferedBytes < 2) {
      this._loop = false;
      return;
    }

    const buf = this.consume(2);

    if ((buf[0] & 0x30) !== 0x00) {
      this._loop = false;
      return error(RangeError, 'RSV2 and RSV3 must be clear', true, 1002);
    }

    const compressed = (buf[0] & 0x40) === 0x40;

    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
      this._loop = false;
      return error(RangeError, 'RSV1 must be clear', true, 1002);
    }

    this._fin = (buf[0] & 0x80) === 0x80;
    this._opcode = buf[0] & 0x0f;
    this._payloadLength = buf[1] & 0x7f;

    if (this._opcode === 0x00) {
      if (compressed) {
        this._loop = false;
        return error(RangeError, 'RSV1 must be clear', true, 1002);
      }

      if (!this._fragmented) {
        this._loop = false;
        return error(RangeError, 'invalid opcode 0', true, 1002);
      }

      this._opcode = this._fragmented;
    } else if (this._opcode === 0x01 || this._opcode === 0x02) {
      if (this._fragmented) {
        this._loop = false;
        return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002);
      }

      this._compressed = compressed;
    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {
      if (!this._fin) {
        this._loop = false;
        return error(RangeError, 'FIN must be set', true, 1002);
      }

      if (compressed) {
        this._loop = false;
        return error(RangeError, 'RSV1 must be clear', true, 1002);
      }

      if (this._payloadLength > 0x7d) {
        this._loop = false;
        return error(
          RangeError,
          `invalid payload length ${this._payloadLength}`,
          true,
          1002
        );
      }
    } else {
      this._loop = false;
      return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002);
    }

    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
    this._masked = (buf[1] & 0x80) === 0x80;

    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;
    else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;
    else return this.haveLength();
  }

  /**
   * Gets extended payload length (7+16).
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  getPayloadLength16() {
    if (this._bufferedBytes < 2) {
      this._loop = false;
      return;
    }

    this._payloadLength = this.consume(2).readUInt16BE(0);
    return this.haveLength();
  }

  /**
   * Gets extended payload length (7+64).
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  getPayloadLength64() {
    if (this._bufferedBytes < 8) {
      this._loop = false;
      return;
    }

    const buf = this.consume(8);
    const num = buf.readUInt32BE(0);

    //
    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned
    // if payload length is greater than this number.
    //
    if (num > Math.pow(2, 53 - 32) - 1) {
      this._loop = false;
      return error(
        RangeError,
        'Unsupported WebSocket frame: payload length > 2^53 - 1',
        false,
        1009
      );
    }

    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
    return this.haveLength();
  }

  /**
   * Payload length has been read.
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  haveLength() {
    if (this._payloadLength && this._opcode < 0x08) {
      this._totalPayloadLength += this._payloadLength;
      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
        this._loop = false;
        return error(RangeError, 'Max payload size exceeded', false, 1009);
      }
    }

    if (this._masked) this._state = GET_MASK;
    else this._state = GET_DATA;
  }

  /**
   * Reads mask bytes.
   *
   * @private
   */
  getMask() {
    if (this._bufferedBytes < 4) {
      this._loop = false;
      return;
    }

    this._mask = this.consume(4);
    this._state = GET_DATA;
  }

  /**
   * Reads data bytes.
   *
   * @param {Function} cb Callback
   * @return {(Error|RangeError|undefined)} A possible error
   * @private
   */
  getData(cb) {
    let data = EMPTY_BUFFER;

    if (this._payloadLength) {
      if (this._bufferedBytes < this._payloadLength) {
        this._loop = false;
        return;
      }

      data = this.consume(this._payloadLength);
      if (this._masked) unmask(data, this._mask);
    }

    if (this._opcode > 0x07) return this.controlMessage(data);

    if (this._compressed) {
      this._state = INFLATING;
      this.decompress(data, cb);
      return;
    }

    if (data.length) {
      //
      // This message is not compressed so its lenght is the sum of the payload
      // length of all fragments.
      //
      this._messageLength = this._totalPayloadLength;
      this._fragments.push(data);
    }

    return this.dataMessage();
  }

  /**
   * Decompresses data.
   *
   * @param {Buffer} data Compressed data
   * @param {Function} cb Callback
   * @private
   */
  decompress(data, cb) {
    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];

    perMessageDeflate.decompress(data, this._fin, (err, buf) => {
      if (err) return cb(err);

      if (buf.length) {
        this._messageLength += buf.length;
        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
          return cb(
            error(RangeError, 'Max payload size exceeded', false, 1009)
          );
        }

        this._fragments.push(buf);
      }

      const er = this.dataMessage();
      if (er) return cb(er);

      this.startLoop(cb);
    });
  }

  /**
   * Handles a data message.
   *
   * @return {(Error|undefined)} A possible error
   * @private
   */
  dataMessage() {
    if (this._fin) {
      const messageLength = this._messageLength;
      const fragments = this._fragments;

      this._totalPayloadLength = 0;
      this._messageLength = 0;
      this._fragmented = 0;
      this._fragments = [];

      if (this._opcode === 2) {
        let data;

        if (this._binaryType === 'nodebuffer') {
          data = concat(fragments, messageLength);
        } else if (this._binaryType === 'arraybuffer') {
          data = toArrayBuffer(concat(fragments, messageLength));
        } else {
          data = fragments;
        }

        this.emit('message', data);
      } else {
        const buf = concat(fragments, messageLength);

        if (!isValidUTF8(buf)) {
          this._loop = false;
          return error(Error, 'invalid UTF-8 sequence', true, 1007);
        }

        this.emit('message', buf.toString());
      }
    }

    this._state = GET_INFO;
  }

  /**
   * Handles a control message.
   *
   * @param {Buffer} data Data to handle
   * @return {(Error|RangeError|undefined)} A possible error
   * @private
   */
  controlMessage(data) {
    if (this._opcode === 0x08) {
      this._loop = false;

      if (data.length === 0) {
        this.emit('conclude', 1005, '');
        this.end();
      } else if (data.length === 1) {
        return error(RangeError, 'invalid payload length 1', true, 1002);
      } else {
        const code = data.readUInt16BE(0);

        if (!isValidStatusCode(code)) {
          return error(RangeError, `invalid status code ${code}`, true, 1002);
        }

        const buf = data.slice(2);

        if (!isValidUTF8(buf)) {
          return error(Error, 'invalid UTF-8 sequence', true, 1007);
        }

        this.emit('conclude', code, buf.toString());
        this.end();
      }
    } else if (this._opcode === 0x09) {
      this.emit('ping', data);
    } else {
      this.emit('pong', data);
    }

    this._state = GET_INFO;
  }
}

module.exports = Receiver;

/**
 * Builds an error object.
 *
 * @param {(Error|RangeError)} ErrorCtor The error constructor
 * @param {String} message The error message
 * @param {Boolean} prefix Specifies whether or not to add a default prefix to
 *     `message`
 * @param {Number} statusCode The status code
 * @return {(Error|RangeError)} The error
 * @private
 */
function error(ErrorCtor, message, prefix, statusCode) {
  const err = new ErrorCtor(
    prefix ? `Invalid WebSocket frame: ${message}` : message
  );

  Error.captureStackTrace(err, error);
  err[kStatusCode] = statusCode;
  return err;
}


/***/ }),

/***/ "./node_modules/ws/lib/sender.js":
/*!***************************************!*\
  !*** ./node_modules/ws/lib/sender.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const { randomFillSync } = __webpack_require__(/*! crypto */ "crypto");

const PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ "./node_modules/ws/lib/permessage-deflate.js");
const { EMPTY_BUFFER } = __webpack_require__(/*! ./constants */ "./node_modules/ws/lib/constants.js");
const { isValidStatusCode } = __webpack_require__(/*! ./validation */ "./node_modules/ws/lib/validation.js");
const { mask: applyMask, toBuffer } = __webpack_require__(/*! ./buffer-util */ "./node_modules/ws/lib/buffer-util.js");

const mask = Buffer.alloc(4);

/**
 * HyBi Sender implementation.
 */
class Sender {
  /**
   * Creates a Sender instance.
   *
   * @param {net.Socket} socket The connection socket
   * @param {Object} extensions An object containing the negotiated extensions
   */
  constructor(socket, extensions) {
    this._extensions = extensions || {};
    this._socket = socket;

    this._firstFragment = true;
    this._compress = false;

    this._bufferedBytes = 0;
    this._deflating = false;
    this._queue = [];
  }

  /**
   * Frames a piece of data according to the HyBi WebSocket protocol.
   *
   * @param {Buffer} data The data to frame
   * @param {Object} options Options object
   * @param {Number} options.opcode The opcode
   * @param {Boolean} options.readOnly Specifies whether `data` can be modified
   * @param {Boolean} options.fin Specifies whether or not to set the FIN bit
   * @param {Boolean} options.mask Specifies whether or not to mask `data`
   * @param {Boolean} options.rsv1 Specifies whether or not to set the RSV1 bit
   * @return {Buffer[]} The framed data as a list of `Buffer` instances
   * @public
   */
  static frame(data, options) {
    const merge = options.mask && options.readOnly;
    let offset = options.mask ? 6 : 2;
    let payloadLength = data.length;

    if (data.length >= 65536) {
      offset += 8;
      payloadLength = 127;
    } else if (data.length > 125) {
      offset += 2;
      payloadLength = 126;
    }

    const target = Buffer.allocUnsafe(merge ? data.length + offset : offset);

    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;
    if (options.rsv1) target[0] |= 0x40;

    target[1] = payloadLength;

    if (payloadLength === 126) {
      target.writeUInt16BE(data.length, 2);
    } else if (payloadLength === 127) {
      target.writeUInt32BE(0, 2);
      target.writeUInt32BE(data.length, 6);
    }

    if (!options.mask) return [target, data];

    randomFillSync(mask, 0, 4);

    target[1] |= 0x80;
    target[offset - 4] = mask[0];
    target[offset - 3] = mask[1];
    target[offset - 2] = mask[2];
    target[offset - 1] = mask[3];

    if (merge) {
      applyMask(data, mask, target, offset, data.length);
      return [target];
    }

    applyMask(data, mask, data, 0, data.length);
    return [target, data];
  }

  /**
   * Sends a close message to the other peer.
   *
   * @param {(Number|undefined)} code The status code component of the body
   * @param {String} data The message component of the body
   * @param {Boolean} mask Specifies whether or not to mask the message
   * @param {Function} cb Callback
   * @public
   */
  close(code, data, mask, cb) {
    let buf;

    if (code === undefined) {
      buf = EMPTY_BUFFER;
    } else if (typeof code !== 'number' || !isValidStatusCode(code)) {
      throw new TypeError('First argument must be a valid error code number');
    } else if (data === undefined || data === '') {
      buf = Buffer.allocUnsafe(2);
      buf.writeUInt16BE(code, 0);
    } else {
      buf = Buffer.allocUnsafe(2 + Buffer.byteLength(data));
      buf.writeUInt16BE(code, 0);
      buf.write(data, 2);
    }

    if (this._deflating) {
      this.enqueue([this.doClose, buf, mask, cb]);
    } else {
      this.doClose(buf, mask, cb);
    }
  }

  /**
   * Frames and sends a close message.
   *
   * @param {Buffer} data The message to send
   * @param {Boolean} mask Specifies whether or not to mask `data`
   * @param {Function} cb Callback
   * @private
   */
  doClose(data, mask, cb) {
    this.sendFrame(
      Sender.frame(data, {
        fin: true,
        rsv1: false,
        opcode: 0x08,
        mask,
        readOnly: false
      }),
      cb
    );
  }

  /**
   * Sends a ping message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Boolean} mask Specifies whether or not to mask `data`
   * @param {Function} cb Callback
   * @public
   */
  ping(data, mask, cb) {
    const buf = toBuffer(data);

    if (this._deflating) {
      this.enqueue([this.doPing, buf, mask, toBuffer.readOnly, cb]);
    } else {
      this.doPing(buf, mask, toBuffer.readOnly, cb);
    }
  }

  /**
   * Frames and sends a ping message.
   *
   * @param {*} data The message to send
   * @param {Boolean} mask Specifies whether or not to mask `data`
   * @param {Boolean} readOnly Specifies whether `data` can be modified
   * @param {Function} cb Callback
   * @private
   */
  doPing(data, mask, readOnly, cb) {
    this.sendFrame(
      Sender.frame(data, {
        fin: true,
        rsv1: false,
        opcode: 0x09,
        mask,
        readOnly
      }),
      cb
    );
  }

  /**
   * Sends a pong message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Boolean} mask Specifies whether or not to mask `data`
   * @param {Function} cb Callback
   * @public
   */
  pong(data, mask, cb) {
    const buf = toBuffer(data);

    if (this._deflating) {
      this.enqueue([this.doPong, buf, mask, toBuffer.readOnly, cb]);
    } else {
      this.doPong(buf, mask, toBuffer.readOnly, cb);
    }
  }

  /**
   * Frames and sends a pong message.
   *
   * @param {*} data The message to send
   * @param {Boolean} mask Specifies whether or not to mask `data`
   * @param {Boolean} readOnly Specifies whether `data` can be modified
   * @param {Function} cb Callback
   * @private
   */
  doPong(data, mask, readOnly, cb) {
    this.sendFrame(
      Sender.frame(data, {
        fin: true,
        rsv1: false,
        opcode: 0x0a,
        mask,
        readOnly
      }),
      cb
    );
  }

  /**
   * Sends a data message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Object} options Options object
   * @param {Boolean} options.compress Specifies whether or not to compress `data`
   * @param {Boolean} options.binary Specifies whether `data` is binary or text
   * @param {Boolean} options.fin Specifies whether the fragment is the last one
   * @param {Boolean} options.mask Specifies whether or not to mask `data`
   * @param {Function} cb Callback
   * @public
   */
  send(data, options, cb) {
    const buf = toBuffer(data);
    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
    let opcode = options.binary ? 2 : 1;
    let rsv1 = options.compress;

    if (this._firstFragment) {
      this._firstFragment = false;
      if (rsv1 && perMessageDeflate) {
        rsv1 = buf.length >= perMessageDeflate._threshold;
      }
      this._compress = rsv1;
    } else {
      rsv1 = false;
      opcode = 0;
    }

    if (options.fin) this._firstFragment = true;

    if (perMessageDeflate) {
      const opts = {
        fin: options.fin,
        rsv1,
        opcode,
        mask: options.mask,
        readOnly: toBuffer.readOnly
      };

      if (this._deflating) {
        this.enqueue([this.dispatch, buf, this._compress, opts, cb]);
      } else {
        this.dispatch(buf, this._compress, opts, cb);
      }
    } else {
      this.sendFrame(
        Sender.frame(buf, {
          fin: options.fin,
          rsv1: false,
          opcode,
          mask: options.mask,
          readOnly: toBuffer.readOnly
        }),
        cb
      );
    }
  }

  /**
   * Dispatches a data message.
   *
   * @param {Buffer} data The message to send
   * @param {Boolean} compress Specifies whether or not to compress `data`
   * @param {Object} options Options object
   * @param {Number} options.opcode The opcode
   * @param {Boolean} options.readOnly Specifies whether `data` can be modified
   * @param {Boolean} options.fin Specifies whether or not to set the FIN bit
   * @param {Boolean} options.mask Specifies whether or not to mask `data`
   * @param {Boolean} options.rsv1 Specifies whether or not to set the RSV1 bit
   * @param {Function} cb Callback
   * @private
   */
  dispatch(data, compress, options, cb) {
    if (!compress) {
      this.sendFrame(Sender.frame(data, options), cb);
      return;
    }

    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];

    this._deflating = true;
    perMessageDeflate.compress(data, options.fin, (_, buf) => {
      this._deflating = false;
      options.readOnly = false;
      this.sendFrame(Sender.frame(buf, options), cb);
      this.dequeue();
    });
  }

  /**
   * Executes queued send operations.
   *
   * @private
   */
  dequeue() {
    while (!this._deflating && this._queue.length) {
      const params = this._queue.shift();

      this._bufferedBytes -= params[1].length;
      Reflect.apply(params[0], this, params.slice(1));
    }
  }

  /**
   * Enqueues a send operation.
   *
   * @param {Array} params Send operation parameters.
   * @private
   */
  enqueue(params) {
    this._bufferedBytes += params[1].length;
    this._queue.push(params);
  }

  /**
   * Sends a frame.
   *
   * @param {Buffer[]} list The frame to send
   * @param {Function} cb Callback
   * @private
   */
  sendFrame(list, cb) {
    if (list.length === 2) {
      this._socket.cork();
      this._socket.write(list[0]);
      this._socket.write(list[1], cb);
      this._socket.uncork();
    } else {
      this._socket.write(list[0], cb);
    }
  }
}

module.exports = Sender;


/***/ }),

/***/ "./node_modules/ws/lib/stream.js":
/*!***************************************!*\
  !*** ./node_modules/ws/lib/stream.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const { Duplex } = __webpack_require__(/*! stream */ "stream");

/**
 * Emits the `'close'` event on a stream.
 *
 * @param {stream.Duplex} The stream.
 * @private
 */
function emitClose(stream) {
  stream.emit('close');
}

/**
 * The listener of the `'end'` event.
 *
 * @private
 */
function duplexOnEnd() {
  if (!this.destroyed && this._writableState.finished) {
    this.destroy();
  }
}

/**
 * The listener of the `'error'` event.
 *
 * @private
 */
function duplexOnError(err) {
  this.removeListener('error', duplexOnError);
  this.destroy();
  if (this.listenerCount('error') === 0) {
    // Do not suppress the throwing behavior.
    this.emit('error', err);
  }
}

/**
 * Wraps a `WebSocket` in a duplex stream.
 *
 * @param {WebSocket} ws The `WebSocket` to wrap
 * @param {Object} options The options for the `Duplex` constructor
 * @return {stream.Duplex} The duplex stream
 * @public
 */
function createWebSocketStream(ws, options) {
  let resumeOnReceiverDrain = true;

  function receiverOnDrain() {
    if (resumeOnReceiverDrain) ws._socket.resume();
  }

  if (ws.readyState === ws.CONNECTING) {
    ws.once('open', function open() {
      ws._receiver.removeAllListeners('drain');
      ws._receiver.on('drain', receiverOnDrain);
    });
  } else {
    ws._receiver.removeAllListeners('drain');
    ws._receiver.on('drain', receiverOnDrain);
  }

  const duplex = new Duplex({
    ...options,
    autoDestroy: false,
    emitClose: false,
    objectMode: false,
    readableObjectMode: false,
    writableObjectMode: false
  });

  ws.on('message', function message(msg) {
    if (!duplex.push(msg)) {
      resumeOnReceiverDrain = false;
      ws._socket.pause();
    }
  });

  ws.once('error', function error(err) {
    duplex.destroy(err);
  });

  ws.once('close', function close() {
    if (duplex.destroyed) return;

    duplex.push(null);
  });

  duplex._destroy = function(err, callback) {
    if (ws.readyState === ws.CLOSED) {
      callback(err);
      process.nextTick(emitClose, duplex);
      return;
    }

    ws.once('close', function close() {
      callback(err);
      process.nextTick(emitClose, duplex);
    });
    ws.terminate();
  };

  duplex._final = function(callback) {
    if (ws.readyState === ws.CONNECTING) {
      ws.once('open', function open() {
        duplex._final(callback);
      });
      return;
    }

    if (ws._socket._writableState.finished) {
      if (duplex._readableState.endEmitted) duplex.destroy();
      callback();
    } else {
      ws._socket.once('finish', function finish() {
        // `duplex` is not destroyed here because the `'end'` event will be
        // emitted on `duplex` after this `'finish'` event. The EOF signaling
        // `null` chunk is, in fact, pushed when the WebSocket emits `'close'`.
        callback();
      });
      ws.close();
    }
  };

  duplex._read = function() {
    if (ws.readyState === ws.OPEN && !resumeOnReceiverDrain) {
      resumeOnReceiverDrain = true;
      if (!ws._receiver._writableState.needDrain) ws._socket.resume();
    }
  };

  duplex._write = function(chunk, encoding, callback) {
    if (ws.readyState === ws.CONNECTING) {
      ws.once('open', function open() {
        duplex._write(chunk, encoding, callback);
      });
      return;
    }

    ws.send(chunk, callback);
  };

  duplex.on('end', duplexOnEnd);
  duplex.on('error', duplexOnError);
  return duplex;
}

module.exports = createWebSocketStream;


/***/ }),

/***/ "./node_modules/ws/lib/validation.js":
/*!*******************************************!*\
  !*** ./node_modules/ws/lib/validation.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


try {
  const isValidUTF8 = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module 'utf-8-validate'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

  exports.isValidUTF8 =
    typeof isValidUTF8 === 'object'
      ? isValidUTF8.Validation.isValidUTF8 // utf-8-validate@<3.0.0
      : isValidUTF8;
} catch (e) /* istanbul ignore next */ {
  exports.isValidUTF8 = () => true;
}

/**
 * Checks if a status code is allowed in a close frame.
 *
 * @param {Number} code The status code
 * @return {Boolean} `true` if the status code is valid, else `false`
 * @public
 */
exports.isValidStatusCode = (code) => {
  return (
    (code >= 1000 &&
      code <= 1013 &&
      code !== 1004 &&
      code !== 1005 &&
      code !== 1006) ||
    (code >= 3000 && code <= 4999)
  );
};


/***/ }),

/***/ "./node_modules/ws/lib/websocket-server.js":
/*!*************************************************!*\
  !*** ./node_modules/ws/lib/websocket-server.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const EventEmitter = __webpack_require__(/*! events */ "events");
const { createHash } = __webpack_require__(/*! crypto */ "crypto");
const { createServer, STATUS_CODES } = __webpack_require__(/*! http */ "http");

const PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ "./node_modules/ws/lib/permessage-deflate.js");
const WebSocket = __webpack_require__(/*! ./websocket */ "./node_modules/ws/lib/websocket.js");
const { format, parse } = __webpack_require__(/*! ./extension */ "./node_modules/ws/lib/extension.js");
const { GUID } = __webpack_require__(/*! ./constants */ "./node_modules/ws/lib/constants.js");

const keyRegex = /^[+/0-9A-Za-z]{22}==$/;
const kUsedByWebSocketServer = Symbol('kUsedByWebSocketServer');

/**
 * Class representing a WebSocket server.
 *
 * @extends EventEmitter
 */
class WebSocketServer extends EventEmitter {
  /**
   * Create a `WebSocketServer` instance.
   *
   * @param {Object} options Configuration options
   * @param {Number} options.backlog The maximum length of the queue of pending
   *     connections
   * @param {Boolean} options.clientTracking Specifies whether or not to track
   *     clients
   * @param {Function} options.handleProtocols A hook to handle protocols
   * @param {String} options.host The hostname where to bind the server
   * @param {Number} options.maxPayload The maximum allowed message size
   * @param {Boolean} options.noServer Enable no server mode
   * @param {String} options.path Accept only connections matching this path
   * @param {(Boolean|Object)} options.perMessageDeflate Enable/disable
   *     permessage-deflate
   * @param {Number} options.port The port where to bind the server
   * @param {http.Server} options.server A pre-created HTTP/S server to use
   * @param {Function} options.verifyClient A hook to reject connections
   * @param {Function} callback A listener for the `listening` event
   */
  constructor(options, callback) {
    super();

    options = {
      maxPayload: 100 * 1024 * 1024,
      perMessageDeflate: false,
      handleProtocols: null,
      clientTracking: true,
      verifyClient: null,
      noServer: false,
      backlog: null, // use default (511 as implemented in net.js)
      server: null,
      host: null,
      path: null,
      port: null,
      ...options
    };

    if (options.port == null && !options.server && !options.noServer) {
      throw new TypeError(
        'One of the "port", "server", or "noServer" options must be specified'
      );
    }

    if (options.port != null) {
      this._server = createServer((req, res) => {
        const body = STATUS_CODES[426];

        res.writeHead(426, {
          'Content-Length': body.length,
          'Content-Type': 'text/plain'
        });
        res.end(body);
      });
      this._server.listen(
        options.port,
        options.host,
        options.backlog,
        callback
      );
    } else if (options.server) {
      this._server = options.server;
    }

    if (this._server) {
      if (this._server[kUsedByWebSocketServer]) {
        throw new Error(
          'The HTTP/S server is already being used by another WebSocket server'
        );
      } else {
        this._server[kUsedByWebSocketServer] = true;
      }

      this._removeListeners = addListeners(this._server, {
        listening: this.emit.bind(this, 'listening'),
        error: this.emit.bind(this, 'error'),
        upgrade: (req, socket, head) => {
          this.handleUpgrade(req, socket, head, (ws) => {
            this.emit('connection', ws, req);
          });
        }
      });
    }

    if (options.perMessageDeflate === true) options.perMessageDeflate = {};
    if (options.clientTracking) this.clients = new Set();
    this.options = options;
  }

  /**
   * Returns the bound address, the address family name, and port of the server
   * as reported by the operating system if listening on an IP socket.
   * If the server is listening on a pipe or UNIX domain socket, the name is
   * returned as a string.
   *
   * @return {(Object|String|null)} The address of the server
   * @public
   */
  address() {
    if (this.options.noServer) {
      throw new Error('The server is operating in "noServer" mode');
    }

    if (!this._server) return null;
    return this._server.address();
  }

  /**
   * Close the server.
   *
   * @param {Function} cb Callback
   * @public
   */
  close(cb) {
    if (cb) this.once('close', cb);

    //
    // Terminate all associated clients.
    //
    if (this.clients) {
      for (const client of this.clients) client.terminate();
    }

    const server = this._server;

    if (server) {
      server[kUsedByWebSocketServer] = false;

      this._removeListeners();
      this._removeListeners = this._server = null;

      //
      // Close the http server if it was internally created.
      //
      if (this.options.port != null) {
        server.close(() => this.emit('close'));
        return;
      }
    }

    process.nextTick(emitClose, this);
  }

  /**
   * See if a given request should be handled by this server instance.
   *
   * @param {http.IncomingMessage} req Request object to inspect
   * @return {Boolean} `true` if the request is valid, else `false`
   * @public
   */
  shouldHandle(req) {
    if (this.options.path) {
      const index = req.url.indexOf('?');
      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;

      if (pathname !== this.options.path) return false;
    }

    return true;
  }

  /**
   * Handle a HTTP Upgrade request.
   *
   * @param {http.IncomingMessage} req The request object
   * @param {net.Socket} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Function} cb Callback
   * @public
   */
  handleUpgrade(req, socket, head, cb) {
    socket.on('error', socketOnError);

    const key =
      req.headers['sec-websocket-key'] !== undefined
        ? req.headers['sec-websocket-key'].trim()
        : false;
    const version = +req.headers['sec-websocket-version'];
    const extensions = {};

    if (
      req.method !== 'GET' ||
      req.headers.upgrade.toLowerCase() !== 'websocket' ||
      !key ||
      !keyRegex.test(key) ||
      (version !== 8 && version !== 13) ||
      !this.shouldHandle(req)
    ) {
      return abortHandshake(socket, 400);
    }

    if (this.options.perMessageDeflate) {
      const perMessageDeflate = new PerMessageDeflate(
        this.options.perMessageDeflate,
        true,
        this.options.maxPayload
      );

      try {
        const offers = parse(req.headers['sec-websocket-extensions']);

        if (offers[PerMessageDeflate.extensionName]) {
          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
        }
      } catch (err) {
        return abortHandshake(socket, 400);
      }
    }

    //
    // Optionally call external client verification handler.
    //
    if (this.options.verifyClient) {
      const info = {
        origin:
          req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],
        secure: !!(req.connection.authorized || req.connection.encrypted),
        req
      };

      if (this.options.verifyClient.length === 2) {
        this.options.verifyClient(info, (verified, code, message, headers) => {
          if (!verified) {
            return abortHandshake(socket, code || 401, message, headers);
          }

          this.completeUpgrade(key, extensions, req, socket, head, cb);
        });
        return;
      }

      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
    }

    this.completeUpgrade(key, extensions, req, socket, head, cb);
  }

  /**
   * Upgrade the connection to WebSocket.
   *
   * @param {String} key The value of the `Sec-WebSocket-Key` header
   * @param {Object} extensions The accepted extensions
   * @param {http.IncomingMessage} req The request object
   * @param {net.Socket} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Function} cb Callback
   * @private
   */
  completeUpgrade(key, extensions, req, socket, head, cb) {
    //
    // Destroy the socket if the client has already sent a FIN packet.
    //
    if (!socket.readable || !socket.writable) return socket.destroy();

    const digest = createHash('sha1')
      .update(key + GUID)
      .digest('base64');

    const headers = [
      'HTTP/1.1 101 Switching Protocols',
      'Upgrade: websocket',
      'Connection: Upgrade',
      `Sec-WebSocket-Accept: ${digest}`
    ];

    const ws = new WebSocket(null);
    let protocol = req.headers['sec-websocket-protocol'];

    if (protocol) {
      protocol = protocol.trim().split(/ *, */);

      //
      // Optionally call external protocol selection handler.
      //
      if (this.options.handleProtocols) {
        protocol = this.options.handleProtocols(protocol, req);
      } else {
        protocol = protocol[0];
      }

      if (protocol) {
        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
        ws.protocol = protocol;
      }
    }

    if (extensions[PerMessageDeflate.extensionName]) {
      const params = extensions[PerMessageDeflate.extensionName].params;
      const value = format({
        [PerMessageDeflate.extensionName]: [params]
      });
      headers.push(`Sec-WebSocket-Extensions: ${value}`);
      ws._extensions = extensions;
    }

    //
    // Allow external modification/inspection of handshake headers.
    //
    this.emit('headers', headers, req);

    socket.write(headers.concat('\r\n').join('\r\n'));
    socket.removeListener('error', socketOnError);

    ws.setSocket(socket, head, this.options.maxPayload);

    if (this.clients) {
      this.clients.add(ws);
      ws.on('close', () => this.clients.delete(ws));
    }

    cb(ws);
  }
}

module.exports = WebSocketServer;

/**
 * Add event listeners on an `EventEmitter` using a map of <event, listener>
 * pairs.
 *
 * @param {EventEmitter} server The event emitter
 * @param {Object.<String, Function>} map The listeners to add
 * @return {Function} A function that will remove the added listeners when called
 * @private
 */
function addListeners(server, map) {
  for (const event of Object.keys(map)) server.on(event, map[event]);

  return function removeListeners() {
    for (const event of Object.keys(map)) {
      server.removeListener(event, map[event]);
    }
  };
}

/**
 * Emit a `'close'` event on an `EventEmitter`.
 *
 * @param {EventEmitter} server The event emitter
 * @private
 */
function emitClose(server) {
  server.emit('close');
}

/**
 * Handle premature socket errors.
 *
 * @private
 */
function socketOnError() {
  this.destroy();
}

/**
 * Close the connection when preconditions are not fulfilled.
 *
 * @param {net.Socket} socket The socket of the upgrade request
 * @param {Number} code The HTTP response status code
 * @param {String} [message] The HTTP response body
 * @param {Object} [headers] Additional HTTP response headers
 * @private
 */
function abortHandshake(socket, code, message, headers) {
  if (socket.writable) {
    message = message || STATUS_CODES[code];
    headers = {
      Connection: 'close',
      'Content-type': 'text/html',
      'Content-Length': Buffer.byteLength(message),
      ...headers
    };

    socket.write(
      `HTTP/1.1 ${code} ${STATUS_CODES[code]}\r\n` +
        Object.keys(headers)
          .map((h) => `${h}: ${headers[h]}`)
          .join('\r\n') +
        '\r\n\r\n' +
        message
    );
  }

  socket.removeListener('error', socketOnError);
  socket.destroy();
}


/***/ }),

/***/ "./node_modules/ws/lib/websocket.js":
/*!******************************************!*\
  !*** ./node_modules/ws/lib/websocket.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const EventEmitter = __webpack_require__(/*! events */ "events");
const https = __webpack_require__(/*! https */ "https");
const http = __webpack_require__(/*! http */ "http");
const net = __webpack_require__(/*! net */ "net");
const tls = __webpack_require__(/*! tls */ "tls");
const { randomBytes, createHash } = __webpack_require__(/*! crypto */ "crypto");
const { URL } = __webpack_require__(/*! url */ "url");

const PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ "./node_modules/ws/lib/permessage-deflate.js");
const Receiver = __webpack_require__(/*! ./receiver */ "./node_modules/ws/lib/receiver.js");
const Sender = __webpack_require__(/*! ./sender */ "./node_modules/ws/lib/sender.js");
const {
  BINARY_TYPES,
  EMPTY_BUFFER,
  GUID,
  kStatusCode,
  kWebSocket,
  NOOP
} = __webpack_require__(/*! ./constants */ "./node_modules/ws/lib/constants.js");
const { addEventListener, removeEventListener } = __webpack_require__(/*! ./event-target */ "./node_modules/ws/lib/event-target.js");
const { format, parse } = __webpack_require__(/*! ./extension */ "./node_modules/ws/lib/extension.js");
const { toBuffer } = __webpack_require__(/*! ./buffer-util */ "./node_modules/ws/lib/buffer-util.js");

const readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];
const protocolVersions = [8, 13];
const closeTimeout = 30 * 1000;

/**
 * Class representing a WebSocket.
 *
 * @extends EventEmitter
 */
class WebSocket extends EventEmitter {
  /**
   * Create a new `WebSocket`.
   *
   * @param {(String|url.URL)} address The URL to which to connect
   * @param {(String|String[])} protocols The subprotocols
   * @param {Object} options Connection options
   */
  constructor(address, protocols, options) {
    super();

    this.readyState = WebSocket.CONNECTING;
    this.protocol = '';

    this._binaryType = BINARY_TYPES[0];
    this._closeFrameReceived = false;
    this._closeFrameSent = false;
    this._closeMessage = '';
    this._closeTimer = null;
    this._closeCode = 1006;
    this._extensions = {};
    this._receiver = null;
    this._sender = null;
    this._socket = null;

    if (address !== null) {
      this._bufferedAmount = 0;
      this._isServer = false;
      this._redirects = 0;

      if (Array.isArray(protocols)) {
        protocols = protocols.join(', ');
      } else if (typeof protocols === 'object' && protocols !== null) {
        options = protocols;
        protocols = undefined;
      }

      initAsClient(this, address, protocols, options);
    } else {
      this._isServer = true;
    }
  }

  get CONNECTING() {
    return WebSocket.CONNECTING;
  }
  get CLOSING() {
    return WebSocket.CLOSING;
  }
  get CLOSED() {
    return WebSocket.CLOSED;
  }
  get OPEN() {
    return WebSocket.OPEN;
  }

  /**
   * This deviates from the WHATWG interface since ws doesn't support the
   * required default "blob" type (instead we define a custom "nodebuffer"
   * type).
   *
   * @type {String}
   */
  get binaryType() {
    return this._binaryType;
  }

  set binaryType(type) {
    if (!BINARY_TYPES.includes(type)) return;

    this._binaryType = type;

    //
    // Allow to change `binaryType` on the fly.
    //
    if (this._receiver) this._receiver._binaryType = type;
  }

  /**
   * @type {Number}
   */
  get bufferedAmount() {
    if (!this._socket) return this._bufferedAmount;

    //
    // `socket.bufferSize` is `undefined` if the socket is closed.
    //
    return (this._socket.bufferSize || 0) + this._sender._bufferedBytes;
  }

  /**
   * @type {String}
   */
  get extensions() {
    return Object.keys(this._extensions).join();
  }

  /**
   * Set up the socket and the internal resources.
   *
   * @param {net.Socket} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Number} maxPayload The maximum allowed message size
   * @private
   */
  setSocket(socket, head, maxPayload) {
    const receiver = new Receiver(
      this._binaryType,
      this._extensions,
      maxPayload
    );

    this._sender = new Sender(socket, this._extensions);
    this._receiver = receiver;
    this._socket = socket;

    receiver[kWebSocket] = this;
    socket[kWebSocket] = this;

    receiver.on('conclude', receiverOnConclude);
    receiver.on('drain', receiverOnDrain);
    receiver.on('error', receiverOnError);
    receiver.on('message', receiverOnMessage);
    receiver.on('ping', receiverOnPing);
    receiver.on('pong', receiverOnPong);

    socket.setTimeout(0);
    socket.setNoDelay();

    if (head.length > 0) socket.unshift(head);

    socket.on('close', socketOnClose);
    socket.on('data', socketOnData);
    socket.on('end', socketOnEnd);
    socket.on('error', socketOnError);

    this.readyState = WebSocket.OPEN;
    this.emit('open');
  }

  /**
   * Emit the `'close'` event.
   *
   * @private
   */
  emitClose() {
    this.readyState = WebSocket.CLOSED;

    if (!this._socket) {
      this.emit('close', this._closeCode, this._closeMessage);
      return;
    }

    if (this._extensions[PerMessageDeflate.extensionName]) {
      this._extensions[PerMessageDeflate.extensionName].cleanup();
    }

    this._receiver.removeAllListeners();
    this.emit('close', this._closeCode, this._closeMessage);
  }

  /**
   * Start a closing handshake.
   *
   *          +----------+   +-----------+   +----------+
   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
   *    |     +----------+   +-----------+   +----------+     |
   *          +----------+   +-----------+         |
   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
   *          +----------+   +-----------+   |
   *    |           |                        |   +---+        |
   *                +------------------------+-->|fin| - - - -
   *    |         +---+                      |   +---+
   *     - - - - -|fin|<---------------------+
   *              +---+
   *
   * @param {Number} code Status code explaining why the connection is closing
   * @param {String} data A string explaining why the connection is closing
   * @public
   */
  close(code, data) {
    if (this.readyState === WebSocket.CLOSED) return;
    if (this.readyState === WebSocket.CONNECTING) {
      const msg = 'WebSocket was closed before the connection was established';
      return abortHandshake(this, this._req, msg);
    }

    if (this.readyState === WebSocket.CLOSING) {
      if (this._closeFrameSent && this._closeFrameReceived) this._socket.end();
      return;
    }

    this.readyState = WebSocket.CLOSING;
    this._sender.close(code, data, !this._isServer, (err) => {
      //
      // This error is handled by the `'error'` listener on the socket. We only
      // want to know if the close frame has been sent here.
      //
      if (err) return;

      this._closeFrameSent = true;
      if (this._closeFrameReceived) this._socket.end();
    });

    //
    // Specify a timeout for the closing handshake to complete.
    //
    this._closeTimer = setTimeout(
      this._socket.destroy.bind(this._socket),
      closeTimeout
    );
  }

  /**
   * Send a ping.
   *
   * @param {*} data The data to send
   * @param {Boolean} mask Indicates whether or not to mask `data`
   * @param {Function} cb Callback which is executed when the ping is sent
   * @public
   */
  ping(data, mask, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof data === 'function') {
      cb = data;
      data = mask = undefined;
    } else if (typeof mask === 'function') {
      cb = mask;
      mask = undefined;
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }

    if (mask === undefined) mask = !this._isServer;
    this._sender.ping(data || EMPTY_BUFFER, mask, cb);
  }

  /**
   * Send a pong.
   *
   * @param {*} data The data to send
   * @param {Boolean} mask Indicates whether or not to mask `data`
   * @param {Function} cb Callback which is executed when the pong is sent
   * @public
   */
  pong(data, mask, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof data === 'function') {
      cb = data;
      data = mask = undefined;
    } else if (typeof mask === 'function') {
      cb = mask;
      mask = undefined;
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }

    if (mask === undefined) mask = !this._isServer;
    this._sender.pong(data || EMPTY_BUFFER, mask, cb);
  }

  /**
   * Send a data message.
   *
   * @param {*} data The message to send
   * @param {Object} options Options object
   * @param {Boolean} options.compress Specifies whether or not to compress
   *     `data`
   * @param {Boolean} options.binary Specifies whether `data` is binary or text
   * @param {Boolean} options.fin Specifies whether the fragment is the last one
   * @param {Boolean} options.mask Specifies whether or not to mask `data`
   * @param {Function} cb Callback which is executed when data is written out
   * @public
   */
  send(data, options, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof options === 'function') {
      cb = options;
      options = {};
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }

    const opts = {
      binary: typeof data !== 'string',
      mask: !this._isServer,
      compress: true,
      fin: true,
      ...options
    };

    if (!this._extensions[PerMessageDeflate.extensionName]) {
      opts.compress = false;
    }

    this._sender.send(data || EMPTY_BUFFER, opts, cb);
  }

  /**
   * Forcibly close the connection.
   *
   * @public
   */
  terminate() {
    if (this.readyState === WebSocket.CLOSED) return;
    if (this.readyState === WebSocket.CONNECTING) {
      const msg = 'WebSocket was closed before the connection was established';
      return abortHandshake(this, this._req, msg);
    }

    if (this._socket) {
      this.readyState = WebSocket.CLOSING;
      this._socket.destroy();
    }
  }
}

readyStates.forEach((readyState, i) => {
  WebSocket[readyState] = i;
});

//
// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.
// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface
//
['open', 'error', 'close', 'message'].forEach((method) => {
  Object.defineProperty(WebSocket.prototype, `on${method}`, {
    /**
     * Return the listener of the event.
     *
     * @return {(Function|undefined)} The event listener or `undefined`
     * @public
     */
    get() {
      const listeners = this.listeners(method);
      for (let i = 0; i < listeners.length; i++) {
        if (listeners[i]._listener) return listeners[i]._listener;
      }

      return undefined;
    },
    /**
     * Add a listener for the event.
     *
     * @param {Function} listener The listener to add
     * @public
     */
    set(listener) {
      const listeners = this.listeners(method);
      for (let i = 0; i < listeners.length; i++) {
        //
        // Remove only the listeners added via `addEventListener`.
        //
        if (listeners[i]._listener) this.removeListener(method, listeners[i]);
      }
      this.addEventListener(method, listener);
    }
  });
});

WebSocket.prototype.addEventListener = addEventListener;
WebSocket.prototype.removeEventListener = removeEventListener;

module.exports = WebSocket;

/**
 * Initialize a WebSocket client.
 *
 * @param {WebSocket} websocket The client to initialize
 * @param {(String|url.URL)} address The URL to which to connect
 * @param {String} protocols The subprotocols
 * @param {Object} options Connection options
 * @param {(Boolean|Object)} options.perMessageDeflate Enable/disable
 *     permessage-deflate
 * @param {Number} options.handshakeTimeout Timeout in milliseconds for the
 *     handshake request
 * @param {Number} options.protocolVersion Value of the `Sec-WebSocket-Version`
 *     header
 * @param {String} options.origin Value of the `Origin` or
 *     `Sec-WebSocket-Origin` header
 * @param {Number} options.maxPayload The maximum allowed message size
 * @param {Boolean} options.followRedirects Whether or not to follow redirects
 * @param {Number} options.maxRedirects The maximum number of redirects allowed
 * @private
 */
function initAsClient(websocket, address, protocols, options) {
  const opts = {
    protocolVersion: protocolVersions[1],
    maxPayload: 100 * 1024 * 1024,
    perMessageDeflate: true,
    followRedirects: false,
    maxRedirects: 10,
    ...options,
    createConnection: undefined,
    socketPath: undefined,
    hostname: undefined,
    protocol: undefined,
    timeout: undefined,
    method: undefined,
    auth: undefined,
    host: undefined,
    path: undefined,
    port: undefined
  };

  if (!protocolVersions.includes(opts.protocolVersion)) {
    throw new RangeError(
      `Unsupported protocol version: ${opts.protocolVersion} ` +
        `(supported versions: ${protocolVersions.join(', ')})`
    );
  }

  let parsedUrl;

  if (address instanceof URL) {
    parsedUrl = address;
    websocket.url = address.href;
  } else {
    parsedUrl = new URL(address);
    websocket.url = address;
  }

  const isUnixSocket = parsedUrl.protocol === 'ws+unix:';

  if (!parsedUrl.host && (!isUnixSocket || !parsedUrl.pathname)) {
    throw new Error(`Invalid URL: ${websocket.url}`);
  }

  const isSecure =
    parsedUrl.protocol === 'wss:' || parsedUrl.protocol === 'https:';
  const defaultPort = isSecure ? 443 : 80;
  const key = randomBytes(16).toString('base64');
  const get = isSecure ? https.get : http.get;
  let perMessageDeflate;

  opts.createConnection = isSecure ? tlsConnect : netConnect;
  opts.defaultPort = opts.defaultPort || defaultPort;
  opts.port = parsedUrl.port || defaultPort;
  opts.host = parsedUrl.hostname.startsWith('[')
    ? parsedUrl.hostname.slice(1, -1)
    : parsedUrl.hostname;
  opts.headers = {
    'Sec-WebSocket-Version': opts.protocolVersion,
    'Sec-WebSocket-Key': key,
    Connection: 'Upgrade',
    Upgrade: 'websocket',
    ...opts.headers
  };
  opts.path = parsedUrl.pathname + parsedUrl.search;
  opts.timeout = opts.handshakeTimeout;

  if (opts.perMessageDeflate) {
    perMessageDeflate = new PerMessageDeflate(
      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
      false,
      opts.maxPayload
    );
    opts.headers['Sec-WebSocket-Extensions'] = format({
      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
    });
  }
  if (protocols) {
    opts.headers['Sec-WebSocket-Protocol'] = protocols;
  }
  if (opts.origin) {
    if (opts.protocolVersion < 13) {
      opts.headers['Sec-WebSocket-Origin'] = opts.origin;
    } else {
      opts.headers.Origin = opts.origin;
    }
  }
  if (parsedUrl.username || parsedUrl.password) {
    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
  }

  if (isUnixSocket) {
    const parts = opts.path.split(':');

    opts.socketPath = parts[0];
    opts.path = parts[1];
  }

  let req = (websocket._req = get(opts));

  if (opts.timeout) {
    req.on('timeout', () => {
      abortHandshake(websocket, req, 'Opening handshake has timed out');
    });
  }

  req.on('error', (err) => {
    if (websocket._req.aborted) return;

    req = websocket._req = null;
    websocket.readyState = WebSocket.CLOSING;
    websocket.emit('error', err);
    websocket.emitClose();
  });

  req.on('response', (res) => {
    const location = res.headers.location;
    const statusCode = res.statusCode;

    if (
      location &&
      opts.followRedirects &&
      statusCode >= 300 &&
      statusCode < 400
    ) {
      if (++websocket._redirects > opts.maxRedirects) {
        abortHandshake(websocket, req, 'Maximum redirects exceeded');
        return;
      }

      req.abort();

      const addr = new URL(location, address);

      initAsClient(websocket, addr, protocols, options);
    } else if (!websocket.emit('unexpected-response', req, res)) {
      abortHandshake(
        websocket,
        req,
        `Unexpected server response: ${res.statusCode}`
      );
    }
  });

  req.on('upgrade', (res, socket, head) => {
    websocket.emit('upgrade', res);

    //
    // The user may have closed the connection from a listener of the `upgrade`
    // event.
    //
    if (websocket.readyState !== WebSocket.CONNECTING) return;

    req = websocket._req = null;

    const digest = createHash('sha1')
      .update(key + GUID)
      .digest('base64');

    if (res.headers['sec-websocket-accept'] !== digest) {
      abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');
      return;
    }

    const serverProt = res.headers['sec-websocket-protocol'];
    const protList = (protocols || '').split(/, */);
    let protError;

    if (!protocols && serverProt) {
      protError = 'Server sent a subprotocol but none was requested';
    } else if (protocols && !serverProt) {
      protError = 'Server sent no subprotocol';
    } else if (serverProt && !protList.includes(serverProt)) {
      protError = 'Server sent an invalid subprotocol';
    }

    if (protError) {
      abortHandshake(websocket, socket, protError);
      return;
    }

    if (serverProt) websocket.protocol = serverProt;

    if (perMessageDeflate) {
      try {
        const extensions = parse(res.headers['sec-websocket-extensions']);

        if (extensions[PerMessageDeflate.extensionName]) {
          perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
          websocket._extensions[
            PerMessageDeflate.extensionName
          ] = perMessageDeflate;
        }
      } catch (err) {
        abortHandshake(
          websocket,
          socket,
          'Invalid Sec-WebSocket-Extensions header'
        );
        return;
      }
    }

    websocket.setSocket(socket, head, opts.maxPayload);
  });
}

/**
 * Create a `net.Socket` and initiate a connection.
 *
 * @param {Object} options Connection options
 * @return {net.Socket} The newly created socket used to start the connection
 * @private
 */
function netConnect(options) {
  options.path = options.socketPath;
  return net.connect(options);
}

/**
 * Create a `tls.TLSSocket` and initiate a connection.
 *
 * @param {Object} options Connection options
 * @return {tls.TLSSocket} The newly created socket used to start the connection
 * @private
 */
function tlsConnect(options) {
  options.path = undefined;

  if (!options.servername && options.servername !== '') {
    options.servername = options.host;
  }

  return tls.connect(options);
}

/**
 * Abort the handshake and emit an error.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @param {(http.ClientRequest|net.Socket)} stream The request to abort or the
 *     socket to destroy
 * @param {String} message The error message
 * @private
 */
function abortHandshake(websocket, stream, message) {
  websocket.readyState = WebSocket.CLOSING;

  const err = new Error(message);
  Error.captureStackTrace(err, abortHandshake);

  if (stream.setHeader) {
    stream.abort();
    stream.once('abort', websocket.emitClose.bind(websocket));
    websocket.emit('error', err);
  } else {
    stream.destroy(err);
    stream.once('error', websocket.emit.bind(websocket, 'error'));
    stream.once('close', websocket.emitClose.bind(websocket));
  }
}

/**
 * Handle cases where the `ping()`, `pong()`, or `send()` methods are called
 * when the `readyState` attribute is `CLOSING` or `CLOSED`.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @param {*} data The data to send
 * @param {Function} cb Callback
 * @private
 */
function sendAfterClose(websocket, data, cb) {
  if (data) {
    const length = toBuffer(data).length;

    //
    // The `_bufferedAmount` property is used only when the peer is a client and
    // the opening handshake fails. Under these circumstances, in fact, the
    // `setSocket()` method is not called, so the `_socket` and `_sender`
    // properties are set to `null`.
    //
    if (websocket._socket) websocket._sender._bufferedBytes += length;
    else websocket._bufferedAmount += length;
  }

  if (cb) {
    const err = new Error(
      `WebSocket is not open: readyState ${websocket.readyState} ` +
        `(${readyStates[websocket.readyState]})`
    );
    cb(err);
  }
}

/**
 * The listener of the `Receiver` `'conclude'` event.
 *
 * @param {Number} code The status code
 * @param {String} reason The reason for closing
 * @private
 */
function receiverOnConclude(code, reason) {
  const websocket = this[kWebSocket];

  websocket._socket.removeListener('data', socketOnData);
  websocket._socket.resume();

  websocket._closeFrameReceived = true;
  websocket._closeMessage = reason;
  websocket._closeCode = code;

  if (code === 1005) websocket.close();
  else websocket.close(code, reason);
}

/**
 * The listener of the `Receiver` `'drain'` event.
 *
 * @private
 */
function receiverOnDrain() {
  this[kWebSocket]._socket.resume();
}

/**
 * The listener of the `Receiver` `'error'` event.
 *
 * @param {(RangeError|Error)} err The emitted error
 * @private
 */
function receiverOnError(err) {
  const websocket = this[kWebSocket];

  websocket._socket.removeListener('data', socketOnData);

  websocket.readyState = WebSocket.CLOSING;
  websocket._closeCode = err[kStatusCode];
  websocket.emit('error', err);
  websocket._socket.destroy();
}

/**
 * The listener of the `Receiver` `'finish'` event.
 *
 * @private
 */
function receiverOnFinish() {
  this[kWebSocket].emitClose();
}

/**
 * The listener of the `Receiver` `'message'` event.
 *
 * @param {(String|Buffer|ArrayBuffer|Buffer[])} data The message
 * @private
 */
function receiverOnMessage(data) {
  this[kWebSocket].emit('message', data);
}

/**
 * The listener of the `Receiver` `'ping'` event.
 *
 * @param {Buffer} data The data included in the ping frame
 * @private
 */
function receiverOnPing(data) {
  const websocket = this[kWebSocket];

  websocket.pong(data, !websocket._isServer, NOOP);
  websocket.emit('ping', data);
}

/**
 * The listener of the `Receiver` `'pong'` event.
 *
 * @param {Buffer} data The data included in the pong frame
 * @private
 */
function receiverOnPong(data) {
  this[kWebSocket].emit('pong', data);
}

/**
 * The listener of the `net.Socket` `'close'` event.
 *
 * @private
 */
function socketOnClose() {
  const websocket = this[kWebSocket];

  this.removeListener('close', socketOnClose);
  this.removeListener('end', socketOnEnd);

  websocket.readyState = WebSocket.CLOSING;

  //
  // The close frame might not have been received or the `'end'` event emitted,
  // for example, if the socket was destroyed due to an error. Ensure that the
  // `receiver` stream is closed after writing any remaining buffered data to
  // it. If the readable side of the socket is in flowing mode then there is no
  // buffered data as everything has been already written and `readable.read()`
  // will return `null`. If instead, the socket is paused, any possible buffered
  // data will be read as a single chunk and emitted synchronously in a single
  // `'data'` event.
  //
  websocket._socket.read();
  websocket._receiver.end();

  this.removeListener('data', socketOnData);
  this[kWebSocket] = undefined;

  clearTimeout(websocket._closeTimer);

  if (
    websocket._receiver._writableState.finished ||
    websocket._receiver._writableState.errorEmitted
  ) {
    websocket.emitClose();
  } else {
    websocket._receiver.on('error', receiverOnFinish);
    websocket._receiver.on('finish', receiverOnFinish);
  }
}

/**
 * The listener of the `net.Socket` `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function socketOnData(chunk) {
  if (!this[kWebSocket]._receiver.write(chunk)) {
    this.pause();
  }
}

/**
 * The listener of the `net.Socket` `'end'` event.
 *
 * @private
 */
function socketOnEnd() {
  const websocket = this[kWebSocket];

  websocket.readyState = WebSocket.CLOSING;
  websocket._receiver.end();
  this.end();
}

/**
 * The listener of the `net.Socket` `'error'` event.
 *
 * @private
 */
function socketOnError() {
  const websocket = this[kWebSocket];

  this.removeListener('error', socketOnError);
  this.on('error', NOOP);

  if (websocket) {
    websocket.readyState = WebSocket.CLOSING;
    this.destroy();
  }
}


/***/ }),

/***/ "./src/abbreviations/abbreviations.charCompletion.ts":
/*!***********************************************************!*\
  !*** ./src/abbreviations/abbreviations.charCompletion.ts ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.charCompletion = {
    appendDirection(secondKey, base) {
        switch (secondKey) {
            case 'l':
                return `${base}-left:`;
            case 't':
                return `${base}-top:`;
            case 'r':
                return `${base}-right:`;
            case 'b':
                return `${base}-bottom:`;
            default:
                return `${base}:`;
        }
    },
    getA(secondKey) {
        switch (secondKey) {
            case 'l':
                return `all:`;
            case 'c':
                return `align-content:`;
            case 's':
                return `align-self:`;
            case 'i':
                return `align-items:`;
            default:
                return `animation:`;
        }
    },
    getB(secondKey, thirdKey, base) {
        switch (secondKey) {
            case 'l':
                return `${base}-left:`;
            case 't':
                return `${base}-top:`;
            case 'r':
                return `${base}-right:`;
            case 'b':
                return `${base}-bottom:`;
            case 'g':
                return `background:`;
            case 'a':
                return borderThirdKey(base, thirdKey);
            case 'u':
                return `bottom:`;
            case 's':
                return `box-shadow:`;
            case 'z':
                return `box-sizing:`;
            case 'd':
                return `box-decoration-break:`;
            case 'v':
                return `backface-visibility:`;
            default:
                return `${base}:`;
        }
    },
    getC(secondKey) {
        switch (secondKey) {
            case 'l':
                return `clip:`;
            case 's':
                return `columns:`;
            case 'o':
                return `column-`;
            case 't':
                return `content:`;
            case 'i':
                return `counter-increment:`;
            case 'r':
                return `counter-reset:`;
            case 'c':
                return `cursor:`;
            default:
                return `color:`;
        }
    },
    getD(secondKey) {
        switch (secondKey) {
            case 'r':
                return `direction:`;
            default:
                return `display:`;
        }
    },
    getFilter(secondKey) {
        switch (secondKey) {
            case 'b':
                return `filter: blur()`;
            case 'r':
                return `filter: brightness()`;
            case 'c':
                return `filter: contrast()`;
            case 'd':
                return `filter: drop-shadow()`;
            case 'g':
                return `filter: grayscale()`;
            case 'h':
                return `filter: hue-rotate()`;
            case 'i':
                return `filter: invert()`;
            case 'o':
                return `filter: opacity()`;
            case 's':
                return `filter: saturate()`;
            case 'e':
                return `filter: sepia()`;
            case 'u':
                return `filter: url()`;
            default:
                return `filter:`;
        }
    },
    getF(secondKey) {
        switch (secondKey) {
            case 'f':
                return `flex:`;
            case 'b':
                return 'flex-basis:';
            case 'd':
                return 'flex-direction:';
            case 'o':
                return 'flex-flow:';
            case 'g':
                return 'flex-grow:';
            case 'h':
                return 'flex-shrink:';
            case 'r':
                return 'flex-wrap:';
            case 'l':
                return 'float:';
            case 'a':
                return 'font-family:';
            case 'k':
                return 'font-kerning:';
            case 's':
                return 'font-size:';
            case 'j':
                return 'font-size-adjust:';
            case 't':
                return 'font-stretch:';
            case 'y':
                return 'font-style:';
            case 'v':
                return 'font-variant:';
            case 'w':
                return 'font-weight:';
            default:
                return 'font:';
        }
    },
    getG(secondKey) {
        switch (secondKey) {
            case 'a':
                return `grid-area:`;
            case 'u':
                return 'grid-auto-columns:';
            case 'f':
                return 'grid-auto-flow:';
            case 'w':
                return 'grid-auto-rows:';
            case 'l':
                return 'grid-column:';
            case 'n':
                return 'grid-column-';
            case 'g':
                return 'grid-gap:';
            case 'o':
                return 'grid-row:';
            case 'i':
                return 'grid-row-';
            case 't':
                return 'grid-template:';
            case 's':
                return 'grid-template-areas:';
            case 'c':
                return 'grid-template-columns:';
            case 'r':
                return 'grid-template-rows:';
            default:
                return 'grid:';
        }
    },
    getH(secondKey) {
        switch (secondKey) {
            case 'a':
                return `hanging-punctuation:`;
            case 'y':
                return 'hyphens:';
            default:
                return 'height:';
        }
    },
    getJ(secondKey, base) {
        switch (secondKey) {
            case 's':
                return `${base}-self:`;
            case 'i':
                return `${base}-items:`;
            default:
                return `${base}-content:`;
        }
    },
    getL(secondKey) {
        switch (secondKey) {
            case 'p':
                return `letter-spacing:`;
            case 'h':
                return `line-height:`;
            case 's':
                return `list-style:`;
            case 'i':
                return `list-style-image:`;
            case 'o':
                return `list-style-position:`;
            case 't':
                return `list-style-type:`;
            default:
                return `left:`;
        }
    },
    getM(secondKey) {
        switch (secondKey) {
            case 'b':
                return `margin-bottom:`;
            case 'l':
                return `margin-left:`;
            case 'r':
                return `margin-right:`;
            case 't':
                return `margin-top:`;
            case 'h':
                return `max-height:`;
            case 'w':
                return `max-width:`;
            case 'e':
                return `min-height:`;
            case 'i':
                return `min-width:`;
            case 'm':
                return `mix-blend-mode:`;
            default:
                return `margin:`;
        }
    },
    getO(secondKey) {
        switch (secondKey) {
            case 'f':
                return `object-fit:`;
            case 'p':
                return `object-position:`;
            case 'a':
                return `opacity:`;
            case 'r':
                return `order:`;
            case 'u':
                return `outline:`;
            case 'c':
                return `outline-color:`;
            case 'o':
                return `outline-offset:`;
            case 's':
                return `outline-style:`;
            case 'w':
                return `outline-width:`;
            case 'y':
                return `overflow-y:`;
            case 'x':
                return `overflow-x:`;
            case 'w':
                return `overflow-wrap:`;
            default:
                return `overflow:`;
        }
    },
    getP(secondKey) {
        switch (secondKey) {
            case 'b':
                return `padding-bottom:`;
            case 'l':
                return `padding-left:`;
            case 'r':
                return `padding-right:`;
            case 't':
                return `padding-top:`;
            case 'a':
                return `page-break-after:`;
            case 'b':
                return `page-break-before:`;
            case 's':
                return `page-break-inside:`;
            case 'r':
                return `perspective:`;
            case 'i':
                return `perspective-origin:`;
            case 'e':
                return `pointer-events:`;
            case 'o':
                return `position:`;
            default:
                return `padding:`;
        }
    },
    getR(secondKey) {
        switch (secondKey) {
            case 'e':
                return `resize:`;
            default:
                return `right:`;
        }
    },
    getT(secondKey) {
        switch (secondKey) {
            case 's':
                return `tab-size:`;
            case 'a':
                return `text-align:`;
            case 'd':
                return `text-decoration:`;
            case 'i':
                return `text-indent:`;
            case 'j':
                return `text-justify:`;
            case 'h':
                return `text-shadow:`;
            case 'o':
                return `text-overflow:`;
            case 'r':
                return `text-transform:`;
            case 't':
                return `transition:`;
            default:
                return `top:`;
        }
    },
    getTransform(secondKey, thirdKey) {
        switch (secondKey) {
            case 'm':
                return transformExtensions('transform', 'matrix', thirdKey, ['3']);
            case 't':
                return transformExtensions('transform', 'translate', thirdKey, ['3', 'x', 'y', 'z']);
            case 's':
                return transformExtensions('transform', 'scale', thirdKey, ['3', 'x', 'y', 'z']);
            case 'r':
                return transformExtensions('transform', 'rotate', thirdKey, ['3', 'x', 'y', 'z']);
            case 'k':
                return transformExtensions('transform', 'skew', thirdKey, ['x', 'y']);
            case 'p':
                return `transform: perspective`;
            default:
                return `transform:`;
        }
    },
    getU(secondKey) {
        switch (secondKey) {
            case 'u':
                return `unicode-bidi:`;
            default:
                return `user-select:`;
        }
    },
    getV(secondKey) {
        switch (secondKey) {
            case 'a':
                return `vertical-align:`;
            default:
                return 'visibility:';
        }
    },
    getW(secondKey) {
        switch (secondKey) {
            case 's':
                return `white-space:`;
            case 'b':
                return `word-break:`;
            case 'p':
                return `word-spacing:`;
            case 'w':
                return `word-wrap:`;
            case 'm':
                return `writing-mode:`;
            default:
                return 'width:';
        }
    }
};
function transformExtensions(base, funcName, thirdKey, allow) {
    if (allow !== undefined) {
        if (allow.indexOf(thirdKey) === -1) {
            return `${base}: ${funcName}()`;
        }
    }
    switch (thirdKey) {
        case '3':
            return `${base}: ${funcName}3d()`;
        case 'x':
            return `${base}: ${funcName}X()`;
        case 'y':
            return `${base}: ${funcName}Y()`;
        case 'z':
            return `${base}: ${funcName}Z()`;
        default:
            return `${base}: ${funcName}()`;
    }
}
function borderThirdKey(base, thirdKey) {
    switch (thirdKey) {
        case 't':
            return `${base}-top-left-radius:`;
        case 'r':
            return `${base}-top-right-radius:`;
        case 'f':
            return `${base}-bottom-left-radius:`;
        case 'g':
            return `${base}-bottom-right-radius:`;
        default:
            return `${base}-radius:`;
    }
}


/***/ }),

/***/ "./src/abbreviations/abbreviations.getSnippetText.ts":
/*!***********************************************************!*\
  !*** ./src/abbreviations/abbreviations.getSnippetText.ts ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const utility_regex_1 = __webpack_require__(/*! ../utility/utility.regex */ "./src/utility/utility.regex.ts");
const timingFunction = 'ease,linear,ease-in,ease-out,ease-in-out,step-start,step-end,steps(),cubic-bezier(),initial,inherit';
function generateSnippetText(text) {
    const arr = text.split('\n');
    const newArr = [];
    let pos = 0;
    for (let i = 0; i < arr.length; i++) {
        const item = arr[i];
        if (utility_regex_1.isClassOrId(item) || utility_regex_1.isInclude(item)) {
            newArr.push(item);
        }
        else {
            switch (item.trim()) {
                case 'animation:':
                    newArr.push(`${item} $\{${(pos++, pos)}:name} $\{${(pos++, pos)}:250ms} $\{${(pos++, pos)}|${timingFunction}|} $\{${(pos++,
                        pos)}:delay} $\{${(pos++, pos)}:iteration-count} $\{${(pos++, pos)}:direction} $\{${(pos++, pos)}:fill-mode} $\{${(pos++,
                        pos)}:play-state}`);
                    break;
                case 'all:':
                    newArr.push(`${item} $\{${(pos++, pos)}|initial,inherit,unset|}`);
                    break;
                case 'justify-self:':
                case 'align-self:':
                    newArr.push(`${item} $\{${(pos++, pos)}|auto,stretch,center,flex-start,flex-end,baseline|}`);
                    break;
                case 'align-content:':
                case 'justify-content:':
                    newArr.push(`${item} $\{${(pos++, pos)}|stretch,center,flex-start,flex-end,space-between,space-around|}`);
                    break;
                case 'justify-items:':
                case 'align-items:':
                    newArr.push(`${item} $\{${(pos++, pos)}|stretch,center,flex-start,flex-end,baseline|}`);
                    break;
                case 'border:':
                case 'border-left:':
                case 'border-right:':
                case 'border-top:':
                case 'border-bottom:':
                case 'outline-style:':
                    newArr.push(`${item} $\{${(pos++, pos)}:1px} $\{${(pos++, pos)}|solid,none,dotted,double,groove,ridge,inset,outset,hidden|} $\{${(pos++,
                        pos)}:red}`);
                    break;
                case 'box-shadow:':
                    newArr.push(`${item} $\{${(pos++, pos)}:h-offset} $\{${(pos++, pos)}:v-offset} $\{${(pos++, pos)}:blur} $\{${(pos++,
                        pos)}:spread} $\{${(pos++, pos)}:color}`);
                    break;
                case 'box-sizing:':
                    newArr.push(`${item} $\{${(pos++, pos)}|content-box,border-box,initial,inherit|}`);
                    break;
                case 'cursor:':
                    newArr.push(`${item} $\{${(pos++,
                        pos)}|pointer,none,default,auto,text,vertical-text,no-drop,alias,URL,all-scroll,cell,context-menu,col-resize,copy,crosshair,grab,grabbing,help,move,e-resize,ew-resize,n-resize,ne-resize,nesw-resize,ns-resize,nw-resize,nwse-resize,not-allowed,progress,row-resize,s-resize,se-resize,w-resize,wait,zoom-in,zoom-out,initial,inherit|}`);
                    break;
                case 'column-':
                    newArr.push(`${item}$\{${(pos++, pos)}|fill: ,gap: ,rule: ,rule-color: ,rule-style: ,rule-width: ,span: ,width: |}`);
                    break;
                case 'columns:':
                    newArr.push(`${item} $\{${(pos++, pos)}|auto,10px|} $\{${(pos++, pos)}:column-count}`);
                    break;
                case 'display:':
                    newArr.push(`${item} $\{${(pos++,
                        pos)}|flex,none,block,inline,inline-block,grid,inline-flex,inline-grid,inline-table,list-item,run-in,table,initial,inherit,contents,table-caption,table-column-group,table-header-group,table-footer-group,table-row-group,table-cell,table-column,table-row|}`);
                    break;
                case 'direction:':
                    newArr.push(`${item} $\{${(pos++, pos)}|ltr,rtl|}`);
                    break;
                case 'empty-cells:':
                    newArr.push(`${item} $\{${(pos++, pos)}|show,hide|}`);
                    break;
                case 'filter: blur()':
                    newArr.push(`${item.replace(')', '')} $\{${(pos++, pos)}:10px} )`);
                    break;
                case 'filter: brightness()':
                    newArr.push(`${item.replace(')', '')} $\{${(pos++, pos)}:120%} )`);
                    break;
                case 'filter: contrast()':
                    newArr.push(`${item.replace(')', '')} $\{${(pos++, pos)}:120%} )`);
                    break;
                case 'filter: drop-shadow()':
                    newArr.push(`${item.replace(')', '')} $\{${(pos++, pos)}:h-shadow} $\{${(pos++, pos)}:v-shadow} $\{${(pos++, pos)}:blur} $\{${(pos++,
                        pos)}:spread} $\{${(pos++, pos)}:color} )`);
                    break;
                case 'filter: grayscale()':
                    newArr.push(`${item.replace(')', '')} $\{${(pos++, pos)}:100%} )`);
                    break;
                case 'filter: hue-rotate()':
                    newArr.push(`${item.replace(')', '')} $\{${(pos++, pos)}:180deg} )`);
                    break;
                case 'filter: opacity()':
                    newArr.push(`${item.replace(')', '')} $\{${(pos++, pos)}:50%} )`);
                    break;
                case 'filter: saturate()':
                    newArr.push(`${item.replace(')', '')} $\{${(pos++, pos)}:120%} )`);
                    break;
                case 'filter: sepia()':
                    newArr.push(`${item.replace(')', '')} $\{${(pos++, pos)}:50%} )`);
                    break;
                case 'filter: url()':
                    newArr.push(`${item.replace(')', '')} $${(pos++, pos)} )`);
                    break;
                case 'flex:':
                    newArr.push(`${item} $\{${(pos++, pos)}:grow} $\{${(pos++, pos)}:shrink} $\{${(pos++, pos)}:basis}`);
                    break;
                case 'flex-direction:':
                    newArr.push(`${item} $\{${(pos++, pos)}|row,row-reverse,column,column-reverse|}`);
                    break;
                case 'flex-flow:':
                    newArr.push(`${item} $\{${(pos++, pos)}|row,row-reverse,column,column-reverse|} $\{${(pos++, pos)}|nowrap,wrap,wrap-reverse|}`);
                    break;
                case 'flex-wrap:':
                    newArr.push(`${item} $\{${(pos++, pos)}|nowrap,wrap,wrap-reverse|}`);
                    break;
                case 'float:':
                    newArr.push(`${item} $\{${(pos++, pos)}|none,left,right|}`);
                    break;
                case 'font:':
                    newArr.push(`${item} $\{${(pos++, pos)}:style} $\{${(pos++, pos)}:variant} $\{${(pos++, pos)}:weight} $\{${(pos++,
                        pos)}:size/height} $\{${(pos++, pos)}:family}`);
                    break;
                case 'font-kerning:':
                    newArr.push(`${item} $\{${(pos++, pos)}|auto,normal,none|}`);
                    break;
                case 'font-size:':
                    newArr.push(`${item} $\{${(pos++, pos)}|medium,xx-small,x-small,small,large,x-large,xx-large,smaller,larger|}`);
                    break;
                case 'font-stretch:':
                    newArr.push(`${item} $\{${(pos++,
                        pos)}|ultra-condensed,extra-condensed,condensed,semi-condensed,normal,semi-expanded,expanded,extra-expanded,ultra-expanded|}`);
                    break;
                case 'font-style:':
                    newArr.push(`${item} $\{${(pos++, pos)}|normal,italic,oblique|}`);
                    break;
                case 'font-variant:':
                    newArr.push(`${item} $\{${(pos++, pos)}|normal,small-caps|}`);
                    break;
                case 'font-weight:':
                    newArr.push(`${item} $\{${(pos++, pos)}|normal,bold,bolder,lighter,100,200,300,400,500,600,700,800,900|}`);
                    break;
                case 'grid:':
                    newArr.push(`${item} $\{${(pos++, pos)}:template-rows} $\{${(pos++, pos)}:template-columns} $\{${(pos++, pos)}:template-areas}`);
                    break;
                case 'grid-auto-rows:':
                case 'grid-auto-columns:':
                    newArr.push(`${item} $\{${(pos++, pos)}|auto,max-content,min-content|}`);
                    break;
                case 'grid-row-':
                case 'grid-column-':
                    newArr.push(`${item}$\{${(pos++, pos)}|end: ,gap: ,start: |}`);
                    break;
                case 'grid-auto-flow:':
                    newArr.push(`${item} $\{${(pos++, pos)}|row,column,dense,row dense,column|}`);
                    break;
                case 'hanging-punctuation:':
                    newArr.push(`${item} $\{${(pos++, pos)}|none,first,last,allow-end,force-end|}`);
                    break;
                case 'hyphens:':
                    newArr.push(`${item} $\{${(pos++, pos)}|none,manual,auto|}`);
                    break;
                case 'isolation:':
                    newArr.push(`${item} $\{${(pos++, pos)}|auto,isolate|}`);
                    break;
                case '@mixin':
                    newArr.push(`@mixin $\{${(pos++, pos)}:name} ($${(pos++, pos)})\n\t$${(pos++, pos)}`);
                    break;
                case 'list-style':
                    newArr.push(`${item} $\{${(pos++, pos)}:type} $\{${(pos++, pos)}:position} $\{${(pos++, pos)}:image}`);
                    break;
                case 'list-style-position:':
                    newArr.push(`${item} $\{${(pos++, pos)}|inside,outside|}`);
                    break;
                case 'mix-blend-mode:':
                    newArr.push(`${item} $\{${(pos++,
                        pos)}|normal,multiply,screen,overlay,darken,lighten,color-dodge,color-burn,difference,exclusion,hue,saturation,color,luminosity|}`);
                    break;
                case 'object-fit:':
                    newArr.push(`${item} $\{${(pos++, pos)}|fill,contain,cover,scale-down,none|}`);
                    break;
                case 'outline:':
                    newArr.push(`${item} $\{${(pos++, pos)}:none}`);
                    break;
                case 'outline-width:':
                    newArr.push(`${item} $\{${(pos++, pos)}|medium,thin,thick|}`);
                    break;
                case 'overflow:':
                case 'overflow-y:':
                case 'overflow-x:':
                    newArr.push(`${item} $\{${(pos++, pos)}|hidden,scroll,visible,auto|}`);
                    break;
                case 'overflow-wrap:':
                    newArr.push(`${item} $\{${(pos++, pos)}|normal,break-word|}`);
                    break;
                case 'page-break-after:':
                case 'page-break-before:':
                case 'page-break-inside:':
                    newArr.push(`${item} $\{${(pos++, pos)}|auto,always,avoid,left,right|}`);
                    break;
                case 'pointer-events:':
                    newArr.push(`${item} $\{${(pos++, pos)}|none,auto|}`);
                    break;
                case 'position:':
                    newArr.push(`${item} $\{${(pos++, pos)}|absolute,relative,fixed,sticky,static|}`);
                    break;
                case 'resize:':
                    newArr.push(`${item} $\{${(pos++, pos)}|none,both,horizontal,vertical|}`);
                    break;
                case 'scroll-behavior:':
                    newArr.push(`${item} $\{${(pos++, pos)}|auto,smooth|}`);
                    break;
                case 'text-align:':
                    newArr.push(`${item} $\{${(pos++, pos)}|left,right,center,justify|}`);
                    break;
                case 'text-decoration:':
                    newArr.push(`${item} $\{${(pos++, pos)}:line}  $\{${(pos++, pos)}:color} $\{${(pos++, pos)}:style}`);
                    break;
                case 'text-justify:':
                    newArr.push(`${item} $\{${(pos++, pos)}|auto,inter-word,inter-character,none|}`);
                    break;
                case 'text-overflow:':
                    newArr.push(`${item} $\{${(pos++, pos)}|clip,ellipsis|}`);
                    break;
                case 'text-overflow:':
                    newArr.push(`${item} $\{${(pos++, pos)}|capitalize,uppercase,lowercase,none|}`);
                    break;
                case 'transition:':
                    newArr.push(`${item} $\{${(pos++, pos)}:all} $\{${(pos++, pos)}:250ms} $\{${(pos++, pos)}|${timingFunction}|}`);
                    break;
                case 'transform: matrix()':
                case 'transform: matrix3d()':
                case 'transform: translate()':
                case 'transform: translate3d()':
                case 'transform: translateY()':
                case 'transform: translateX()':
                case 'transform: translateZ()':
                case 'transform: scale()':
                case 'transform: scale3d()':
                case 'transform: scaleY()':
                case 'transform: scaleX()':
                case 'transform: scaleZ()':
                case 'transform: rotate()':
                case 'transform: rotate3d()':
                case 'transform: rotateY()':
                case 'transform: rotateX()':
                case 'transform: rotateZ()':
                case 'transform: skew()':
                case 'transform: skewX()':
                case 'transform: skewY()':
                    newArr.push(`${item.replace(')', '')} $${(pos++, pos)} )`);
                    break;
                case 'unicode-bidi:':
                    newArr.push(`${item} $\{${(pos++, pos)}|normal,embed,bidi-override|}`);
                    break;
                case 'user-select:':
                    newArr.push(`${item} $\{${(pos++, pos)}|none,auto,text,all|}`);
                    break;
                case 'vertical-align:':
                    newArr.push(`${item} $\{${(pos++, pos)}|baseline,sub,super,top,text-top,middle,bottom,text-bottom|}`);
                    break;
                case 'visibility:':
                    newArr.push(`${item} $\{${(pos++, pos)}|visible,hidden,collapse|}`);
                    break;
                case 'white-space:':
                    newArr.push(`${item} $\{${(pos++, pos)}|normal,nowrap,pre,pre-line,pre-wrap|}`);
                    break;
                case 'word-break:':
                    newArr.push(`${item} $\{${(pos++, pos)}|normal,break-all,keep-all,break-word|}`);
                    break;
                case 'word-wrap:':
                    newArr.push(`${item} $\{${(pos++, pos)}|normal,break-word|}`);
                    break;
                case 'writing-mode:':
                    newArr.push(`${item} $\{${(pos++, pos)}|horizontal-tb,vertical-rl,vertical-lr|}`);
                    break;
                case 'top: 0':
                case 'bottom: 0':
                case 'left: 0':
                case 'right: 0':
                    newArr.push(item);
                    break;
                default:
                    newArr.push(`${item} $${(pos++, pos)}`);
                    break;
            }
        }
    }
    return newArr.join('\n').concat('\n');
}
exports.generateSnippetText = generateSnippetText;


/***/ }),

/***/ "./src/abbreviations/abbreviations.info.ts":
/*!*************************************************!*\
  !*** ./src/abbreviations/abbreviations.info.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function getCharInfo(char, space) {
    if (char === undefined || char === '') {
        return { text: defaultText(space), lines: 3 };
    }
    switch (char) {
        case 'a':
            return { text: `${space}// l = all, c = align-content, s = align-self, i = align-items`, lines: 1 };
        case 'b':
            return {
                text: `${space}// g = background, u = bottom, s = box-shadow, z = box-sizing
${space}// ${directionSuggestions('border')}
${space}// d = box-decoration-break, a = border-radius, f = backface-visibility
${space}// Border Radius Directions, r = top-right, t = top-left, f = bottom-left, g = bottom-right`,
                lines: 4
            };
        case 'c':
            return {
                text: `${space}// l = clip, o = column-, s = columns, t = content, c = cursor 
${space}// i = counter-increment, r = counter-reset)`,
                lines: 2
            };
        case 'd':
            return { text: `${space}// r = direction`, lines: 1 };
        case 'F':
            return {
                text: `${space}// b = blur, r = brightness, c = contrast, d = drop-shadow, g = grayscale
${space}// h = hue-rotate, i = invert, o = opacity, s = saturate, e = sepia, u = url`,
                lines: 2
            };
        case 'f':
            return {
                text: `${space}// f = flex, b = flex-basis, d = flex-direction, o = flex-flow, g = flex-grow
${space}// h = flex-shrink, r = flex-wrap, l = float, a = font-family, k = font-kerning, s = font-size
${space}// j = font-size-adjust, t = font-stretch, y = font-style, v = font-variant, w = font-weight`,
                lines: 3
            };
        case 'g':
            return {
                text: `${space}// grid-**
${space}// a = area, u = auto-columns, f = auto-flow, w = auto-rows, l = column, n = column-, g = gap
${space}// o = row, i = row-, t = template, s = template-areas, c = template-columns, r = template-rows`,
                lines: 3
            };
        case 'h':
            return { text: `${space}// a = hanging-punctuation, y = hyphens`, lines: 1 };
        case 'j':
            return { text: `${space}// s = justify-self, i = justify-items`, lines: 1 };
        case 'l':
            return {
                text: `${space}// p = letter-spacing, h = line-height, s = list-style, i = list-style-image 
${space}// o = list-style-position, t list-style-type`,
                lines: 2
            };
        case 'm':
            return {
                text: `${space}// h = max-height, w = max-width, e = min-height, i = min-width, m = mix-blend-mode
// ${directionSuggestions('margin')}`,
                lines: 2
            };
        case 'o':
            return {
                text: `${space}// f = object-fit, p = object-position, a = opacity, r = order, u = outline
${space}// c = outline-color, o = outline-offset, s = outline-style, w = outline-width
${space}// y = overflow-y, x = overflow-x, w = overflow-wrap`,
                lines: 3
            };
        case 'p':
            return {
                text: `${space}// o = position, e = pointer-events, r = perspective, i = perspective-origin
${space}// a = page-break-after, b = page-break-before, s = page-break-inside
${space}// ${directionSuggestions('padding')})`,
                lines: 3
            };
        case 'r':
            return { text: `${space}// e = resize`, lines: 1 };
        case 't':
            return {
                text: `${space}// s = tab-size, a = text-align, d = text-decoration, i = text-indent
${space}// j = text-justify, h = text-shadow, r = text-transform, t = transition, o = text-overflow`,
                lines: 2
            };
        case 'T':
            return {
                text: `${space}// m = matrix, t = transform, s = scale, r = rotate, k = skew, p = perspective
${space}// (3 = 3d, x = X, y = Y, z = Z)`,
                lines: 2
            };
        case 'r':
            return { text: `${space}// u = unicode-bidi`, lines: 1 };
        case 'v':
            return { text: `${space}// a = vertical-align`, lines: 1 };
        case 'w':
            return { text: `${space}// s = white-space, b = word-break, p = word-spacing, w = word-wrap, m = writing-mode`, lines: 1 };
        default:
            return { text: defaultText(space), lines: 3 };
    }
}
exports.getCharInfo = getCharInfo;
function directionSuggestions(base) {
    return `l = ${base}-left, t = ${base}-top, r = ${base}-right, b = ${base}-bottom`;
}
const defaultText = (space) => `${space}// .** = class, #** = id, I** = @include, R = resets the indentation
${space}// M = @mixin, F = filter, T = Transform, ! = gets the classes and is from a html file with the same name in the same directory.
${space}// [a-z] = properties`;


/***/ }),

/***/ "./src/abbreviations/abbreviations.ts":
/*!********************************************!*\
  !*** ./src/abbreviations/abbreviations.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const vscode_1 = __webpack_require__(/*! vscode */ "vscode");
const utility_1 = __webpack_require__(/*! ../utility/utility */ "./src/utility/utility.ts");
const abbreviations_getSnippetText_1 = __webpack_require__(/*! ./abbreviations.getSnippetText */ "./src/abbreviations/abbreviations.getSnippetText.ts");
const abbreviations_info_1 = __webpack_require__(/*! ./abbreviations.info */ "./src/abbreviations/abbreviations.info.ts");
const abbreviations_charCompletion_1 = __webpack_require__(/*! ./abbreviations.charCompletion */ "./src/abbreviations/abbreviations.charCompletion.ts");
const abbreviations_utility_1 = __webpack_require__(/*! ./abbreviations.utility */ "./src/abbreviations/abbreviations.utility.ts");
// is active avoids that Abbreviations gets called twice in a row.
let isActive = false;
function Abbreviations(document, start, currentWord) {
    if (isActive === false) {
        const inputBox = vscode_1.window.createInputBox();
        const tabSize = vscode_1.window.activeTextEditor.options.tabSize || 4;
        inputBox.title = 'SASS Abbreviations';
        inputBox.placeholder = 'Abbreviations';
        inputBox.show();
        console.log('SASS Abbreviations', isActive);
        isActive = true;
        const initialEmptySpace = abbreviations_utility_1.AbbreviationsUtility.getTabs(utility_1.getDistance(currentWord));
        const defaultCharInfo = abbreviations_info_1.getCharInfo('', initialEmptySpace);
        let previousText = defaultCharInfo.text.concat('\n');
        let commandsText = '';
        let endLine = start.line + defaultCharInfo.lines;
        // Init
        const InitialEdit = new vscode_1.WorkspaceEdit();
        InitialEdit.replace(document.uri, new vscode_1.Range(start, new vscode_1.Position(start.line, initialEmptySpace.length + 1)), previousText);
        vscode_1.workspace.applyEdit(InitialEdit);
        //
        inputBox.onDidChangeValue(valueChange);
        function valueChange(value) {
            let commands = value.split(',');
            const charInfo = abbreviations_info_1.getCharInfo(commands[commands.length - 1][0], initialEmptySpace);
            let tabs = initialEmptySpace;
            if (commands[0][0] === '!') {
                inputBox.dispose();
                abbreviations_utility_1.AbbreviationsUtility.htmlCommand(document, start, endLine, previousText, tabSize);
            }
            else if (commands[0][0] === '"') {
                inputBox.dispose();
                setTimeout(() => {
                    abbreviations_utility_1.AbbreviationsUtility.htmlCommand(document, start, endLine, previousText, tabSize);
                }, 0);
                abbreviations_utility_1.AbbreviationsUtility.angularInit(document);
            }
            else {
                for (let i = 0; i < commands.length; i++) {
                    let command = commands[i];
                    // Get KEYS
                    let key = command[0];
                    let secondKey = command[1];
                    let thirdKey = command[2];
                    if (command.startsWith(' ')) {
                        key = command[1];
                        secondKey = command[2];
                    }
                    //-----------------------------
                    let addTab = false;
                    let resetTab = false;
                    switch (key) {
                        // SECTION Special.
                        case 'M':
                            addTab = true;
                            command = command.replace(/^ ?M{1}/, '@mixin');
                            break;
                        case '#':
                            addTab = true;
                            break;
                        case '.':
                            addTab = true;
                            break;
                        case '*':
                            addTab = true;
                            break;
                        case 'I':
                            command = command.replace(/^ ?I{1}/, '');
                            command = '@include'.concat(command);
                            break;
                        case 'D':
                            inputBox.value = inputBox.value.replace(/ ?D{1}$/, '').concat('t 0,bu 0,r 0,l 0');
                            setTimeout(() => valueChange(inputBox.value), 10);
                            break;
                        case 'R':
                            resetTab = true;
                            command = command.replace(/^ ?R{1}$/, '');
                            break;
                        // - !SECTION
                        // SECTION properties
                        case 'a':
                            command = command.replace(abbreviations_utility_1.AbbreviationsUtility.propRegex('a', 'lcsi'), abbreviations_charCompletion_1.charCompletion.getA(secondKey));
                            break;
                        case 'b':
                            command = command.replace(abbreviations_utility_1.AbbreviationsUtility.propRegex('b', 'lrtbgvdbszua', 'trfg'), abbreviations_charCompletion_1.charCompletion.getB(secondKey, thirdKey, 'border'));
                            break;
                        case 'c':
                            command = command.replace(abbreviations_utility_1.AbbreviationsUtility.propRegex('c', 'lostirc'), abbreviations_charCompletion_1.charCompletion.getC(secondKey));
                            break;
                        case 'd':
                            command = command.replace(abbreviations_utility_1.AbbreviationsUtility.propRegex('d', 'r'), abbreviations_charCompletion_1.charCompletion.getD(secondKey));
                            break;
                        case 'e':
                            command = command.replace(abbreviations_utility_1.AbbreviationsUtility.propRegex('e'), 'empty-cells:');
                            break;
                        case 'f':
                            command = command.replace(abbreviations_utility_1.AbbreviationsUtility.propRegex('f', 'fbdoghrlaksjtyvw'), abbreviations_charCompletion_1.charCompletion.getF(secondKey));
                            break;
                        case 'F':
                            command = command.replace(abbreviations_utility_1.AbbreviationsUtility.propRegex('F', 'brcdghioseu'), abbreviations_charCompletion_1.charCompletion.getFilter(secondKey));
                            break;
                        case 'g':
                            command = command.replace(abbreviations_utility_1.AbbreviationsUtility.propRegex('g', 'aufwlngoitscr'), abbreviations_charCompletion_1.charCompletion.getG(secondKey));
                            break;
                        case 'h':
                            command = command.replace(abbreviations_utility_1.AbbreviationsUtility.propRegex('h', 'ay'), abbreviations_charCompletion_1.charCompletion.getH(secondKey));
                            break;
                        case 'i':
                            command = command.replace(abbreviations_utility_1.AbbreviationsUtility.propRegex('i'), 'isolation:');
                            break;
                        case 'j':
                            command = command.replace(abbreviations_utility_1.AbbreviationsUtility.propRegex('j', 'si'), abbreviations_charCompletion_1.charCompletion.getJ(secondKey, 'justify'));
                            break;
                        case 'l':
                            command = command.replace(abbreviations_utility_1.AbbreviationsUtility.propRegex('l', 'phsiot'), abbreviations_charCompletion_1.charCompletion.getL(secondKey));
                            break;
                        case 'm':
                            command = command.replace(abbreviations_utility_1.AbbreviationsUtility.propRegex('m', 'blrthweim'), abbreviations_charCompletion_1.charCompletion.getM(secondKey));
                            break;
                        case 'o':
                            command = command.replace(abbreviations_utility_1.AbbreviationsUtility.propRegex('o', 'fparucoswyxw'), abbreviations_charCompletion_1.charCompletion.getO(secondKey));
                            break;
                        case 'p':
                            command = command.replace(abbreviations_utility_1.AbbreviationsUtility.propRegex('p', 'blrtabsrieo'), abbreviations_charCompletion_1.charCompletion.getP(secondKey));
                            break;
                        case 'q':
                            command = command.replace(abbreviations_utility_1.AbbreviationsUtility.propRegex('q'), 'quotes:');
                            break;
                        case 'r':
                            command = command.replace(abbreviations_utility_1.AbbreviationsUtility.propRegex('r', 'e'), abbreviations_charCompletion_1.charCompletion.getR(secondKey));
                            break;
                        case 's':
                            command = command.replace(abbreviations_utility_1.AbbreviationsUtility.propRegex('s'), 'scroll-behavior:');
                            break;
                        case 't':
                            command = command.replace(abbreviations_utility_1.AbbreviationsUtility.propRegex('t', 'sadijhrto'), abbreviations_charCompletion_1.charCompletion.getT(secondKey));
                            break;
                        case 'T':
                            command = command.replace(abbreviations_utility_1.AbbreviationsUtility.propRegex('T', 'mtsrkp', '3xyz'), abbreviations_charCompletion_1.charCompletion.getTransform(secondKey, thirdKey));
                            break;
                        case 'u':
                            command = command.replace(abbreviations_utility_1.AbbreviationsUtility.propRegex('u', 'u'), abbreviations_charCompletion_1.charCompletion.getU(secondKey));
                            break;
                        case 'v':
                            command = command.replace(abbreviations_utility_1.AbbreviationsUtility.propRegex('v', 'a'), abbreviations_charCompletion_1.charCompletion.getV(secondKey));
                            break;
                        case 'w':
                            command = command.replace(abbreviations_utility_1.AbbreviationsUtility.propRegex('w', 'sbpwm'), abbreviations_charCompletion_1.charCompletion.getW(secondKey));
                            break;
                        case 'z':
                            command = command.replace(abbreviations_utility_1.AbbreviationsUtility.propRegex('z'), 'z-index:');
                            break;
                        // - !SECTION
                    }
                    command = tabs.concat(command);
                    commands[i] = command;
                    if (resetTab) {
                        tabs = '';
                    }
                    if (addTab) {
                        tabs = tabs.concat('\t');
                    }
                }
                const insertText = charInfo.text.concat('\n', commands.join('\n'));
                const edit = new vscode_1.WorkspaceEdit();
                edit.replace(document.uri, new vscode_1.Range(start, new vscode_1.Position(endLine, previousText.length)), insertText);
                vscode_1.workspace.applyEdit(edit);
                endLine = start.line + commands.length - 1 + charInfo.lines;
                previousText = insertText;
                commandsText = commands.join('\n');
            }
        }
        inputBox.onDidAccept(() => {
            inputBox.dispose();
            isActive = false;
            commandsText = abbreviations_getSnippetText_1.generateSnippetText(commandsText);
            const edit = new vscode_1.WorkspaceEdit();
            edit.replace(document.uri, new vscode_1.Range(start, new vscode_1.Position(endLine, commandsText.length)), '');
            vscode_1.workspace.applyEdit(edit).then(() => {
                vscode_1.window.activeTextEditor.insertSnippet(new vscode_1.SnippetString(commandsText), start);
            });
        });
        inputBox.onDidHide(() => {
            inputBox.dispose();
            isActive = false;
            const edit = new vscode_1.WorkspaceEdit();
            edit.replace(document.uri, new vscode_1.Range(start, new vscode_1.Position(endLine, previousText.length)), '');
            vscode_1.workspace.applyEdit(edit);
        });
    }
}
exports.Abbreviations = Abbreviations;


/***/ }),

/***/ "./src/abbreviations/abbreviations.utility.ts":
/*!****************************************************!*\
  !*** ./src/abbreviations/abbreviations.utility.ts ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const vscode_1 = __webpack_require__(/*! vscode */ "vscode");
const path_1 = __webpack_require__(/*! path */ "path");
const fs_1 = __webpack_require__(/*! fs */ "fs");
const utility_regex_1 = __webpack_require__(/*! ../utility/utility.regex */ "./src/utility/utility.regex.ts");
class AbbreviationsUtility {
    static getTabs(chars) {
        let tabs = '';
        for (let i = 0; i < chars; i++) {
            tabs = tabs.concat(' ');
        }
        return tabs;
    }
    static propRegex(firstLetter, secondary, tertiary) {
        let additional = '';
        if (secondary !== undefined) {
            additional = additional.concat(`[${secondary}]?`);
        }
        if (tertiary !== undefined) {
            additional = additional.concat(`[${tertiary}]?`);
        }
        return new RegExp(`^ ?${firstLetter}{1}${additional}`);
    }
    static htmlCommand(document, start, endLine, previousText, tabSize) {
        const edit = new vscode_1.WorkspaceEdit();
        edit.replace(document.uri, new vscode_1.Range(start, new vscode_1.Position(endLine, previousText.length)), '');
        vscode_1.workspace
            .applyEdit(edit)
            .then(() => vscode_1.window.activeTextEditor.insertSnippet(new vscode_1.SnippetString(AbbreviationsUtility._CREATE_HTML_SNIPPET_TEXT(AbbreviationsUtility._GET_HTML_STRUCTURE(document), tabSize)), start));
    }
    static angularInit(document) {
        for (let i = 0; i < vscode_1.workspace.workspaceFolders.length; i++) {
            const path = vscode_1.workspace.workspaceFolders[i];
            if (fs_1.existsSync(path_1.join(path.uri.fsPath, '/src/styles.sass'))) {
                const importPath = path_1.relative(path_1.join(document.uri.fsPath, '../'), path_1.join(path.uri.fsPath, 'src/styles.sass'));
                const rep = importPath.replace(/\\/g, '/');
                setTimeout(() => {
                    if (document.lineAt(0).text !== `@import ${importPath.startsWith('.') ? rep : './'.concat(rep)}`) {
                        const edit = new vscode_1.WorkspaceEdit();
                        edit.insert(document.uri, new vscode_1.Position(0, 0), `@import ${importPath.startsWith('.') ? rep : './'.concat(rep)}\n`);
                        vscode_1.workspace.applyEdit(edit);
                    }
                }, 50);
            }
        }
    }
    static getDocumentClassesAndIds(document) {
        const classesAndIds = [];
        for (let i = 0; i < document.lineCount; i++) {
            const line = document.lineAt(i);
            if (utility_regex_1.isClassOrId(line.text)) {
                classesAndIds.push(line.text.trim());
            }
        }
        return classesAndIds;
    }
    static _GET_HTML_STRUCTURE(document) {
        const path = path_1.normalize(path_1.join(document.fileName, '../', './'));
        const dir = fs_1.readdirSync(path);
        const classesAndIds = this.getDocumentClassesAndIds(document);
        let tagArr = [];
        let previousResLength = 0;
        const res = [];
        for (const file of dir) {
            if (new RegExp(`${path_1.basename(document.fileName).replace('.sass', '.html')}`).test(file)) {
                const text = fs_1.readFileSync(path_1.normalize(document.fileName).replace('.sass', '.html')).toString();
                const textLines = text.split('\n');
                let indentation = 0;
                for (let index = 0; index < textLines.length; index++) {
                    const line = textLines[index];
                    const tagParts = line.split('<');
                    for (let i = 0; i < tagParts.length; i++) {
                        const tagPart = tagParts[i];
                        const tagPartName = tagPart.split(' ')[0].replace('>', '');
                        const regex = /class="([\w ]*)"|id="(\w*)"/g;
                        if (tagPart.trim() !== '' && !tagPart.startsWith('/')) {
                            let m;
                            while ((m = regex.exec(tagPart)) !== null) {
                                if (m.index === regex.lastIndex) {
                                    regex.lastIndex++;
                                }
                                m.forEach((match, groupIndex) => {
                                    if (groupIndex !== 0 && match !== undefined) {
                                        if (groupIndex === 1) {
                                            const classes = match.split(' ');
                                            classes.forEach(className => {
                                                if (classesAndIds.find(value => value === '.'.concat(className)) === undefined) {
                                                    res.push({ name: '.'.concat(className), indentation: indentation });
                                                }
                                            });
                                        }
                                        else {
                                            if (classesAndIds.find(value => value === '#'.concat(match)) === undefined) {
                                                res.push({ name: '#'.concat(match), indentation: indentation });
                                            }
                                        }
                                    }
                                });
                            }
                            tagArr.unshift(previousResLength !== res.length ?  true && !utility_regex_1.isVoidHtmlTag(tagPartName) : false);
                            previousResLength = res.length;
                            if (tagArr[0] === true) {
                                indentation++;
                            }
                        }
                        else if (tagPart.startsWith('/')) {
                            const currentTagPart = tagArr.shift();
                            if (currentTagPart === true) {
                                indentation--;
                            }
                        }
                    }
                }
            }
        }
        return res;
    }
    static _CREATE_HTML_SNIPPET_TEXT(tags, tabSize) {
        let text = '';
        let pos = 0;
        for (let i = 0; i < tags.length; i++) {
            const tag = tags[i];
            text = text.concat(this.replaceWithOffset(tag.name, tag.indentation * tabSize), '\n', `${this.replaceWithOffset('', (tag.indentation + 1) * tabSize)}$${(pos++, pos)}`, '\n');
        }
        return text;
    }
    /**
     * adds or removes whitespace based on the given offset, a positive value adds whitespace a negative value removes it.
     */
    static replaceWithOffset(text, offset) {
        if (offset < 0) {
            text = text.replace(new RegExp(`^ {${Math.abs(offset)}}`), '');
        }
        else {
            let space = '';
            for (let i = 0; i < offset; i++) {
                space = space.concat(' ');
            }
            text = text.replace(/^/, space);
        }
        return text;
    }
}
exports.AbbreviationsUtility = AbbreviationsUtility;


/***/ }),

/***/ "./src/extension.ts":
/*!**************************!*\
  !*** ./src/extension.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tree_provider_1 = __webpack_require__(/*! ./tree/tree.provider */ "./src/tree/tree.provider.ts");
const tree_utility_1 = __webpack_require__(/*! ./tree/tree.utility */ "./src/tree/tree.utility.ts");
const abbreviations_1 = __webpack_require__(/*! ./abbreviations/abbreviations */ "./src/abbreviations/abbreviations.ts");
const vscode_1 = __webpack_require__(/*! vscode */ "vscode");
const preview_1 = __webpack_require__(/*! ./preview/preview */ "./src/preview/preview.ts");
function activate(context) {
    const abbreviations = vscode_1.commands.registerCommand('sass.abbreviations', () => {
        if (vscode_1.window && vscode_1.window.activeTextEditor) {
            const start = new vscode_1.Position(vscode_1.window.activeTextEditor.selection.start.line, 0);
            const currentWord = vscode_1.window.activeTextEditor.document.getText(new vscode_1.Range(start, vscode_1.window.activeTextEditor.selection.active));
            abbreviations_1.Abbreviations(vscode_1.window.activeTextEditor.document, start, currentWord);
        }
    });
    let preview_server = null;
    const preview = vscode_1.commands.registerCommand('sass.preview', () => {
        console.log('PREVIEW');
        preview_server = new preview_1.PreviewServer();
    });
    // Tree SECTION
    let TreeDisposables = [];
    const TreeProvider = new tree_provider_1.TreeSnippetProvider(context);
    tree_provider_1.SnippetProviderUtility.setProvider(TreeProvider);
    TreeDisposables[0] = vscode_1.window.registerTreeDataProvider('snippets', TreeProvider);
    TreeDisposables[1] = vscode_1.commands.registerCommand('sass.tree.refreshEntry', () => {
        TreeProvider.refresh(true);
    });
    TreeDisposables[2] = vscode_1.commands.registerCommand('sass.tree.addFromSelection', item => {
        tree_utility_1.TreeUtility.addFromSelection(item);
    });
    TreeDisposables[3] = vscode_1.commands.registerCommand('sass.tree.delete', item => {
        tree_utility_1.TreeUtility.delete(item);
    });
    TreeDisposables[4] = vscode_1.commands.registerCommand('sass.tree.edit', item => {
        tree_utility_1.TreeUtility.edit(item);
    });
    TreeDisposables[5] = vscode_1.commands.registerCommand('sass.tree.moveUp', item => {
        tree_utility_1.TreeUtility.move(item, 'up');
    });
    TreeDisposables[6] = vscode_1.commands.registerCommand('sass.tree.moveDown', item => {
        tree_utility_1.TreeUtility.move(item, 'down');
    });
    TreeDisposables[7] = vscode_1.commands.registerCommand('sass.tree.copy', item => {
        tree_utility_1.TreeUtility.copy(item);
    });
    TreeDisposables[8] = vscode_1.commands.registerCommand('sass.tree.paste', item => {
        tree_utility_1.TreeUtility.paste(item);
        // TreeUtility.pasteFromClipboard();
    });
    TreeDisposables[9] = vscode_1.commands.registerCommand('sass.tree.addFolder', item => {
        tree_utility_1.TreeUtility.addFolder(item);
    });
    TreeDisposables[10] = vscode_1.commands.registerCommand('sass.tree.insert', item => {
        tree_utility_1.TreeUtility.insert(item);
    });
    TreeDisposables[11] = vscode_1.commands.registerCommand('sass.tree.insertFolder', item => {
        tree_utility_1.TreeUtility.insertFolder(item);
    });
    TreeDisposables[12] = vscode_1.commands.registerCommand('sass.tree.openFile', item => {
        tree_utility_1.TreeUtility.openFile(item);
    });
    TreeDisposables[13] = vscode_1.commands.registerCommand('sass.tree.cut', item => {
        tree_utility_1.TreeUtility.cut(item);
    });
    TreeDisposables[14] = vscode_1.commands.registerCommand('sass.tree.recalculatePosition', item => {
        tree_utility_1.TreeUtility.recalculatePosition(item);
    });
    TreeDisposables[15] = vscode_1.commands.registerCommand('sass.tree.addFromFile', item => {
        tree_utility_1.TreeUtility.addFromFile(item, 'both');
    });
    TreeDisposables[16] = vscode_1.commands.registerCommand('sass.tree.addFromFileMixins', item => {
        tree_utility_1.TreeUtility.addFromFile(item, 'mixin');
    });
    TreeDisposables[17] = vscode_1.commands.registerCommand('sass.tree.addFromFileVariables', item => {
        tree_utility_1.TreeUtility.addFromFile(item, 'var');
    });
    // - !SECTION
    context.subscriptions.push(...TreeDisposables);
    context.subscriptions.push(abbreviations);
    context.subscriptions.push(preview);
}
exports.activate = activate;
function deactivate() { }
exports.deactivate = deactivate;


/***/ }),

/***/ "./src/preview/preview.ts":
/*!********************************!*\
  !*** ./src/preview/preview.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const express = __webpack_require__(/*! express */ "./node_modules/express/index.js");
const WebSocket = __webpack_require__(/*! ws */ "./node_modules/ws/index.js");
const chokidar = __webpack_require__(/*! chokidar */ "./node_modules/chokidar/index.js");
const chalk_1 = __webpack_require__(/*! chalk */ "./node_modules/chalk/index.js");
const fs_1 = __webpack_require__(/*! fs */ "fs");
// import { renderSync } from 'node-sass';
// import sass = require('node-sass');
const sass_1 = __webpack_require__(/*! sass */ "./node_modules/sass/sass.dart.js");
const utility_regex_1 = __webpack_require__(/*! ../utility/utility.regex */ "./src/utility/utility.regex.ts");
const path_1 = __webpack_require__(/*! path */ "path");
const vscode_1 = __webpack_require__(/*! vscode */ "vscode");
class PreviewServerMessage {
    constructor(payload, type = 'message') {
        this.payload = payload;
        this.type = type;
    }
}
class PreviewData {
    constructor(css, sass, selector) {
        this.css = css;
        this.sass = sass;
        this.selector = selector;
    }
}
class PreviewServer {
    constructor(path = 'C:\\Users\\Syler\\Google Drive\\Code Stuff\\tests\\test.sass', selector = 'class', app = express(), port = 3000, socketServer = new WebSocket.Server({
        port: port + 10
    })) {
        this.path = path;
        this.selector = selector;
        this.app = app;
        this.port = port;
        this.socketServer = socketServer;
        this._FILE = {
            text: undefined,
            changedContent: {
                variables: undefined,
                class: undefined
            }
        };
        console.log('DIR', path_1.resolve(vscode_1.extensions.getExtension('syler.sass-next').extensionPath, './dist/public/index.html'));
        // extensions.getExtension('syler.sass-next')
        // serve static
        // app.use(express.static('src/preview/public'));
        app.get('/', (req, res) => {
            res.sendFile(path_1.resolve(vscode_1.extensions.getExtension('syler.sass-next').extensionPath, './dist/public/index.html'));
        });
        app.get('/index.css', (req, res) => {
            res.sendFile(path_1.resolve(vscode_1.extensions.getExtension('syler.sass-next').extensionPath, './dist/public/index.css'));
        });
        app.get('/index.js', (req, res) => {
            res.sendFile(path_1.resolve(vscode_1.extensions.getExtension('syler.sass-next').extensionPath, './dist/public/index.js'));
        });
        app.get('/favicon.png', (req, res) => {
            res.sendFile(path_1.resolve(vscode_1.extensions.getExtension('syler.sass-next').extensionPath, './dist/public/favicon.png'));
        });
        app.use(express.json());
        app.post('/compileSass', (req, res) => {
            const data = this.compile(req.body.sass, false);
            if (data.css !== undefined) {
                res.send({ css: data.css, msg: '[compileSass]: successfully compiled' });
            }
            else if (data.err !== undefined) {
                res.status(400).send({ css: undefined, msg: '[compileSass]:'.concat(data.err) });
            }
            else {
                res.status(500).send({ css: undefined, msg: '[compileSass]: Unknown Error' });
            }
        });
        app.post('/writeToFile', (req, res) => {
            if (this._FILE.text && req.body) {
                fs_1.writeFileSync(path, this.insertIntoFile(req.body.sass));
                this.broadcast(new PreviewServerMessage(`Writing to: ${path} at: ${new Date().toLocaleString()}`));
                res.send({ css: undefined, msg: '[writeToFile]: Success ' });
            }
            else {
                res.status(500).send({ css: undefined, msg: '[writeToFile]: Unknown Error' });
            }
        });
        app.get('/setPreview', (req, res) => {
            const file = this.filterRawFile(fs_1.readFileSync(path).toString());
            this.broadcast(new PreviewServerMessage(`Loading: ${path} at: ${new Date().toLocaleString()}`));
            this.compile(file);
            res.send({ msg: '[setPreview]: success' });
        });
        app.listen(port, () => {
            console.log(chalk_1.default.yellow('[Express]'), 'Listening... ', port, new Date().toLocaleString());
        });
        socketServer.on('connection', ws => {
            console.log(chalk_1.default.magenta('[Websocket]'), 'Connected');
        });
        chokidar.watch(path).on('all', (event, _path) => {
            console.log(chalk_1.default.blueBright.bold('[chokidar]'), event, _path);
            this.broadcast(new PreviewServerMessage(`${event}: ${_path} at: ${new Date().toLocaleString()}`));
            const file = this.filterRawFile(fs_1.readFileSync(_path).toString());
            this.compile(file);
        });
    }
    broadcast(data) {
        this.socketServer.clients.forEach(ws => {
            ws.send(JSON.stringify(data));
        });
    }
    compile(data, broadcastSuccess = true) {
        try {
            const result = sass_1.renderSync({
                data: data,
                indentedSyntax: true
            });
            const css = result.css.toString();
            if (css) {
                if (broadcastSuccess) {
                    this.broadcast(new PreviewServerMessage(new PreviewData(css, data, this.selector), 'setPreview'));
                }
                return { css, err: undefined };
            }
        }
        catch (err) {
            this.broadcast(new PreviewServerMessage(`ERROR ${err}`));
            return { css: undefined, err };
        }
        return { css: undefined, err: undefined };
    }
    filterRawFile(file) {
        const lines = file.split('\n');
        let variables = '';
        let content = '._sass_preview_class\n';
        let add = false;
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            if (utility_regex_1.isVar(line)) {
                variables = variables.concat(line, '\n');
            }
            else if (new RegExp('^ *'.concat(`\\.${this.selector}`)).test(line)) {
                add = true;
            }
            else if (add) {
                if (!utility_regex_1.isClassOrId(line) && !utility_regex_1.isMixin(line)) {
                    content = content.concat(line, '\n');
                }
                else {
                    add = false;
                }
            }
        }
        this._FILE.text = file;
        this._FILE.changedContent.variables = variables;
        this._FILE.changedContent.class = content.replace('_sass_preview_class', this.selector);
        return variables.concat(content);
    }
    /**
     * adds the changed content to the file and returns it.
     */
    insertIntoFile(content) {
        const varKeys = this._FILE.changedContent.variables.replace(/( *\$.*:).*/gm, '$1').split(/\r?\n/);
        const split = content.split('._sass_preview_class');
        const variables = split[0].split(/\r?\n/);
        const classContent = split[1];
        let newFile = '';
        const lines = this._FILE.text.split(/\r?\n/);
        let add = true;
        let skip = false;
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            skip = false;
            if (utility_regex_1.isVar(line)) {
                for (let j = 0; j < varKeys.length; j++) {
                    const key = varKeys[j];
                    const reg = new RegExp(utility_regex_1.escapeRegExp(key));
                    if (key && reg.test(line)) {
                        newFile = newFile.concat(variables.find(value => reg.test(value)), '\n');
                        skip = true;
                    }
                }
            }
            if (new RegExp('^ *'.concat(`\\.${this.selector}`)).test(line)) {
                add = false;
                newFile = newFile.concat(`\.${this.selector}`, classContent);
            }
            else if (utility_regex_1.isClassOrId(line) || utility_regex_1.isMixin(line)) {
                add = true;
            }
            if (add === true && !skip) {
                newFile = newFile.concat('\n', line);
            }
        }
        return newFile;
    }
}
exports.PreviewServer = PreviewServer;
// const test = new PreviewServer();


/***/ }),

/***/ "./src/tree/tree.item.ts":
/*!*******************************!*\
  !*** ./src/tree/tree.item.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__filename) {
Object.defineProperty(exports, "__esModule", { value: true });
const vscode_1 = __webpack_require__(/*! vscode */ "vscode");
const path_1 = __webpack_require__(/*! path */ "path");
class SassTreeItemData {
    constructor(insert, type, path, position, desc) {
        this.insert = insert;
        this.type = type;
        this.path = path;
        this.position = position;
        this.desc = desc;
    }
}
exports.SassTreeItemData = SassTreeItemData;
class SassTreeItem extends vscode_1.TreeItem {
    constructor(label, data, collapsibleState, command) {
        super(label, collapsibleState);
        this.label = label;
        this.data = data;
        this.collapsibleState = collapsibleState;
        this.command = command;
    }
    get tooltip() {
        return this.data.desc === undefined ? this.label : this.data.desc;
    }
    get description() {
        return this.data.desc;
    }
    get iconPath() {
        switch (this.data.type) {
            case 'root':
            case 'folder':
                return {
                    light: path_1.join(__filename, '..', '..', '..', 'resources', 'light', 'folder.svg'),
                    dark: path_1.join(__filename, '..', '..', '..', 'resources', 'dark', 'folder.svg')
                };
            case 'snippet':
                if (this.label.startsWith('@')) {
                    return {
                        light: path_1.join(__filename, '..', '..', '..', 'resources', 'light', 'method.svg'),
                        dark: path_1.join(__filename, '..', '..', '..', 'resources', 'dark', 'method.svg')
                    };
                }
                else if (this.label.startsWith('$')) {
                    return {
                        light: path_1.join(__filename, '..', '..', '..', 'resources', 'light', 'variable.svg'),
                        dark: path_1.join(__filename, '..', '..', '..', 'resources', 'dark', 'variable.svg')
                    };
                }
                else {
                    return {
                        light: path_1.join(__filename, '..', '..', '..', 'resources', 'light', 'snippet.svg'),
                        dark: path_1.join(__filename, '..', '..', '..', 'resources', 'dark', 'snippet.svg')
                    };
                }
        }
    }
    get contextValue() {
        return this.data.type;
    }
}
exports.SassTreeItem = SassTreeItem;

/* WEBPACK VAR INJECTION */}.call(this, "/index.js"))

/***/ }),

/***/ "./src/tree/tree.provider.ts":
/*!***********************************!*\
  !*** ./src/tree/tree.provider.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const vscode_1 = __webpack_require__(/*! vscode */ "vscode");
const tree_utility_1 = __webpack_require__(/*! ./tree.utility */ "./src/tree/tree.utility.ts");
class TreeSnippetProvider {
    constructor(context) {
        this._onDidChangeTreeData = new vscode_1.EventEmitter();
        this.onDidChangeTreeData = this._onDidChangeTreeData.event;
        this.ReadFromFiles = true;
        this.context = context;
    }
    refresh(readFromFile) {
        if (readFromFile) {
            this.ReadFromFiles = true;
        }
        this._onDidChangeTreeData.fire();
    }
    getTreeItem(element) {
        return element;
    }
    getChildren(element) {
        if (element) {
            return Promise.resolve(tree_utility_1.TreeUtility.getItems(tree_utility_1.TreeUtility.getData(element.data.path), element.data.path));
        }
        else {
            if (this.ReadFromFiles) {
                this.ReadFromFiles = false;
                return Promise.resolve(tree_utility_1.TreeUtility.getItems(tree_utility_1.TreeUtility.getDataFromFile()));
            }
            else {
                return Promise.resolve(tree_utility_1.TreeUtility.getItems(tree_utility_1.TreeUtility.getData()));
            }
        }
    }
}
exports.TreeSnippetProvider = TreeSnippetProvider;
class SnippetProviderUtility {
    static setProvider(provider) {
        this._PROVIDER = provider;
    }
    static get Context() {
        return this._PROVIDER.context;
    }
    static Refresh(readFromFile) {
        this._PROVIDER.refresh(readFromFile);
    }
}
exports.SnippetProviderUtility = SnippetProviderUtility;


/***/ }),

/***/ "./src/tree/tree.utility.ts":
/*!**********************************!*\
  !*** ./src/tree/tree.utility.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const vscode_1 = __webpack_require__(/*! vscode */ "vscode");
const fs_1 = __webpack_require__(/*! fs */ "fs");
const path_1 = __webpack_require__(/*! path */ "path");
const tree_item_1 = __webpack_require__(/*! ./tree.item */ "./src/tree/tree.item.ts");
const tree_provider_1 = __webpack_require__(/*! ./tree.provider */ "./src/tree/tree.provider.ts");
const utility_regex_1 = __webpack_require__(/*! ../utility/utility.regex */ "./src/utility/utility.regex.ts");
class SassTreeItemDataRaw {
    constructor(type, position, insert, desc, isOpen) {
        this.type = type;
        this.position = position;
        this.insert = insert;
        this.desc = desc;
        this.isOpen = isOpen;
    }
}
class TreeUtility {
    constructor() { }
    static getDataFromFile() {
        this._DATA = {};
        const folders = vscode_1.workspace.workspaceFolders;
        if (folders !== undefined) {
            folders.forEach((folderPath, i) => {
                const path = path_1.join(folderPath.uri.fsPath, '.vscode', 'sass.snippets.json');
                if (fs_1.existsSync(path)) {
                    const rawData = fs_1.readFileSync(path);
                    this._FILE_LOCATIONS[folderPath.name] = { path };
                    this._DATA = Object.assign({}, this._DATA, { [folderPath.name]: { children: JSON.parse(rawData.toString()), data: { type: 'root', isOpen: true, position: i + 1 } } });
                }
            });
        }
        const globalPath = vscode_1.workspace.getConfiguration().get('sass.snippets.path');
        if (globalPath && globalPath !== 'none') {
            if (fs_1.existsSync(globalPath)) {
                const rawData = fs_1.readFileSync(globalPath);
                this._FILE_LOCATIONS['Global'] = { path: globalPath };
                this._DATA = Object.assign({}, this._DATA, { ['Global']: { children: JSON.parse(rawData.toString()), data: { type: 'root', isOpen: true, position: 0 } } });
            }
            else {
                vscode_1.window.showWarningMessage(`${globalPath} does not exist!`, 'Create new File', 'Reset Setting').then(value => {
                    switch (value) {
                        case 'Create new File':
                            if (/.json/.test(globalPath)) {
                                fs_1.writeFileSync(globalPath, '{}');
                            }
                            else {
                                vscode_1.window.showErrorMessage('Path Has to end with .json', 'Chose New Path').then(value => {
                                    if (value === 'Chose New Path') {
                                        this._GET_GLOBAL_PATH(true);
                                    }
                                });
                            }
                            break;
                        case 'Reset Setting':
                            vscode_1.workspace.getConfiguration().update('sass.snippets.path', 'none', true);
                            break;
                        default:
                            break;
                    }
                });
            }
        }
        else {
            this._GET_GLOBAL_PATH();
        }
        this._INITIALIZED = true;
        return this._DATA;
    }
    static getItems(data, path) {
        const items = [];
        for (const key in data) {
            if (data.hasOwnProperty(key)) {
                const item = data[key];
                let isFolder = false;
                if (item.data.type === 'folder' || item.data.type === 'root') {
                    isFolder = true;
                }
                items.push(new tree_item_1.SassTreeItem(key, new tree_item_1.SassTreeItemData(item.data.insert, item.data.type, this._CREATE_PATH(key, path), item.data.position, item.data.desc), isFolder ? (item.data.isOpen ? vscode_1.TreeItemCollapsibleState.Expanded : vscode_1.TreeItemCollapsibleState.Collapsed) : vscode_1.TreeItemCollapsibleState.None));
            }
        }
        items.sort((a, b) => a.data.position - b.data.position);
        return items;
    }
    static getData(path) {
        if (path !== undefined) {
            return this._DOES_PATH_EXIST(path).data;
        }
        else {
            return this._DATA;
        }
    }
    static addFromSelection(item) {
        if (vscode_1.window.activeTextEditor !== undefined && vscode_1.window.activeTextEditor.document !== undefined) {
            if (!this._INITIALIZED) {
                this.getDataFromFile();
            }
            const document = vscode_1.window.activeTextEditor.document;
            const selections = vscode_1.window.activeTextEditor.selections;
            let newItems = [];
            for (let i = 0; i < selections.length; i++) {
                const selection = document.getText(selections[i]);
                if (selection.length > 0) {
                    newItems.push(new SassTreeItemDataRaw('snippet', 0, selection));
                }
            }
            for (let i = 0; i < newItems.length; i++) {
                const newItem = newItems[i];
                let itemName = `Selection${i === 0 ? '' : '-'.concat(i.toString())}`;
                let path;
                let counter = 0;
                if (item && item.data !== undefined) {
                    path = item.data.path;
                }
                else {
                    const config = vscode_1.workspace.getConfiguration().get('sass.snippets.path');
                    if (config !== '' && config !== 'none') {
                        path = ['Global'];
                    }
                    else {
                        path = [vscode_1.workspace.getWorkspaceFolder(document.uri).name];
                    }
                }
                while (this._DOES_PATH_EXIST(path.concat([itemName])).exists === true) {
                    counter++;
                    itemName = `Selection-${i + counter}`;
                }
                newItem.position = this._GET_POSITION(path);
                this._INSERT_DATA(path, { [itemName]: { data: newItem, children: {} } });
                this._WRITE_DATA_TO_FILES({ location: this._FILE_LOCATIONS[path[0]], baseName: path[0] });
                tree_provider_1.SnippetProviderUtility.Refresh();
            }
        }
    }
    static delete(item) {
        this._DELETE_DATA(item.data.path);
        tree_provider_1.SnippetProviderUtility.Refresh();
        this._WRITE_DATA_TO_FILES({ location: this._FILE_LOCATIONS[item.data.path[0]], baseName: item.data.path[0] });
    }
    static edit(item) {
        vscode_1.window.showInputBox({ placeHolder: 'newName' }).then(value => {
            if (value) {
                const newPath = item.data.path.slice(0, item.data.path.length - 1).concat(value);
                if (!this._DOES_PATH_EXIST(newPath).exists) {
                    let deletedData = this._DELETE_DATA(item.data.path);
                    tree_provider_1.SnippetProviderUtility.Refresh();
                    this._INSERT_DATA(item.data.path.slice(0, item.data.path.length - 1), { [value]: deletedData });
                    this._WRITE_DATA_TO_FILES({ location: this._FILE_LOCATIONS[item.data.path[0]], baseName: item.data.path[0] });
                }
                else {
                    vscode_1.window.showWarningMessage(`name: ${value} already in use.`);
                }
            }
        });
    }
    static move(item, direction) {
        if (direction === 'up' ? item.data.position + 1 >= 0 : true) {
            const path = item.data.path.slice(0, item.data.path.length - 1);
            const itemData = this.getData(path)[item.label].data;
            const write = this._UPDATE_ITEM_POSITIONS(path, { data: itemData, name: item.label }, direction);
            if (write) {
                this._WRITE_DATA_TO_FILES({ location: this._FILE_LOCATIONS[item.data.path[0]], baseName: item.data.path[0] });
                tree_provider_1.SnippetProviderUtility.Refresh();
            }
        }
    }
    static copy(item) {
        this._COPY = { data: this.getData(item.data.path.slice(0, item.data.path.length - 1))[item.label], name: item.label };
    }
    static cut(item) {
        this._COPY = { data: this._DELETE_DATA(item.data.path), name: item.label };
        tree_provider_1.SnippetProviderUtility.Refresh();
    }
    static paste(item) {
        if (!this._DOES_PATH_EXIST(item.data.path.concat(this._COPY.name)).exists) {
            this._PASTE(item);
        }
        else {
            vscode_1.window.showWarningMessage(`item: ${this._COPY.name} already exists, do you want to overwrite it?`, 'Yes', 'No').then(value => {
                if (value === 'Yes') {
                    this._PASTE(item);
                }
            });
        }
    }
    static addFolder(item) {
        vscode_1.window.showInputBox({ placeHolder: 'Folder Name' }).then(value => {
            if (value) {
                const newPath = item.data.path.concat(value);
                if (!this._DOES_PATH_EXIST(newPath).exists) {
                    this._INSERT_DATA(item.data.path, {
                        [value]: { children: {}, data: { type: 'folder', position: this._GET_POSITION(item.data.path) } }
                    });
                    tree_provider_1.SnippetProviderUtility.Refresh();
                    this._WRITE_DATA_TO_FILES({ location: this._FILE_LOCATIONS[item.data.path[0]], baseName: item.data.path[0] });
                }
                else {
                    vscode_1.window.showWarningMessage(`folder: ${value} already exists.`);
                }
            }
        });
    }
    static insert(item) {
        if (vscode_1.window.activeTextEditor) {
            let counter = 0;
            const insert = item.data.insert.replace(/(\\?\${?N)/g, function (_, grp) {
                return grp[0] === '\\' ? grp : grp.replace(/^\${?N$/, `$${grp[1] === '{' ? '{' : ''}${(counter++, counter)}`);
            });
            vscode_1.window.activeTextEditor.insertSnippet(new vscode_1.SnippetString(insert.concat('\n')));
        }
    }
    static insertFolder(item) {
        if (vscode_1.window.activeTextEditor) {
            const data = this.getData(item.data.path);
            let items = '';
            let counter = 0;
            for (const key in data) {
                if (data.hasOwnProperty(key)) {
                    const item = data[key];
                    if (item.data && item.data.insert) {
                        const insert = item.data.insert.replace(/(\\?\${?N)/g, function (_, grp) {
                            return grp[0] === '\\' ? grp : grp.replace(/^\${?N$/, `$${grp[1] === '{' ? '{' : ''}${(counter++, counter)}`);
                        });
                        items = items.concat(insert.concat('\n'));
                    }
                }
            }
            vscode_1.window.activeTextEditor.insertSnippet(new vscode_1.SnippetString(items));
        }
    }
    static openFile(item) {
        vscode_1.window.showTextDocument(vscode_1.Uri.file(this._FILE_LOCATIONS[item.data.path[0]].path));
    }
    static recalculatePosition(item) {
        const path = item.data.path;
        let level = 0;
        let pos = 0;
        path.reduce((lastReturnValue, currentKey) => {
            level++;
            if (level === path.length) {
                for (const key in lastReturnValue[currentKey].children) {
                    if (lastReturnValue[currentKey].children.hasOwnProperty(key)) {
                        lastReturnValue[currentKey].children[key].data.position = pos;
                        pos++;
                    }
                }
                return lastReturnValue[currentKey];
            }
            else {
                return lastReturnValue[currentKey].children;
            }
        }, this._DATA);
        this._WRITE_DATA_TO_FILES({ location: this._FILE_LOCATIONS[item.data.path[0]], baseName: item.data.path[0] });
        tree_provider_1.SnippetProviderUtility.Refresh();
    }
    static pasteFromClipboard() {
        vscode_1.env.clipboard.readText().then(text => {
            console.log('clipboard', text);
        });
    }
    static addFromFile(item, type) {
        if (vscode_1.window.activeTextEditor !== undefined && vscode_1.window.activeTextEditor.document !== undefined) {
            const document = vscode_1.window.activeTextEditor.document;
            const baseName = path_1.basename(document.fileName);
            const itemsRaw = TreeUtility._SCAN_FILE(document);
            let items = {
                vars: [],
                mixin: []
            };
            let path = [];
            if (item && item.data !== undefined) {
                path = item.data.path;
            }
            else {
                const config = vscode_1.workspace.getConfiguration().get('sass.snippets.path');
                if (config !== '' && config !== 'none') {
                    path = ['Global'];
                }
                else {
                    path = [vscode_1.workspace.getWorkspaceFolder(document.uri).name];
                }
            }
            let pos = 0;
            for (const key in itemsRaw) {
                if (itemsRaw.hasOwnProperty(key)) {
                    const item = itemsRaw[key];
                    if (item.type === 'mixin' && type !== 'var') {
                        items.mixin.push({
                            data: new SassTreeItemDataRaw('snippet', pos, item.insert, item.desc),
                            name: item.name
                        });
                        pos++;
                    }
                    else if (item.type === 'var' && type !== 'mixin') {
                        items.vars.push({
                            data: new SassTreeItemDataRaw('snippet', pos, item.insert, item.desc),
                            name: item.name
                        });
                        pos++;
                    }
                }
            }
            let folderName = baseName;
            let counter = 0;
            while (this._DOES_PATH_EXIST(path.concat([folderName])).exists === true) {
                counter++;
                folderName = `${baseName}-${counter}`;
            }
            const desc = type === 'both' ? '' : type === 'mixin' ? '.Mixins' : '.Variables';
            let res;
            switch (type) {
                case 'both':
                    res = {
                        [folderName]: {
                            children: {
                                Variables: { children: {}, data: { position: 0, type: 'folder' } },
                                Mixins: { children: {}, data: { position: 1, type: 'folder' } }
                            },
                            data: { type: 'folder', position: this._GET_POSITION(path) }
                        }
                    };
                    items.mixin.reduce(accumulator, res[folderName].children.Mixins.children);
                    items.vars.reduce(accumulator, res[folderName].children.Variables.children);
                    break;
                case 'mixin':
                    res = {
                        [folderName.concat(desc)]: {
                            children: {},
                            data: { type: 'folder', position: this._GET_POSITION(path) }
                        }
                    };
                    items.mixin.reduce(accumulator, res[folderName.concat(desc)].children);
                    break;
                case 'var':
                    res = {
                        [folderName.concat(desc)]: {
                            children: {},
                            data: { type: 'folder', position: this._GET_POSITION(path) }
                        }
                    };
                    items.vars.reduce(accumulator, res[folderName.concat(desc)].children);
                    break;
            }
            function accumulator(acc, currentItem) {
                acc[currentItem.name] = { data: currentItem.data, children: {} };
                return acc;
            }
            this._INSERT_DATA(path, res);
            this._WRITE_DATA_TO_FILES({ location: this._FILE_LOCATIONS[path[0]], baseName: path[0] });
            tree_provider_1.SnippetProviderUtility.Refresh();
        }
    }
    static _SCAN_FILE(document) {
        const items = [];
        let isInMixin = false;
        let currentMixin = '';
        let currentMixinName = '';
        for (let i = 0; i < document.lineCount; i++) {
            const line = document.lineAt(i);
            const lineText = line.text.trim();
            if (utility_regex_1.isVar(line.text)) {
                const varSplit = lineText.split(':');
                items.push({
                    insert: lineText.replace('$', '\\$'),
                    name: varSplit[0],
                    desc: varSplit[1].trim(),
                    type: 'var'
                });
            }
            else if (utility_regex_1.isMixin(lineText)) {
                if (isInMixin === true) {
                    pushMixin();
                }
                currentMixinName = lineText
                    .split('(')[0]
                    .replace('@mixin', '')
                    .trim();
                currentMixin = currentMixin.concat(lineText);
                isInMixin = true;
            }
            else if (!line.isEmptyOrWhitespace && /^[@#\.]/.test(line.text)) {
                if (isInMixin) {
                    pushMixin();
                    isInMixin = false;
                }
            }
            else if (isInMixin && !line.isEmptyOrWhitespace) {
                currentMixin = currentMixin.concat('\n', line.text);
            }
        }
        if (isInMixin) {
            pushMixin();
        }
        function pushMixin() {
            items.push({ name: '@'.concat(currentMixinName), desc: '', insert: currentMixin, type: 'mixin' });
            currentMixin = '';
            currentMixinName = '';
        }
        return items;
    }
    static _PASTE(item) {
        this._INSERT_DATA(item.data.path, {
            [this._COPY.name]: {
                children: this._COPY.data.children,
                data: {
                    type: this._COPY.data.data.type,
                    position: Object.keys(this.getData(item.data.path)).length,
                    desc: this._COPY.data.data.desc,
                    insert: this._COPY.data.data.insert,
                    isOpen: this._COPY.data.data.isOpen
                }
            }
        });
        this._WRITE_DATA_TO_FILES({ location: this._FILE_LOCATIONS[item.data.path[0]], baseName: item.data.path[0] });
        tree_provider_1.SnippetProviderUtility.Refresh();
    }
    static _GET_POSITION(path) {
        return Object.keys(this.getData(path)).length;
    }
    static _GET_GLOBAL_PATH(skipQuestion) {
        if (skipQuestion) {
            vscode_1.window.showOpenDialog({ openLabel: 'Set Snippet Path', canSelectFiles: false, canSelectFolders: true }).then(res => {
                if (res) {
                    vscode_1.workspace.getConfiguration().update('sass.snippets.path', res[0].fsPath.concat('/sass-snippets.json'), true);
                    fs_1.writeFileSync(res[0].fsPath.concat('/sass-snippets.json'), '{}');
                    tree_provider_1.SnippetProviderUtility.Refresh(true);
                }
            });
        }
        else {
            vscode_1.window.showInformationMessage('Global Snippet path Not set, would you like to set it now?', 'Yes', 'No').then(value => {
                if (value === 'Yes') {
                    vscode_1.window.showOpenDialog({ openLabel: 'Set Snippet Path', canSelectFiles: false, canSelectFolders: true }).then(res => {
                        if (res) {
                            vscode_1.workspace.getConfiguration().update('sass.snippets.path', res[0].fsPath.concat('/sass-snippets.json'), true);
                            fs_1.writeFileSync(res[0].fsPath.concat('/sass-snippets.json'), '{}');
                            tree_provider_1.SnippetProviderUtility.Refresh(true);
                        }
                    });
                }
            });
        }
    }
    /**
     * Inserts data Into the given folder.
     *
     * Example path = [a, b, c], data will be added to c.[currentKey].children.
     *
     * **`Overwrites data with the same key.`**
     */
    static _INSERT_DATA(path, data) {
        let level = 0;
        path.reduce((accumulator, currentKey) => {
            level++;
            if (level === path.length) {
                accumulator[currentKey].children = Object.assign({}, accumulator[currentKey].children, data);
            }
            else {
                return accumulator[currentKey].children;
            }
        }, this._DATA);
    }
    static _UPDATE_ITEM_POSITIONS(path, itemToMove, direction) {
        let level = 0;
        let canChangePos = false;
        path.reduce((accumulator, currentKey) => {
            level++;
            if (level === path.length) {
                for (const key in accumulator[currentKey].children) {
                    if (accumulator[currentKey].children.hasOwnProperty(key)) {
                        const currentItemDataRef = accumulator[currentKey].children[key].data;
                        if (!(key === itemToMove.name)) {
                            if (direction === 'up' && itemToMove.data.position - 1 === currentItemDataRef.position) {
                                canChangePos = true;
                                accumulator[currentKey].children[key].data.position = currentItemDataRef.position + 1;
                            }
                            else if (direction === 'down' && itemToMove.data.position + 1 === currentItemDataRef.position) {
                                canChangePos = true;
                                accumulator[currentKey].children[key].data.position = currentItemDataRef.position - 1;
                            }
                        }
                    }
                }
                if (canChangePos) {
                    accumulator[currentKey].children[itemToMove.name].data.position =
                        direction === 'up'
                            ? accumulator[currentKey].children[itemToMove.name].data.position - 1
                            : accumulator[currentKey].children[itemToMove.name].data.position + 1;
                }
                return accumulator;
            }
            else {
                return accumulator[currentKey].children;
            }
        }, this._DATA);
        return canChangePos;
    }
    static _DELETE_DATA(path) {
        let level = 0;
        let deletedData = undefined;
        path.reduce((lastReturnValue, currentKey) => {
            level++;
            if (level === path.length) {
                deletedData = lastReturnValue[currentKey];
                delete lastReturnValue[currentKey];
                return;
            }
            else {
                return lastReturnValue[currentKey].children;
            }
        }, this._DATA);
        return deletedData;
    }
    static _WRITE_DATA_TO_FILES(single) {
        if (single !== undefined) {
            fs_1.writeFile(single.location.path, JSON.stringify(this._DATA[single.baseName].children), err => {
                throw err;
            });
        }
        else {
            for (const key in this._FILE_LOCATIONS) {
                if (this._FILE_LOCATIONS.hasOwnProperty(key)) {
                    const location = this._FILE_LOCATIONS[key];
                    fs_1.writeFile(location.path, JSON.stringify(this._DATA[key].children), err => {
                        throw err;
                    });
                }
            }
        }
    }
    static _DOES_PATH_EXIST(path) {
        let tempData = null;
        let exists = true;
        for (let i = 0; i < path.length; i++) {
            const key = path[i];
            if (tempData === null) {
                if (this._DOES_KEY_EXIST(this._DATA, key)) {
                    tempData = this._DATA[key].children;
                }
                else {
                    exists = false;
                    tempData = {};
                    break;
                }
            }
            else {
                if (this._DOES_KEY_EXIST(tempData, key)) {
                    tempData = tempData[key].children;
                }
                else {
                    exists = false;
                    tempData = {};
                    break;
                }
            }
        }
        return { data: tempData, exists };
    }
    static _DOES_KEY_EXIST(data, key) {
        if (data === undefined || data[key] === undefined) {
            return false;
        }
        return true;
    }
    static _CREATE_PATH(key, path) {
        if (path !== undefined) {
            return path.concat(key);
        }
        else {
            return [key];
        }
    }
}
/**
 * Stores the absolute path for each root folder;
 */
TreeUtility._FILE_LOCATIONS = {};
TreeUtility._INITIALIZED = false;
exports.TreeUtility = TreeUtility;


/***/ }),

/***/ "./src/utility/utility.html.ts":
/*!*************************************!*\
  !*** ./src/utility/utility.html.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.htmlTags = [
    'a',
    'abbr',
    'address',
    'area',
    'article',
    'aside',
    'audio',
    'b',
    'base',
    'bdi',
    'bdo',
    'blockquote',
    'body',
    'br',
    'button',
    'canvas',
    'caption',
    'cite',
    'code',
    'col',
    'colgroup',
    'data',
    'datalist',
    'dd',
    'del',
    'details',
    'dfn',
    'dialog',
    'div',
    'dl',
    'dt',
    'em',
    'embed',
    'fieldset',
    'figure',
    'footer',
    'form',
    'h1',
    'h2',
    'h3',
    'h4',
    'h5',
    'h6',
    'head',
    'header',
    'hgroup',
    'hr',
    'html',
    'i',
    'iframe',
    'img',
    'input',
    'ins',
    'kbd',
    'keygen',
    'label',
    'legend',
    'li',
    'link',
    'main',
    'map',
    'mark',
    'menu',
    'menuitem',
    'meta',
    'meter',
    'nav',
    'noscript',
    'object',
    'ol',
    'optgroup',
    'option',
    'output',
    'p',
    'param',
    'pre',
    'progress',
    'q',
    'rb',
    'rp',
    'rt',
    'rtc',
    'ruby',
    's',
    'samp',
    'script',
    'section',
    'select',
    'small',
    'source',
    'span',
    'strong',
    'style',
    'sub',
    'summary',
    'sup',
    'table',
    'tbody',
    'td',
    'template',
    'textarea',
    'tfoot',
    'th',
    'thead',
    'time',
    'title',
    'tr',
    'track',
    'u',
    'ul',
    'var',
    'video',
    'wbr'
];
exports.voidHtmlTags = [
    'area',
    'base',
    'br',
    'col',
    'embed',
    'hr',
    'img',
    'input',
    'link',
    'meta',
    'param',
    'source',
    'track',
    'wbr',
    'command',
    'keygen',
    'menuitem'
];


/***/ }),

/***/ "./src/utility/utility.regex.ts":
/*!**************************************!*\
  !*** ./src/utility/utility.regex.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const utility_html_1 = __webpack_require__(/*! ./utility.html */ "./src/utility/utility.html.ts");
function escapeRegExp(text) {
    return text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
}
exports.escapeRegExp = escapeRegExp;
/**
 * Check whether text is a variable.
 */
function isVar(text) {
    return /^ *?\$.*:.*/.test(text);
}
exports.isVar = isVar;
/**
 * Check whether text is a *
 */
function isStar(text) {
    return /^ *?\*/.test(text);
}
exports.isStar = isStar;
/**
 * Check whether text is class, id or placeholder
 */
function isClassOrId(text) {
    return /^ *?#/.test(text) || /^ *\./.test(text) || /^ *%/.test(text);
}
exports.isClassOrId = isClassOrId;
/**
 * Check whether text is a property
 */
function isProperty(text) {
    return /^ *.*:/.test(text);
}
exports.isProperty = isProperty;
/**
 * Check whether text is a property
 */
function isInclude(text) {
    return /^ *@include/.test(text);
}
exports.isInclude = isInclude;
/**
 * Check whether text is a property
 */
function isKeyframes(text) {
    return /^ *@keyframes/.test(text);
}
exports.isKeyframes = isKeyframes;
/**
 * Check whether text is a mixin
 */
function isMixin(text) {
    return /^ *@mixin/.test(text);
}
exports.isMixin = isMixin;
/**
 * Check whether text starts with &
 */
function isAnd(text) {
    return /^ *&/.test(text);
}
exports.isAnd = isAnd;
/**
 * Check whether text is at rule
 */
function isAtRule(text) {
    return /^ *@/.test(text);
}
exports.isAtRule = isAtRule;
/**
 * checks if text last char is a number
 * @param {String} text
 * @return {CompletionItem}
 */
function isNumber(text) {
    const reg = /[0-9]$/;
    return reg.test(text) && !text.includes('#');
}
exports.isNumber = isNumber;
/**
 * Check whether text starts with a self closing html tag.
 */
function isVoidHtmlTag(text) {
    let isTag = false;
    for (let i = 0; i < utility_html_1.voidHtmlTags.length; i++) {
        const tag = utility_html_1.voidHtmlTags[i];
        if (new RegExp(`^ *${tag}$|^ *${tag}\\[.*\\].*$`).test(text)) {
            isTag = true;
            break;
        }
    }
    return isTag;
}
exports.isVoidHtmlTag = isVoidHtmlTag;
/**
 * Check whether text starts with ::.
 */
function isPseudo(text) {
    return /^ *::/.test(text);
}
exports.isPseudo = isPseudo;
/**
 * Check whether text starts with @if.
 */
function isIfOrElse(text) {
    return /^ *@if|^ *@else/.test(text);
}
exports.isIfOrElse = isIfOrElse;
/**
 * Check whether text starts with @else.
 */
function isElse(text) {
    return /^ *@else/.test(text);
}
exports.isElse = isElse;
/**
 * Check whether text starts with //R.
 */
function isReset(text) {
    return /^ *\/?\/\/ *R *$/.test(text);
}
exports.isReset = isReset;
/**
 * Check whether text starts with //S.
 */
function isSassSpace(text) {
    return /^ *\/?\/\/ *S *$/.test(text);
}
exports.isSassSpace = isSassSpace;
/**
 *
 */
function isPath(text) {
    return /^.*['"]\.?[\.\/]$/.test(text);
}
exports.isPath = isPath;


/***/ }),

/***/ "./src/utility/utility.ts":
/*!********************************!*\
  !*** ./src/utility/utility.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * returns the distance between the beginning and the first char that is not the checkAgainstChar in form of a number.
 * @param checkAgainstChar defaults to `' '` should always be only one char.
 */
function getDistance(text, checkAgainstChar = ' ') {
    let count = 0;
    for (let i = 0; i < text.length; i++) {
        const char = text[i];
        if (char !== checkAgainstChar) {
            break;
        }
        count++;
    }
    return count;
}
exports.getDistance = getDistance;
/**
 * returns the distance between the end and the first char that is not the checkAgainstChar in form of a number.
 * @param checkAgainstChar defaults to `' '` should always be only one char.
 */
function getDistanceReversed(text, checkAgainstChar = ' ') {
    let count = 0;
    for (let i = text.length - 1; i > 0; i--) {
        const char = text[i];
        if (char !== checkAgainstChar) {
            break;
        }
        count++;
    }
    return count;
}
exports.getDistanceReversed = getDistanceReversed;
function escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}
exports.escapeRegExp = escapeRegExp;


/***/ }),

/***/ "buffer":
/*!*************************!*\
  !*** external "buffer" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("buffer");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("crypto");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("events");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("fs");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("http");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("https");

/***/ }),

/***/ "net":
/*!**********************!*\
  !*** external "net" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("net");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("os");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("path");

/***/ }),

/***/ "querystring":
/*!******************************!*\
  !*** external "querystring" ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("querystring");

/***/ }),

/***/ "readline":
/*!***************************!*\
  !*** external "readline" ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("readline");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("stream");

/***/ }),

/***/ "string_decoder":
/*!*********************************!*\
  !*** external "string_decoder" ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("string_decoder");

/***/ }),

/***/ "tls":
/*!**********************!*\
  !*** external "tls" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("tls");

/***/ }),

/***/ "tty":
/*!**********************!*\
  !*** external "tty" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("tty");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("url");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("util");

/***/ }),

/***/ "vscode":
/*!*************************!*\
  !*** external "vscode" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("vscode");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("zlib");

/***/ })

/******/ });
//# sourceMappingURL=extension.js.map